/* tslint:disable */
/* eslint-disable */
/**
 * OceanBase Dashboard API
 * OceanBase Dashboard
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AlarmMatcher
 */
export interface AlarmMatcher {
    /**
     * 
     * @type {boolean}
     * @memberof AlarmMatcher
     */
    'isRegex'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AlarmMatcher
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlarmMatcher
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AlarmSeverity = {
    SeverityCritical: 'critical',
    SeverityWarning: 'warning',
    SeverityCaution: 'caution',
    SeverityInfo: 'info'
} as const;

export type AlarmSeverity = typeof AlarmSeverity[keyof typeof AlarmSeverity];


/**
 * 
 * @export
 * @interface AlertAlert
 */
export interface AlertAlert {
    /**
     * 
     * @type {string}
     * @memberof AlertAlert
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof AlertAlert
     */
    'endsAt': number;
    /**
     * 
     * @type {string}
     * @memberof AlertAlert
     */
    'fingerprint': string;
    /**
     * 
     * @type {OceanbaseOBInstance}
     * @memberof AlertAlert
     */
    'instance': OceanbaseOBInstance;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof AlertAlert
     */
    'labels'?: Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof AlertAlert
     */
    'rule': string;
    /**
     * 
     * @type {AlarmSeverity}
     * @memberof AlertAlert
     */
    'severity': AlarmSeverity;
    /**
     * 
     * @type {number}
     * @memberof AlertAlert
     */
    'startsAt': number;
    /**
     * 
     * @type {AlertStatus}
     * @memberof AlertAlert
     */
    'status': AlertStatus;
    /**
     * 
     * @type {string}
     * @memberof AlertAlert
     */
    'summary'?: string;
    /**
     * 
     * @type {number}
     * @memberof AlertAlert
     */
    'updatedAt': number;
}


/**
 * 
 * @export
 * @interface AlertAlertFilter
 */
export interface AlertAlertFilter {
    /**
     * 
     * @type {number}
     * @memberof AlertAlertFilter
     */
    'endTime'?: number;
    /**
     * 
     * @type {OceanbaseOBInstance}
     * @memberof AlertAlertFilter
     */
    'instance'?: OceanbaseOBInstance;
    /**
     * 
     * @type {OceanbaseOBInstanceType}
     * @memberof AlertAlertFilter
     */
    'instanceType'?: OceanbaseOBInstanceType;
    /**
     * 
     * @type {string}
     * @memberof AlertAlertFilter
     */
    'keyword'?: string;
    /**
     * 
     * @type {AlarmSeverity}
     * @memberof AlertAlertFilter
     */
    'severity'?: AlarmSeverity;
    /**
     * 
     * @type {number}
     * @memberof AlertAlertFilter
     */
    'startTime'?: number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AlertState = {
    StateActive: 'active',
    StateUnprocessed: 'unprocessed',
    StateSuppressed: 'suppressed'
} as const;

export type AlertState = typeof AlertState[keyof typeof AlertState];


/**
 * 
 * @export
 * @interface AlertStatus
 */
export interface AlertStatus {
    /**
     * 
     * @type {Array<string>}
     * @memberof AlertStatus
     */
    'inhibitedBy': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AlertStatus
     */
    'silencedBy': Array<string>;
    /**
     * 
     * @type {AlertState}
     * @memberof AlertStatus
     */
    'state': AlertState;
}


/**
 * 
 * @export
 * @interface CommonAffinitySpec
 */
export interface CommonAffinitySpec {
    /**
     * 
     * @type {string}
     * @memberof CommonAffinitySpec
     */
    'key'?: string;
    /**
     * 
     * @type {CommonAffinityType}
     * @memberof CommonAffinitySpec
     */
    'type'?: CommonAffinityType;
    /**
     * 
     * @type {string}
     * @memberof CommonAffinitySpec
     */
    'value'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const CommonAffinityType = {
    NodeAffinityType: 'NODE',
    PodAffinityType: 'POD',
    PodAntiAffinityType: 'POD_ANTI'
} as const;

export type CommonAffinityType = typeof CommonAffinityType[keyof typeof CommonAffinityType];


/**
 * 
 * @export
 * @enum {string}
 */

export const CommonClusterMode = {
    ClusterModeNormal: 'NORMAL',
    ClusterModeStandalone: 'STANDALONE',
    ClusterModeService: 'SERVICE'
} as const;

export type CommonClusterMode = typeof CommonClusterMode[keyof typeof CommonClusterMode];


/**
 * 
 * @export
 * @interface CommonKVPair
 */
export interface CommonKVPair {
    /**
     * 
     * @type {string}
     * @memberof CommonKVPair
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonKVPair
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface CommonResourceSpec
 */
export interface CommonResourceSpec {
    /**
     * 
     * @type {number}
     * @memberof CommonResourceSpec
     */
    'cpu'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommonResourceSpec
     */
    'memory'?: number;
}
/**
 * 
 * @export
 * @interface CommonStorageSpec
 */
export interface CommonStorageSpec {
    /**
     * 
     * @type {number}
     * @memberof CommonStorageSpec
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof CommonStorageSpec
     */
    'storageClass'?: string;
}
/**
 * 
 * @export
 * @interface ConnectDatabase200Response
 */
export interface ConnectDatabase200Response {
    /**
     * 
     * @type {ResponseOBConnection}
     * @memberof ConnectDatabase200Response
     */
    'data': ResponseOBConnection;
    /**
     * 
     * @type {string}
     * @memberof ConnectDatabase200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectDatabase200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateOBCluster200Response
 */
export interface CreateOBCluster200Response {
    /**
     * 
     * @type {ResponseOBCluster}
     * @memberof CreateOBCluster200Response
     */
    'data': ResponseOBCluster;
    /**
     * 
     * @type {string}
     * @memberof CreateOBCluster200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOBCluster200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateOBPROXY200Response
 */
export interface CreateOBPROXY200Response {
    /**
     * 
     * @type {ObproxyOBProxy}
     * @memberof CreateOBPROXY200Response
     */
    'data': ObproxyOBProxy;
    /**
     * 
     * @type {string}
     * @memberof CreateOBPROXY200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOBPROXY200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateReceiver200Response
 */
export interface CreateOrUpdateReceiver200Response {
    /**
     * 
     * @type {ReceiverReceiver}
     * @memberof CreateOrUpdateReceiver200Response
     */
    'data': ReceiverReceiver;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateReceiver200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrUpdateReceiver200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateRoute200Response
 */
export interface CreateOrUpdateRoute200Response {
    /**
     * 
     * @type {RouteRouteResponse}
     * @memberof CreateOrUpdateRoute200Response
     */
    'data': RouteRouteResponse;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateRoute200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrUpdateRoute200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateRule200Response
 */
export interface CreateOrUpdateRule200Response {
    /**
     * 
     * @type {RuleRuleResponse}
     * @memberof CreateOrUpdateRule200Response
     */
    'data': RuleRuleResponse;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateRule200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrUpdateRule200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateSilencer200Response
 */
export interface CreateOrUpdateSilencer200Response {
    /**
     * 
     * @type {SilenceSilencerResponse}
     * @memberof CreateOrUpdateSilencer200Response
     */
    'data': SilenceSilencerResponse;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateSilencer200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrUpdateSilencer200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateTenant200Response
 */
export interface CreateTenant200Response {
    /**
     * 
     * @type {ResponseOBTenantDetail}
     * @memberof CreateTenant200Response
     */
    'data': ResponseOBTenantDetail;
    /**
     * 
     * @type {string}
     * @memberof CreateTenant200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTenant200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface DeleteOBCluster200Response
 */
export interface DeleteOBCluster200Response {
    /**
     * 
     * @type {boolean}
     * @memberof DeleteOBCluster200Response
     */
    'data': boolean;
    /**
     * 
     * @type {string}
     * @memberof DeleteOBCluster200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteOBCluster200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface GetBackupPolicy200Response
 */
export interface GetBackupPolicy200Response {
    /**
     * 
     * @type {ResponseBackupPolicy}
     * @memberof GetBackupPolicy200Response
     */
    'data': ResponseBackupPolicy;
    /**
     * 
     * @type {string}
     * @memberof GetBackupPolicy200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetBackupPolicy200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface GetOBClusterStatistic200Response
 */
export interface GetOBClusterStatistic200Response {
    /**
     * 
     * @type {Array<ResponseOBClusterStatistic>}
     * @memberof GetOBClusterStatistic200Response
     */
    'data': Array<ResponseOBClusterStatistic>;
    /**
     * 
     * @type {string}
     * @memberof GetOBClusterStatistic200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetOBClusterStatistic200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface GetOBTenantStatistic200Response
 */
export interface GetOBTenantStatistic200Response {
    /**
     * 
     * @type {Array<ResponseOBTenantStatistic>}
     * @memberof GetOBTenantStatistic200Response
     */
    'data': Array<ResponseOBTenantStatistic>;
    /**
     * 
     * @type {string}
     * @memberof GetOBTenantStatistic200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetOBTenantStatistic200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface GetProcessInfo200Response
 */
export interface GetProcessInfo200Response {
    /**
     * 
     * @type {ResponseDashboardInfo}
     * @memberof GetProcessInfo200Response
     */
    'data': ResponseDashboardInfo;
    /**
     * 
     * @type {string}
     * @memberof GetProcessInfo200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetProcessInfo200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface GetReceiverTemplate200Response
 */
export interface GetReceiverTemplate200Response {
    /**
     * 
     * @type {ReceiverTemplate}
     * @memberof GetReceiverTemplate200Response
     */
    'data': ReceiverTemplate;
    /**
     * 
     * @type {string}
     * @memberof GetReceiverTemplate200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetReceiverTemplate200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface GetStatistics200Response
 */
export interface GetStatistics200Response {
    /**
     * 
     * @type {ResponseStatisticData}
     * @memberof GetStatistics200Response
     */
    'data': ResponseStatisticData;
    /**
     * 
     * @type {string}
     * @memberof GetStatistics200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetStatistics200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListAlerts200Response
 */
export interface ListAlerts200Response {
    /**
     * 
     * @type {Array<AlertAlert>}
     * @memberof ListAlerts200Response
     */
    'data': Array<AlertAlert>;
    /**
     * 
     * @type {string}
     * @memberof ListAlerts200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListAlerts200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListAllMetrics200Response
 */
export interface ListAllMetrics200Response {
    /**
     * 
     * @type {Array<ResponseMetricClass>}
     * @memberof ListAllMetrics200Response
     */
    'data': Array<ResponseMetricClass>;
    /**
     * 
     * @type {string}
     * @memberof ListAllMetrics200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListAllMetrics200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListAllTenants200Response
 */
export interface ListAllTenants200Response {
    /**
     * 
     * @type {Array<ResponseOBTenantOverview>}
     * @memberof ListAllTenants200Response
     */
    'data': Array<ResponseOBTenantOverview>;
    /**
     * 
     * @type {string}
     * @memberof ListAllTenants200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListAllTenants200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListBackupJobs200Response
 */
export interface ListBackupJobs200Response {
    /**
     * 
     * @type {Array<ResponseBackupJob>}
     * @memberof ListBackupJobs200Response
     */
    'data': Array<ResponseBackupJob>;
    /**
     * 
     * @type {string}
     * @memberof ListBackupJobs200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListBackupJobs200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListK8sEvents200Response
 */
export interface ListK8sEvents200Response {
    /**
     * 
     * @type {Array<ResponseK8sEvent>}
     * @memberof ListK8sEvents200Response
     */
    'data': Array<ResponseK8sEvent>;
    /**
     * 
     * @type {string}
     * @memberof ListK8sEvents200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListK8sEvents200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListK8sNamespaces200Response
 */
export interface ListK8sNamespaces200Response {
    /**
     * 
     * @type {Array<ResponseNamespace>}
     * @memberof ListK8sNamespaces200Response
     */
    'data': Array<ResponseNamespace>;
    /**
     * 
     * @type {string}
     * @memberof ListK8sNamespaces200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListK8sNamespaces200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListK8sNodes200Response
 */
export interface ListK8sNodes200Response {
    /**
     * 
     * @type {Array<ResponseK8sNode>}
     * @memberof ListK8sNodes200Response
     */
    'data': Array<ResponseK8sNode>;
    /**
     * 
     * @type {string}
     * @memberof ListK8sNodes200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListK8sNodes200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListK8sStorageClasses200Response
 */
export interface ListK8sStorageClasses200Response {
    /**
     * 
     * @type {Array<ResponseStorageClass>}
     * @memberof ListK8sStorageClasses200Response
     */
    'data': Array<ResponseStorageClass>;
    /**
     * 
     * @type {string}
     * @memberof ListK8sStorageClasses200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListK8sStorageClasses200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListOBClusterResources200Response
 */
export interface ListOBClusterResources200Response {
    /**
     * 
     * @type {ResponseOBClusterResources}
     * @memberof ListOBClusterResources200Response
     */
    'data': ResponseOBClusterResources;
    /**
     * 
     * @type {string}
     * @memberof ListOBClusterResources200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListOBClusterResources200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListOBClusters200Response
 */
export interface ListOBClusters200Response {
    /**
     * 
     * @type {Array<ResponseOBClusterOverview>}
     * @memberof ListOBClusters200Response
     */
    'data': Array<ResponseOBClusterOverview>;
    /**
     * 
     * @type {string}
     * @memberof ListOBClusters200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListOBClusters200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListOBProxies200Response
 */
export interface ListOBProxies200Response {
    /**
     * 
     * @type {Array<ObproxyOBProxyOverview>}
     * @memberof ListOBProxies200Response
     */
    'data': Array<ObproxyOBProxyOverview>;
    /**
     * 
     * @type {string}
     * @memberof ListOBProxies200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListOBProxies200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListOBProxyParameters200Response
 */
export interface ListOBProxyParameters200Response {
    /**
     * 
     * @type {Array<ObproxyConfigItem>}
     * @memberof ListOBProxyParameters200Response
     */
    'data': Array<ObproxyConfigItem>;
    /**
     * 
     * @type {string}
     * @memberof ListOBProxyParameters200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListOBProxyParameters200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListReceiverTemplates200Response
 */
export interface ListReceiverTemplates200Response {
    /**
     * 
     * @type {Array<ReceiverTemplate>}
     * @memberof ListReceiverTemplates200Response
     */
    'data': Array<ReceiverTemplate>;
    /**
     * 
     * @type {string}
     * @memberof ListReceiverTemplates200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListReceiverTemplates200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListReceivers200Response
 */
export interface ListReceivers200Response {
    /**
     * 
     * @type {Array<ReceiverReceiver>}
     * @memberof ListReceivers200Response
     */
    'data': Array<ReceiverReceiver>;
    /**
     * 
     * @type {string}
     * @memberof ListReceivers200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListReceivers200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListRoutes200Response
 */
export interface ListRoutes200Response {
    /**
     * 
     * @type {Array<RouteRouteResponse>}
     * @memberof ListRoutes200Response
     */
    'data': Array<RouteRouteResponse>;
    /**
     * 
     * @type {string}
     * @memberof ListRoutes200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListRoutes200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListRules200Response
 */
export interface ListRules200Response {
    /**
     * 
     * @type {Array<RuleRuleResponse>}
     * @memberof ListRules200Response
     */
    'data': Array<RuleRuleResponse>;
    /**
     * 
     * @type {string}
     * @memberof ListRules200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListRules200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListSilencers200Response
 */
export interface ListSilencers200Response {
    /**
     * 
     * @type {Array<SilenceSilencerResponse>}
     * @memberof ListSilencers200Response
     */
    'data': Array<SilenceSilencerResponse>;
    /**
     * 
     * @type {string}
     * @memberof ListSilencers200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListSilencers200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ModelsK8sEvent
 */
export interface ModelsK8sEvent {
    /**
     * 
     * @type {number}
     * @memberof ModelsK8sEvent
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsK8sEvent
     */
    'firstTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsK8sEvent
     */
    'kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsK8sEvent
     */
    'lastTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsK8sEvent
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsK8sEvent
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsK8sEvent
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsK8sEvent
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsK8sEvent
     */
    'resourceName'?: string;
}
/**
 * 
 * @export
 * @interface ModelsOBBackupPolicy
 */
export interface ModelsOBBackupPolicy {
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'archiveDestType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'archiveSwitchPieceInterval'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'bakDataDestType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'bakDataFullCrontab'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'bakDataIncrCrontab'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsOBBackupPolicy
     */
    'encryptBakData'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'runningFlow'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'runningTask'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'taskStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'tenantCR'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'tenantName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface ModelsOBCluster
 */
export interface ModelsOBCluster {
    /**
     * 
     * @type {number}
     * @memberof ModelsOBCluster
     */
    'clusterId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'clusterMode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'clusterName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsOBCluster
     */
    'configuredBackupVolume'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsOBCluster
     */
    'configuredMonitor'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBCluster
     */
    'cpu'?: number;
    /**
     * 
     * @type {ModelsStorageSpec}
     * @memberof ModelsOBCluster
     */
    'dataStorage'?: ModelsStorageSpec;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'image'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsOBCluster
     */
    'independentPVC'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBCluster
     */
    'memory'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'namespace'?: string;
    /**
     * 
     * @type {ModelsStorageSpec}
     * @memberof ModelsOBCluster
     */
    'redoLogStorage'?: ModelsStorageSpec;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'runningFlow'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'runningTask'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsOBCluster
     */
    'singlePVC'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'status'?: string;
    /**
     * 
     * @type {ModelsStorageSpec}
     * @memberof ModelsOBCluster
     */
    'sysLogStorage'?: ModelsStorageSpec;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'taskStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'uid'?: string;
    /**
     * 
     * @type {Array<ModelsOBZoneStatus>}
     * @memberof ModelsOBCluster
     */
    'zones'?: Array<ModelsOBZoneStatus>;
}
/**
 * 
 * @export
 * @interface ModelsOBServer
 */
export interface ModelsOBServer {
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'clusterCR'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBServer
     */
    'clusterId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'clusterName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'cni'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'podIPHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'podPhase'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'runningFlow'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'runningTask'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'serviceIPHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'taskStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'zoneName'?: string;
}
/**
 * 
 * @export
 * @interface ModelsOBTenant
 */
export interface ModelsOBTenant {
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'archiveDestType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'bakDataDestType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'clusterName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'primaryTenant'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'runningFlow'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'runningTask'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'taskStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'tenantName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'tenantRole'?: string;
    /**
     * 
     * @type {Array<ModelsOBTenantResourcePool>}
     * @memberof ModelsOBTenant
     */
    'topology'?: Array<ModelsOBTenantResourcePool>;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'uid'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenant
     */
    'unitNumber'?: number;
}
/**
 * 
 * @export
 * @interface ModelsOBTenantResourcePool
 */
export interface ModelsOBTenantResourcePool {
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'IOPSWeight'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'logDiskSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'maxCPU'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'maxIOPS'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'memorySize'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'minCPU'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'minIOPS'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'priority'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenantResourcePool
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'unitNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenantResourcePool
     */
    'zone'?: string;
}
/**
 * 
 * @export
 * @interface ModelsOBZone
 */
export interface ModelsOBZone {
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'clusterCR'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBZone
     */
    'clusterId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'clusterName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'runningFlow'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'runningTask'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'taskStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface ModelsOBZoneStatus
 */
export interface ModelsOBZoneStatus {
    /**
     * 
     * @type {number}
     * @memberof ModelsOBZoneStatus
     */
    'replica'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZoneStatus
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZoneStatus
     */
    'zoneName'?: string;
}
/**
 * 
 * @export
 * @interface ModelsStorageSpec
 */
export interface ModelsStorageSpec {
    /**
     * 
     * @type {string}
     * @memberof ModelsStorageSpec
     */
    'storageClass'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsStorageSpec
     */
    'storageSize'?: number;
}
/**
 * 
 * @export
 * @interface ObproxyConfigItem
 */
export interface ObproxyConfigItem {
    /**
     * 
     * @type {string}
     * @memberof ObproxyConfigItem
     */
    'info'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyConfigItem
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ObproxyConfigItem
     */
    'needReboot'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ObproxyConfigItem
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyConfigItem
     */
    'visibleLevel'?: string;
}
/**
 * 
 * @export
 * @interface ObproxyCreateOBProxyParam
 */
export interface ObproxyCreateOBProxyParam {
    /**
     * 
     * @type {string}
     * @memberof ObproxyCreateOBProxyParam
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyCreateOBProxyParam
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyCreateOBProxyParam
     */
    'namespace': string;
    /**
     * 
     * @type {ObproxyK8sObject}
     * @memberof ObproxyCreateOBProxyParam
     */
    'obCluster': ObproxyK8sObject;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ObproxyCreateOBProxyParam
     */
    'parameters'?: Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof ObproxyCreateOBProxyParam
     */
    'proxyClusterName': string;
    /**
     * Password should be encrypted
     * @type {string}
     * @memberof ObproxyCreateOBProxyParam
     */
    'proxySysPassword': string;
    /**
     * 
     * @type {number}
     * @memberof ObproxyCreateOBProxyParam
     */
    'replicas': number;
    /**
     * 
     * @type {CommonResourceSpec}
     * @memberof ObproxyCreateOBProxyParam
     */
    'resource': CommonResourceSpec;
    /**
     * 
     * @type {string}
     * @memberof ObproxyCreateOBProxyParam
     */
    'serviceType': ObproxyCreateOBProxyParamServiceTypeEnum;
}

export const ObproxyCreateOBProxyParamServiceTypeEnum = {
    ClusterIP: 'ClusterIP',
    NodePort: 'NodePort',
    LoadBalancer: 'LoadBalancer',
    ExternalName: 'ExternalName'
} as const;

export type ObproxyCreateOBProxyParamServiceTypeEnum = typeof ObproxyCreateOBProxyParamServiceTypeEnum[keyof typeof ObproxyCreateOBProxyParamServiceTypeEnum];

/**
 * 
 * @export
 * @interface ObproxyK8sObject
 */
export interface ObproxyK8sObject {
    /**
     * 
     * @type {string}
     * @memberof ObproxyK8sObject
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyK8sObject
     */
    'namespace': string;
}
/**
 * 
 * @export
 * @interface ObproxyOBProxy
 */
export interface ObproxyOBProxy {
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxy
     */
    'creationTime': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxy
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxy
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxy
     */
    'namespace': string;
    /**
     * 
     * @type {ObproxyK8sObject}
     * @memberof ObproxyOBProxy
     */
    'obCluster': ObproxyK8sObject;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ObproxyOBProxy
     */
    'parameters': Array<CommonKVPair>;
    /**
     * 
     * @type {Array<ResponseK8sPodInfo>}
     * @memberof ObproxyOBProxy
     */
    'pods': Array<ResponseK8sPodInfo>;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxy
     */
    'proxyClusterName': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxy
     */
    'proxySysSecret': string;
    /**
     * 
     * @type {number}
     * @memberof ObproxyOBProxy
     */
    'replicas': number;
    /**
     * 
     * @type {CommonResourceSpec}
     * @memberof ObproxyOBProxy
     */
    'resource': CommonResourceSpec;
    /**
     * 
     * @type {ResponseK8sService}
     * @memberof ObproxyOBProxy
     */
    'service': ResponseK8sService;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxy
     */
    'serviceIp': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxy
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ObproxyOBProxyOverview
 */
export interface ObproxyOBProxyOverview {
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxyOverview
     */
    'creationTime': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxyOverview
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxyOverview
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxyOverview
     */
    'namespace': string;
    /**
     * 
     * @type {ObproxyK8sObject}
     * @memberof ObproxyOBProxyOverview
     */
    'obCluster': ObproxyK8sObject;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxyOverview
     */
    'proxyClusterName': string;
    /**
     * 
     * @type {number}
     * @memberof ObproxyOBProxyOverview
     */
    'replicas': number;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxyOverview
     */
    'serviceIp': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxyOverview
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ObproxyPatchOBProxyParam
 */
export interface ObproxyPatchOBProxyParam {
    /**
     * 
     * @type {string}
     * @memberof ObproxyPatchOBProxyParam
     */
    'image'?: string;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ObproxyPatchOBProxyParam
     */
    'parameters'?: Array<CommonKVPair>;
    /**
     * 
     * @type {number}
     * @memberof ObproxyPatchOBProxyParam
     */
    'replicas'?: number;
    /**
     * 
     * @type {CommonResourceSpec}
     * @memberof ObproxyPatchOBProxyParam
     */
    'resource'?: CommonResourceSpec;
    /**
     * 
     * @type {string}
     * @memberof ObproxyPatchOBProxyParam
     */
    'serviceType'?: ObproxyPatchOBProxyParamServiceTypeEnum;
}

export const ObproxyPatchOBProxyParamServiceTypeEnum = {
    ClusterIP: 'ClusterIP',
    NodePort: 'NodePort',
    LoadBalancer: 'LoadBalancer',
    ExternalName: 'ExternalName'
} as const;

export type ObproxyPatchOBProxyParamServiceTypeEnum = typeof ObproxyPatchOBProxyParamServiceTypeEnum[keyof typeof ObproxyPatchOBProxyParamServiceTypeEnum];

/**
 * 
 * @export
 * @interface OceanbaseOBInstance
 */
export interface OceanbaseOBInstance {
    /**
     * 
     * @type {string}
     * @memberof OceanbaseOBInstance
     */
    'obcluster'?: string;
    /**
     * 
     * @type {string}
     * @memberof OceanbaseOBInstance
     */
    'observer'?: string;
    /**
     * 
     * @type {string}
     * @memberof OceanbaseOBInstance
     */
    'obtenant'?: string;
    /**
     * obzone may exist in labels
     * @type {string}
     * @memberof OceanbaseOBInstance
     */
    'obzone'?: string;
    /**
     * 
     * @type {OceanbaseOBInstanceType}
     * @memberof OceanbaseOBInstance
     */
    'type': OceanbaseOBInstanceType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const OceanbaseOBInstanceType = {
    TypeUnknown: 'unknown',
    TypeOBCluster: 'obcluster',
    TypeOBZone: 'obzone',
    TypeOBTenant: 'obtenant',
    TypeOBServer: 'observer'
} as const;

export type OceanbaseOBInstanceType = typeof OceanbaseOBInstanceType[keyof typeof OceanbaseOBInstanceType];


/**
 * 
 * @export
 * @interface ParamChangeTenantRole
 */
export interface ParamChangeTenantRole {
    /**
     * 
     * @type {boolean}
     * @memberof ParamChangeTenantRole
     */
    'failover'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ParamChangeTenantRole
     */
    'switchover'?: boolean;
}
/**
 * 
 * @export
 * @interface ParamChangeUserPassword
 */
export interface ParamChangeUserPassword {
    /**
     * 
     * @type {string}
     * @memberof ParamChangeUserPassword
     */
    'password': string;
    /**
     * Description: The user name of the database account, only root is supported now.
     * @type {string}
     * @memberof ParamChangeUserPassword
     */
    'user': string;
}
/**
 * 
 * @export
 * @interface ParamCreateBackupPolicy
 */
export interface ParamCreateBackupPolicy {
    /**
     * 
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'archivePath': string;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'bakDataPath': string;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'bakEncryptionPassword'?: string;
    /**
     * Enum: NFS, OSS
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'destType': string;
    /**
     * 
     * @type {number}
     * @memberof ParamCreateBackupPolicy
     */
    'jobKeepDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'ossAccessId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'ossAccessKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof ParamCreateBackupPolicy
     */
    'pieceIntervalDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof ParamCreateBackupPolicy
     */
    'recoveryDays'?: number;
    /**
     * 
     * @type {Array<ParamScheduleDate>}
     * @memberof ParamCreateBackupPolicy
     */
    'scheduleDates'?: Array<ParamScheduleDate>;
    /**
     * Description: HH:MM Example: 04:00
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'scheduleTime'?: string;
    /**
     * Enum: Weekly, Monthly
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'scheduleType'?: string;
}
/**
 * 
 * @export
 * @interface ParamCreateNamespaceParam
 */
export interface ParamCreateNamespaceParam {
    /**
     * 
     * @type {string}
     * @memberof ParamCreateNamespaceParam
     */
    'namespace'?: string;
}
/**
 * 
 * @export
 * @interface ParamCreateOBClusterParam
 */
export interface ParamCreateOBClusterParam {
    /**
     * 
     * @type {ParamNFSVolumeSpec}
     * @memberof ParamCreateOBClusterParam
     */
    'backupVolume'?: ParamNFSVolumeSpec;
    /**
     * 
     * @type {number}
     * @memberof ParamCreateOBClusterParam
     */
    'clusterId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBClusterParam
     */
    'clusterName'?: string;
    /**
     * 
     * @type {CommonClusterMode}
     * @memberof ParamCreateOBClusterParam
     */
    'mode'?: CommonClusterMode;
    /**
     * 
     * @type {ParamMonitorSpec}
     * @memberof ParamCreateOBClusterParam
     */
    'monitor'?: ParamMonitorSpec;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBClusterParam
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBClusterParam
     */
    'namespace'?: string;
    /**
     * 
     * @type {ParamOBServerSpec}
     * @memberof ParamCreateOBClusterParam
     */
    'observer'?: ParamOBServerSpec;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ParamCreateOBClusterParam
     */
    'parameters'?: Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBClusterParam
     */
    'rootPassword'?: string;
    /**
     * 
     * @type {Array<ParamZoneTopology>}
     * @memberof ParamCreateOBClusterParam
     */
    'topology'?: Array<ParamZoneTopology>;
}


/**
 * 
 * @export
 * @interface ParamCreateOBTenantParam
 */
export interface ParamCreateOBTenantParam {
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'charset'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'connectWhiteList'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'obcluster': string;
    /**
     * 
     * @type {Array<ParamResourcePoolSpec>}
     * @memberof ParamCreateOBTenantParam
     */
    'pools': Array<ParamResourcePoolSpec>;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'rootPassword': string;
    /**
     * 
     * @type {ParamTenantSourceSpec}
     * @memberof ParamCreateOBTenantParam
     */
    'source'?: ParamTenantSourceSpec;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'tenantName': string;
    /**
     * Enum: Primary, Standby
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'tenantRole'?: string;
    /**
     * 
     * @type {ParamUnitConfig}
     * @memberof ParamCreateOBTenantParam
     */
    'unitConfig': ParamUnitConfig;
    /**
     * 
     * @type {number}
     * @memberof ParamCreateOBTenantParam
     */
    'unitNum': number;
}
/**
 * 
 * @export
 * @interface ParamLoginParam
 */
export interface ParamLoginParam {
    /**
     * 
     * @type {string}
     * @memberof ParamLoginParam
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamLoginParam
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface ParamMetricQuery
 */
export interface ParamMetricQuery {
    /**
     * 
     * @type {Array<string>}
     * @memberof ParamMetricQuery
     */
    'groupLabels'?: Array<string>;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ParamMetricQuery
     */
    'labels'?: Array<CommonKVPair>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ParamMetricQuery
     */
    'metrics'?: Array<string>;
    /**
     * 
     * @type {ParamQueryRange}
     * @memberof ParamMetricQuery
     */
    'queryRange'?: ParamQueryRange;
}
/**
 * 
 * @export
 * @interface ParamMonitorSpec
 */
export interface ParamMonitorSpec {
    /**
     * 
     * @type {string}
     * @memberof ParamMonitorSpec
     */
    'image'?: string;
    /**
     * 
     * @type {CommonResourceSpec}
     * @memberof ParamMonitorSpec
     */
    'resource'?: CommonResourceSpec;
}
/**
 * 
 * @export
 * @interface ParamNFSVolumeSpec
 */
export interface ParamNFSVolumeSpec {
    /**
     * 
     * @type {string}
     * @memberof ParamNFSVolumeSpec
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamNFSVolumeSpec
     */
    'path'?: string;
}
/**
 * 
 * @export
 * @interface ParamOBServerSpec
 */
export interface ParamOBServerSpec {
    /**
     * 
     * @type {string}
     * @memberof ParamOBServerSpec
     */
    'image'?: string;
    /**
     * 
     * @type {CommonResourceSpec}
     * @memberof ParamOBServerSpec
     */
    'resource'?: CommonResourceSpec;
    /**
     * 
     * @type {ParamOBServerStorageSpec}
     * @memberof ParamOBServerSpec
     */
    'storage'?: ParamOBServerStorageSpec;
}
/**
 * 
 * @export
 * @interface ParamOBServerStorageSpec
 */
export interface ParamOBServerStorageSpec {
    /**
     * 
     * @type {CommonStorageSpec}
     * @memberof ParamOBServerStorageSpec
     */
    'data'?: CommonStorageSpec;
    /**
     * 
     * @type {CommonStorageSpec}
     * @memberof ParamOBServerStorageSpec
     */
    'log'?: CommonStorageSpec;
    /**
     * 
     * @type {CommonStorageSpec}
     * @memberof ParamOBServerStorageSpec
     */
    'redoLog'?: CommonStorageSpec;
}
/**
 * 
 * @export
 * @interface ParamPatchTenant
 */
export interface ParamPatchTenant {
    /**
     * Deprecated Description: Deprecated, use PATCH /obtenants/:namespace/:name/pools/:zoneName instead
     * @type {ParamPatchUnitConfig}
     * @memberof ParamPatchTenant
     */
    'unitConfig'?: ParamPatchUnitConfig;
    /**
     * 
     * @type {number}
     * @memberof ParamPatchTenant
     */
    'unitNum'?: number;
}
/**
 * 
 * @export
 * @interface ParamPatchUnitConfig
 */
export interface ParamPatchUnitConfig {
    /**
     * 
     * @type {Array<ParamResourcePoolSpec>}
     * @memberof ParamPatchUnitConfig
     */
    'pools': Array<ParamResourcePoolSpec>;
    /**
     * 
     * @type {ParamUnitConfig}
     * @memberof ParamPatchUnitConfig
     */
    'unitConfig': ParamUnitConfig;
}
/**
 * 
 * @export
 * @interface ParamQueryRange
 */
export interface ParamQueryRange {
    /**
     * 
     * @type {number}
     * @memberof ParamQueryRange
     */
    'endTimestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof ParamQueryRange
     */
    'startTimestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof ParamQueryRange
     */
    'step'?: number;
}
/**
 * 
 * @export
 * @interface ParamReplayStandbyLog
 */
export interface ParamReplayStandbyLog {
    /**
     * 
     * @type {string}
     * @memberof ParamReplayStandbyLog
     */
    'timestamp'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ParamReplayStandbyLog
     */
    'unlimited'?: boolean;
}
/**
 * 
 * @export
 * @interface ParamResourcePoolSpec
 */
export interface ParamResourcePoolSpec {
    /**
     * 
     * @type {number}
     * @memberof ParamResourcePoolSpec
     */
    'priority'?: number;
    /**
     * Enum: Readonly, Full
     * @type {string}
     * @memberof ParamResourcePoolSpec
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamResourcePoolSpec
     */
    'zone': string;
}
/**
 * 
 * @export
 * @interface ParamRestoreSourceSpec
 */
export interface ParamRestoreSourceSpec {
    /**
     * 
     * @type {string}
     * @memberof ParamRestoreSourceSpec
     */
    'archiveSource': string;
    /**
     * 
     * @type {string}
     * @memberof ParamRestoreSourceSpec
     */
    'bakDataSource': string;
    /**
     * 
     * @type {string}
     * @memberof ParamRestoreSourceSpec
     */
    'bakEncryptionPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamRestoreSourceSpec
     */
    'ossAccessId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamRestoreSourceSpec
     */
    'ossAccessKey'?: string;
    /**
     * Enum: OSS, NFS
     * @type {string}
     * @memberof ParamRestoreSourceSpec
     */
    'type': string;
    /**
     * 
     * @type {ParamRestoreUntilConfig}
     * @memberof ParamRestoreSourceSpec
     */
    'until'?: ParamRestoreUntilConfig;
}
/**
 * 
 * @export
 * @interface ParamRestoreUntilConfig
 */
export interface ParamRestoreUntilConfig {
    /**
     * 
     * @type {string}
     * @memberof ParamRestoreUntilConfig
     */
    'timestamp'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ParamRestoreUntilConfig
     */
    'unlimited'?: boolean;
}
/**
 * 
 * @export
 * @interface ParamScaleOBServerParam
 */
export interface ParamScaleOBServerParam {
    /**
     * 
     * @type {number}
     * @memberof ParamScaleOBServerParam
     */
    'replicas'?: number;
}
/**
 * 
 * @export
 * @interface ParamScheduleDate
 */
export interface ParamScheduleDate {
    /**
     * Enum: Full, Incremental
     * @type {string}
     * @memberof ParamScheduleDate
     */
    'backupType': string;
    /**
     * Description: 1-31 for monthly, 1-7 for weekly
     * @type {number}
     * @memberof ParamScheduleDate
     */
    'day': number;
}
/**
 * 
 * @export
 * @interface ParamTenantPoolSpec
 */
export interface ParamTenantPoolSpec {
    /**
     * 
     * @type {number}
     * @memberof ParamTenantPoolSpec
     */
    'priority'?: number;
    /**
     * 
     * @type {ParamUnitConfig}
     * @memberof ParamTenantPoolSpec
     */
    'unitConfig'?: ParamUnitConfig;
}
/**
 * 
 * @export
 * @interface ParamTenantSourceSpec
 */
export interface ParamTenantSourceSpec {
    /**
     * 
     * @type {ParamRestoreSourceSpec}
     * @memberof ParamTenantSourceSpec
     */
    'restore'?: ParamRestoreSourceSpec;
    /**
     * 
     * @type {string}
     * @memberof ParamTenantSourceSpec
     */
    'tenant'?: string;
}
/**
 * 
 * @export
 * @interface ParamUnitConfig
 */
export interface ParamUnitConfig {
    /**
     * 
     * @type {string}
     * @memberof ParamUnitConfig
     */
    'cpuCount': string;
    /**
     * 
     * @type {number}
     * @memberof ParamUnitConfig
     */
    'iopsWeight'?: number;
    /**
     * 
     * @type {string}
     * @memberof ParamUnitConfig
     */
    'logDiskSize'?: string;
    /**
     * 
     * @type {number}
     * @memberof ParamUnitConfig
     */
    'maxIops'?: number;
    /**
     * 
     * @type {string}
     * @memberof ParamUnitConfig
     */
    'memorySize': string;
    /**
     * 
     * @type {number}
     * @memberof ParamUnitConfig
     */
    'minIops'?: number;
}
/**
 * 
 * @export
 * @interface ParamUpdateBackupPolicy
 */
export interface ParamUpdateBackupPolicy {
    /**
     * 
     * @type {number}
     * @memberof ParamUpdateBackupPolicy
     */
    'jobKeepDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof ParamUpdateBackupPolicy
     */
    'pieceIntervalDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof ParamUpdateBackupPolicy
     */
    'recoveryDays'?: number;
    /**
     * 
     * @type {Array<ParamScheduleDate>}
     * @memberof ParamUpdateBackupPolicy
     */
    'scheduleDates'?: Array<ParamScheduleDate>;
    /**
     * Description: HH:MM Example: 04:00
     * @type {string}
     * @memberof ParamUpdateBackupPolicy
     */
    'scheduleTime'?: string;
    /**
     * Enum: Weekly, Monthly
     * @type {string}
     * @memberof ParamUpdateBackupPolicy
     */
    'scheduleType'?: string;
    /**
     * Enum: PAUSED, RUNNING
     * @type {string}
     * @memberof ParamUpdateBackupPolicy
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ParamUpgradeOBClusterParam
 */
export interface ParamUpgradeOBClusterParam {
    /**
     * 
     * @type {string}
     * @memberof ParamUpgradeOBClusterParam
     */
    'image'?: string;
}
/**
 * 
 * @export
 * @interface ParamZoneTopology
 */
export interface ParamZoneTopology {
    /**
     * 
     * @type {Array<CommonAffinitySpec>}
     * @memberof ParamZoneTopology
     */
    'affinities'?: Array<CommonAffinitySpec>;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ParamZoneTopology
     */
    'nodeSelector'?: Array<CommonKVPair>;
    /**
     * 
     * @type {number}
     * @memberof ParamZoneTopology
     */
    'replicas'?: number;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ParamZoneTopology
     */
    'tolerations'?: Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof ParamZoneTopology
     */
    'zone'?: string;
}
/**
 * 
 * @export
 * @interface PayloadAlert
 */
export interface PayloadAlert {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PayloadAlert
     */
    'annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PayloadAlert
     */
    'endsAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayloadAlert
     */
    'generatorURL'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PayloadAlert
     */
    'labels'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PayloadAlert
     */
    'startsAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayloadAlert
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface PayloadWebhookPayload
 */
export interface PayloadWebhookPayload {
    /**
     * 
     * @type {Array<PayloadAlert>}
     * @memberof PayloadWebhookPayload
     */
    'alerts'?: Array<PayloadAlert>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PayloadWebhookPayload
     */
    'commonAnnotations'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PayloadWebhookPayload
     */
    'commonLabels'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PayloadWebhookPayload
     */
    'externalURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayloadWebhookPayload
     */
    'groupKey'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PayloadWebhookPayload
     */
    'groupLabels'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PayloadWebhookPayload
     */
    'receiver'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayloadWebhookPayload
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayloadWebhookPayload
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface QueryMetrics200Response
 */
export interface QueryMetrics200Response {
    /**
     * 
     * @type {Array<ResponseMetricData>}
     * @memberof QueryMetrics200Response
     */
    'data': Array<ResponseMetricData>;
    /**
     * 
     * @type {string}
     * @memberof QueryMetrics200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof QueryMetrics200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ReceiverReceiver
 */
export interface ReceiverReceiver {
    /**
     * 
     * @type {string}
     * @memberof ReceiverReceiver
     */
    'config': string;
    /**
     * 
     * @type {string}
     * @memberof ReceiverReceiver
     */
    'name': string;
    /**
     * 
     * @type {ReceiverReceiverType}
     * @memberof ReceiverReceiver
     */
    'type': ReceiverReceiverType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ReceiverReceiverType = {
    TypeDiscord: 'discord',
    TypeEmail: 'email',
    TypePagerduty: 'pagerduty',
    TypeSlack: 'slack',
    TypeWebhook: 'webhook',
    TypeOpsGenie: 'opsgenie',
    TypeWechat: 'wechat',
    TypePushover: 'pushover',
    TypeVictorOps: 'victorops',
    TypeSNS: 'sns',
    TypeTelegram: 'telegram',
    TypeWebex: 'webex',
    TypeMSTeams: 'msteams'
} as const;

export type ReceiverReceiverType = typeof ReceiverReceiverType[keyof typeof ReceiverReceiverType];


/**
 * 
 * @export
 * @interface ReceiverTemplate
 */
export interface ReceiverTemplate {
    /**
     * 
     * @type {string}
     * @memberof ReceiverTemplate
     */
    'template': string;
    /**
     * 
     * @type {ReceiverReceiverType}
     * @memberof ReceiverTemplate
     */
    'type': ReceiverReceiverType;
}


/**
 * 
 * @export
 * @interface ResponseAPIResponse
 */
export interface ResponseAPIResponse {
    /**
     * 
     * @type {object}
     * @memberof ResponseAPIResponse
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof ResponseAPIResponse
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseAPIResponse
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ResponseBackupJob
 */
export interface ResponseBackupJob {
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'backupPolicyName': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'encryptionSecret'?: string;
    /**
     * End time of the backup job, empty for ARCHIVE job
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'namespace': string;
    /**
     * Empty for Clean job
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'path': string;
    /**
     * Start time of the backup job, StartScnDisplay for ARCHIVE job
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'statusInDatabase': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'tenantName': string;
    /**
     * Enum: FULL, INCR, ARCHIVE, CLEAN
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'uid': string;
}
/**
 * 
 * @export
 * @interface ResponseBackupPolicy
 */
export interface ResponseBackupPolicy {
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'archivePath': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'bakDataPath': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'bakEncryptionSecret'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'createTime': string;
    /**
     * Enum: NFS, OSS
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'destType': string;
    /**
     * 
     * @type {Array<ResponseK8sEvent>}
     * @memberof ResponseBackupPolicy
     */
    'events': Array<ResponseK8sEvent>;
    /**
     * 
     * @type {number}
     * @memberof ResponseBackupPolicy
     */
    'jobKeepDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'ossAccessSecret'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseBackupPolicy
     */
    'pieceIntervalDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseBackupPolicy
     */
    'recoveryDays'?: number;
    /**
     * 
     * @type {Array<ParamScheduleDate>}
     * @memberof ResponseBackupPolicy
     */
    'scheduleDates'?: Array<ParamScheduleDate>;
    /**
     * Description: HH:MM Example: 04:00
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'scheduleTime'?: string;
    /**
     * Enum: Weekly, Monthly
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'scheduleType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'tenantName': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'uid': string;
}
/**
 * 
 * @export
 * @interface ResponseContainerInfo
 */
export interface ResponseContainerInfo {
    /**
     * 
     * @type {string}
     * @memberof ResponseContainerInfo
     */
    'image': string;
    /**
     * 
     * @type {CommonResourceSpec}
     * @memberof ResponseContainerInfo
     */
    'limits': CommonResourceSpec;
    /**
     * 
     * @type {string}
     * @memberof ResponseContainerInfo
     */
    'name': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ResponseContainerInfo
     */
    'ports': Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseContainerInfo
     */
    'ready': boolean;
    /**
     * 
     * @type {CommonResourceSpec}
     * @memberof ResponseContainerInfo
     */
    'requests': CommonResourceSpec;
    /**
     * 
     * @type {number}
     * @memberof ResponseContainerInfo
     */
    'restartCount': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseContainerInfo
     */
    'startTime': string;
}
/**
 * 
 * @export
 * @interface ResponseDashboardInfo
 */
export interface ResponseDashboardInfo {
    /**
     * 
     * @type {string}
     * @memberof ResponseDashboardInfo
     */
    'appName': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDashboardInfo
     */
    'publicKey': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDashboardInfo
     */
    'reportHost': string;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseDashboardInfo
     */
    'reportStatistics': boolean;
    /**
     * 
     * @type {string}
     * @memberof ResponseDashboardInfo
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResponseK8sEvent
 */
export interface ResponseK8sEvent {
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sEvent
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sEvent
     */
    'firstOccur': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sEvent
     */
    'lastSeen': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sEvent
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sEvent
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sEvent
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sEvent
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sEvent
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ResponseK8sNode
 */
export interface ResponseK8sNode {
    /**
     * 
     * @type {ResponseK8sNodeInfo}
     * @memberof ResponseK8sNode
     */
    'info'?: ResponseK8sNodeInfo;
    /**
     * 
     * @type {ResponseK8sNodeResource}
     * @memberof ResponseK8sNode
     */
    'resource'?: ResponseK8sNodeResource;
}
/**
 * 
 * @export
 * @interface ResponseK8sNodeCondition
 */
export interface ResponseK8sNodeCondition {
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeCondition
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeCondition
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeCondition
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ResponseK8sNodeInfo
 */
export interface ResponseK8sNodeInfo {
    /**
     * 
     * @type {Array<ResponseK8sNodeCondition>}
     * @memberof ResponseK8sNodeInfo
     */
    'conditions': Array<ResponseK8sNodeCondition>;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeInfo
     */
    'cri': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeInfo
     */
    'externalIP': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeInfo
     */
    'internalIP': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeInfo
     */
    'kernel': string;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ResponseK8sNodeInfo
     */
    'labels': Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeInfo
     */
    'os': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseK8sNodeInfo
     */
    'roles': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeInfo
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sNodeInfo
     */
    'uptime': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeInfo
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResponseK8sNodeResource
 */
export interface ResponseK8sNodeResource {
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sNodeResource
     */
    'cpuFree': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sNodeResource
     */
    'cpuTotal': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sNodeResource
     */
    'cpuUsed': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sNodeResource
     */
    'memoryFree': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sNodeResource
     */
    'memoryTotal': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sNodeResource
     */
    'memoryUsed': number;
}
/**
 * 
 * @export
 * @interface ResponseK8sPodInfo
 */
export interface ResponseK8sPodInfo {
    /**
     * 
     * @type {Array<ResponseContainerInfo>}
     * @memberof ResponseK8sPodInfo
     */
    'containers': Array<ResponseContainerInfo>;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sPodInfo
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sPodInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sPodInfo
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sPodInfo
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sPodInfo
     */
    'podIP': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sPodInfo
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sPodInfo
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sPodInfo
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ResponseK8sService
 */
export interface ResponseK8sService {
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sService
     */
    'clusterIP'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sService
     */
    'externalIP'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sService
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sService
     */
    'namespace'?: string;
    /**
     * 
     * @type {Array<ResponseK8sServicePort>}
     * @memberof ResponseK8sService
     */
    'ports'?: Array<ResponseK8sServicePort>;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sService
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ResponseK8sServicePort
 */
export interface ResponseK8sServicePort {
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sServicePort
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sServicePort
     */
    'port'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sServicePort
     */
    'targetPort'?: number;
}
/**
 * 
 * @export
 * @interface ResponseMetric
 */
export interface ResponseMetric {
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ResponseMetric
     */
    'labels'?: Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof ResponseMetric
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ResponseMetricClass
 */
export interface ResponseMetricClass {
    /**
     * 
     * @type {string}
     * @memberof ResponseMetricClass
     */
    'description': string;
    /**
     * 
     * @type {Array<ResponseMetricGroup>}
     * @memberof ResponseMetricClass
     */
    'metricGroups': Array<ResponseMetricGroup>;
    /**
     * 
     * @type {string}
     * @memberof ResponseMetricClass
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ResponseMetricData
 */
export interface ResponseMetricData {
    /**
     * 
     * @type {ResponseMetric}
     * @memberof ResponseMetricData
     */
    'metric': ResponseMetric;
    /**
     * 
     * @type {Array<ResponseMetricValue>}
     * @memberof ResponseMetricData
     */
    'values': Array<ResponseMetricValue>;
}
/**
 * 
 * @export
 * @interface ResponseMetricGroup
 */
export interface ResponseMetricGroup {
    /**
     * 
     * @type {string}
     * @memberof ResponseMetricGroup
     */
    'description': string;
    /**
     * 
     * @type {Array<ResponseMetricMeta>}
     * @memberof ResponseMetricGroup
     */
    'metrics': Array<ResponseMetricMeta>;
    /**
     * 
     * @type {string}
     * @memberof ResponseMetricGroup
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ResponseMetricMeta
 */
export interface ResponseMetricMeta {
    /**
     * 
     * @type {string}
     * @memberof ResponseMetricMeta
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseMetricMeta
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseMetricMeta
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseMetricMeta
     */
    'unit': string;
}
/**
 * 
 * @export
 * @interface ResponseMetricValue
 */
export interface ResponseMetricValue {
    /**
     * 
     * @type {number}
     * @memberof ResponseMetricValue
     */
    'timestamp': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseMetricValue
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface ResponseMonitorSpec
 */
export interface ResponseMonitorSpec {
    /**
     * 
     * @type {string}
     * @memberof ResponseMonitorSpec
     */
    'image': string;
    /**
     * 
     * @type {ResponseResourceSpecRender}
     * @memberof ResponseMonitorSpec
     */
    'resource': ResponseResourceSpecRender;
}
/**
 * 
 * @export
 * @interface ResponseNFSVolumeSpec
 */
export interface ResponseNFSVolumeSpec {
    /**
     * 
     * @type {string}
     * @memberof ResponseNFSVolumeSpec
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseNFSVolumeSpec
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface ResponseNamespace
 */
export interface ResponseNamespace {
    /**
     * 
     * @type {string}
     * @memberof ResponseNamespace
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseNamespace
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ResponseOBCluster
 */
export interface ResponseOBCluster {
    /**
     * 
     * @type {ResponseNFSVolumeSpec}
     * @memberof ResponseOBCluster
     */
    'backupVolume'?: ResponseNFSVolumeSpec;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBCluster
     */
    'clusterId': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'clusterName': string;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBCluster
     */
    'createTime': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'image': string;
    /**
     * 
     * @type {ResponseOBMetrics}
     * @memberof ResponseOBCluster
     */
    'metrics'?: ResponseOBMetrics;
    /**
     * 
     * @type {CommonClusterMode}
     * @memberof ResponseOBCluster
     */
    'mode': CommonClusterMode;
    /**
     * 
     * @type {ResponseMonitorSpec}
     * @memberof ResponseOBCluster
     */
    'monitor'?: ResponseMonitorSpec;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'namespace': string;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ResponseOBCluster
     */
    'parameters': Array<CommonKVPair>;
    /**
     * 
     * @type {ResponseResourceSpecRender}
     * @memberof ResponseOBCluster
     */
    'resource': ResponseResourceSpecRender;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'rootPasswordSecret': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'statusDetail': string;
    /**
     * 
     * @type {ResponseOBServerStorage}
     * @memberof ResponseOBCluster
     */
    'storage': ResponseOBServerStorage;
    /**
     * 
     * @type {Array<ResponseOBZone>}
     * @memberof ResponseOBCluster
     */
    'topology': Array<ResponseOBZone>;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'version'?: string;
}


/**
 * 
 * @export
 * @interface ResponseOBClusterOverview
 */
export interface ResponseOBClusterOverview {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBClusterOverview
     */
    'clusterId': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterOverview
     */
    'clusterName': string;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBClusterOverview
     */
    'createTime': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterOverview
     */
    'image': string;
    /**
     * 
     * @type {CommonClusterMode}
     * @memberof ResponseOBClusterOverview
     */
    'mode': CommonClusterMode;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterOverview
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterOverview
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterOverview
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterOverview
     */
    'statusDetail': string;
    /**
     * 
     * @type {Array<ResponseOBZone>}
     * @memberof ResponseOBClusterOverview
     */
    'topology': Array<ResponseOBZone>;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterOverview
     */
    'uid': string;
}


/**
 * 
 * @export
 * @interface ResponseOBClusterResources
 */
export interface ResponseOBClusterResources {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBClusterResources
     */
    'minPoolMemory': number;
    /**
     * 
     * @type {Array<ResponseOBServerAvailableResource>}
     * @memberof ResponseOBClusterResources
     */
    'obServerResources'?: Array<ResponseOBServerAvailableResource>;
    /**
     * 
     * @type {{ [key: string]: ResponseOBZoneAvailableResource; }}
     * @memberof ResponseOBClusterResources
     */
    'obZoneResourceMap'?: { [key: string]: ResponseOBZoneAvailableResource; };
}
/**
 * 
 * @export
 * @interface ResponseOBClusterStatistic
 */
export interface ResponseOBClusterStatistic {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBClusterStatistic
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterStatistic
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ResponseOBConnection
 */
export interface ResponseOBConnection {
    /**
     * 
     * @type {string}
     * @memberof ResponseOBConnection
     */
    'clientIp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBConnection
     */
    'cluster'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBConnection
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBConnection
     */
    'pod'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBConnection
     */
    'tenant'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBConnection
     */
    'terminalId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBConnection
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @interface ResponseOBMetrics
 */
export interface ResponseOBMetrics {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBMetrics
     */
    'cpuPercent': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBMetrics
     */
    'diskPercent': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBMetrics
     */
    'memoryPercent': number;
}
/**
 * 
 * @export
 * @interface ResponseOBServer
 */
export interface ResponseOBServer {
    /**
     * 
     * @type {string}
     * @memberof ResponseOBServer
     */
    'address': string;
    /**
     * 
     * @type {ResponseOBMetrics}
     * @memberof ResponseOBServer
     */
    'metrics'?: ResponseOBMetrics;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBServer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBServer
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBServer
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBServer
     */
    'statusDetail': string;
}
/**
 * 
 * @export
 * @interface ResponseOBServerAvailableResource
 */
export interface ResponseOBServerAvailableResource {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBServerAvailableResource
     */
    'availableCPU': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBServerAvailableResource
     */
    'availableDataDisk': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBServerAvailableResource
     */
    'availableLogDisk': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBServerAvailableResource
     */
    'availableMemory': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBServerAvailableResource
     */
    'obServerIP': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBServerAvailableResource
     */
    'obZone': string;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBServerAvailableResource
     */
    'serverCount': number;
}
/**
 * 
 * @export
 * @interface ResponseOBServerStorage
 */
export interface ResponseOBServerStorage {
    /**
     * 
     * @type {ResponseStorageSpec}
     * @memberof ResponseOBServerStorage
     */
    'dataStorage': ResponseStorageSpec;
    /**
     * 
     * @type {ResponseStorageSpec}
     * @memberof ResponseOBServerStorage
     */
    'redoLogStorage': ResponseStorageSpec;
    /**
     * 
     * @type {ResponseStorageSpec}
     * @memberof ResponseOBServerStorage
     */
    'sysLogStorage': ResponseStorageSpec;
}
/**
 * 
 * @export
 * @interface ResponseOBTenantDetail
 */
export interface ResponseOBTenantDetail {
    /**
     * Charset of the tenant
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'charset': string;
    /**
     * Name of the cluster belonging to
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'clusterResourceName': string;
    /**
     * Creation time of the tenant
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'createTime': string;
    /**
     * Locality of the tenant units
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'locality': string;
    /**
     * Name of the resource
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'name': string;
    /**
     * Namespace of the resource
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'primaryTenant'?: string;
    /**
     * Primary zone of the tenant
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'primaryZone': string;
    /**
     * 
     * @type {ResponseRestoreSource}
     * @memberof ResponseOBTenantDetail
     */
    'restoreSource'?: ResponseRestoreSource;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'rootCredential'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'standbyROCredential'?: string;
    /**
     * Status of the tenant
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'status': string;
    /**
     * Name of the tenant in the database
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'tenantName': string;
    /**
     * Enum: Primary, Standby
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'tenantRole': string;
    /**
     * Topology of the tenant
     * @type {Array<ResponseOBTenantReplica>}
     * @memberof ResponseOBTenantDetail
     */
    'topology'?: Array<ResponseOBTenantReplica>;
    /**
     * Unique identifier of the resource
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'uid': string;
    /**
     * Number of units in every zone
     * @type {number}
     * @memberof ResponseOBTenantDetail
     */
    'unitNumber': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'version'?: string;
}
/**
 * Brief information about OBTenant
 * @export
 * @interface ResponseOBTenantOverview
 */
export interface ResponseOBTenantOverview {
    /**
     * Charset of the tenant
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'charset': string;
    /**
     * Name of the cluster belonging to
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'clusterResourceName': string;
    /**
     * Creation time of the tenant
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'createTime': string;
    /**
     * Locality of the tenant units
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'locality': string;
    /**
     * Name of the resource
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'name': string;
    /**
     * Namespace of the resource
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'namespace': string;
    /**
     * Primary zone of the tenant
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'primaryZone': string;
    /**
     * Status of the tenant
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'status': string;
    /**
     * Name of the tenant in the database
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'tenantName': string;
    /**
     * Enum: Primary, Standby
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'tenantRole': string;
    /**
     * Topology of the tenant
     * @type {Array<ResponseOBTenantReplica>}
     * @memberof ResponseOBTenantOverview
     */
    'topology'?: Array<ResponseOBTenantReplica>;
    /**
     * Unique identifier of the resource
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'uid': string;
    /**
     * Number of units in every zone
     * @type {number}
     * @memberof ResponseOBTenantOverview
     */
    'unitNumber': number;
}
/**
 * 
 * @export
 * @interface ResponseOBTenantReplica
 */
export interface ResponseOBTenantReplica {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBTenantReplica
     */
    'iopsWeight': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBTenantReplica
     */
    'logDiskSize': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBTenantReplica
     */
    'maxCPU': string;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBTenantReplica
     */
    'maxIops': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBTenantReplica
     */
    'memorySize': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBTenantReplica
     */
    'minCPU': string;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBTenantReplica
     */
    'minIops': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBTenantReplica
     */
    'priority': number;
    /**
     * Enum: Readonly, Full
     * @type {string}
     * @memberof ResponseOBTenantReplica
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBTenantReplica
     */
    'zone': string;
}
/**
 * 
 * @export
 * @interface ResponseOBTenantStatistic
 */
export interface ResponseOBTenantStatistic {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBTenantStatistic
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBTenantStatistic
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ResponseOBZone
 */
export interface ResponseOBZone {
    /**
     * 
     * @type {Array<CommonAffinitySpec>}
     * @memberof ResponseOBZone
     */
    'affinities'?: Array<CommonAffinitySpec>;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBZone
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBZone
     */
    'namespace': string;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ResponseOBZone
     */
    'nodeSelector'?: Array<CommonKVPair>;
    /**
     * 
     * @type {Array<ResponseOBServer>}
     * @memberof ResponseOBZone
     */
    'observers'?: Array<ResponseOBServer>;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBZone
     */
    'replicas': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBZone
     */
    'rootService'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBZone
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBZone
     */
    'statusDetail': string;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ResponseOBZone
     */
    'tolerations'?: Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBZone
     */
    'zone': string;
}
/**
 * 
 * @export
 * @interface ResponseOBZoneAvailableResource
 */
export interface ResponseOBZoneAvailableResource {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBZoneAvailableResource
     */
    'availableCPU': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBZoneAvailableResource
     */
    'availableDataDisk': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBZoneAvailableResource
     */
    'availableLogDisk': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBZoneAvailableResource
     */
    'availableMemory': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBZoneAvailableResource
     */
    'obZone': string;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBZoneAvailableResource
     */
    'serverCount': number;
}
/**
 * 
 * @export
 * @interface ResponseResourceSpecRender
 */
export interface ResponseResourceSpecRender {
    /**
     * 
     * @type {number}
     * @memberof ResponseResourceSpecRender
     */
    'cpu': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseResourceSpecRender
     */
    'memory': string;
}
/**
 * 
 * @export
 * @interface ResponseRestoreSource
 */
export interface ResponseRestoreSource {
    /**
     * 
     * @type {string}
     * @memberof ResponseRestoreSource
     */
    'archiveSource': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRestoreSource
     */
    'bakDataSource': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRestoreSource
     */
    'bakEncryptionSecret'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRestoreSource
     */
    'ossAccessSecret'?: string;
    /**
     * Enum: OSS, NFS
     * @type {string}
     * @memberof ResponseRestoreSource
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRestoreSource
     */
    'until'?: string;
}
/**
 * 
 * @export
 * @interface ResponseStatisticData
 */
export interface ResponseStatisticData {
    /**
     * 
     * @type {Array<ModelsOBBackupPolicy>}
     * @memberof ResponseStatisticData
     */
    'backupPolicies': Array<ModelsOBBackupPolicy>;
    /**
     * 
     * @type {Array<ModelsOBCluster>}
     * @memberof ResponseStatisticData
     */
    'clusters': Array<ModelsOBCluster>;
    /**
     * 
     * @type {Array<ResponseK8sNode>}
     * @memberof ResponseStatisticData
     */
    'k8sNodes': Array<ResponseK8sNode>;
    /**
     * 
     * @type {string}
     * @memberof ResponseStatisticData
     */
    'operatorVersion'?: string;
    /**
     * 
     * @type {Array<ModelsOBServer>}
     * @memberof ResponseStatisticData
     */
    'servers': Array<ModelsOBServer>;
    /**
     * 
     * @type {Array<ModelsOBTenant>}
     * @memberof ResponseStatisticData
     */
    'tenants': Array<ModelsOBTenant>;
    /**
     * 
     * @type {Array<ModelsK8sEvent>}
     * @memberof ResponseStatisticData
     */
    'warningEvents': Array<ModelsK8sEvent>;
    /**
     * 
     * @type {Array<ModelsOBZone>}
     * @memberof ResponseStatisticData
     */
    'zones': Array<ModelsOBZone>;
}
/**
 * 
 * @export
 * @interface ResponseStorageClass
 */
export interface ResponseStorageClass {
    /**
     * 
     * @type {boolean}
     * @memberof ResponseStorageClass
     */
    'allowVolumeExpansion': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseStorageClass
     */
    'mountOptions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResponseStorageClass
     */
    'name': string;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ResponseStorageClass
     */
    'parameters'?: Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof ResponseStorageClass
     */
    'provisioner': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseStorageClass
     */
    'reclaimPolicy': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseStorageClass
     */
    'volumeBindingMode': string;
}
/**
 * 
 * @export
 * @interface ResponseStorageSpec
 */
export interface ResponseStorageSpec {
    /**
     * 
     * @type {string}
     * @memberof ResponseStorageSpec
     */
    'size': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseStorageSpec
     */
    'storageClass': string;
}
/**
 * 
 * @export
 * @interface RouteRouteParam
 */
export interface RouteRouteParam {
    /**
     * 
     * @type {Array<string>}
     * @memberof RouteRouteParam
     */
    'aggregateLabels': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof RouteRouteParam
     */
    'groupInterval': number;
    /**
     * 
     * @type {number}
     * @memberof RouteRouteParam
     */
    'groupWait': number;
    /**
     * 
     * @type {string}
     * @memberof RouteRouteParam
     */
    'id'?: string;
    /**
     * 
     * @type {Array<AlarmMatcher>}
     * @memberof RouteRouteParam
     */
    'matchers': Array<AlarmMatcher>;
    /**
     * 
     * @type {string}
     * @memberof RouteRouteParam
     */
    'receiver': string;
    /**
     * 
     * @type {number}
     * @memberof RouteRouteParam
     */
    'repeatInterval': number;
}
/**
 * 
 * @export
 * @interface RouteRouteResponse
 */
export interface RouteRouteResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof RouteRouteResponse
     */
    'aggregateLabels': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof RouteRouteResponse
     */
    'groupInterval': number;
    /**
     * 
     * @type {number}
     * @memberof RouteRouteResponse
     */
    'groupWait': number;
    /**
     * 
     * @type {string}
     * @memberof RouteRouteResponse
     */
    'id': string;
    /**
     * 
     * @type {Array<AlarmMatcher>}
     * @memberof RouteRouteResponse
     */
    'matchers': Array<AlarmMatcher>;
    /**
     * 
     * @type {string}
     * @memberof RouteRouteResponse
     */
    'receiver': string;
    /**
     * 
     * @type {number}
     * @memberof RouteRouteResponse
     */
    'repeatInterval': number;
}
/**
 * 
 * @export
 * @interface RuleRule
 */
export interface RuleRule {
    /**
     * 
     * @type {string}
     * @memberof RuleRule
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof RuleRule
     */
    'duration': number;
    /**
     * 
     * @type {OceanbaseOBInstanceType}
     * @memberof RuleRule
     */
    'instanceType': OceanbaseOBInstanceType;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof RuleRule
     */
    'labels': Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof RuleRule
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RuleRule
     */
    'query': string;
    /**
     * 
     * @type {AlarmSeverity}
     * @memberof RuleRule
     */
    'severity': AlarmSeverity;
    /**
     * 
     * @type {string}
     * @memberof RuleRule
     */
    'summary': string;
    /**
     * 
     * @type {RuleRuleType}
     * @memberof RuleRule
     */
    'type'?: RuleRuleType;
}


/**
 * 
 * @export
 * @interface RuleRuleFilter
 */
export interface RuleRuleFilter {
    /**
     * 
     * @type {OceanbaseOBInstanceType}
     * @memberof RuleRuleFilter
     */
    'instanceType'?: OceanbaseOBInstanceType;
    /**
     * 
     * @type {string}
     * @memberof RuleRuleFilter
     */
    'keyword'?: string;
    /**
     * 
     * @type {AlarmSeverity}
     * @memberof RuleRuleFilter
     */
    'severity'?: AlarmSeverity;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RuleRuleHealth = {
    HealthUnknown: 'unknown',
    HealthOK: 'ok',
    HealthError: 'error'
} as const;

export type RuleRuleHealth = typeof RuleRuleHealth[keyof typeof RuleRuleHealth];


/**
 * 
 * @export
 * @interface RuleRuleResponse
 */
export interface RuleRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof RuleRuleResponse
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof RuleRuleResponse
     */
    'duration': number;
    /**
     * 
     * @type {number}
     * @memberof RuleRuleResponse
     */
    'evaluationTime': number;
    /**
     * 
     * @type {RuleRuleHealth}
     * @memberof RuleRuleResponse
     */
    'health': RuleRuleHealth;
    /**
     * 
     * @type {OceanbaseOBInstanceType}
     * @memberof RuleRuleResponse
     */
    'instanceType': OceanbaseOBInstanceType;
    /**
     * 
     * @type {number}
     * @memberof RuleRuleResponse
     */
    'keepFiringFor': number;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof RuleRuleResponse
     */
    'labels': Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof RuleRuleResponse
     */
    'lastError'?: string;
    /**
     * 
     * @type {number}
     * @memberof RuleRuleResponse
     */
    'lastEvaluation': number;
    /**
     * 
     * @type {string}
     * @memberof RuleRuleResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RuleRuleResponse
     */
    'query': string;
    /**
     * 
     * @type {AlarmSeverity}
     * @memberof RuleRuleResponse
     */
    'severity': AlarmSeverity;
    /**
     * 
     * @type {RuleRuleState}
     * @memberof RuleRuleResponse
     */
    'state': RuleRuleState;
    /**
     * 
     * @type {string}
     * @memberof RuleRuleResponse
     */
    'summary': string;
    /**
     * 
     * @type {RuleRuleType}
     * @memberof RuleRuleResponse
     */
    'type'?: RuleRuleType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RuleRuleState = {
    StateActive: 'active',
    StateInactive: 'inactive'
} as const;

export type RuleRuleState = typeof RuleRuleState[keyof typeof RuleRuleState];


/**
 * 
 * @export
 * @enum {string}
 */

export const RuleRuleType = {
    TypeBuiltin: 'builtin',
    TypeCustomized: 'customized'
} as const;

export type RuleRuleType = typeof RuleRuleType[keyof typeof RuleRuleType];


/**
 * 
 * @export
 * @interface SilenceSilencerFilter
 */
export interface SilenceSilencerFilter {
    /**
     * 
     * @type {OceanbaseOBInstance}
     * @memberof SilenceSilencerFilter
     */
    'instance'?: OceanbaseOBInstance;
    /**
     * 
     * @type {OceanbaseOBInstanceType}
     * @memberof SilenceSilencerFilter
     */
    'instanceType'?: OceanbaseOBInstanceType;
    /**
     * 
     * @type {string}
     * @memberof SilenceSilencerFilter
     */
    'keyword'?: string;
}


/**
 * 
 * @export
 * @interface SilenceSilencerParam
 */
export interface SilenceSilencerParam {
    /**
     * 
     * @type {string}
     * @memberof SilenceSilencerParam
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof SilenceSilencerParam
     */
    'createdBy': string;
    /**
     * 
     * @type {number}
     * @memberof SilenceSilencerParam
     */
    'endsAt': number;
    /**
     * 
     * @type {string}
     * @memberof SilenceSilencerParam
     */
    'id'?: string;
    /**
     * 
     * @type {Array<OceanbaseOBInstance>}
     * @memberof SilenceSilencerParam
     */
    'instances': Array<OceanbaseOBInstance>;
    /**
     * 
     * @type {Array<AlarmMatcher>}
     * @memberof SilenceSilencerParam
     */
    'matchers': Array<AlarmMatcher>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SilenceSilencerParam
     */
    'rules': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SilenceSilencerParam
     */
    'startsAt': number;
}
/**
 * 
 * @export
 * @interface SilenceSilencerResponse
 */
export interface SilenceSilencerResponse {
    /**
     * 
     * @type {string}
     * @memberof SilenceSilencerResponse
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof SilenceSilencerResponse
     */
    'createdBy': string;
    /**
     * 
     * @type {number}
     * @memberof SilenceSilencerResponse
     */
    'endsAt': number;
    /**
     * 
     * @type {string}
     * @memberof SilenceSilencerResponse
     */
    'id': string;
    /**
     * 
     * @type {Array<OceanbaseOBInstance>}
     * @memberof SilenceSilencerResponse
     */
    'instances': Array<OceanbaseOBInstance>;
    /**
     * 
     * @type {Array<AlarmMatcher>}
     * @memberof SilenceSilencerResponse
     */
    'matchers': Array<AlarmMatcher>;
    /**
     * 
     * @type {number}
     * @memberof SilenceSilencerResponse
     */
    'startsAt': number;
    /**
     * 
     * @type {SilenceStatus}
     * @memberof SilenceSilencerResponse
     */
    'status': SilenceStatus;
    /**
     * 
     * @type {number}
     * @memberof SilenceSilencerResponse
     */
    'updatedAt': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SilenceState = {
    StateActive: 'active',
    StateExpired: 'expired',
    StatePending: 'pending'
} as const;

export type SilenceState = typeof SilenceState[keyof typeof SilenceState];


/**
 * 
 * @export
 * @interface SilenceStatus
 */
export interface SilenceStatus {
    /**
     * 
     * @type {SilenceState}
     * @memberof SilenceStatus
     */
    'state': SilenceState;
}



/**
 * AlarmApi - axios parameter creator
 * @export
 */
export const AlarmApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create or update alarm receiver.
         * @summary Create or update alarm receiver
         * @param {ReceiverReceiver} body receiver
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateReceiver: async (body: ReceiverReceiver, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrUpdateReceiver', 'body', body)
            const localVarPath = `/api/v1/alarm/receiver/receivers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update alarm route.
         * @summary Create or update alarm route
         * @param {RouteRouteParam} body route
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateRoute: async (body: RouteRouteParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrUpdateRoute', 'body', body)
            const localVarPath = `/api/v1/alarm/route/routes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update alarm rule.
         * @summary Create or update alarm rule
         * @param {RuleRule} body rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateRule: async (body: RuleRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrUpdateRule', 'body', body)
            const localVarPath = `/api/v1/alarm/rule/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update alarm silencer.
         * @summary Create or update alarm silencer
         * @param {SilenceSilencerParam} body silencer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateSilencer: async (body: SilenceSilencerParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrUpdateSilencer', 'body', body)
            const localVarPath = `/api/v1/alarm/silence/silencers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete alarm receiver by receiver name.
         * @summary Delete alarm receiver
         * @param {string} name receiver name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReceiver: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteReceiver', 'name', name)
            const localVarPath = `/api/v1/alarm/receiver/receivers/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete alarm channel by channel name.
         * @summary Delete alarm channel
         * @param {string} id route id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoute: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRoute', 'id', id)
            const localVarPath = `/api/v1/alarm/route/routes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete alarm rule by rule name.
         * @summary Delete alarm rule
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteRule', 'name', name)
            const localVarPath = `/api/v1/alarm/rule/rules/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete alarm silencer by silencer id.
         * @summary Delete alarm silencer
         * @param {string} id silencer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSilencer: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSilencer', 'id', id)
            const localVarPath = `/api/v1/alarm/silence/silencers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get alarm receiver, query by receiver name.
         * @summary Get alarm receiver
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceiver: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getReceiver', 'name', name)
            const localVarPath = `/api/v1/alarm/receiver/receivers/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get alarm receiver template.
         * @summary Get alarm receiver template
         * @param {string} type receiver type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceiverTemplate: async (type: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getReceiverTemplate', 'type', type)
            const localVarPath = `/api/v1/alarm/receiver/templates/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get alarm route, query by route name.
         * @summary Get alarm route
         * @param {string} id route id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoute: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoute', 'id', id)
            const localVarPath = `/api/v1/alarm/route/routes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get alarm rule, query by rule name.
         * @summary Get alarm rule
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRule', 'name', name)
            const localVarPath = `/api/v1/alarm/rule/rules/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get alarm silencer, query by silencer id.
         * @summary Get alarm silencer
         * @param {string} id silencer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSilencer: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSilencer', 'id', id)
            const localVarPath = `/api/v1/alarm/silence/silencers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List alerts, filter with alarm objects, severity, time and keywords.
         * @summary List alerts
         * @param {AlertAlertFilter} [body] alert filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts: async (body?: AlertAlertFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alarm/alert/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List alarm receiver templates.
         * @summary List alarm receiver templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReceiverTemplates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alarm/receiver/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List alarm receivers, do not support filter, list all receivers at once.
         * @summary List alarm receivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReceivers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alarm/receiver/receivers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List alarm routes, do not support filter, list all routes at once.
         * @summary List alarm routes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoutes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alarm/route/routes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List alarm rules, filter with alarm objects type, severity and keywords.
         * @summary List alarm rules
         * @param {RuleRuleFilter} [body] rule filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRules: async (body?: RuleRuleFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alarm/rule/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List alarm silencers, filter with alarm objects and keywords.
         * @summary List alarm silencers
         * @param {SilenceSilencerFilter} [body] silencer filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSilencers: async (body?: SilenceSilencerFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alarm/silence/silencers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlarmApi - functional programming interface
 * @export
 */
export const AlarmApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlarmApiAxiosParamCreator(configuration)
    return {
        /**
         * Create or update alarm receiver.
         * @summary Create or update alarm receiver
         * @param {ReceiverReceiver} body receiver
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateReceiver(body: ReceiverReceiver, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateReceiver200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateReceiver(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.createOrUpdateReceiver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update alarm route.
         * @summary Create or update alarm route
         * @param {RouteRouteParam} body route
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateRoute(body: RouteRouteParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateRoute200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateRoute(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.createOrUpdateRoute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update alarm rule.
         * @summary Create or update alarm rule
         * @param {RuleRule} body rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateRule(body: RuleRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateRule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateRule(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.createOrUpdateRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update alarm silencer.
         * @summary Create or update alarm silencer
         * @param {SilenceSilencerParam} body silencer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateSilencer(body: SilenceSilencerParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateSilencer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateSilencer(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.createOrUpdateSilencer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete alarm receiver by receiver name.
         * @summary Delete alarm receiver
         * @param {string} name receiver name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReceiver(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReceiver(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.deleteReceiver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete alarm channel by channel name.
         * @summary Delete alarm channel
         * @param {string} id route id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoute(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoute(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.deleteRoute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete alarm rule by rule name.
         * @summary Delete alarm rule
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRule(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRule(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.deleteRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete alarm silencer by silencer id.
         * @summary Delete alarm silencer
         * @param {string} id silencer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSilencer(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSilencer(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.deleteSilencer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get alarm receiver, query by receiver name.
         * @summary Get alarm receiver
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReceiver(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateReceiver200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReceiver(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.getReceiver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get alarm receiver template.
         * @summary Get alarm receiver template
         * @param {string} type receiver type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReceiverTemplate(type: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReceiverTemplate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReceiverTemplate(type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.getReceiverTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get alarm route, query by route name.
         * @summary Get alarm route
         * @param {string} id route id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoute(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateRoute200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoute(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.getRoute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get alarm rule, query by rule name.
         * @summary Get alarm rule
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRule(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateRule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRule(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.getRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get alarm silencer, query by silencer id.
         * @summary Get alarm silencer
         * @param {string} id silencer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSilencer(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateSilencer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSilencer(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.getSilencer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List alerts, filter with alarm objects, severity, time and keywords.
         * @summary List alerts
         * @param {AlertAlertFilter} [body] alert filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlerts(body?: AlertAlertFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAlerts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlerts(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.listAlerts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List alarm receiver templates.
         * @summary List alarm receiver templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReceiverTemplates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListReceiverTemplates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReceiverTemplates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.listReceiverTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List alarm receivers, do not support filter, list all receivers at once.
         * @summary List alarm receivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReceivers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListReceivers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReceivers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.listReceivers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List alarm routes, do not support filter, list all routes at once.
         * @summary List alarm routes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoutes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRoutes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoutes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.listRoutes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List alarm rules, filter with alarm objects type, severity and keywords.
         * @summary List alarm rules
         * @param {RuleRuleFilter} [body] rule filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRules(body?: RuleRuleFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRules(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.listRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List alarm silencers, filter with alarm objects and keywords.
         * @summary List alarm silencers
         * @param {SilenceSilencerFilter} [body] silencer filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSilencers(body?: SilenceSilencerFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSilencers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSilencers(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.listSilencers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AlarmApi - factory interface
 * @export
 */
export const AlarmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlarmApiFp(configuration)
    return {
        /**
         * Create or update alarm receiver.
         * @summary Create or update alarm receiver
         * @param {ReceiverReceiver} body receiver
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateReceiver(body: ReceiverReceiver, options?: any): AxiosPromise<CreateOrUpdateReceiver200Response> {
            return localVarFp.createOrUpdateReceiver(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update alarm route.
         * @summary Create or update alarm route
         * @param {RouteRouteParam} body route
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateRoute(body: RouteRouteParam, options?: any): AxiosPromise<CreateOrUpdateRoute200Response> {
            return localVarFp.createOrUpdateRoute(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update alarm rule.
         * @summary Create or update alarm rule
         * @param {RuleRule} body rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateRule(body: RuleRule, options?: any): AxiosPromise<CreateOrUpdateRule200Response> {
            return localVarFp.createOrUpdateRule(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update alarm silencer.
         * @summary Create or update alarm silencer
         * @param {SilenceSilencerParam} body silencer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateSilencer(body: SilenceSilencerParam, options?: any): AxiosPromise<CreateOrUpdateSilencer200Response> {
            return localVarFp.createOrUpdateSilencer(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete alarm receiver by receiver name.
         * @summary Delete alarm receiver
         * @param {string} name receiver name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReceiver(name: string, options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.deleteReceiver(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete alarm channel by channel name.
         * @summary Delete alarm channel
         * @param {string} id route id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoute(id: string, options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.deleteRoute(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete alarm rule by rule name.
         * @summary Delete alarm rule
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule(name: string, options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.deleteRule(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete alarm silencer by silencer id.
         * @summary Delete alarm silencer
         * @param {string} id silencer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSilencer(id: string, options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.deleteSilencer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get alarm receiver, query by receiver name.
         * @summary Get alarm receiver
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceiver(name: string, options?: any): AxiosPromise<CreateOrUpdateReceiver200Response> {
            return localVarFp.getReceiver(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get alarm receiver template.
         * @summary Get alarm receiver template
         * @param {string} type receiver type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceiverTemplate(type: string, options?: any): AxiosPromise<GetReceiverTemplate200Response> {
            return localVarFp.getReceiverTemplate(type, options).then((request) => request(axios, basePath));
        },
        /**
         * Get alarm route, query by route name.
         * @summary Get alarm route
         * @param {string} id route id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoute(id: string, options?: any): AxiosPromise<CreateOrUpdateRoute200Response> {
            return localVarFp.getRoute(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get alarm rule, query by rule name.
         * @summary Get alarm rule
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule(name: string, options?: any): AxiosPromise<CreateOrUpdateRule200Response> {
            return localVarFp.getRule(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get alarm silencer, query by silencer id.
         * @summary Get alarm silencer
         * @param {string} id silencer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSilencer(id: string, options?: any): AxiosPromise<CreateOrUpdateSilencer200Response> {
            return localVarFp.getSilencer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List alerts, filter with alarm objects, severity, time and keywords.
         * @summary List alerts
         * @param {AlertAlertFilter} [body] alert filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts(body?: AlertAlertFilter, options?: any): AxiosPromise<ListAlerts200Response> {
            return localVarFp.listAlerts(body, options).then((request) => request(axios, basePath));
        },
        /**
         * List alarm receiver templates.
         * @summary List alarm receiver templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReceiverTemplates(options?: any): AxiosPromise<ListReceiverTemplates200Response> {
            return localVarFp.listReceiverTemplates(options).then((request) => request(axios, basePath));
        },
        /**
         * List alarm receivers, do not support filter, list all receivers at once.
         * @summary List alarm receivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReceivers(options?: any): AxiosPromise<ListReceivers200Response> {
            return localVarFp.listReceivers(options).then((request) => request(axios, basePath));
        },
        /**
         * List alarm routes, do not support filter, list all routes at once.
         * @summary List alarm routes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoutes(options?: any): AxiosPromise<ListRoutes200Response> {
            return localVarFp.listRoutes(options).then((request) => request(axios, basePath));
        },
        /**
         * List alarm rules, filter with alarm objects type, severity and keywords.
         * @summary List alarm rules
         * @param {RuleRuleFilter} [body] rule filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRules(body?: RuleRuleFilter, options?: any): AxiosPromise<ListRules200Response> {
            return localVarFp.listRules(body, options).then((request) => request(axios, basePath));
        },
        /**
         * List alarm silencers, filter with alarm objects and keywords.
         * @summary List alarm silencers
         * @param {SilenceSilencerFilter} [body] silencer filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSilencers(body?: SilenceSilencerFilter, options?: any): AxiosPromise<ListSilencers200Response> {
            return localVarFp.listSilencers(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlarmApi - object-oriented interface
 * @export
 * @class AlarmApi
 * @extends {BaseAPI}
 */
export class AlarmApi extends BaseAPI {
    /**
     * Create or update alarm receiver.
     * @summary Create or update alarm receiver
     * @param {ReceiverReceiver} body receiver
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public createOrUpdateReceiver(body: ReceiverReceiver, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).createOrUpdateReceiver(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update alarm route.
     * @summary Create or update alarm route
     * @param {RouteRouteParam} body route
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public createOrUpdateRoute(body: RouteRouteParam, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).createOrUpdateRoute(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update alarm rule.
     * @summary Create or update alarm rule
     * @param {RuleRule} body rule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public createOrUpdateRule(body: RuleRule, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).createOrUpdateRule(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update alarm silencer.
     * @summary Create or update alarm silencer
     * @param {SilenceSilencerParam} body silencer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public createOrUpdateSilencer(body: SilenceSilencerParam, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).createOrUpdateSilencer(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete alarm receiver by receiver name.
     * @summary Delete alarm receiver
     * @param {string} name receiver name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public deleteReceiver(name: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).deleteReceiver(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete alarm channel by channel name.
     * @summary Delete alarm channel
     * @param {string} id route id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public deleteRoute(id: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).deleteRoute(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete alarm rule by rule name.
     * @summary Delete alarm rule
     * @param {string} name rule name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public deleteRule(name: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).deleteRule(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete alarm silencer by silencer id.
     * @summary Delete alarm silencer
     * @param {string} id silencer id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public deleteSilencer(id: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).deleteSilencer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get alarm receiver, query by receiver name.
     * @summary Get alarm receiver
     * @param {string} name rule name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public getReceiver(name: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).getReceiver(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get alarm receiver template.
     * @summary Get alarm receiver template
     * @param {string} type receiver type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public getReceiverTemplate(type: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).getReceiverTemplate(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get alarm route, query by route name.
     * @summary Get alarm route
     * @param {string} id route id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public getRoute(id: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).getRoute(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get alarm rule, query by rule name.
     * @summary Get alarm rule
     * @param {string} name rule name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public getRule(name: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).getRule(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get alarm silencer, query by silencer id.
     * @summary Get alarm silencer
     * @param {string} id silencer id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public getSilencer(id: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).getSilencer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List alerts, filter with alarm objects, severity, time and keywords.
     * @summary List alerts
     * @param {AlertAlertFilter} [body] alert filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public listAlerts(body?: AlertAlertFilter, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).listAlerts(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List alarm receiver templates.
     * @summary List alarm receiver templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public listReceiverTemplates(options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).listReceiverTemplates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List alarm receivers, do not support filter, list all receivers at once.
     * @summary List alarm receivers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public listReceivers(options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).listReceivers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List alarm routes, do not support filter, list all routes at once.
     * @summary List alarm routes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public listRoutes(options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).listRoutes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List alarm rules, filter with alarm objects type, severity and keywords.
     * @summary List alarm rules
     * @param {RuleRuleFilter} [body] rule filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public listRules(body?: RuleRuleFilter, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).listRules(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List alarm silencers, filter with alarm objects and keywords.
     * @summary List alarm silencers
     * @param {SilenceSilencerFilter} [body] silencer filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public listSilencers(body?: SilenceSilencerFilter, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).listSilencers(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClusterApi - axios parameter creator
 * @export
 */
export const ClusterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create k8s namespace
         * @summary create k8s namespace
         * @param {ParamCreateNamespaceParam} body create obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createK8sNamespace: async (body: ParamCreateNamespaceParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createK8sNamespace', 'body', body)
            const localVarPath = `/api/v1/cluster/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list k8s events
         * @summary list k8s event
         * @param {ListK8sEventsObjectTypeEnum} [objectType] related object types
         * @param {ListK8sEventsTypeEnum} [type] event level
         * @param {string} [name] Object name
         * @param {string} [namespace] Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sEvents: async (objectType?: ListK8sEventsObjectTypeEnum, type?: ListK8sEventsTypeEnum, name?: string, namespace?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/cluster/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)

            if (objectType !== undefined) {
                localVarQueryParameter['objectType'] = objectType;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list k8s namespaces
         * @summary list k8s namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sNamespaces: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/cluster/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list k8s nodes
         * @summary list k8s nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sNodes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/cluster/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list k8s storage classes
         * @summary list k8s storage classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sStorageClasses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/cluster/storageClasses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterApi - functional programming interface
 * @export
 */
export const ClusterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClusterApiAxiosParamCreator(configuration)
    return {
        /**
         * create k8s namespace
         * @summary create k8s namespace
         * @param {ParamCreateNamespaceParam} body create obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createK8sNamespace(body: ParamCreateNamespaceParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createK8sNamespace(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterApi.createK8sNamespace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list k8s events
         * @summary list k8s event
         * @param {ListK8sEventsObjectTypeEnum} [objectType] related object types
         * @param {ListK8sEventsTypeEnum} [type] event level
         * @param {string} [name] Object name
         * @param {string} [namespace] Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listK8sEvents(objectType?: ListK8sEventsObjectTypeEnum, type?: ListK8sEventsTypeEnum, name?: string, namespace?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListK8sEvents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listK8sEvents(objectType, type, name, namespace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterApi.listK8sEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list k8s namespaces
         * @summary list k8s namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listK8sNamespaces(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListK8sNamespaces200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listK8sNamespaces(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterApi.listK8sNamespaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list k8s nodes
         * @summary list k8s nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listK8sNodes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListK8sNodes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listK8sNodes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterApi.listK8sNodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list k8s storage classes
         * @summary list k8s storage classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listK8sStorageClasses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListK8sStorageClasses200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listK8sStorageClasses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterApi.listK8sStorageClasses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClusterApi - factory interface
 * @export
 */
export const ClusterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClusterApiFp(configuration)
    return {
        /**
         * create k8s namespace
         * @summary create k8s namespace
         * @param {ParamCreateNamespaceParam} body create obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createK8sNamespace(body: ParamCreateNamespaceParam, options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.createK8sNamespace(body, options).then((request) => request(axios, basePath));
        },
        /**
         * list k8s events
         * @summary list k8s event
         * @param {ListK8sEventsObjectTypeEnum} [objectType] related object types
         * @param {ListK8sEventsTypeEnum} [type] event level
         * @param {string} [name] Object name
         * @param {string} [namespace] Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sEvents(objectType?: ListK8sEventsObjectTypeEnum, type?: ListK8sEventsTypeEnum, name?: string, namespace?: string, options?: any): AxiosPromise<ListK8sEvents200Response> {
            return localVarFp.listK8sEvents(objectType, type, name, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * list k8s namespaces
         * @summary list k8s namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sNamespaces(options?: any): AxiosPromise<ListK8sNamespaces200Response> {
            return localVarFp.listK8sNamespaces(options).then((request) => request(axios, basePath));
        },
        /**
         * list k8s nodes
         * @summary list k8s nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sNodes(options?: any): AxiosPromise<ListK8sNodes200Response> {
            return localVarFp.listK8sNodes(options).then((request) => request(axios, basePath));
        },
        /**
         * list k8s storage classes
         * @summary list k8s storage classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sStorageClasses(options?: any): AxiosPromise<ListK8sStorageClasses200Response> {
            return localVarFp.listK8sStorageClasses(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClusterApi - object-oriented interface
 * @export
 * @class ClusterApi
 * @extends {BaseAPI}
 */
export class ClusterApi extends BaseAPI {
    /**
     * create k8s namespace
     * @summary create k8s namespace
     * @param {ParamCreateNamespaceParam} body create obcluster request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public createK8sNamespace(body: ParamCreateNamespaceParam, options?: RawAxiosRequestConfig) {
        return ClusterApiFp(this.configuration).createK8sNamespace(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list k8s events
     * @summary list k8s event
     * @param {ListK8sEventsObjectTypeEnum} [objectType] related object types
     * @param {ListK8sEventsTypeEnum} [type] event level
     * @param {string} [name] Object name
     * @param {string} [namespace] Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public listK8sEvents(objectType?: ListK8sEventsObjectTypeEnum, type?: ListK8sEventsTypeEnum, name?: string, namespace?: string, options?: RawAxiosRequestConfig) {
        return ClusterApiFp(this.configuration).listK8sEvents(objectType, type, name, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list k8s namespaces
     * @summary list k8s namespaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public listK8sNamespaces(options?: RawAxiosRequestConfig) {
        return ClusterApiFp(this.configuration).listK8sNamespaces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list k8s nodes
     * @summary list k8s nodes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public listK8sNodes(options?: RawAxiosRequestConfig) {
        return ClusterApiFp(this.configuration).listK8sNodes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list k8s storage classes
     * @summary list k8s storage classes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public listK8sStorageClasses(options?: RawAxiosRequestConfig) {
        return ClusterApiFp(this.configuration).listK8sStorageClasses(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListK8sEventsObjectTypeEnum = {
    OBCLUSTER: 'OBCLUSTER',
    OBTENANT: 'OBTENANT',
    OBBACKUPPOLICY: 'OBBACKUPPOLICY',
    OBPROXY: 'OBPROXY'
} as const;
export type ListK8sEventsObjectTypeEnum = typeof ListK8sEventsObjectTypeEnum[keyof typeof ListK8sEventsObjectTypeEnum];
/**
 * @export
 */
export const ListK8sEventsTypeEnum = {
    NORMAL: 'NORMAL',
    WARNING: 'WARNING'
} as const;
export type ListK8sEventsTypeEnum = typeof ListK8sEventsTypeEnum[keyof typeof ListK8sEventsTypeEnum];


/**
 * InfoApi - axios parameter creator
 * @export
 */
export const InfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get process info of OceanBase Dashboard, including process name etc.
         * @summary Get process info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get statistic data
         * @summary get statistic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatistics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 * @export
 */
export const InfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoApiAxiosParamCreator(configuration)
    return {
        /**
         * Get process info of OceanBase Dashboard, including process name etc.
         * @summary Get process info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProcessInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.getProcessInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get statistic data
         * @summary get statistic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatistics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatistics200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatistics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.getStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfoApi - factory interface
 * @export
 */
export const InfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoApiFp(configuration)
    return {
        /**
         * Get process info of OceanBase Dashboard, including process name etc.
         * @summary Get process info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInfo(options?: any): AxiosPromise<GetProcessInfo200Response> {
            return localVarFp.getProcessInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * get statistic data
         * @summary get statistic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatistics(options?: any): AxiosPromise<GetStatistics200Response> {
            return localVarFp.getStatistics(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoApi - object-oriented interface
 * @export
 * @class InfoApi
 * @extends {BaseAPI}
 */
export class InfoApi extends BaseAPI {
    /**
     * Get process info of OceanBase Dashboard, including process name etc.
     * @summary Get process info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public getProcessInfo(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).getProcessInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get statistic data
     * @summary get statistic data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public getStatistics(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).getStatistics(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetricApi - axios parameter creator
 * @export
 */
export const MetricApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * list all metrics meta info, return by groups
         * @summary list all metrics
         * @param {ListAllMetricsScopeEnum} scope metrics scope
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllMetrics: async (scope: ListAllMetricsScopeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('listAllMetrics', 'scope', scope)
            const localVarPath = `/api/v1/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * query metric data
         * @summary query metrics
         * @param {ParamMetricQuery} body metric query request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryMetrics: async (body: ParamMetricQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('queryMetrics', 'body', body)
            const localVarPath = `/api/v1/metrics/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricApi - functional programming interface
 * @export
 */
export const MetricApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricApiAxiosParamCreator(configuration)
    return {
        /**
         * list all metrics meta info, return by groups
         * @summary list all metrics
         * @param {ListAllMetricsScopeEnum} scope metrics scope
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllMetrics(scope: ListAllMetricsScopeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllMetrics200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllMetrics(scope, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricApi.listAllMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * query metric data
         * @summary query metrics
         * @param {ParamMetricQuery} body metric query request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryMetrics(body: ParamMetricQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryMetrics200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryMetrics(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricApi.queryMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetricApi - factory interface
 * @export
 */
export const MetricApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricApiFp(configuration)
    return {
        /**
         * list all metrics meta info, return by groups
         * @summary list all metrics
         * @param {ListAllMetricsScopeEnum} scope metrics scope
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllMetrics(scope: ListAllMetricsScopeEnum, options?: any): AxiosPromise<ListAllMetrics200Response> {
            return localVarFp.listAllMetrics(scope, options).then((request) => request(axios, basePath));
        },
        /**
         * query metric data
         * @summary query metrics
         * @param {ParamMetricQuery} body metric query request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryMetrics(body: ParamMetricQuery, options?: any): AxiosPromise<QueryMetrics200Response> {
            return localVarFp.queryMetrics(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricApi - object-oriented interface
 * @export
 * @class MetricApi
 * @extends {BaseAPI}
 */
export class MetricApi extends BaseAPI {
    /**
     * list all metrics meta info, return by groups
     * @summary list all metrics
     * @param {ListAllMetricsScopeEnum} scope metrics scope
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricApi
     */
    public listAllMetrics(scope: ListAllMetricsScopeEnum, options?: RawAxiosRequestConfig) {
        return MetricApiFp(this.configuration).listAllMetrics(scope, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * query metric data
     * @summary query metrics
     * @param {ParamMetricQuery} body metric query request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricApi
     */
    public queryMetrics(body: ParamMetricQuery, options?: RawAxiosRequestConfig) {
        return MetricApiFp(this.configuration).queryMetrics(body, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListAllMetricsScopeEnum = {
    OBCLUSTER: 'OBCLUSTER',
    OBTENANT: 'OBTENANT'
} as const;
export type ListAllMetricsScopeEnum = typeof ListAllMetricsScopeEnum[keyof typeof ListAllMetricsScopeEnum];


/**
 * OBClusterApi - axios parameter creator
 * @export
 */
export const OBClusterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * add obzone
         * @summary add obzone
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamZoneTopology} body add obzone request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOBZone: async (namespace: string, name: string, body: ParamZoneTopology, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('addOBZone', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addOBZone', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addOBZone', 'body', body)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}/obzones`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create obcluster
         * @summary create obcluster
         * @param {ParamCreateOBClusterParam} body create obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBCluster: async (body: ParamCreateOBClusterParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOBCluster', 'body', body)
            const localVarPath = `/api/v1/obclusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete obcluster
         * @summary delete obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBCluster: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteOBCluster', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteOBCluster', 'name', name)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete obzone
         * @summary delete obzone
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {string} obzoneName obzone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBZone: async (namespace: string, name: string, obzoneName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteOBZone', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteOBZone', 'name', name)
            // verify required parameter 'obzoneName' is not null or undefined
            assertParamExists('deleteOBZone', 'obzoneName', obzoneName)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}/obzones/{obzoneName}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"obzoneName"}}`, encodeURIComponent(String(obzoneName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get obcluster detailed info
         * @summary get obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOBCluster: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getOBCluster', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getOBCluster', 'name', name)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get obcluster statistic info
         * @summary get obcluster statistic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOBClusterStatistic: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/obclusters/statistic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list related events of specific obcluster, including obzone and observer.
         * @summary list related events
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBClusterRelatedEvents: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listOBClusterRelatedEvents', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listOBClusterRelatedEvents', 'name', name)
            const localVarPath = `/api/v1/obclusters/{namespace}/{name}/related-events`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list resource usages of specific obcluster, such as cpu, memory, storage, etc. The old router ending with /essential-parameters is deprecated
         * @summary list resource usages, the old router ending with /essential-parameters is deprecated
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBClusterResources: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listOBClusterResources', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listOBClusterResources', 'name', name)
            const localVarPath = `/api/v1/obclusters/{namespace}/{name}/resource-usages`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list obclusters
         * @summary list obclusters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBClusters: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/obclusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * scale observer
         * @summary scale observer
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {string} obzoneName obzone name
         * @param {ParamScaleOBServerParam} body scale observer request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scaleOBServer: async (namespace: string, name: string, obzoneName: string, body: ParamScaleOBServerParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('scaleOBServer', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('scaleOBServer', 'name', name)
            // verify required parameter 'obzoneName' is not null or undefined
            assertParamExists('scaleOBServer', 'obzoneName', obzoneName)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('scaleOBServer', 'body', body)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}/obzones/{obzoneName}/scale`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"obzoneName"}}`, encodeURIComponent(String(obzoneName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * upgrade obcluster
         * @summary upgrade obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamUpgradeOBClusterParam} body upgrade obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeOBCluster: async (namespace: string, name: string, body: ParamUpgradeOBClusterParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('upgradeOBCluster', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('upgradeOBCluster', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('upgradeOBCluster', 'body', body)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OBClusterApi - functional programming interface
 * @export
 */
export const OBClusterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OBClusterApiAxiosParamCreator(configuration)
    return {
        /**
         * add obzone
         * @summary add obzone
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamZoneTopology} body add obzone request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOBZone(namespace: string, name: string, body: ParamZoneTopology, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBCluster200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOBZone(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.addOBZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create obcluster
         * @summary create obcluster
         * @param {ParamCreateOBClusterParam} body create obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOBCluster(body: ParamCreateOBClusterParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBCluster200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOBCluster(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.createOBCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete obcluster
         * @summary delete obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOBCluster(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteOBCluster200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOBCluster(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.deleteOBCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete obzone
         * @summary delete obzone
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {string} obzoneName obzone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOBZone(namespace: string, name: string, obzoneName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBCluster200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOBZone(namespace, name, obzoneName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.deleteOBZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get obcluster detailed info
         * @summary get obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOBCluster(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBCluster200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOBCluster(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.getOBCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get obcluster statistic info
         * @summary get obcluster statistic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOBClusterStatistic(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOBClusterStatistic200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOBClusterStatistic(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.getOBClusterStatistic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list related events of specific obcluster, including obzone and observer.
         * @summary list related events
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOBClusterRelatedEvents(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListK8sEvents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOBClusterRelatedEvents(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.listOBClusterRelatedEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list resource usages of specific obcluster, such as cpu, memory, storage, etc. The old router ending with /essential-parameters is deprecated
         * @summary list resource usages, the old router ending with /essential-parameters is deprecated
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOBClusterResources(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOBClusterResources200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOBClusterResources(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.listOBClusterResources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list obclusters
         * @summary list obclusters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOBClusters(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOBClusters200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOBClusters(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.listOBClusters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * scale observer
         * @summary scale observer
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {string} obzoneName obzone name
         * @param {ParamScaleOBServerParam} body scale observer request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scaleOBServer(namespace: string, name: string, obzoneName: string, body: ParamScaleOBServerParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBCluster200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scaleOBServer(namespace, name, obzoneName, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.scaleOBServer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * upgrade obcluster
         * @summary upgrade obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamUpgradeOBClusterParam} body upgrade obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upgradeOBCluster(namespace: string, name: string, body: ParamUpgradeOBClusterParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBCluster200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upgradeOBCluster(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.upgradeOBCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OBClusterApi - factory interface
 * @export
 */
export const OBClusterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OBClusterApiFp(configuration)
    return {
        /**
         * add obzone
         * @summary add obzone
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamZoneTopology} body add obzone request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOBZone(namespace: string, name: string, body: ParamZoneTopology, options?: any): AxiosPromise<CreateOBCluster200Response> {
            return localVarFp.addOBZone(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * create obcluster
         * @summary create obcluster
         * @param {ParamCreateOBClusterParam} body create obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBCluster(body: ParamCreateOBClusterParam, options?: any): AxiosPromise<CreateOBCluster200Response> {
            return localVarFp.createOBCluster(body, options).then((request) => request(axios, basePath));
        },
        /**
         * delete obcluster
         * @summary delete obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBCluster(namespace: string, name: string, options?: any): AxiosPromise<DeleteOBCluster200Response> {
            return localVarFp.deleteOBCluster(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * delete obzone
         * @summary delete obzone
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {string} obzoneName obzone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBZone(namespace: string, name: string, obzoneName: string, options?: any): AxiosPromise<CreateOBCluster200Response> {
            return localVarFp.deleteOBZone(namespace, name, obzoneName, options).then((request) => request(axios, basePath));
        },
        /**
         * get obcluster detailed info
         * @summary get obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOBCluster(namespace: string, name: string, options?: any): AxiosPromise<CreateOBCluster200Response> {
            return localVarFp.getOBCluster(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * get obcluster statistic info
         * @summary get obcluster statistic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOBClusterStatistic(options?: any): AxiosPromise<GetOBClusterStatistic200Response> {
            return localVarFp.getOBClusterStatistic(options).then((request) => request(axios, basePath));
        },
        /**
         * list related events of specific obcluster, including obzone and observer.
         * @summary list related events
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBClusterRelatedEvents(namespace: string, name: string, options?: any): AxiosPromise<ListK8sEvents200Response> {
            return localVarFp.listOBClusterRelatedEvents(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * list resource usages of specific obcluster, such as cpu, memory, storage, etc. The old router ending with /essential-parameters is deprecated
         * @summary list resource usages, the old router ending with /essential-parameters is deprecated
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBClusterResources(namespace: string, name: string, options?: any): AxiosPromise<ListOBClusterResources200Response> {
            return localVarFp.listOBClusterResources(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * list obclusters
         * @summary list obclusters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBClusters(options?: any): AxiosPromise<ListOBClusters200Response> {
            return localVarFp.listOBClusters(options).then((request) => request(axios, basePath));
        },
        /**
         * scale observer
         * @summary scale observer
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {string} obzoneName obzone name
         * @param {ParamScaleOBServerParam} body scale observer request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scaleOBServer(namespace: string, name: string, obzoneName: string, body: ParamScaleOBServerParam, options?: any): AxiosPromise<CreateOBCluster200Response> {
            return localVarFp.scaleOBServer(namespace, name, obzoneName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * upgrade obcluster
         * @summary upgrade obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamUpgradeOBClusterParam} body upgrade obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeOBCluster(namespace: string, name: string, body: ParamUpgradeOBClusterParam, options?: any): AxiosPromise<CreateOBCluster200Response> {
            return localVarFp.upgradeOBCluster(namespace, name, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OBClusterApi - object-oriented interface
 * @export
 * @class OBClusterApi
 * @extends {BaseAPI}
 */
export class OBClusterApi extends BaseAPI {
    /**
     * add obzone
     * @summary add obzone
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {ParamZoneTopology} body add obzone request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public addOBZone(namespace: string, name: string, body: ParamZoneTopology, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).addOBZone(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create obcluster
     * @summary create obcluster
     * @param {ParamCreateOBClusterParam} body create obcluster request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public createOBCluster(body: ParamCreateOBClusterParam, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).createOBCluster(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete obcluster
     * @summary delete obcluster
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public deleteOBCluster(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).deleteOBCluster(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete obzone
     * @summary delete obzone
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {string} obzoneName obzone name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public deleteOBZone(namespace: string, name: string, obzoneName: string, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).deleteOBZone(namespace, name, obzoneName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get obcluster detailed info
     * @summary get obcluster
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public getOBCluster(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).getOBCluster(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get obcluster statistic info
     * @summary get obcluster statistic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public getOBClusterStatistic(options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).getOBClusterStatistic(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list related events of specific obcluster, including obzone and observer.
     * @summary list related events
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public listOBClusterRelatedEvents(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).listOBClusterRelatedEvents(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list resource usages of specific obcluster, such as cpu, memory, storage, etc. The old router ending with /essential-parameters is deprecated
     * @summary list resource usages, the old router ending with /essential-parameters is deprecated
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public listOBClusterResources(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).listOBClusterResources(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list obclusters
     * @summary list obclusters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public listOBClusters(options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).listOBClusters(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * scale observer
     * @summary scale observer
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {string} obzoneName obzone name
     * @param {ParamScaleOBServerParam} body scale observer request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public scaleOBServer(namespace: string, name: string, obzoneName: string, body: ParamScaleOBServerParam, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).scaleOBServer(namespace, name, obzoneName, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * upgrade obcluster
     * @summary upgrade obcluster
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {ParamUpgradeOBClusterParam} body upgrade obcluster request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public upgradeOBCluster(namespace: string, name: string, body: ParamUpgradeOBClusterParam, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).upgradeOBCluster(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OBProxyApi - axios parameter creator
 * @export
 */
export const OBProxyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create OBProxy with the specified parameters
         * @summary Create OBProxy
         * @param {ObproxyCreateOBProxyParam} body Request body for creating obproxy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBPROXY: async (body: ObproxyCreateOBProxyParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOBPROXY', 'body', body)
            const localVarPath = `/api/v1/obproxies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete OBProxy by namespace and name
         * @summary Delete OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBProxy: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteOBProxy', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteOBProxy', 'name', name)
            const localVarPath = `/api/v1/obproxies/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get OBProxy by namespace and name
         * @summary Get OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOBProxy: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getOBProxy', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getOBProxy', 'name', name)
            const localVarPath = `/api/v1/obproxies/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list obproxies
         * @summary list obproxies
         * @param {string} [ns] ns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBProxies: async (ns?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/obproxies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)

            if (ns !== undefined) {
                localVarQueryParameter['ns'] = ns;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List OBProxy Parameters by namespace and name
         * @summary List OBProxy Parameters
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBProxyParameters: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listOBProxyParameters', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listOBProxyParameters', 'name', name)
            const localVarPath = `/api/v1/obproxies/{namespace}/{name}/parameters`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch OBProxy with the specified parameters
         * @summary Patch OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {ObproxyPatchOBProxyParam} body Request body for patching obproxy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOBProxy: async (namespace: string, name: string, body: ObproxyPatchOBProxyParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('patchOBProxy', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('patchOBProxy', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchOBProxy', 'body', body)
            const localVarPath = `/api/v1/obproxies/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OBProxyApi - functional programming interface
 * @export
 */
export const OBProxyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OBProxyApiAxiosParamCreator(configuration)
    return {
        /**
         * Create OBProxy with the specified parameters
         * @summary Create OBProxy
         * @param {ObproxyCreateOBProxyParam} body Request body for creating obproxy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOBPROXY(body: ObproxyCreateOBProxyParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBPROXY200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOBPROXY(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBProxyApi.createOBPROXY']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete OBProxy by namespace and name
         * @summary Delete OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOBProxy(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBPROXY200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOBProxy(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBProxyApi.deleteOBProxy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get OBProxy by namespace and name
         * @summary Get OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOBProxy(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBPROXY200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOBProxy(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBProxyApi.getOBProxy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list obproxies
         * @summary list obproxies
         * @param {string} [ns] ns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOBProxies(ns?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOBProxies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOBProxies(ns, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBProxyApi.listOBProxies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List OBProxy Parameters by namespace and name
         * @summary List OBProxy Parameters
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOBProxyParameters(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOBProxyParameters200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOBProxyParameters(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBProxyApi.listOBProxyParameters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Patch OBProxy with the specified parameters
         * @summary Patch OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {ObproxyPatchOBProxyParam} body Request body for patching obproxy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOBProxy(namespace: string, name: string, body: ObproxyPatchOBProxyParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBPROXY200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOBProxy(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBProxyApi.patchOBProxy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OBProxyApi - factory interface
 * @export
 */
export const OBProxyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OBProxyApiFp(configuration)
    return {
        /**
         * Create OBProxy with the specified parameters
         * @summary Create OBProxy
         * @param {ObproxyCreateOBProxyParam} body Request body for creating obproxy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBPROXY(body: ObproxyCreateOBProxyParam, options?: any): AxiosPromise<CreateOBPROXY200Response> {
            return localVarFp.createOBPROXY(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete OBProxy by namespace and name
         * @summary Delete OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBProxy(namespace: string, name: string, options?: any): AxiosPromise<CreateOBPROXY200Response> {
            return localVarFp.deleteOBProxy(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get OBProxy by namespace and name
         * @summary Get OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOBProxy(namespace: string, name: string, options?: any): AxiosPromise<CreateOBPROXY200Response> {
            return localVarFp.getOBProxy(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * list obproxies
         * @summary list obproxies
         * @param {string} [ns] ns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBProxies(ns?: string, options?: any): AxiosPromise<ListOBProxies200Response> {
            return localVarFp.listOBProxies(ns, options).then((request) => request(axios, basePath));
        },
        /**
         * List OBProxy Parameters by namespace and name
         * @summary List OBProxy Parameters
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBProxyParameters(namespace: string, name: string, options?: any): AxiosPromise<ListOBProxyParameters200Response> {
            return localVarFp.listOBProxyParameters(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch OBProxy with the specified parameters
         * @summary Patch OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {ObproxyPatchOBProxyParam} body Request body for patching obproxy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOBProxy(namespace: string, name: string, body: ObproxyPatchOBProxyParam, options?: any): AxiosPromise<CreateOBPROXY200Response> {
            return localVarFp.patchOBProxy(namespace, name, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OBProxyApi - object-oriented interface
 * @export
 * @class OBProxyApi
 * @extends {BaseAPI}
 */
export class OBProxyApi extends BaseAPI {
    /**
     * Create OBProxy with the specified parameters
     * @summary Create OBProxy
     * @param {ObproxyCreateOBProxyParam} body Request body for creating obproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBProxyApi
     */
    public createOBPROXY(body: ObproxyCreateOBProxyParam, options?: RawAxiosRequestConfig) {
        return OBProxyApiFp(this.configuration).createOBPROXY(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete OBProxy by namespace and name
     * @summary Delete OBProxy
     * @param {string} namespace namespace of obproxy deployment
     * @param {string} name name of obproxy deployment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBProxyApi
     */
    public deleteOBProxy(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBProxyApiFp(this.configuration).deleteOBProxy(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get OBProxy by namespace and name
     * @summary Get OBProxy
     * @param {string} namespace namespace of obproxy deployment
     * @param {string} name name of obproxy deployment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBProxyApi
     */
    public getOBProxy(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBProxyApiFp(this.configuration).getOBProxy(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list obproxies
     * @summary list obproxies
     * @param {string} [ns] ns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBProxyApi
     */
    public listOBProxies(ns?: string, options?: RawAxiosRequestConfig) {
        return OBProxyApiFp(this.configuration).listOBProxies(ns, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List OBProxy Parameters by namespace and name
     * @summary List OBProxy Parameters
     * @param {string} namespace namespace of obproxy deployment
     * @param {string} name name of obproxy deployment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBProxyApi
     */
    public listOBProxyParameters(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBProxyApiFp(this.configuration).listOBProxyParameters(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch OBProxy with the specified parameters
     * @summary Patch OBProxy
     * @param {string} namespace namespace of obproxy deployment
     * @param {string} name name of obproxy deployment
     * @param {ObproxyPatchOBProxyParam} body Request body for patching obproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBProxyApi
     */
    public patchOBProxy(namespace: string, name: string, body: ObproxyPatchOBProxyParam, options?: RawAxiosRequestConfig) {
        return OBProxyApiFp(this.configuration).patchOBProxy(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OBTenantApi - axios parameter creator
 * @export
 */
export const OBTenantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change tenant role of specific tenant, if a tenant is a standby tenant, it can be changed to primary tenant, vice versa
         * @summary Change tenant role of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamChangeTenantRole} body target role to change to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeTenantRole: async (namespace: string, name: string, body: ParamChangeTenantRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('changeTenantRole', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('changeTenantRole', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('changeTenantRole', 'body', body)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/role`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change root password of specific tenant, encrypted by AES
         * @summary Change root password of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamChangeUserPassword} body new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPassword: async (namespace: string, name: string, body: ParamChangeUserPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('changeUserPassword', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('changeUserPassword', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('changeUserPassword', 'body', body)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/userCredentials`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create backup policy of specific tenant, passwords should be encrypted by AES
         * @summary Create backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamCreateBackupPolicy} body create backup policy request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBackupPolicy: async (namespace: string, name: string, body: ParamCreateBackupPolicy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('createBackupPolicy', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createBackupPolicy', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createBackupPolicy', 'body', body)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/backupPolicy`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an obtenant pool in a specific namespace
         * @summary Create obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {ParamTenantPoolSpec} body create obtenant pool request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBTenantPool: async (namespace: string, name: string, zoneName: string, body: ParamTenantPoolSpec, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('createOBTenantPool', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createOBTenantPool', 'name', name)
            // verify required parameter 'zoneName' is not null or undefined
            assertParamExists('createOBTenantPool', 'zoneName', zoneName)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOBTenantPool', 'body', body)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/pools/{zoneName}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"zoneName"}}`, encodeURIComponent(String(zoneName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an obtenant in a specific namespace, passwords should be encrypted by AES
         * @summary Create tenant
         * @param {ParamCreateOBTenantParam} body create obtenant request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant: async (body: ParamCreateOBTenantParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createTenant', 'body', body)
            const localVarPath = `/api/v1/obtenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete backup policy of specific tenant
         * @summary Delete backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} [force] force delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackupPolicy: async (namespace: string, name: string, force?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteBackupPolicy', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteBackupPolicy', 'name', name)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/backupPolicy`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an obtenant pool in a specific namespace
         * @summary Delete obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBTenantPool: async (namespace: string, name: string, zoneName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteOBTenantPool', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteOBTenantPool', 'name', name)
            // verify required parameter 'zoneName' is not null or undefined
            assertParamExists('deleteOBTenantPool', 'zoneName', zoneName)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/pools/{zoneName}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"zoneName"}}`, encodeURIComponent(String(zoneName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an obtenant in a specific namespace, ask user to confrim the deletion carefully
         * @summary Delete tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenant: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteTenant', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteTenant', 'name', name)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get backup policy of specific tenant
         * @summary Get backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupPolicy: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getBackupPolicy', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getBackupPolicy', 'name', name)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/backupPolicy`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List statistics information of tenants
         * @summary List statistics information of tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOBTenantStatistic: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/obtenants/statistic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an obtenant in a specific namespace
         * @summary Get tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenant: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getTenant', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getTenant', 'name', name)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all tenants and return them
         * @summary List all tenants
         * @param {string} [obcluster] obcluster to filter
         * @param {string} [ns] namespace to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTenants: async (obcluster?: string, ns?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/obtenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)

            if (obcluster !== undefined) {
                localVarQueryParameter['obcluster'] = obcluster;
            }

            if (ns !== undefined) {
                localVarQueryParameter['ns'] = ns;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List backup jobs of specific tenant
         * @summary List backup jobs of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ListBackupJobsTypeEnum} type backup job type
         * @param {number} [limit] limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBackupJobs: async (namespace: string, name: string, type: ListBackupJobsTypeEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listBackupJobs', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listBackupJobs', 'name', name)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('listBackupJobs', 'type', type)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/backup/{type}/jobs`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List related events of specific tenant, including restore, backup and backup policy events
         * @summary List related events of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBTenantRelatedEvents: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listOBTenantRelatedEvents', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listOBTenantRelatedEvents', 'name', name)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/related-events`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch an obtenant pool in a specific namespace
         * @summary Patch obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {ParamTenantPoolSpec} body patch obtenant pool request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOBTenantPool: async (namespace: string, name: string, zoneName: string, body: ParamTenantPoolSpec, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('patchOBTenantPool', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('patchOBTenantPool', 'name', name)
            // verify required parameter 'zoneName' is not null or undefined
            assertParamExists('patchOBTenantPool', 'zoneName', zoneName)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchOBTenantPool', 'body', body)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/pools/{zoneName}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"zoneName"}}`, encodeURIComponent(String(zoneName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch tenant\'s configuration
         * @summary Patch tenant\'s configuration
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamPatchTenant} body patch tenant body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTenant: async (namespace: string, name: string, body: ParamPatchTenant, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('patchTenant', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('patchTenant', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchTenant', 'body', body)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replay standby log of specific standby tenant
         * @summary Replay standby log of specific standby tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamReplayStandbyLog} body target timestamp to replay to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replayStandbyLog: async (namespace: string, name: string, body: ParamReplayStandbyLog, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('replayStandbyLog', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('replayStandbyLog', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('replayStandbyLog', 'body', body)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/logreplay`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update backup policy of specific tenant
         * @summary Update backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamUpdateBackupPolicy} body update backup policy request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBackupPolicy: async (namespace: string, name: string, body: ParamUpdateBackupPolicy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateBackupPolicy', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateBackupPolicy', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateBackupPolicy', 'body', body)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/backupPolicy`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upgrade tenant compatibility version of specific tenant to match the version of cluster
         * @summary Upgrade tenant compatibility version of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeTenantVersion: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('upgradeTenantVersion', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('upgradeTenantVersion', 'name', name)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/version`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OBTenantApi - functional programming interface
 * @export
 */
export const OBTenantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OBTenantApiAxiosParamCreator(configuration)
    return {
        /**
         * Change tenant role of specific tenant, if a tenant is a standby tenant, it can be changed to primary tenant, vice versa
         * @summary Change tenant role of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamChangeTenantRole} body target role to change to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeTenantRole(namespace: string, name: string, body: ParamChangeTenantRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeTenantRole(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.changeTenantRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change root password of specific tenant, encrypted by AES
         * @summary Change root password of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamChangeUserPassword} body new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeUserPassword(namespace: string, name: string, body: ParamChangeUserPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeUserPassword(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.changeUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create backup policy of specific tenant, passwords should be encrypted by AES
         * @summary Create backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamCreateBackupPolicy} body create backup policy request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBackupPolicy(namespace: string, name: string, body: ParamCreateBackupPolicy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBackupPolicy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBackupPolicy(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.createBackupPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an obtenant pool in a specific namespace
         * @summary Create obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {ParamTenantPoolSpec} body create obtenant pool request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOBTenantPool(namespace: string, name: string, zoneName: string, body: ParamTenantPoolSpec, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOBTenantPool(namespace, name, zoneName, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.createOBTenantPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an obtenant in a specific namespace, passwords should be encrypted by AES
         * @summary Create tenant
         * @param {ParamCreateOBTenantParam} body create obtenant request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTenant(body: ParamCreateOBTenantParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTenant(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.createTenant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete backup policy of specific tenant
         * @summary Delete backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} [force] force delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBackupPolicy(namespace: string, name: string, force?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBackupPolicy(namespace, name, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.deleteBackupPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an obtenant pool in a specific namespace
         * @summary Delete obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOBTenantPool(namespace: string, name: string, zoneName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOBTenantPool(namespace, name, zoneName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.deleteOBTenantPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an obtenant in a specific namespace, ask user to confrim the deletion carefully
         * @summary Delete tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTenant(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTenant(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.deleteTenant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get backup policy of specific tenant
         * @summary Get backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackupPolicy(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBackupPolicy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackupPolicy(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.getBackupPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List statistics information of tenants
         * @summary List statistics information of tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOBTenantStatistic(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOBTenantStatistic200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOBTenantStatistic(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.getOBTenantStatistic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an obtenant in a specific namespace
         * @summary Get tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTenant(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTenant(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.getTenant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all tenants and return them
         * @summary List all tenants
         * @param {string} [obcluster] obcluster to filter
         * @param {string} [ns] namespace to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllTenants(obcluster?: string, ns?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllTenants200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllTenants(obcluster, ns, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.listAllTenants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List backup jobs of specific tenant
         * @summary List backup jobs of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ListBackupJobsTypeEnum} type backup job type
         * @param {number} [limit] limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBackupJobs(namespace: string, name: string, type: ListBackupJobsTypeEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBackupJobs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBackupJobs(namespace, name, type, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.listBackupJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List related events of specific tenant, including restore, backup and backup policy events
         * @summary List related events of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOBTenantRelatedEvents(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListK8sEvents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOBTenantRelatedEvents(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.listOBTenantRelatedEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Patch an obtenant pool in a specific namespace
         * @summary Patch obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {ParamTenantPoolSpec} body patch obtenant pool request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOBTenantPool(namespace: string, name: string, zoneName: string, body: ParamTenantPoolSpec, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOBTenantPool(namespace, name, zoneName, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.patchOBTenantPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Patch tenant\'s configuration
         * @summary Patch tenant\'s configuration
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamPatchTenant} body patch tenant body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchTenant(namespace: string, name: string, body: ParamPatchTenant, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchTenant(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.patchTenant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replay standby log of specific standby tenant
         * @summary Replay standby log of specific standby tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamReplayStandbyLog} body target timestamp to replay to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replayStandbyLog(namespace: string, name: string, body: ParamReplayStandbyLog, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replayStandbyLog(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.replayStandbyLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update backup policy of specific tenant
         * @summary Update backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamUpdateBackupPolicy} body update backup policy request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBackupPolicy(namespace: string, name: string, body: ParamUpdateBackupPolicy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBackupPolicy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBackupPolicy(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.updateBackupPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upgrade tenant compatibility version of specific tenant to match the version of cluster
         * @summary Upgrade tenant compatibility version of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upgradeTenantVersion(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upgradeTenantVersion(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.upgradeTenantVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OBTenantApi - factory interface
 * @export
 */
export const OBTenantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OBTenantApiFp(configuration)
    return {
        /**
         * Change tenant role of specific tenant, if a tenant is a standby tenant, it can be changed to primary tenant, vice versa
         * @summary Change tenant role of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamChangeTenantRole} body target role to change to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeTenantRole(namespace: string, name: string, body: ParamChangeTenantRole, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.changeTenantRole(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Change root password of specific tenant, encrypted by AES
         * @summary Change root password of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamChangeUserPassword} body new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPassword(namespace: string, name: string, body: ParamChangeUserPassword, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.changeUserPassword(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create backup policy of specific tenant, passwords should be encrypted by AES
         * @summary Create backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamCreateBackupPolicy} body create backup policy request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBackupPolicy(namespace: string, name: string, body: ParamCreateBackupPolicy, options?: any): AxiosPromise<GetBackupPolicy200Response> {
            return localVarFp.createBackupPolicy(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an obtenant pool in a specific namespace
         * @summary Create obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {ParamTenantPoolSpec} body create obtenant pool request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBTenantPool(namespace: string, name: string, zoneName: string, body: ParamTenantPoolSpec, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.createOBTenantPool(namespace, name, zoneName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an obtenant in a specific namespace, passwords should be encrypted by AES
         * @summary Create tenant
         * @param {ParamCreateOBTenantParam} body create obtenant request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant(body: ParamCreateOBTenantParam, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.createTenant(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete backup policy of specific tenant
         * @summary Delete backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} [force] force delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackupPolicy(namespace: string, name: string, force?: string, options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.deleteBackupPolicy(namespace, name, force, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an obtenant pool in a specific namespace
         * @summary Delete obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBTenantPool(namespace: string, name: string, zoneName: string, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.deleteOBTenantPool(namespace, name, zoneName, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an obtenant in a specific namespace, ask user to confrim the deletion carefully
         * @summary Delete tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenant(namespace: string, name: string, options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.deleteTenant(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get backup policy of specific tenant
         * @summary Get backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupPolicy(namespace: string, name: string, options?: any): AxiosPromise<GetBackupPolicy200Response> {
            return localVarFp.getBackupPolicy(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * List statistics information of tenants
         * @summary List statistics information of tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOBTenantStatistic(options?: any): AxiosPromise<GetOBTenantStatistic200Response> {
            return localVarFp.getOBTenantStatistic(options).then((request) => request(axios, basePath));
        },
        /**
         * Get an obtenant in a specific namespace
         * @summary Get tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenant(namespace: string, name: string, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.getTenant(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * List all tenants and return them
         * @summary List all tenants
         * @param {string} [obcluster] obcluster to filter
         * @param {string} [ns] namespace to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTenants(obcluster?: string, ns?: string, options?: any): AxiosPromise<ListAllTenants200Response> {
            return localVarFp.listAllTenants(obcluster, ns, options).then((request) => request(axios, basePath));
        },
        /**
         * List backup jobs of specific tenant
         * @summary List backup jobs of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ListBackupJobsTypeEnum} type backup job type
         * @param {number} [limit] limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBackupJobs(namespace: string, name: string, type: ListBackupJobsTypeEnum, limit?: number, options?: any): AxiosPromise<ListBackupJobs200Response> {
            return localVarFp.listBackupJobs(namespace, name, type, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * List related events of specific tenant, including restore, backup and backup policy events
         * @summary List related events of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBTenantRelatedEvents(namespace: string, name: string, options?: any): AxiosPromise<ListK8sEvents200Response> {
            return localVarFp.listOBTenantRelatedEvents(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch an obtenant pool in a specific namespace
         * @summary Patch obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {ParamTenantPoolSpec} body patch obtenant pool request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOBTenantPool(namespace: string, name: string, zoneName: string, body: ParamTenantPoolSpec, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.patchOBTenantPool(namespace, name, zoneName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch tenant\'s configuration
         * @summary Patch tenant\'s configuration
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamPatchTenant} body patch tenant body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTenant(namespace: string, name: string, body: ParamPatchTenant, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.patchTenant(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Replay standby log of specific standby tenant
         * @summary Replay standby log of specific standby tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamReplayStandbyLog} body target timestamp to replay to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replayStandbyLog(namespace: string, name: string, body: ParamReplayStandbyLog, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.replayStandbyLog(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update backup policy of specific tenant
         * @summary Update backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamUpdateBackupPolicy} body update backup policy request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBackupPolicy(namespace: string, name: string, body: ParamUpdateBackupPolicy, options?: any): AxiosPromise<GetBackupPolicy200Response> {
            return localVarFp.updateBackupPolicy(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Upgrade tenant compatibility version of specific tenant to match the version of cluster
         * @summary Upgrade tenant compatibility version of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeTenantVersion(namespace: string, name: string, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.upgradeTenantVersion(namespace, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OBTenantApi - object-oriented interface
 * @export
 * @class OBTenantApi
 * @extends {BaseAPI}
 */
export class OBTenantApi extends BaseAPI {
    /**
     * Change tenant role of specific tenant, if a tenant is a standby tenant, it can be changed to primary tenant, vice versa
     * @summary Change tenant role of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {ParamChangeTenantRole} body target role to change to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public changeTenantRole(namespace: string, name: string, body: ParamChangeTenantRole, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).changeTenantRole(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change root password of specific tenant, encrypted by AES
     * @summary Change root password of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {ParamChangeUserPassword} body new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public changeUserPassword(namespace: string, name: string, body: ParamChangeUserPassword, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).changeUserPassword(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create backup policy of specific tenant, passwords should be encrypted by AES
     * @summary Create backup policy of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {ParamCreateBackupPolicy} body create backup policy request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public createBackupPolicy(namespace: string, name: string, body: ParamCreateBackupPolicy, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).createBackupPolicy(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an obtenant pool in a specific namespace
     * @summary Create obtenant pool
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {string} zoneName obzone name
     * @param {ParamTenantPoolSpec} body create obtenant pool request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public createOBTenantPool(namespace: string, name: string, zoneName: string, body: ParamTenantPoolSpec, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).createOBTenantPool(namespace, name, zoneName, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an obtenant in a specific namespace, passwords should be encrypted by AES
     * @summary Create tenant
     * @param {ParamCreateOBTenantParam} body create obtenant request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public createTenant(body: ParamCreateOBTenantParam, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).createTenant(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete backup policy of specific tenant
     * @summary Delete backup policy of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {string} [force] force delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public deleteBackupPolicy(namespace: string, name: string, force?: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).deleteBackupPolicy(namespace, name, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an obtenant pool in a specific namespace
     * @summary Delete obtenant pool
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {string} zoneName obzone name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public deleteOBTenantPool(namespace: string, name: string, zoneName: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).deleteOBTenantPool(namespace, name, zoneName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an obtenant in a specific namespace, ask user to confrim the deletion carefully
     * @summary Delete tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public deleteTenant(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).deleteTenant(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get backup policy of specific tenant
     * @summary Get backup policy of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public getBackupPolicy(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).getBackupPolicy(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List statistics information of tenants
     * @summary List statistics information of tenants
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public getOBTenantStatistic(options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).getOBTenantStatistic(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an obtenant in a specific namespace
     * @summary Get tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public getTenant(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).getTenant(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all tenants and return them
     * @summary List all tenants
     * @param {string} [obcluster] obcluster to filter
     * @param {string} [ns] namespace to filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public listAllTenants(obcluster?: string, ns?: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).listAllTenants(obcluster, ns, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List backup jobs of specific tenant
     * @summary List backup jobs of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {ListBackupJobsTypeEnum} type backup job type
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public listBackupJobs(namespace: string, name: string, type: ListBackupJobsTypeEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).listBackupJobs(namespace, name, type, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List related events of specific tenant, including restore, backup and backup policy events
     * @summary List related events of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public listOBTenantRelatedEvents(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).listOBTenantRelatedEvents(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch an obtenant pool in a specific namespace
     * @summary Patch obtenant pool
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {string} zoneName obzone name
     * @param {ParamTenantPoolSpec} body patch obtenant pool request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public patchOBTenantPool(namespace: string, name: string, zoneName: string, body: ParamTenantPoolSpec, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).patchOBTenantPool(namespace, name, zoneName, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch tenant\'s configuration
     * @summary Patch tenant\'s configuration
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {ParamPatchTenant} body patch tenant body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public patchTenant(namespace: string, name: string, body: ParamPatchTenant, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).patchTenant(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replay standby log of specific standby tenant
     * @summary Replay standby log of specific standby tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {ParamReplayStandbyLog} body target timestamp to replay to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public replayStandbyLog(namespace: string, name: string, body: ParamReplayStandbyLog, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).replayStandbyLog(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update backup policy of specific tenant
     * @summary Update backup policy of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {ParamUpdateBackupPolicy} body update backup policy request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public updateBackupPolicy(namespace: string, name: string, body: ParamUpdateBackupPolicy, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).updateBackupPolicy(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upgrade tenant compatibility version of specific tenant to match the version of cluster
     * @summary Upgrade tenant compatibility version of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public upgradeTenantVersion(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).upgradeTenantVersion(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListBackupJobsTypeEnum = {
    FULL: 'FULL',
    INC: 'INC',
    CLEAN: 'CLEAN',
    ARCHIVE: 'ARCHIVE'
} as const;
export type ListBackupJobsTypeEnum = typeof ListBackupJobsTypeEnum[keyof typeof ListBackupJobsTypeEnum];


/**
 * TerminalApi - axios parameter creator
 * @export
 */
export const TerminalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Connect to oceanbase database in websocket
         * @summary Connect to oceanbase database
         * @param {string} terminalId terminalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectDatabase: async (terminalId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terminalId' is not null or undefined
            assertParamExists('connectDatabase', 'terminalId', terminalId)
            const localVarPath = `/api/v1/conn/{terminalId}`
                .replace(`{${"terminalId"}}`, encodeURIComponent(String(terminalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create oceanbase cluster connection terminal
         * @summary Create oceanbase cluster connection
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBClusterConnection: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('createOBClusterConnection', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createOBClusterConnection', 'name', name)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}/terminal`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create oceanbase tenant connection terminal
         * @summary Create oceanbase tenant connection
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBTenantConnection: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('createOBTenantConnection', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createOBTenantConnection', 'name', name)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/terminal`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TerminalApi - functional programming interface
 * @export
 */
export const TerminalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TerminalApiAxiosParamCreator(configuration)
    return {
        /**
         * Connect to oceanbase database in websocket
         * @summary Connect to oceanbase database
         * @param {string} terminalId terminalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectDatabase(terminalId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectDatabase200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectDatabase(terminalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerminalApi.connectDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create oceanbase cluster connection terminal
         * @summary Create oceanbase cluster connection
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOBClusterConnection(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectDatabase200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOBClusterConnection(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerminalApi.createOBClusterConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create oceanbase tenant connection terminal
         * @summary Create oceanbase tenant connection
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOBTenantConnection(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectDatabase200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOBTenantConnection(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerminalApi.createOBTenantConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TerminalApi - factory interface
 * @export
 */
export const TerminalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TerminalApiFp(configuration)
    return {
        /**
         * Connect to oceanbase database in websocket
         * @summary Connect to oceanbase database
         * @param {string} terminalId terminalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectDatabase(terminalId: string, options?: any): AxiosPromise<ConnectDatabase200Response> {
            return localVarFp.connectDatabase(terminalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create oceanbase cluster connection terminal
         * @summary Create oceanbase cluster connection
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBClusterConnection(namespace: string, name: string, options?: any): AxiosPromise<ConnectDatabase200Response> {
            return localVarFp.createOBClusterConnection(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Create oceanbase tenant connection terminal
         * @summary Create oceanbase tenant connection
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBTenantConnection(namespace: string, name: string, options?: any): AxiosPromise<ConnectDatabase200Response> {
            return localVarFp.createOBTenantConnection(namespace, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TerminalApi - object-oriented interface
 * @export
 * @class TerminalApi
 * @extends {BaseAPI}
 */
export class TerminalApi extends BaseAPI {
    /**
     * Connect to oceanbase database in websocket
     * @summary Connect to oceanbase database
     * @param {string} terminalId terminalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApi
     */
    public connectDatabase(terminalId: string, options?: RawAxiosRequestConfig) {
        return TerminalApiFp(this.configuration).connectDatabase(terminalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create oceanbase cluster connection terminal
     * @summary Create oceanbase cluster connection
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApi
     */
    public createOBClusterConnection(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return TerminalApiFp(this.configuration).createOBClusterConnection(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create oceanbase tenant connection terminal
     * @summary Create oceanbase tenant connection
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApi
     */
    public createOBTenantConnection(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return TerminalApiFp(this.configuration).createOBTenantConnection(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User login and return access token with cookie.
         * @summary User login
         * @param {ParamLoginParam} loginInfo login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginInfo: ParamLoginParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginInfo' is not null or undefined
            assertParamExists('login', 'loginInfo', loginInfo)
            const localVarPath = `/api/v1/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User logout and clear session.
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * User login and return access token with cookie.
         * @summary User login
         * @param {ParamLoginParam} loginInfo login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginInfo: ParamLoginParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginInfo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User logout and clear session.
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * User login and return access token with cookie.
         * @summary User login
         * @param {ParamLoginParam} loginInfo login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginInfo: ParamLoginParam, options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.login(loginInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * User logout and clear session.
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * User login and return access token with cookie.
     * @summary User login
     * @param {ParamLoginParam} loginInfo login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public login(loginInfo: ParamLoginParam, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).login(loginInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User logout and clear session.
     * @summary User logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public logout(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Log alerts sent by alertmanager.
         * @summary Log alerts
         * @param {PayloadWebhookPayload} body payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logAlerts: async (body: PayloadWebhookPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('logAlerts', 'body', body)
            const localVarPath = `/api/v1/webhook/alert/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * Log alerts sent by alertmanager.
         * @summary Log alerts
         * @param {PayloadWebhookPayload} body payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logAlerts(body: PayloadWebhookPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProcessInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logAlerts(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.logAlerts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * Log alerts sent by alertmanager.
         * @summary Log alerts
         * @param {PayloadWebhookPayload} body payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logAlerts(body: PayloadWebhookPayload, options?: any): AxiosPromise<GetProcessInfo200Response> {
            return localVarFp.logAlerts(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * Log alerts sent by alertmanager.
     * @summary Log alerts
     * @param {PayloadWebhookPayload} body payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public logAlerts(body: PayloadWebhookPayload, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).logAlerts(body, options).then((request) => request(this.axios, this.basePath));
    }
}



