/* tslint:disable */
/* eslint-disable */
/**
 * OceanBase Dashboard API
 * OceanBase Dashboard
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AcAccount
 */
export interface AcAccount {
    /**
     * 
     * @type {string}
     * @memberof AcAccount
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof AcAccount
     */
    'lastLoginAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AcAccount
     */
    'needReset'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AcAccount
     */
    'nickname'?: string;
    /**
     * 
     * @type {Array<AcRole>}
     * @memberof AcAccount
     */
    'roles': Array<AcRole>;
    /**
     * 
     * @type {string}
     * @memberof AcAccount
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface AcCreateAccountParam
 */
export interface AcCreateAccountParam {
    /**
     * 
     * @type {string}
     * @memberof AcCreateAccountParam
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof AcCreateAccountParam
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof AcCreateAccountParam
     */
    'password': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AcCreateAccountParam
     */
    'roles': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AcCreateAccountParam
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface AcCreateRoleParam
 */
export interface AcCreateRoleParam {
    /**
     * 
     * @type {string}
     * @memberof AcCreateRoleParam
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof AcCreateRoleParam
     */
    'name': string;
    /**
     * 
     * @type {Array<AcPolicy>}
     * @memberof AcCreateRoleParam
     */
    'permissions': Array<AcPolicy>;
}
/**
 * 
 * @export
 * @interface AcPatchAccountParam
 */
export interface AcPatchAccountParam {
    /**
     * 
     * @type {string}
     * @memberof AcPatchAccountParam
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof AcPatchAccountParam
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof AcPatchAccountParam
     */
    'password'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AcPatchAccountParam
     */
    'roles'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AcPatchRoleParam
 */
export interface AcPatchRoleParam {
    /**
     * 
     * @type {string}
     * @memberof AcPatchRoleParam
     */
    'description'?: string;
    /**
     * 
     * @type {Array<AcPolicy>}
     * @memberof AcPatchRoleParam
     */
    'permissions'?: Array<AcPolicy>;
}
/**
 * 
 * @export
 * @interface AcPolicy
 */
export interface AcPolicy {
    /**
     * 
     * @type {string}
     * @memberof AcPolicy
     */
    'action': string;
    /**
     * 
     * @type {string}
     * @memberof AcPolicy
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof AcPolicy
     */
    'object': string;
}
/**
 * 
 * @export
 * @interface AcRole
 */
export interface AcRole {
    /**
     * 
     * @type {string}
     * @memberof AcRole
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof AcRole
     */
    'name': string;
    /**
     * 
     * @type {Array<AcPolicy>}
     * @memberof AcRole
     */
    'policies': Array<AcPolicy>;
}
/**
 * 
 * @export
 * @interface AlarmMatcher
 */
export interface AlarmMatcher {
    /**
     * 
     * @type {boolean}
     * @memberof AlarmMatcher
     */
    'isRegex'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AlarmMatcher
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlarmMatcher
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AlarmSeverity = {
    SeverityCritical: 'critical',
    SeverityWarning: 'warning',
    SeverityCaution: 'caution',
    SeverityInfo: 'info'
} as const;

export type AlarmSeverity = typeof AlarmSeverity[keyof typeof AlarmSeverity];


/**
 * 
 * @export
 * @interface AlertAlert
 */
export interface AlertAlert {
    /**
     * 
     * @type {string}
     * @memberof AlertAlert
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof AlertAlert
     */
    'endsAt': number;
    /**
     * 
     * @type {string}
     * @memberof AlertAlert
     */
    'fingerprint': string;
    /**
     * 
     * @type {OceanbaseOBInstance}
     * @memberof AlertAlert
     */
    'instance': OceanbaseOBInstance;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof AlertAlert
     */
    'labels'?: Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof AlertAlert
     */
    'rule': string;
    /**
     * 
     * @type {AlarmSeverity}
     * @memberof AlertAlert
     */
    'severity': AlarmSeverity;
    /**
     * 
     * @type {number}
     * @memberof AlertAlert
     */
    'startsAt': number;
    /**
     * 
     * @type {AlertStatus}
     * @memberof AlertAlert
     */
    'status': AlertStatus;
    /**
     * 
     * @type {string}
     * @memberof AlertAlert
     */
    'summary'?: string;
    /**
     * 
     * @type {number}
     * @memberof AlertAlert
     */
    'updatedAt': number;
}


/**
 * 
 * @export
 * @interface AlertAlertFilter
 */
export interface AlertAlertFilter {
    /**
     * 
     * @type {number}
     * @memberof AlertAlertFilter
     */
    'endTime'?: number;
    /**
     * 
     * @type {OceanbaseOBInstance}
     * @memberof AlertAlertFilter
     */
    'instance'?: OceanbaseOBInstance;
    /**
     * 
     * @type {OceanbaseOBInstanceType}
     * @memberof AlertAlertFilter
     */
    'instanceType'?: OceanbaseOBInstanceType;
    /**
     * 
     * @type {string}
     * @memberof AlertAlertFilter
     */
    'keyword'?: string;
    /**
     * 
     * @type {AlarmSeverity}
     * @memberof AlertAlertFilter
     */
    'severity'?: AlarmSeverity;
    /**
     * 
     * @type {number}
     * @memberof AlertAlertFilter
     */
    'startTime'?: number;
}


/**
 * 
 * @export
 * @interface AlertAnalyzeParam
 */
export interface AlertAnalyzeParam {
    /**
     * 
     * @type {number}
     * @memberof AlertAnalyzeParam
     */
    'endsAt': number;
    /**
     * 
     * @type {OceanbaseOBInstance}
     * @memberof AlertAnalyzeParam
     */
    'instance': OceanbaseOBInstance;
    /**
     * 
     * @type {string}
     * @memberof AlertAnalyzeParam
     */
    'resultPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertAnalyzeParam
     */
    'rule': string;
    /**
     * 
     * @type {number}
     * @memberof AlertAnalyzeParam
     */
    'startsAt': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AlertState = {
    StateActive: 'active',
    StateUnprocessed: 'unprocessed',
    StateSuppressed: 'suppressed'
} as const;

export type AlertState = typeof AlertState[keyof typeof AlertState];


/**
 * 
 * @export
 * @interface AlertStatus
 */
export interface AlertStatus {
    /**
     * 
     * @type {Array<string>}
     * @memberof AlertStatus
     */
    'inhibitedBy': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AlertStatus
     */
    'silencedBy': Array<string>;
    /**
     * 
     * @type {AlertState}
     * @memberof AlertStatus
     */
    'state': AlertState;
}


/**
 * 
 * @export
 * @interface CommonAffinitySpec
 */
export interface CommonAffinitySpec {
    /**
     * 
     * @type {string}
     * @memberof CommonAffinitySpec
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonAffinitySpec
     */
    'operator'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CommonAffinitySpec
     */
    'preferred'?: boolean;
    /**
     * Enum: NODE, POD, POD_ANTI
     * @type {CommonAffinityType}
     * @memberof CommonAffinitySpec
     */
    'type'?: CommonAffinityType;
    /**
     * 
     * @type {Array<string>}
     * @memberof CommonAffinitySpec
     */
    'values'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CommonAffinitySpec
     */
    'weight'?: number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const CommonAffinityType = {
    NodeAffinityType: 'NODE',
    PodAffinityType: 'POD',
    PodAntiAffinityType: 'POD_ANTI'
} as const;

export type CommonAffinityType = typeof CommonAffinityType[keyof typeof CommonAffinityType];


/**
 * 
 * @export
 * @enum {string}
 */

export const CommonClusterMode = {
    ClusterModeNormal: 'NORMAL',
    ClusterModeStandalone: 'STANDALONE',
    ClusterModeService: 'SERVICE'
} as const;

export type CommonClusterMode = typeof CommonClusterMode[keyof typeof CommonClusterMode];


/**
 * 
 * @export
 * @interface CommonKVPair
 */
export interface CommonKVPair {
    /**
     * 
     * @type {string}
     * @memberof CommonKVPair
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonKVPair
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface CommonResourceSpec
 */
export interface CommonResourceSpec {
    /**
     * 
     * @type {number}
     * @memberof CommonResourceSpec
     */
    'cpu'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommonResourceSpec
     */
    'memory'?: number;
}
/**
 * 
 * @export
 * @interface CommonStorageSpec
 */
export interface CommonStorageSpec {
    /**
     * 
     * @type {number}
     * @memberof CommonStorageSpec
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof CommonStorageSpec
     */
    'storageClass'?: string;
}
/**
 * 
 * @export
 * @interface CommonTolerationSpec
 */
export interface CommonTolerationSpec {
    /**
     * 
     * @type {string}
     * @memberof CommonTolerationSpec
     */
    'effect'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonTolerationSpec
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonTolerationSpec
     */
    'operator'?: string;
    /**
     * 
     * @type {number}
     * @memberof CommonTolerationSpec
     */
    'tolerationSeconds'?: number;
    /**
     * 
     * @type {string}
     * @memberof CommonTolerationSpec
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface ConnectDatabase200Response
 */
export interface ConnectDatabase200Response {
    /**
     * 
     * @type {ResponseOBConnection}
     * @memberof ConnectDatabase200Response
     */
    'data': ResponseOBConnection;
    /**
     * 
     * @type {string}
     * @memberof ConnectDatabase200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectDatabase200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateAccount200Response
 */
export interface CreateAccount200Response {
    /**
     * 
     * @type {AcAccount}
     * @memberof CreateAccount200Response
     */
    'data': AcAccount;
    /**
     * 
     * @type {string}
     * @memberof CreateAccount200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAccount200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateOBCluster200Response
 */
export interface CreateOBCluster200Response {
    /**
     * 
     * @type {ResponseOBCluster}
     * @memberof CreateOBCluster200Response
     */
    'data': ResponseOBCluster;
    /**
     * 
     * @type {string}
     * @memberof CreateOBCluster200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOBCluster200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateOBPROXY200Response
 */
export interface CreateOBPROXY200Response {
    /**
     * 
     * @type {ObproxyOBProxy}
     * @memberof CreateOBPROXY200Response
     */
    'data': ObproxyOBProxy;
    /**
     * 
     * @type {string}
     * @memberof CreateOBPROXY200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOBPROXY200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateInspectionPolicy200Response
 */
export interface CreateOrUpdateInspectionPolicy200Response {
    /**
     * 
     * @type {InspectionPolicy}
     * @memberof CreateOrUpdateInspectionPolicy200Response
     */
    'data': InspectionPolicy;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateInspectionPolicy200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrUpdateInspectionPolicy200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateReceiver200Response
 */
export interface CreateOrUpdateReceiver200Response {
    /**
     * 
     * @type {ReceiverReceiver}
     * @memberof CreateOrUpdateReceiver200Response
     */
    'data': ReceiverReceiver;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateReceiver200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrUpdateReceiver200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateRoute200Response
 */
export interface CreateOrUpdateRoute200Response {
    /**
     * 
     * @type {RouteRouteResponse}
     * @memberof CreateOrUpdateRoute200Response
     */
    'data': RouteRouteResponse;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateRoute200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrUpdateRoute200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateRule200Response
 */
export interface CreateOrUpdateRule200Response {
    /**
     * 
     * @type {RuleRuleResponse}
     * @memberof CreateOrUpdateRule200Response
     */
    'data': RuleRuleResponse;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateRule200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrUpdateRule200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateSilencer200Response
 */
export interface CreateOrUpdateSilencer200Response {
    /**
     * 
     * @type {SilenceSilencerResponse}
     * @memberof CreateOrUpdateSilencer200Response
     */
    'data': SilenceSilencerResponse;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateSilencer200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrUpdateSilencer200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateRole200Response
 */
export interface CreateRole200Response {
    /**
     * 
     * @type {AcRole}
     * @memberof CreateRole200Response
     */
    'data': AcRole;
    /**
     * 
     * @type {string}
     * @memberof CreateRole200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRole200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface CreateTenant200Response
 */
export interface CreateTenant200Response {
    /**
     * 
     * @type {ResponseOBTenantDetail}
     * @memberof CreateTenant200Response
     */
    'data': ResponseOBTenantDetail;
    /**
     * 
     * @type {string}
     * @memberof CreateTenant200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateTenant200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface DeleteInspectionPolicy200Response
 */
export interface DeleteInspectionPolicy200Response {
    /**
     * 
     * @type {boolean}
     * @memberof DeleteInspectionPolicy200Response
     */
    'data': boolean;
    /**
     * 
     * @type {string}
     * @memberof DeleteInspectionPolicy200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteInspectionPolicy200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface DiagnoseAlert200Response
 */
export interface DiagnoseAlert200Response {
    /**
     * 
     * @type {JobJob}
     * @memberof DiagnoseAlert200Response
     */
    'data': JobJob;
    /**
     * 
     * @type {string}
     * @memberof DiagnoseAlert200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof DiagnoseAlert200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface GetBackupPolicy200Response
 */
export interface GetBackupPolicy200Response {
    /**
     * 
     * @type {ResponseBackupPolicy}
     * @memberof GetBackupPolicy200Response
     */
    'data': ResponseBackupPolicy;
    /**
     * 
     * @type {string}
     * @memberof GetBackupPolicy200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetBackupPolicy200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface GetInspectionReport200Response
 */
export interface GetInspectionReport200Response {
    /**
     * 
     * @type {InspectionReport}
     * @memberof GetInspectionReport200Response
     */
    'data': InspectionReport;
    /**
     * 
     * @type {string}
     * @memberof GetInspectionReport200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetInspectionReport200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface GetOBClusterStatistic200Response
 */
export interface GetOBClusterStatistic200Response {
    /**
     * 
     * @type {Array<ResponseOBClusterStatistic>}
     * @memberof GetOBClusterStatistic200Response
     */
    'data': Array<ResponseOBClusterStatistic>;
    /**
     * 
     * @type {string}
     * @memberof GetOBClusterStatistic200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetOBClusterStatistic200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface GetOBTenantStatistic200Response
 */
export interface GetOBTenantStatistic200Response {
    /**
     * 
     * @type {Array<ResponseOBTenantStatistic>}
     * @memberof GetOBTenantStatistic200Response
     */
    'data': Array<ResponseOBTenantStatistic>;
    /**
     * 
     * @type {string}
     * @memberof GetOBTenantStatistic200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetOBTenantStatistic200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface GetProcessInfo200Response
 */
export interface GetProcessInfo200Response {
    /**
     * 
     * @type {ResponseDashboardInfo}
     * @memberof GetProcessInfo200Response
     */
    'data': ResponseDashboardInfo;
    /**
     * 
     * @type {string}
     * @memberof GetProcessInfo200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetProcessInfo200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface GetReceiverTemplate200Response
 */
export interface GetReceiverTemplate200Response {
    /**
     * 
     * @type {ReceiverTemplate}
     * @memberof GetReceiverTemplate200Response
     */
    'data': ReceiverTemplate;
    /**
     * 
     * @type {string}
     * @memberof GetReceiverTemplate200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetReceiverTemplate200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface GetStatistics200Response
 */
export interface GetStatistics200Response {
    /**
     * 
     * @type {ResponseStatisticData}
     * @memberof GetStatistics200Response
     */
    'data': ResponseStatisticData;
    /**
     * 
     * @type {string}
     * @memberof GetStatistics200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetStatistics200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface InspectionInspectionItem
 */
export interface InspectionInspectionItem {
    /**
     * 
     * @type {string}
     * @memberof InspectionInspectionItem
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InspectionInspectionItem
     */
    'results'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const InspectionInspectionScenario = {
    ScenarioBasic: 'basic',
    ScenarioPerformance: 'performance'
} as const;

export type InspectionInspectionScenario = typeof InspectionInspectionScenario[keyof typeof InspectionInspectionScenario];


/**
 * 
 * @export
 * @interface InspectionInspectionScheduleConfig
 */
export interface InspectionInspectionScheduleConfig {
    /**
     * 
     * @type {string}
     * @memberof InspectionInspectionScheduleConfig
     */
    'crontab': string;
    /**
     * 
     * @type {InspectionInspectionScenario}
     * @memberof InspectionInspectionScheduleConfig
     */
    'scenario': InspectionInspectionScenario;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const InspectionInspectionScheduleStatus = {
    ScheduleEnabled: 'enabled',
    ScheduleDisabled: 'disabled'
} as const;

export type InspectionInspectionScheduleStatus = typeof InspectionInspectionScheduleStatus[keyof typeof InspectionInspectionScheduleStatus];


/**
 * 
 * @export
 * @interface InspectionPolicy
 */
export interface InspectionPolicy {
    /**
     * 
     * @type {Array<InspectionReportBriefInfo>}
     * @memberof InspectionPolicy
     */
    'latestReports'?: Array<InspectionReportBriefInfo>;
    /**
     * 
     * @type {ResponseOBClusterMeta}
     * @memberof InspectionPolicy
     */
    'obCluster': ResponseOBClusterMeta;
    /**
     * 
     * @type {Array<InspectionInspectionScheduleConfig>}
     * @memberof InspectionPolicy
     */
    'scheduleConfig'?: Array<InspectionInspectionScheduleConfig>;
    /**
     * 
     * @type {InspectionInspectionScheduleStatus}
     * @memberof InspectionPolicy
     */
    'status': InspectionInspectionScheduleStatus;
}


/**
 * 
 * @export
 * @interface InspectionReport
 */
export interface InspectionReport {
    /**
     * 
     * @type {number}
     * @memberof InspectionReport
     */
    'finishTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof InspectionReport
     */
    'id': string;
    /**
     * 
     * @type {ResponseOBClusterMeta}
     * @memberof InspectionReport
     */
    'obCluster': ResponseOBClusterMeta;
    /**
     * 
     * @type {InspectionResultDetail}
     * @memberof InspectionReport
     */
    'resultDetail'?: InspectionResultDetail;
    /**
     * 
     * @type {InspectionResultStatistics}
     * @memberof InspectionReport
     */
    'resultStatistics': InspectionResultStatistics;
    /**
     * 
     * @type {InspectionInspectionScenario}
     * @memberof InspectionReport
     */
    'scenario': InspectionInspectionScenario;
    /**
     * 
     * @type {number}
     * @memberof InspectionReport
     */
    'startTime'?: number;
    /**
     * 
     * @type {JobJobStatus}
     * @memberof InspectionReport
     */
    'status': JobJobStatus;
}


/**
 * 
 * @export
 * @interface InspectionReportBriefInfo
 */
export interface InspectionReportBriefInfo {
    /**
     * 
     * @type {number}
     * @memberof InspectionReportBriefInfo
     */
    'finishTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof InspectionReportBriefInfo
     */
    'id': string;
    /**
     * 
     * @type {ResponseOBClusterMeta}
     * @memberof InspectionReportBriefInfo
     */
    'obCluster': ResponseOBClusterMeta;
    /**
     * 
     * @type {InspectionResultStatistics}
     * @memberof InspectionReportBriefInfo
     */
    'resultStatistics': InspectionResultStatistics;
    /**
     * 
     * @type {InspectionInspectionScenario}
     * @memberof InspectionReportBriefInfo
     */
    'scenario': InspectionInspectionScenario;
    /**
     * 
     * @type {number}
     * @memberof InspectionReportBriefInfo
     */
    'startTime'?: number;
    /**
     * 
     * @type {JobJobStatus}
     * @memberof InspectionReportBriefInfo
     */
    'status': JobJobStatus;
}


/**
 * 
 * @export
 * @interface InspectionResultDetail
 */
export interface InspectionResultDetail {
    /**
     * 
     * @type {Array<InspectionInspectionItem>}
     * @memberof InspectionResultDetail
     */
    'criticalItems'?: Array<InspectionInspectionItem>;
    /**
     * 
     * @type {Array<InspectionInspectionItem>}
     * @memberof InspectionResultDetail
     */
    'failedItems'?: Array<InspectionInspectionItem>;
    /**
     * 
     * @type {Array<InspectionInspectionItem>}
     * @memberof InspectionResultDetail
     */
    'moderateItems'?: Array<InspectionInspectionItem>;
    /**
     * 
     * @type {Array<InspectionInspectionItem>}
     * @memberof InspectionResultDetail
     */
    'negligibleItems'?: Array<InspectionInspectionItem>;
}
/**
 * 
 * @export
 * @interface InspectionResultStatistics
 */
export interface InspectionResultStatistics {
    /**
     * 
     * @type {number}
     * @memberof InspectionResultStatistics
     */
    'criticalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InspectionResultStatistics
     */
    'failedCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InspectionResultStatistics
     */
    'moderateCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InspectionResultStatistics
     */
    'negligibleCount'?: number;
}
/**
 * 
 * @export
 * @interface JobJob
 */
export interface JobJob {
    /**
     * 
     * @type {number}
     * @memberof JobJob
     */
    'finishTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof JobJob
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof JobJob
     */
    'name': string;
    /**
     * 
     * @type {JobJobResult}
     * @memberof JobJob
     */
    'result'?: JobJobResult;
    /**
     * 
     * @type {number}
     * @memberof JobJob
     */
    'startTime'?: number;
    /**
     * 
     * @type {JobJobStatus}
     * @memberof JobJob
     */
    'status': JobJobStatus;
}


/**
 * 
 * @export
 * @interface JobJobResult
 */
export interface JobJobResult {
    /**
     * 
     * @type {string}
     * @memberof JobJobResult
     */
    'attachmentId'?: string;
    /**
     * 
     * @type {number}
     * @memberof JobJobResult
     */
    'exitCode': number;
    /**
     * 
     * @type {string}
     * @memberof JobJobResult
     */
    'output'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JobJobStatus = {
    JobStatusSuccessful: 'successful',
    JobStatusFailed: 'failed',
    JobStatusRunning: 'running',
    JobStatusPending: 'pending'
} as const;

export type JobJobStatus = typeof JobJobStatus[keyof typeof JobJobStatus];


/**
 * 
 * @export
 * @interface ListAlerts200Response
 */
export interface ListAlerts200Response {
    /**
     * 
     * @type {Array<AlertAlert>}
     * @memberof ListAlerts200Response
     */
    'data': Array<AlertAlert>;
    /**
     * 
     * @type {string}
     * @memberof ListAlerts200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListAlerts200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListAllAccounts200Response
 */
export interface ListAllAccounts200Response {
    /**
     * 
     * @type {Array<AcAccount>}
     * @memberof ListAllAccounts200Response
     */
    'data': Array<AcAccount>;
    /**
     * 
     * @type {string}
     * @memberof ListAllAccounts200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListAllAccounts200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListAllMetrics200Response
 */
export interface ListAllMetrics200Response {
    /**
     * 
     * @type {Array<ResponseMetricClass>}
     * @memberof ListAllMetrics200Response
     */
    'data': Array<ResponseMetricClass>;
    /**
     * 
     * @type {string}
     * @memberof ListAllMetrics200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListAllMetrics200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListAllPolicies200Response
 */
export interface ListAllPolicies200Response {
    /**
     * 
     * @type {Array<AcPolicy>}
     * @memberof ListAllPolicies200Response
     */
    'data': Array<AcPolicy>;
    /**
     * 
     * @type {string}
     * @memberof ListAllPolicies200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListAllPolicies200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListAllRoles200Response
 */
export interface ListAllRoles200Response {
    /**
     * 
     * @type {Array<AcRole>}
     * @memberof ListAllRoles200Response
     */
    'data': Array<AcRole>;
    /**
     * 
     * @type {string}
     * @memberof ListAllRoles200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListAllRoles200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListAllTenants200Response
 */
export interface ListAllTenants200Response {
    /**
     * 
     * @type {Array<ResponseOBTenantOverview>}
     * @memberof ListAllTenants200Response
     */
    'data': Array<ResponseOBTenantOverview>;
    /**
     * 
     * @type {string}
     * @memberof ListAllTenants200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListAllTenants200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListBackupJobs200Response
 */
export interface ListBackupJobs200Response {
    /**
     * 
     * @type {Array<ResponseBackupJob>}
     * @memberof ListBackupJobs200Response
     */
    'data': Array<ResponseBackupJob>;
    /**
     * 
     * @type {string}
     * @memberof ListBackupJobs200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListBackupJobs200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListInspectionPolicies200Response
 */
export interface ListInspectionPolicies200Response {
    /**
     * 
     * @type {Array<InspectionPolicy>}
     * @memberof ListInspectionPolicies200Response
     */
    'data': Array<InspectionPolicy>;
    /**
     * 
     * @type {string}
     * @memberof ListInspectionPolicies200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListInspectionPolicies200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListInspectionReports200Response
 */
export interface ListInspectionReports200Response {
    /**
     * 
     * @type {Array<InspectionReportBriefInfo>}
     * @memberof ListInspectionReports200Response
     */
    'data': Array<InspectionReportBriefInfo>;
    /**
     * 
     * @type {string}
     * @memberof ListInspectionReports200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListInspectionReports200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListK8sEvents200Response
 */
export interface ListK8sEvents200Response {
    /**
     * 
     * @type {Array<ResponseK8sEvent>}
     * @memberof ListK8sEvents200Response
     */
    'data': Array<ResponseK8sEvent>;
    /**
     * 
     * @type {string}
     * @memberof ListK8sEvents200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListK8sEvents200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListK8sNamespaces200Response
 */
export interface ListK8sNamespaces200Response {
    /**
     * 
     * @type {Array<ResponseNamespace>}
     * @memberof ListK8sNamespaces200Response
     */
    'data': Array<ResponseNamespace>;
    /**
     * 
     * @type {string}
     * @memberof ListK8sNamespaces200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListK8sNamespaces200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListK8sNodes200Response
 */
export interface ListK8sNodes200Response {
    /**
     * 
     * @type {Array<ResponseK8sNode>}
     * @memberof ListK8sNodes200Response
     */
    'data': Array<ResponseK8sNode>;
    /**
     * 
     * @type {string}
     * @memberof ListK8sNodes200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListK8sNodes200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListK8sStorageClasses200Response
 */
export interface ListK8sStorageClasses200Response {
    /**
     * 
     * @type {Array<ResponseStorageClass>}
     * @memberof ListK8sStorageClasses200Response
     */
    'data': Array<ResponseStorageClass>;
    /**
     * 
     * @type {string}
     * @memberof ListK8sStorageClasses200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListK8sStorageClasses200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListOBClusterParameters200Response
 */
export interface ListOBClusterParameters200Response {
    /**
     * 
     * @type {Array<ModelParameter>}
     * @memberof ListOBClusterParameters200Response
     */
    'data': Array<ModelParameter>;
    /**
     * 
     * @type {string}
     * @memberof ListOBClusterParameters200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListOBClusterParameters200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListOBClusterResources200Response
 */
export interface ListOBClusterResources200Response {
    /**
     * 
     * @type {ResponseOBClusterResources}
     * @memberof ListOBClusterResources200Response
     */
    'data': ResponseOBClusterResources;
    /**
     * 
     * @type {string}
     * @memberof ListOBClusterResources200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListOBClusterResources200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListOBClusters200Response
 */
export interface ListOBClusters200Response {
    /**
     * 
     * @type {Array<ResponseOBClusterOverview>}
     * @memberof ListOBClusters200Response
     */
    'data': Array<ResponseOBClusterOverview>;
    /**
     * 
     * @type {string}
     * @memberof ListOBClusters200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListOBClusters200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListOBProxies200Response
 */
export interface ListOBProxies200Response {
    /**
     * 
     * @type {Array<ObproxyOBProxyOverview>}
     * @memberof ListOBProxies200Response
     */
    'data': Array<ObproxyOBProxyOverview>;
    /**
     * 
     * @type {string}
     * @memberof ListOBProxies200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListOBProxies200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListOBProxyParameters200Response
 */
export interface ListOBProxyParameters200Response {
    /**
     * 
     * @type {Array<ObproxyConfigItem>}
     * @memberof ListOBProxyParameters200Response
     */
    'data': Array<ObproxyConfigItem>;
    /**
     * 
     * @type {string}
     * @memberof ListOBProxyParameters200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListOBProxyParameters200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListOBTenantDatabases200Response
 */
export interface ListOBTenantDatabases200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof ListOBTenantDatabases200Response
     */
    'data': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ListOBTenantDatabases200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListOBTenantDatabases200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListReceiverTemplates200Response
 */
export interface ListReceiverTemplates200Response {
    /**
     * 
     * @type {Array<ReceiverTemplate>}
     * @memberof ListReceiverTemplates200Response
     */
    'data': Array<ReceiverTemplate>;
    /**
     * 
     * @type {string}
     * @memberof ListReceiverTemplates200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListReceiverTemplates200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListReceivers200Response
 */
export interface ListReceivers200Response {
    /**
     * 
     * @type {Array<ReceiverReceiver>}
     * @memberof ListReceivers200Response
     */
    'data': Array<ReceiverReceiver>;
    /**
     * 
     * @type {string}
     * @memberof ListReceivers200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListReceivers200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListRoutes200Response
 */
export interface ListRoutes200Response {
    /**
     * 
     * @type {Array<RouteRouteResponse>}
     * @memberof ListRoutes200Response
     */
    'data': Array<RouteRouteResponse>;
    /**
     * 
     * @type {string}
     * @memberof ListRoutes200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListRoutes200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListRules200Response
 */
export interface ListRules200Response {
    /**
     * 
     * @type {Array<RuleRuleResponse>}
     * @memberof ListRules200Response
     */
    'data': Array<RuleRuleResponse>;
    /**
     * 
     * @type {string}
     * @memberof ListRules200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListRules200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListSilencers200Response
 */
export interface ListSilencers200Response {
    /**
     * 
     * @type {Array<SilenceSilencerResponse>}
     * @memberof ListSilencers200Response
     */
    'data': Array<SilenceSilencerResponse>;
    /**
     * 
     * @type {string}
     * @memberof ListSilencers200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListSilencers200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListSqlMetrics200Response
 */
export interface ListSqlMetrics200Response {
    /**
     * 
     * @type {Array<SqlSqlMetricMetaCategory>}
     * @memberof ListSqlMetrics200Response
     */
    'data': Array<SqlSqlMetricMetaCategory>;
    /**
     * 
     * @type {string}
     * @memberof ListSqlMetrics200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListSqlMetrics200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ListSuspiciousSqls200Response
 */
export interface ListSuspiciousSqls200Response {
    /**
     * 
     * @type {Array<SqlSqlInfo>}
     * @memberof ListSuspiciousSqls200Response
     */
    'data': Array<SqlSqlInfo>;
    /**
     * 
     * @type {string}
     * @memberof ListSuspiciousSqls200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListSuspiciousSqls200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ModelParameter
 */
export interface ModelParameter {
    /**
     * 
     * @type {string}
     * @memberof ModelParameter
     */
    'dataType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelParameter
     */
    'defaultValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelParameter
     */
    'edit_level'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelParameter
     */
    'info'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelParameter
     */
    'isDefault'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelParameter
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelParameter
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelParameter
     */
    'section'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelParameter
     */
    'svr_ip'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelParameter
     */
    'svr_port'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelParameter
     */
    'tenant_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelParameter
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelParameter
     */
    'zone'?: string;
}
/**
 * 
 * @export
 * @interface ModelsK8sEvent
 */
export interface ModelsK8sEvent {
    /**
     * 
     * @type {number}
     * @memberof ModelsK8sEvent
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsK8sEvent
     */
    'firstTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsK8sEvent
     */
    'kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsK8sEvent
     */
    'lastTimestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsK8sEvent
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsK8sEvent
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsK8sEvent
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsK8sEvent
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsK8sEvent
     */
    'resourceName'?: string;
}
/**
 * 
 * @export
 * @interface ModelsOBBackupPolicy
 */
export interface ModelsOBBackupPolicy {
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'archiveDestType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'archiveSwitchPieceInterval'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'bakDataDestType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'bakDataFullCrontab'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'bakDataIncrCrontab'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsOBBackupPolicy
     */
    'encryptBakData'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'runningFlow'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'runningTask'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'taskStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'tenantCR'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'tenantName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBBackupPolicy
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface ModelsOBCluster
 */
export interface ModelsOBCluster {
    /**
     * 
     * @type {number}
     * @memberof ModelsOBCluster
     */
    'clusterId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'clusterMode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'clusterName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsOBCluster
     */
    'configuredBackupVolume'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsOBCluster
     */
    'configuredMonitor'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBCluster
     */
    'cpu'?: number;
    /**
     * 
     * @type {ModelsStorageSpec}
     * @memberof ModelsOBCluster
     */
    'dataStorage'?: ModelsStorageSpec;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'image'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsOBCluster
     */
    'independentPVC'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBCluster
     */
    'memory'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'namespace'?: string;
    /**
     * 
     * @type {ModelsStorageSpec}
     * @memberof ModelsOBCluster
     */
    'redoLogStorage'?: ModelsStorageSpec;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'runningFlow'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'runningTask'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsOBCluster
     */
    'singlePVC'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'status'?: string;
    /**
     * 
     * @type {ModelsStorageSpec}
     * @memberof ModelsOBCluster
     */
    'sysLogStorage'?: ModelsStorageSpec;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'taskStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBCluster
     */
    'uid'?: string;
    /**
     * 
     * @type {Array<ModelsOBZoneStatus>}
     * @memberof ModelsOBCluster
     */
    'zones'?: Array<ModelsOBZoneStatus>;
}
/**
 * 
 * @export
 * @interface ModelsOBServer
 */
export interface ModelsOBServer {
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'clusterCR'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBServer
     */
    'clusterId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'clusterName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'cni'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'podIPHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'podPhase'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'runningFlow'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'runningTask'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'serviceIPHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'taskStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBServer
     */
    'zoneName'?: string;
}
/**
 * 
 * @export
 * @interface ModelsOBTenant
 */
export interface ModelsOBTenant {
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'archiveDestType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'bakDataDestType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'clusterName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'primaryTenant'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'runningFlow'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'runningTask'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'taskStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'tenantName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'tenantRole'?: string;
    /**
     * 
     * @type {Array<ModelsOBTenantResourcePool>}
     * @memberof ModelsOBTenant
     */
    'topology'?: Array<ModelsOBTenantResourcePool>;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenant
     */
    'uid'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenant
     */
    'unitNumber'?: number;
}
/**
 * 
 * @export
 * @interface ModelsOBTenantResourcePool
 */
export interface ModelsOBTenantResourcePool {
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'IOPSWeight'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'logDiskSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'maxCPU'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'maxIOPS'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'memorySize'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'minCPU'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'minIOPS'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'priority'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenantResourcePool
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBTenantResourcePool
     */
    'unitNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBTenantResourcePool
     */
    'zone'?: string;
}
/**
 * 
 * @export
 * @interface ModelsOBZone
 */
export interface ModelsOBZone {
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'clusterCR'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsOBZone
     */
    'clusterId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'clusterName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'runningFlow'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'runningTask'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'taskStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZone
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface ModelsOBZoneStatus
 */
export interface ModelsOBZoneStatus {
    /**
     * 
     * @type {number}
     * @memberof ModelsOBZoneStatus
     */
    'replica'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZoneStatus
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsOBZoneStatus
     */
    'zoneName'?: string;
}
/**
 * 
 * @export
 * @interface ModelsStorageSpec
 */
export interface ModelsStorageSpec {
    /**
     * 
     * @type {string}
     * @memberof ModelsStorageSpec
     */
    'storageClass'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsStorageSpec
     */
    'storageSize'?: number;
}
/**
 * 
 * @export
 * @interface ObproxyConfigItem
 */
export interface ObproxyConfigItem {
    /**
     * 
     * @type {string}
     * @memberof ObproxyConfigItem
     */
    'info'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyConfigItem
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ObproxyConfigItem
     */
    'needReboot'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ObproxyConfigItem
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyConfigItem
     */
    'visibleLevel'?: string;
}
/**
 * 
 * @export
 * @interface ObproxyCreateOBProxyParam
 */
export interface ObproxyCreateOBProxyParam {
    /**
     * 
     * @type {string}
     * @memberof ObproxyCreateOBProxyParam
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyCreateOBProxyParam
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyCreateOBProxyParam
     */
    'namespace': string;
    /**
     * 
     * @type {ObproxyK8sObject}
     * @memberof ObproxyCreateOBProxyParam
     */
    'obCluster': ObproxyK8sObject;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ObproxyCreateOBProxyParam
     */
    'parameters'?: Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof ObproxyCreateOBProxyParam
     */
    'proxyClusterName': string;
    /**
     * Password should be encrypted
     * @type {string}
     * @memberof ObproxyCreateOBProxyParam
     */
    'proxySysPassword': string;
    /**
     * 
     * @type {number}
     * @memberof ObproxyCreateOBProxyParam
     */
    'replicas': number;
    /**
     * 
     * @type {CommonResourceSpec}
     * @memberof ObproxyCreateOBProxyParam
     */
    'resource': CommonResourceSpec;
    /**
     * 
     * @type {string}
     * @memberof ObproxyCreateOBProxyParam
     */
    'serviceType': ObproxyCreateOBProxyParamServiceTypeEnum;
}

export const ObproxyCreateOBProxyParamServiceTypeEnum = {
    ClusterIP: 'ClusterIP',
    NodePort: 'NodePort',
    LoadBalancer: 'LoadBalancer',
    ExternalName: 'ExternalName'
} as const;

export type ObproxyCreateOBProxyParamServiceTypeEnum = typeof ObproxyCreateOBProxyParamServiceTypeEnum[keyof typeof ObproxyCreateOBProxyParamServiceTypeEnum];

/**
 * 
 * @export
 * @interface ObproxyK8sObject
 */
export interface ObproxyK8sObject {
    /**
     * 
     * @type {string}
     * @memberof ObproxyK8sObject
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyK8sObject
     */
    'namespace': string;
}
/**
 * 
 * @export
 * @interface ObproxyOBProxy
 */
export interface ObproxyOBProxy {
    /**
     * 
     * @type {number}
     * @memberof ObproxyOBProxy
     */
    'creationTime': number;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxy
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxy
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxy
     */
    'namespace': string;
    /**
     * 
     * @type {ObproxyK8sObject}
     * @memberof ObproxyOBProxy
     */
    'obCluster': ObproxyK8sObject;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ObproxyOBProxy
     */
    'parameters': Array<CommonKVPair>;
    /**
     * 
     * @type {Array<ResponseK8sPodInfo>}
     * @memberof ObproxyOBProxy
     */
    'pods': Array<ResponseK8sPodInfo>;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxy
     */
    'proxyClusterName': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxy
     */
    'proxySysSecret': string;
    /**
     * 
     * @type {number}
     * @memberof ObproxyOBProxy
     */
    'replicas': number;
    /**
     * 
     * @type {CommonResourceSpec}
     * @memberof ObproxyOBProxy
     */
    'resource': CommonResourceSpec;
    /**
     * 
     * @type {ResponseK8sService}
     * @memberof ObproxyOBProxy
     */
    'service': ResponseK8sService;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxy
     */
    'serviceIp': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxy
     */
    'serviceType': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxy
     */
    'status': ObproxyOBProxyStatusEnum;
}

export const ObproxyOBProxyStatusEnum = {
    Running: 'Running',
    Pending: 'Pending'
} as const;

export type ObproxyOBProxyStatusEnum = typeof ObproxyOBProxyStatusEnum[keyof typeof ObproxyOBProxyStatusEnum];

/**
 * 
 * @export
 * @interface ObproxyOBProxyOverview
 */
export interface ObproxyOBProxyOverview {
    /**
     * 
     * @type {number}
     * @memberof ObproxyOBProxyOverview
     */
    'creationTime': number;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxyOverview
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxyOverview
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxyOverview
     */
    'namespace': string;
    /**
     * 
     * @type {ObproxyK8sObject}
     * @memberof ObproxyOBProxyOverview
     */
    'obCluster': ObproxyK8sObject;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxyOverview
     */
    'proxyClusterName': string;
    /**
     * 
     * @type {number}
     * @memberof ObproxyOBProxyOverview
     */
    'replicas': number;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxyOverview
     */
    'serviceIp': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxyOverview
     */
    'serviceType': string;
    /**
     * 
     * @type {string}
     * @memberof ObproxyOBProxyOverview
     */
    'status': ObproxyOBProxyOverviewStatusEnum;
}

export const ObproxyOBProxyOverviewStatusEnum = {
    Running: 'Running',
    Pending: 'Pending'
} as const;

export type ObproxyOBProxyOverviewStatusEnum = typeof ObproxyOBProxyOverviewStatusEnum[keyof typeof ObproxyOBProxyOverviewStatusEnum];

/**
 * 
 * @export
 * @interface ObproxyPatchOBProxyParam
 */
export interface ObproxyPatchOBProxyParam {
    /**
     * 
     * @type {string}
     * @memberof ObproxyPatchOBProxyParam
     */
    'image'?: string;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ObproxyPatchOBProxyParam
     */
    'parameters'?: Array<CommonKVPair>;
    /**
     * 
     * @type {number}
     * @memberof ObproxyPatchOBProxyParam
     */
    'replicas'?: number;
    /**
     * 
     * @type {CommonResourceSpec}
     * @memberof ObproxyPatchOBProxyParam
     */
    'resource'?: CommonResourceSpec;
    /**
     * 
     * @type {string}
     * @memberof ObproxyPatchOBProxyParam
     */
    'serviceType'?: ObproxyPatchOBProxyParamServiceTypeEnum;
}

export const ObproxyPatchOBProxyParamServiceTypeEnum = {
    ClusterIP: 'ClusterIP',
    NodePort: 'NodePort',
    LoadBalancer: 'LoadBalancer',
    ExternalName: 'ExternalName'
} as const;

export type ObproxyPatchOBProxyParamServiceTypeEnum = typeof ObproxyPatchOBProxyParamServiceTypeEnum[keyof typeof ObproxyPatchOBProxyParamServiceTypeEnum];

/**
 * 
 * @export
 * @interface OceanbaseOBInstance
 */
export interface OceanbaseOBInstance {
    /**
     * 
     * @type {string}
     * @memberof OceanbaseOBInstance
     */
    'obcluster'?: string;
    /**
     * 
     * @type {string}
     * @memberof OceanbaseOBInstance
     */
    'observer'?: string;
    /**
     * 
     * @type {string}
     * @memberof OceanbaseOBInstance
     */
    'obtenant'?: string;
    /**
     * obzone may exist in labels
     * @type {string}
     * @memberof OceanbaseOBInstance
     */
    'obzone'?: string;
    /**
     * 
     * @type {OceanbaseOBInstanceType}
     * @memberof OceanbaseOBInstance
     */
    'type': OceanbaseOBInstanceType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const OceanbaseOBInstanceType = {
    TypeUnknown: 'unknown',
    TypeOBCluster: 'obcluster',
    TypeOBZone: 'obzone',
    TypeOBTenant: 'obtenant',
    TypeOBServer: 'observer'
} as const;

export type OceanbaseOBInstanceType = typeof OceanbaseOBInstanceType[keyof typeof OceanbaseOBInstanceType];


/**
 * 
 * @export
 * @enum {string}
 */

export const ParamBackupDestType = {
    BackupDestNFS: 'NFS',
    BackupDestOSS: 'OSS',
    BackupDestCOS: 'COS',
    BackupDestS3: 'S3',
    BackupDestS3Compatible: 'S3_COMPATIBLE'
} as const;

export type ParamBackupDestType = typeof ParamBackupDestType[keyof typeof ParamBackupDestType];


/**
 * 
 * @export
 * @interface ParamChangeTenantRole
 */
export interface ParamChangeTenantRole {
    /**
     * 
     * @type {boolean}
     * @memberof ParamChangeTenantRole
     */
    'failover'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ParamChangeTenantRole
     */
    'switchover'?: boolean;
}
/**
 * 
 * @export
 * @interface ParamChangeUserPassword
 */
export interface ParamChangeUserPassword {
    /**
     * 
     * @type {string}
     * @memberof ParamChangeUserPassword
     */
    'password': string;
    /**
     * Description: The user name of the database account, only root is supported now.
     * @type {string}
     * @memberof ParamChangeUserPassword
     */
    'user': string;
}
/**
 * 
 * @export
 * @interface ParamConfigurableInfo
 */
export interface ParamConfigurableInfo {
    /**
     * 
     * @type {string}
     * @memberof ParamConfigurableInfo
     */
    'odcURL'?: string;
}
/**
 * 
 * @export
 * @interface ParamCreateBackupPolicy
 */
export interface ParamCreateBackupPolicy {
    /**
     * Used for COS
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'appId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'archivePath': string;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'bakDataPath': string;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'bakEncryptionPassword'?: string;
    /**
     * Enum: NFS, OSS, COS, S3, S3_COMPATIBLE
     * @type {ParamBackupDestType}
     * @memberof ParamCreateBackupPolicy
     */
    'destType': ParamBackupDestType;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'host'?: string;
    /**
     * 
     * @type {number}
     * @memberof ParamCreateBackupPolicy
     */
    'jobKeepDays'?: number;
    /**
     * Used for non-NFS
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'ossAccessId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'ossAccessKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof ParamCreateBackupPolicy
     */
    'pieceIntervalDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof ParamCreateBackupPolicy
     */
    'recoveryDays'?: number;
    /**
     * Used for S3
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'region'?: string;
    /**
     * 
     * @type {Array<ParamScheduleDate>}
     * @memberof ParamCreateBackupPolicy
     */
    'scheduleDates'?: Array<ParamScheduleDate>;
    /**
     * Description: HH:MM Example: 04:00
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'scheduleTime'?: string;
    /**
     * Enum: Weekly, Monthly
     * @type {string}
     * @memberof ParamCreateBackupPolicy
     */
    'scheduleType'?: string;
}


/**
 * 
 * @export
 * @interface ParamCreateNamespaceParam
 */
export interface ParamCreateNamespaceParam {
    /**
     * 
     * @type {string}
     * @memberof ParamCreateNamespaceParam
     */
    'namespace'?: string;
}
/**
 * 
 * @export
 * @interface ParamCreateOBClusterParam
 */
export interface ParamCreateOBClusterParam {
    /**
     * 
     * @type {ParamNFSVolumeSpec}
     * @memberof ParamCreateOBClusterParam
     */
    'backupVolume'?: ParamNFSVolumeSpec;
    /**
     * 
     * @type {number}
     * @memberof ParamCreateOBClusterParam
     */
    'clusterId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBClusterParam
     */
    'clusterName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ParamCreateOBClusterParam
     */
    'deletionProtection'?: boolean;
    /**
     * 
     * @type {CommonClusterMode}
     * @memberof ParamCreateOBClusterParam
     */
    'mode'?: CommonClusterMode;
    /**
     * 
     * @type {ParamMonitorSpec}
     * @memberof ParamCreateOBClusterParam
     */
    'monitor'?: ParamMonitorSpec;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBClusterParam
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBClusterParam
     */
    'namespace'?: string;
    /**
     * 
     * @type {ParamOBServerSpec}
     * @memberof ParamCreateOBClusterParam
     */
    'observer'?: ParamOBServerSpec;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ParamCreateOBClusterParam
     */
    'parameters'?: Array<CommonKVPair>;
    /**
     * 
     * @type {boolean}
     * @memberof ParamCreateOBClusterParam
     */
    'pvcIndependent'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBClusterParam
     */
    'rootPassword'?: string;
    /**
     * Enum: express_oltp, express_oltp, olap, kv, htap, express_oltp_perf
     * @type {string}
     * @memberof ParamCreateOBClusterParam
     */
    'scenario'?: string;
    /**
     * 
     * @type {Array<ParamZoneTopology>}
     * @memberof ParamCreateOBClusterParam
     */
    'topology'?: Array<ParamZoneTopology>;
}


/**
 * 
 * @export
 * @interface ParamCreateOBTenantParam
 */
export interface ParamCreateOBTenantParam {
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'charset'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'connectWhiteList'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ParamCreateOBTenantParam
     */
    'deletionProtection'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'obcluster': string;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ParamCreateOBTenantParam
     */
    'parameters'?: Array<CommonKVPair>;
    /**
     * 
     * @type {Array<ParamResourcePoolSpec>}
     * @memberof ParamCreateOBTenantParam
     */
    'pools': Array<ParamResourcePoolSpec>;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'rootPassword': string;
    /**
     * Enum: express_oltp, express_oltp, olap, kv, htap, express_oltp_perf
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'scenario'?: string;
    /**
     * 
     * @type {ParamTenantSourceSpec}
     * @memberof ParamCreateOBTenantParam
     */
    'source'?: ParamTenantSourceSpec;
    /**
     * 
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'tenantName': string;
    /**
     * Enum: Primary, Standby
     * @type {string}
     * @memberof ParamCreateOBTenantParam
     */
    'tenantRole'?: string;
    /**
     * 
     * @type {ParamUnitConfig}
     * @memberof ParamCreateOBTenantParam
     */
    'unitConfig': ParamUnitConfig;
    /**
     * 
     * @type {number}
     * @memberof ParamCreateOBTenantParam
     */
    'unitNum': number;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ParamCreateOBTenantParam
     */
    'variables'?: Array<CommonKVPair>;
}
/**
 * 
 * @export
 * @interface ParamDeleteOBServersParam
 */
export interface ParamDeleteOBServersParam {
    /**
     * 
     * @type {Array<string>}
     * @memberof ParamDeleteOBServersParam
     */
    'observers'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ParamLoginParam
 */
export interface ParamLoginParam {
    /**
     * 
     * @type {string}
     * @memberof ParamLoginParam
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamLoginParam
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface ParamMetricQuery
 */
export interface ParamMetricQuery {
    /**
     * 
     * @type {Array<string>}
     * @memberof ParamMetricQuery
     */
    'groupLabels'?: Array<string>;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ParamMetricQuery
     */
    'labels'?: Array<CommonKVPair>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ParamMetricQuery
     */
    'metrics'?: Array<string>;
    /**
     * 
     * @type {ParamQueryRange}
     * @memberof ParamMetricQuery
     */
    'queryRange'?: ParamQueryRange;
}
/**
 * 
 * @export
 * @interface ParamMonitorSpec
 */
export interface ParamMonitorSpec {
    /**
     * 
     * @type {string}
     * @memberof ParamMonitorSpec
     */
    'image'?: string;
    /**
     * 
     * @type {CommonResourceSpec}
     * @memberof ParamMonitorSpec
     */
    'resource'?: CommonResourceSpec;
}
/**
 * 
 * @export
 * @interface ParamNFSVolumeSpec
 */
export interface ParamNFSVolumeSpec {
    /**
     * 
     * @type {string}
     * @memberof ParamNFSVolumeSpec
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamNFSVolumeSpec
     */
    'path'?: string;
}
/**
 * 
 * @export
 * @interface ParamOBServerSpec
 */
export interface ParamOBServerSpec {
    /**
     * 
     * @type {string}
     * @memberof ParamOBServerSpec
     */
    'image'?: string;
    /**
     * 
     * @type {CommonResourceSpec}
     * @memberof ParamOBServerSpec
     */
    'resource'?: CommonResourceSpec;
    /**
     * 
     * @type {ParamOBServerStorageSpec}
     * @memberof ParamOBServerSpec
     */
    'storage'?: ParamOBServerStorageSpec;
}
/**
 * 
 * @export
 * @interface ParamOBServerStorageSpec
 */
export interface ParamOBServerStorageSpec {
    /**
     * 
     * @type {CommonStorageSpec}
     * @memberof ParamOBServerStorageSpec
     */
    'data'?: CommonStorageSpec;
    /**
     * 
     * @type {CommonStorageSpec}
     * @memberof ParamOBServerStorageSpec
     */
    'log'?: CommonStorageSpec;
    /**
     * 
     * @type {CommonStorageSpec}
     * @memberof ParamOBServerStorageSpec
     */
    'redoLog'?: CommonStorageSpec;
}
/**
 * 
 * @export
 * @interface ParamPatchOBClusterParam
 */
export interface ParamPatchOBClusterParam {
    /**
     * 
     * @type {boolean}
     * @memberof ParamPatchOBClusterParam
     */
    'addDeletionProtection'?: boolean;
    /**
     * 
     * @type {ParamNFSVolumeSpec}
     * @memberof ParamPatchOBClusterParam
     */
    'backupVolume'?: ParamNFSVolumeSpec;
    /**
     * Delete some parameters
     * @type {Array<string>}
     * @memberof ParamPatchOBClusterParam
     */
    'deletedParameters'?: Array<string>;
    /**
     * Add or modify some parameters
     * @type {Array<CommonKVPair>}
     * @memberof ParamPatchOBClusterParam
     */
    'modifiedParameters'?: Array<CommonKVPair>;
    /**
     * 
     * @type {ParamMonitorSpec}
     * @memberof ParamPatchOBClusterParam
     */
    'monitor'?: ParamMonitorSpec;
    /**
     * Replace all parameters
     * @type {Array<CommonKVPair>}
     * @memberof ParamPatchOBClusterParam
     */
    'parameters'?: Array<CommonKVPair>;
    /**
     * 
     * @type {boolean}
     * @memberof ParamPatchOBClusterParam
     */
    'removeBackupVolume'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ParamPatchOBClusterParam
     */
    'removeDeletionProtection'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ParamPatchOBClusterParam
     */
    'removeMonitor'?: boolean;
    /**
     * 
     * @type {CommonResourceSpec}
     * @memberof ParamPatchOBClusterParam
     */
    'resource'?: CommonResourceSpec;
    /**
     * 
     * @type {ParamOBServerStorageSpec}
     * @memberof ParamPatchOBClusterParam
     */
    'storage'?: ParamOBServerStorageSpec;
}
/**
 * 
 * @export
 * @interface ParamPatchTenant
 */
export interface ParamPatchTenant {
    /**
     * 
     * @type {boolean}
     * @memberof ParamPatchTenant
     */
    'addDeletionProtection'?: boolean;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ParamPatchTenant
     */
    'parameters'?: Array<CommonKVPair>;
    /**
     * 
     * @type {boolean}
     * @memberof ParamPatchTenant
     */
    'removeDeletionProtection'?: boolean;
    /**
     * Deprecated Description: Deprecated, use PATCH /obtenants/:namespace/:name/pools/:zoneName instead
     * @type {ParamPatchUnitConfig}
     * @memberof ParamPatchTenant
     */
    'unitConfig'?: ParamPatchUnitConfig;
    /**
     * 
     * @type {number}
     * @memberof ParamPatchTenant
     */
    'unitNum'?: number;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ParamPatchTenant
     */
    'variables'?: Array<CommonKVPair>;
}
/**
 * 
 * @export
 * @interface ParamPatchUnitConfig
 */
export interface ParamPatchUnitConfig {
    /**
     * 
     * @type {Array<ParamResourcePoolSpec>}
     * @memberof ParamPatchUnitConfig
     */
    'pools': Array<ParamResourcePoolSpec>;
    /**
     * 
     * @type {ParamUnitConfig}
     * @memberof ParamPatchUnitConfig
     */
    'unitConfig': ParamUnitConfig;
}
/**
 * 
 * @export
 * @interface ParamQueryRange
 */
export interface ParamQueryRange {
    /**
     * 
     * @type {number}
     * @memberof ParamQueryRange
     */
    'endTimestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof ParamQueryRange
     */
    'startTimestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof ParamQueryRange
     */
    'step'?: number;
}
/**
 * 
 * @export
 * @interface ParamReplayStandbyLog
 */
export interface ParamReplayStandbyLog {
    /**
     * 
     * @type {string}
     * @memberof ParamReplayStandbyLog
     */
    'timestamp'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ParamReplayStandbyLog
     */
    'unlimited'?: boolean;
}
/**
 * 
 * @export
 * @interface ParamResetPasswordParam
 */
export interface ParamResetPasswordParam {
    /**
     * 
     * @type {string}
     * @memberof ParamResetPasswordParam
     */
    'oldPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamResetPasswordParam
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ParamResourcePoolSpec
 */
export interface ParamResourcePoolSpec {
    /**
     * 
     * @type {number}
     * @memberof ParamResourcePoolSpec
     */
    'priority'?: number;
    /**
     * Enum: Readonly, Full
     * @type {string}
     * @memberof ParamResourcePoolSpec
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamResourcePoolSpec
     */
    'zone': string;
}
/**
 * 
 * @export
 * @interface ParamRestartOBServersParam
 */
export interface ParamRestartOBServersParam {
    /**
     * 
     * @type {boolean}
     * @memberof ParamRestartOBServersParam
     */
    'all'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ParamRestartOBServersParam
     */
    'observers'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ParamRestartOBServersParam
     */
    'obzones'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ParamRestoreSourceSpec
 */
export interface ParamRestoreSourceSpec {
    /**
     * 
     * @type {string}
     * @memberof ParamRestoreSourceSpec
     */
    'appId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamRestoreSourceSpec
     */
    'archiveSource': string;
    /**
     * 
     * @type {string}
     * @memberof ParamRestoreSourceSpec
     */
    'bakDataSource': string;
    /**
     * 
     * @type {string}
     * @memberof ParamRestoreSourceSpec
     */
    'bakEncryptionPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamRestoreSourceSpec
     */
    'ossAccessId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamRestoreSourceSpec
     */
    'ossAccessKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParamRestoreSourceSpec
     */
    'region'?: string;
    /**
     * Enum: OSS, NFS, COS, S3, S3_COMPATIBLE
     * @type {ParamBackupDestType}
     * @memberof ParamRestoreSourceSpec
     */
    'type': ParamBackupDestType;
    /**
     * 
     * @type {ParamRestoreUntilConfig}
     * @memberof ParamRestoreSourceSpec
     */
    'until'?: ParamRestoreUntilConfig;
}


/**
 * 
 * @export
 * @interface ParamRestoreUntilConfig
 */
export interface ParamRestoreUntilConfig {
    /**
     * 
     * @type {string}
     * @memberof ParamRestoreUntilConfig
     */
    'timestamp'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ParamRestoreUntilConfig
     */
    'unlimited'?: boolean;
}
/**
 * 
 * @export
 * @interface ParamScaleOBServerParam
 */
export interface ParamScaleOBServerParam {
    /**
     * 
     * @type {number}
     * @memberof ParamScaleOBServerParam
     */
    'replicas'?: number;
}
/**
 * 
 * @export
 * @interface ParamScheduleDate
 */
export interface ParamScheduleDate {
    /**
     * Enum: Full, Incremental
     * @type {string}
     * @memberof ParamScheduleDate
     */
    'backupType': string;
    /**
     * Description: 1-31 for monthly, 1-7 for weekly
     * @type {number}
     * @memberof ParamScheduleDate
     */
    'day': number;
}
/**
 * 
 * @export
 * @interface ParamTenantPoolSpec
 */
export interface ParamTenantPoolSpec {
    /**
     * 
     * @type {number}
     * @memberof ParamTenantPoolSpec
     */
    'priority'?: number;
    /**
     * 
     * @type {ParamUnitConfig}
     * @memberof ParamTenantPoolSpec
     */
    'unitConfig'?: ParamUnitConfig;
}
/**
 * 
 * @export
 * @interface ParamTenantSourceSpec
 */
export interface ParamTenantSourceSpec {
    /**
     * 
     * @type {ParamRestoreSourceSpec}
     * @memberof ParamTenantSourceSpec
     */
    'restore'?: ParamRestoreSourceSpec;
    /**
     * 
     * @type {string}
     * @memberof ParamTenantSourceSpec
     */
    'tenant'?: string;
}
/**
 * 
 * @export
 * @interface ParamUnitConfig
 */
export interface ParamUnitConfig {
    /**
     * 
     * @type {string}
     * @memberof ParamUnitConfig
     */
    'cpuCount': string;
    /**
     * 
     * @type {number}
     * @memberof ParamUnitConfig
     */
    'iopsWeight'?: number;
    /**
     * 
     * @type {string}
     * @memberof ParamUnitConfig
     */
    'logDiskSize'?: string;
    /**
     * 
     * @type {number}
     * @memberof ParamUnitConfig
     */
    'maxIops'?: number;
    /**
     * 
     * @type {string}
     * @memberof ParamUnitConfig
     */
    'memorySize': string;
    /**
     * 
     * @type {number}
     * @memberof ParamUnitConfig
     */
    'minIops'?: number;
}
/**
 * 
 * @export
 * @interface ParamUpdateBackupPolicy
 */
export interface ParamUpdateBackupPolicy {
    /**
     * 
     * @type {number}
     * @memberof ParamUpdateBackupPolicy
     */
    'jobKeepDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof ParamUpdateBackupPolicy
     */
    'pieceIntervalDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof ParamUpdateBackupPolicy
     */
    'recoveryDays'?: number;
    /**
     * 
     * @type {Array<ParamScheduleDate>}
     * @memberof ParamUpdateBackupPolicy
     */
    'scheduleDates'?: Array<ParamScheduleDate>;
    /**
     * Description: HH:MM Example: 04:00
     * @type {string}
     * @memberof ParamUpdateBackupPolicy
     */
    'scheduleTime'?: string;
    /**
     * Enum: Weekly, Monthly
     * @type {string}
     * @memberof ParamUpdateBackupPolicy
     */
    'scheduleType'?: string;
    /**
     * Enum: PAUSED, RUNNING
     * @type {string}
     * @memberof ParamUpdateBackupPolicy
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ParamUpgradeOBClusterParam
 */
export interface ParamUpgradeOBClusterParam {
    /**
     * 
     * @type {string}
     * @memberof ParamUpgradeOBClusterParam
     */
    'image'?: string;
}
/**
 * 
 * @export
 * @interface ParamZoneTopology
 */
export interface ParamZoneTopology {
    /**
     * 
     * @type {Array<CommonAffinitySpec>}
     * @memberof ParamZoneTopology
     */
    'affinities'?: Array<CommonAffinitySpec>;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ParamZoneTopology
     */
    'nodeSelector'?: Array<CommonKVPair>;
    /**
     * 
     * @type {number}
     * @memberof ParamZoneTopology
     */
    'replicas'?: number;
    /**
     * 
     * @type {Array<CommonTolerationSpec>}
     * @memberof ParamZoneTopology
     */
    'tolerations'?: Array<CommonTolerationSpec>;
    /**
     * 
     * @type {string}
     * @memberof ParamZoneTopology
     */
    'zone'?: string;
}
/**
 * 
 * @export
 * @interface PayloadAlert
 */
export interface PayloadAlert {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PayloadAlert
     */
    'annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PayloadAlert
     */
    'endsAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayloadAlert
     */
    'generatorURL'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PayloadAlert
     */
    'labels'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PayloadAlert
     */
    'startsAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayloadAlert
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface PayloadWebhookPayload
 */
export interface PayloadWebhookPayload {
    /**
     * 
     * @type {Array<PayloadAlert>}
     * @memberof PayloadWebhookPayload
     */
    'alerts'?: Array<PayloadAlert>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PayloadWebhookPayload
     */
    'commonAnnotations'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PayloadWebhookPayload
     */
    'commonLabels'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PayloadWebhookPayload
     */
    'externalURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayloadWebhookPayload
     */
    'groupKey'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PayloadWebhookPayload
     */
    'groupLabels'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PayloadWebhookPayload
     */
    'receiver'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayloadWebhookPayload
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayloadWebhookPayload
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface QueryMetrics200Response
 */
export interface QueryMetrics200Response {
    /**
     * 
     * @type {Array<ResponseMetricData>}
     * @memberof QueryMetrics200Response
     */
    'data': Array<ResponseMetricData>;
    /**
     * 
     * @type {string}
     * @memberof QueryMetrics200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof QueryMetrics200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface QueryPlanDetailInfo200Response
 */
export interface QueryPlanDetailInfo200Response {
    /**
     * 
     * @type {SqlPlanDetail}
     * @memberof QueryPlanDetailInfo200Response
     */
    'data': SqlPlanDetail;
    /**
     * 
     * @type {string}
     * @memberof QueryPlanDetailInfo200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof QueryPlanDetailInfo200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface QuerySqlDetailInfo200Response
 */
export interface QuerySqlDetailInfo200Response {
    /**
     * 
     * @type {SqlSqlDetailedInfo}
     * @memberof QuerySqlDetailInfo200Response
     */
    'data': SqlSqlDetailedInfo;
    /**
     * 
     * @type {string}
     * @memberof QuerySqlDetailInfo200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof QuerySqlDetailInfo200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ReceiverReceiver
 */
export interface ReceiverReceiver {
    /**
     * 
     * @type {string}
     * @memberof ReceiverReceiver
     */
    'config': string;
    /**
     * 
     * @type {string}
     * @memberof ReceiverReceiver
     */
    'name': string;
    /**
     * 
     * @type {ReceiverReceiverType}
     * @memberof ReceiverReceiver
     */
    'type': ReceiverReceiverType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ReceiverReceiverType = {
    TypeDiscord: 'discord',
    TypeEmail: 'email',
    TypePagerduty: 'pagerduty',
    TypeSlack: 'slack',
    TypeWebhook: 'webhook',
    TypeOpsGenie: 'opsgenie',
    TypeWechat: 'wechat',
    TypePushover: 'pushover',
    TypeVictorOps: 'victorops',
    TypeSNS: 'sns',
    TypeTelegram: 'telegram',
    TypeWebex: 'webex',
    TypeMSTeams: 'msteams'
} as const;

export type ReceiverReceiverType = typeof ReceiverReceiverType[keyof typeof ReceiverReceiverType];


/**
 * 
 * @export
 * @interface ReceiverTemplate
 */
export interface ReceiverTemplate {
    /**
     * 
     * @type {string}
     * @memberof ReceiverTemplate
     */
    'template': string;
    /**
     * 
     * @type {ReceiverReceiverType}
     * @memberof ReceiverTemplate
     */
    'type': ReceiverReceiverType;
}


/**
 * 
 * @export
 * @interface RequestStatistics200Response
 */
export interface RequestStatistics200Response {
    /**
     * 
     * @type {Array<SqlRequestStatisticInfo>}
     * @memberof RequestStatistics200Response
     */
    'data': Array<SqlRequestStatisticInfo>;
    /**
     * 
     * @type {string}
     * @memberof RequestStatistics200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof RequestStatistics200Response
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ResponseAPIResponse
 */
export interface ResponseAPIResponse {
    /**
     * 
     * @type {object}
     * @memberof ResponseAPIResponse
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof ResponseAPIResponse
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseAPIResponse
     */
    'successful': boolean;
}
/**
 * 
 * @export
 * @interface ResponseBackupJob
 */
export interface ResponseBackupJob {
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'backupPolicyName': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'encryptionSecret'?: string;
    /**
     * End time of the backup job, empty for ARCHIVE job
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'namespace': string;
    /**
     * Empty for Clean job
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'path': string;
    /**
     * Start time of the backup job, StartScnDisplay for ARCHIVE job
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'statusInDatabase': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'tenantName': string;
    /**
     * Enum: FULL, INCR, ARCHIVE, CLEAN
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupJob
     */
    'uid': string;
}
/**
 * 
 * @export
 * @interface ResponseBackupPolicy
 */
export interface ResponseBackupPolicy {
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'archivePath': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'bakDataPath': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'bakEncryptionSecret'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'createTime': string;
    /**
     * Enum: NFS, OSS, COS, S3, S3_COMPATIBLE
     * @type {ParamBackupDestType}
     * @memberof ResponseBackupPolicy
     */
    'destType': ParamBackupDestType;
    /**
     * 
     * @type {Array<ResponseK8sEvent>}
     * @memberof ResponseBackupPolicy
     */
    'events': Array<ResponseK8sEvent>;
    /**
     * 
     * @type {number}
     * @memberof ResponseBackupPolicy
     */
    'jobKeepDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'ossAccessSecret'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseBackupPolicy
     */
    'pieceIntervalDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseBackupPolicy
     */
    'recoveryDays'?: number;
    /**
     * 
     * @type {Array<ParamScheduleDate>}
     * @memberof ResponseBackupPolicy
     */
    'scheduleDates'?: Array<ParamScheduleDate>;
    /**
     * Description: HH:MM Example: 04:00
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'scheduleTime'?: string;
    /**
     * Enum: Weekly, Monthly
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'scheduleType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'tenantName': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseBackupPolicy
     */
    'uid': string;
}


/**
 * 
 * @export
 * @interface ResponseConfigurableInfo
 */
export interface ResponseConfigurableInfo {
    /**
     * 
     * @type {string}
     * @memberof ResponseConfigurableInfo
     */
    'odcURL': string;
}
/**
 * 
 * @export
 * @interface ResponseContainerInfo
 */
export interface ResponseContainerInfo {
    /**
     * 
     * @type {string}
     * @memberof ResponseContainerInfo
     */
    'image': string;
    /**
     * 
     * @type {CommonResourceSpec}
     * @memberof ResponseContainerInfo
     */
    'limits': CommonResourceSpec;
    /**
     * 
     * @type {string}
     * @memberof ResponseContainerInfo
     */
    'name': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ResponseContainerInfo
     */
    'ports': Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseContainerInfo
     */
    'ready': boolean;
    /**
     * 
     * @type {CommonResourceSpec}
     * @memberof ResponseContainerInfo
     */
    'requests': CommonResourceSpec;
    /**
     * 
     * @type {number}
     * @memberof ResponseContainerInfo
     */
    'restartCount': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseContainerInfo
     */
    'startTime': string;
}
/**
 * 
 * @export
 * @interface ResponseDashboardInfo
 */
export interface ResponseDashboardInfo {
    /**
     * 
     * @type {string}
     * @memberof ResponseDashboardInfo
     */
    'appName': string;
    /**
     * 
     * @type {ResponseConfigurableInfo}
     * @memberof ResponseDashboardInfo
     */
    'configurableInfo': ResponseConfigurableInfo;
    /**
     * 
     * @type {string}
     * @memberof ResponseDashboardInfo
     */
    'publicKey': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseDashboardInfo
     */
    'reportHost': string;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseDashboardInfo
     */
    'reportStatistics': boolean;
    /**
     * 
     * @type {string}
     * @memberof ResponseDashboardInfo
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResponseK8sEvent
 */
export interface ResponseK8sEvent {
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sEvent
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sEvent
     */
    'firstOccur': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sEvent
     */
    'lastSeen': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sEvent
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sEvent
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sEvent
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sEvent
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sEvent
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ResponseK8sNode
 */
export interface ResponseK8sNode {
    /**
     * 
     * @type {ResponseK8sNodeInfo}
     * @memberof ResponseK8sNode
     */
    'info'?: ResponseK8sNodeInfo;
    /**
     * 
     * @type {ResponseK8sNodeResource}
     * @memberof ResponseK8sNode
     */
    'resource'?: ResponseK8sNodeResource;
}
/**
 * 
 * @export
 * @interface ResponseK8sNodeCondition
 */
export interface ResponseK8sNodeCondition {
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeCondition
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeCondition
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeCondition
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ResponseK8sNodeInfo
 */
export interface ResponseK8sNodeInfo {
    /**
     * 
     * @type {Array<ResponseK8sNodeCondition>}
     * @memberof ResponseK8sNodeInfo
     */
    'conditions': Array<ResponseK8sNodeCondition>;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeInfo
     */
    'cri': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeInfo
     */
    'externalIP': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeInfo
     */
    'internalIP': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeInfo
     */
    'kernel': string;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ResponseK8sNodeInfo
     */
    'labels': Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeInfo
     */
    'os': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseK8sNodeInfo
     */
    'roles': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeInfo
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sNodeInfo
     */
    'uptime': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sNodeInfo
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ResponseK8sNodeResource
 */
export interface ResponseK8sNodeResource {
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sNodeResource
     */
    'cpuFree': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sNodeResource
     */
    'cpuTotal': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sNodeResource
     */
    'cpuUsed': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sNodeResource
     */
    'memoryFree': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sNodeResource
     */
    'memoryTotal': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sNodeResource
     */
    'memoryUsed': number;
}
/**
 * 
 * @export
 * @interface ResponseK8sPodInfo
 */
export interface ResponseK8sPodInfo {
    /**
     * 
     * @type {Array<ResponseContainerInfo>}
     * @memberof ResponseK8sPodInfo
     */
    'containers': Array<ResponseContainerInfo>;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sPodInfo
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sPodInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sPodInfo
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sPodInfo
     */
    'nodeName': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sPodInfo
     */
    'podIP': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sPodInfo
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sPodInfo
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sPodInfo
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ResponseK8sService
 */
export interface ResponseK8sService {
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sService
     */
    'clusterIP': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sService
     */
    'externalIP'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sService
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sService
     */
    'namespace': string;
    /**
     * 
     * @type {Array<ResponseK8sServicePort>}
     * @memberof ResponseK8sService
     */
    'ports': Array<ResponseK8sServicePort>;
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sService
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ResponseK8sServicePort
 */
export interface ResponseK8sServicePort {
    /**
     * 
     * @type {string}
     * @memberof ResponseK8sServicePort
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sServicePort
     */
    'nodePort'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sServicePort
     */
    'port': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseK8sServicePort
     */
    'targetPort': number;
}
/**
 * 
 * @export
 * @interface ResponseMetric
 */
export interface ResponseMetric {
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ResponseMetric
     */
    'labels'?: Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof ResponseMetric
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ResponseMetricClass
 */
export interface ResponseMetricClass {
    /**
     * 
     * @type {string}
     * @memberof ResponseMetricClass
     */
    'description': string;
    /**
     * 
     * @type {Array<ResponseMetricGroup>}
     * @memberof ResponseMetricClass
     */
    'metricGroups': Array<ResponseMetricGroup>;
    /**
     * 
     * @type {string}
     * @memberof ResponseMetricClass
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ResponseMetricData
 */
export interface ResponseMetricData {
    /**
     * 
     * @type {ResponseMetric}
     * @memberof ResponseMetricData
     */
    'metric': ResponseMetric;
    /**
     * 
     * @type {Array<ResponseMetricValue>}
     * @memberof ResponseMetricData
     */
    'values': Array<ResponseMetricValue>;
}
/**
 * 
 * @export
 * @interface ResponseMetricGroup
 */
export interface ResponseMetricGroup {
    /**
     * 
     * @type {string}
     * @memberof ResponseMetricGroup
     */
    'description': string;
    /**
     * 
     * @type {Array<ResponseMetricMeta>}
     * @memberof ResponseMetricGroup
     */
    'metrics': Array<ResponseMetricMeta>;
    /**
     * 
     * @type {string}
     * @memberof ResponseMetricGroup
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ResponseMetricMeta
 */
export interface ResponseMetricMeta {
    /**
     * 
     * @type {string}
     * @memberof ResponseMetricMeta
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseMetricMeta
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseMetricMeta
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseMetricMeta
     */
    'unit': string;
}
/**
 * 
 * @export
 * @interface ResponseMetricValue
 */
export interface ResponseMetricValue {
    /**
     * 
     * @type {number}
     * @memberof ResponseMetricValue
     */
    'timestamp': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseMetricValue
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface ResponseMonitorSpec
 */
export interface ResponseMonitorSpec {
    /**
     * 
     * @type {string}
     * @memberof ResponseMonitorSpec
     */
    'image': string;
    /**
     * 
     * @type {ResponseResourceSpecRender}
     * @memberof ResponseMonitorSpec
     */
    'resource': ResponseResourceSpecRender;
}
/**
 * 
 * @export
 * @interface ResponseNFSVolumeSpec
 */
export interface ResponseNFSVolumeSpec {
    /**
     * 
     * @type {string}
     * @memberof ResponseNFSVolumeSpec
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseNFSVolumeSpec
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface ResponseNamespace
 */
export interface ResponseNamespace {
    /**
     * 
     * @type {string}
     * @memberof ResponseNamespace
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseNamespace
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ResponseOBCluster
 */
export interface ResponseOBCluster {
    /**
     * 
     * @type {ResponseNFSVolumeSpec}
     * @memberof ResponseOBCluster
     */
    'backupVolume'?: ResponseNFSVolumeSpec;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBCluster
     */
    'clusterId': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'clusterName': string;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBCluster
     */
    'createTime': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'image': string;
    /**
     * 
     * @type {ResponseOBMetrics}
     * @memberof ResponseOBCluster
     */
    'metrics'?: ResponseOBMetrics;
    /**
     * 
     * @type {CommonClusterMode}
     * @memberof ResponseOBCluster
     */
    'mode': CommonClusterMode;
    /**
     * 
     * @type {ResponseMonitorSpec}
     * @memberof ResponseOBCluster
     */
    'monitor'?: ResponseMonitorSpec;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'namespace': string;
    /**
     * 
     * @type {Array<ResponseParameterSpec>}
     * @memberof ResponseOBCluster
     */
    'parameters': Array<ResponseParameterSpec>;
    /**
     * 
     * @type {ResponseResourceSpecRender}
     * @memberof ResponseOBCluster
     */
    'resource': ResponseResourceSpecRender;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'rootPasswordSecret': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'statusDetail': string;
    /**
     * 
     * @type {ResponseOBServerStorage}
     * @memberof ResponseOBCluster
     */
    'storage': ResponseOBServerStorage;
    /**
     * 
     * @type {Array<ResponseOBZone>}
     * @memberof ResponseOBCluster
     */
    'topology': Array<ResponseOBZone>;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBCluster
     */
    'version'?: string;
}


/**
 * 
 * @export
 * @interface ResponseOBClusterMeta
 */
export interface ResponseOBClusterMeta {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBClusterMeta
     */
    'clusterId': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterMeta
     */
    'clusterName': string;
    /**
     * 
     * @type {CommonClusterMode}
     * @memberof ResponseOBClusterMeta
     */
    'mode': CommonClusterMode;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterMeta
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterMeta
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterMeta
     */
    'uid': string;
}


/**
 * 
 * @export
 * @interface ResponseOBClusterOverview
 */
export interface ResponseOBClusterOverview {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBClusterOverview
     */
    'clusterId': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterOverview
     */
    'clusterName': string;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBClusterOverview
     */
    'createTime': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterOverview
     */
    'image': string;
    /**
     * 
     * @type {CommonClusterMode}
     * @memberof ResponseOBClusterOverview
     */
    'mode': CommonClusterMode;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterOverview
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterOverview
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterOverview
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterOverview
     */
    'statusDetail': string;
    /**
     * 
     * @type {Array<ResponseOBZone>}
     * @memberof ResponseOBClusterOverview
     */
    'topology': Array<ResponseOBZone>;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterOverview
     */
    'uid': string;
}


/**
 * 
 * @export
 * @interface ResponseOBClusterResources
 */
export interface ResponseOBClusterResources {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBClusterResources
     */
    'minPoolMemory': number;
    /**
     * 
     * @type {Array<ResponseOBServerAvailableResource>}
     * @memberof ResponseOBClusterResources
     */
    'obServerResources'?: Array<ResponseOBServerAvailableResource>;
    /**
     * 
     * @type {{ [key: string]: ResponseOBZoneAvailableResource; }}
     * @memberof ResponseOBClusterResources
     */
    'obZoneResourceMap'?: { [key: string]: ResponseOBZoneAvailableResource; };
}
/**
 * 
 * @export
 * @interface ResponseOBClusterStatistic
 */
export interface ResponseOBClusterStatistic {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBClusterStatistic
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBClusterStatistic
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ResponseOBConnection
 */
export interface ResponseOBConnection {
    /**
     * 
     * @type {string}
     * @memberof ResponseOBConnection
     */
    'clientIp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBConnection
     */
    'cluster'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBConnection
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBConnection
     */
    'odcConnectionURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBConnection
     */
    'pod'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBConnection
     */
    'tenant'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBConnection
     */
    'terminalId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBConnection
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @interface ResponseOBMetrics
 */
export interface ResponseOBMetrics {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBMetrics
     */
    'cpuPercent': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBMetrics
     */
    'diskPercent': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBMetrics
     */
    'memoryPercent': number;
}
/**
 * 
 * @export
 * @interface ResponseOBServer
 */
export interface ResponseOBServer {
    /**
     * 
     * @type {string}
     * @memberof ResponseOBServer
     */
    'address': string;
    /**
     * 
     * @type {ResponseOBMetrics}
     * @memberof ResponseOBServer
     */
    'metrics'?: ResponseOBMetrics;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBServer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBServer
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBServer
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBServer
     */
    'statusDetail': string;
}
/**
 * 
 * @export
 * @interface ResponseOBServerAvailableResource
 */
export interface ResponseOBServerAvailableResource {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBServerAvailableResource
     */
    'availableCPU': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBServerAvailableResource
     */
    'availableDataDisk': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBServerAvailableResource
     */
    'availableLogDisk': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBServerAvailableResource
     */
    'availableMemory': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBServerAvailableResource
     */
    'obServerIP': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBServerAvailableResource
     */
    'obZone': string;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBServerAvailableResource
     */
    'serverCount': number;
}
/**
 * 
 * @export
 * @interface ResponseOBServerStorage
 */
export interface ResponseOBServerStorage {
    /**
     * 
     * @type {ResponseStorageSpec}
     * @memberof ResponseOBServerStorage
     */
    'dataStorage': ResponseStorageSpec;
    /**
     * 
     * @type {ResponseStorageSpec}
     * @memberof ResponseOBServerStorage
     */
    'redoLogStorage': ResponseStorageSpec;
    /**
     * 
     * @type {ResponseStorageSpec}
     * @memberof ResponseOBServerStorage
     */
    'sysLogStorage': ResponseStorageSpec;
}
/**
 * 
 * @export
 * @interface ResponseOBTenantDetail
 */
export interface ResponseOBTenantDetail {
    /**
     * Charset of the tenant
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'charset': string;
    /**
     * Name of the cluster belonging to
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'clusterResourceName': string;
    /**
     * Creation time of the tenant
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'createTime': string;
    /**
     * Locality of the tenant units
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'locality': string;
    /**
     * Name of the resource
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'name': string;
    /**
     * Namespace of the resource
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'primaryTenant'?: string;
    /**
     * Primary zone of the tenant
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'primaryZone': string;
    /**
     * 
     * @type {ResponseRestoreSource}
     * @memberof ResponseOBTenantDetail
     */
    'restoreSource'?: ResponseRestoreSource;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'rootCredential'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'standbyROCredential'?: string;
    /**
     * Status of the tenant
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'status': string;
    /**
     * Name of the tenant in the database
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'tenantName': string;
    /**
     * Enum: Primary, Standby
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'tenantRole': string;
    /**
     * Topology of the tenant
     * @type {Array<ResponseOBTenantReplica>}
     * @memberof ResponseOBTenantDetail
     */
    'topology'?: Array<ResponseOBTenantReplica>;
    /**
     * Unique identifier of the resource
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'uid': string;
    /**
     * Number of units in every zone
     * @type {number}
     * @memberof ResponseOBTenantDetail
     */
    'unitNumber': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBTenantDetail
     */
    'version'?: string;
}
/**
 * Brief information about OBTenant
 * @export
 * @interface ResponseOBTenantOverview
 */
export interface ResponseOBTenantOverview {
    /**
     * Charset of the tenant
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'charset': string;
    /**
     * Name of the cluster belonging to
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'clusterResourceName': string;
    /**
     * Creation time of the tenant
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'createTime': string;
    /**
     * Locality of the tenant units
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'locality': string;
    /**
     * Name of the resource
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'name': string;
    /**
     * Namespace of the resource
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'namespace': string;
    /**
     * Primary zone of the tenant
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'primaryZone': string;
    /**
     * Status of the tenant
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'status': string;
    /**
     * Name of the tenant in the database
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'tenantName': string;
    /**
     * Enum: Primary, Standby
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'tenantRole': string;
    /**
     * Topology of the tenant
     * @type {Array<ResponseOBTenantReplica>}
     * @memberof ResponseOBTenantOverview
     */
    'topology'?: Array<ResponseOBTenantReplica>;
    /**
     * Unique identifier of the resource
     * @type {string}
     * @memberof ResponseOBTenantOverview
     */
    'uid': string;
    /**
     * Number of units in every zone
     * @type {number}
     * @memberof ResponseOBTenantOverview
     */
    'unitNumber': number;
}
/**
 * 
 * @export
 * @interface ResponseOBTenantReplica
 */
export interface ResponseOBTenantReplica {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBTenantReplica
     */
    'iopsWeight': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBTenantReplica
     */
    'logDiskSize': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBTenantReplica
     */
    'maxCPU': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBTenantReplica
     */
    'maxIops': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBTenantReplica
     */
    'memorySize': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBTenantReplica
     */
    'minCPU': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBTenantReplica
     */
    'minIops': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBTenantReplica
     */
    'priority': number;
    /**
     * Enum: Readonly, Full
     * @type {string}
     * @memberof ResponseOBTenantReplica
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBTenantReplica
     */
    'zone': string;
}
/**
 * 
 * @export
 * @interface ResponseOBTenantStatistic
 */
export interface ResponseOBTenantStatistic {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBTenantStatistic
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBTenantStatistic
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ResponseOBZone
 */
export interface ResponseOBZone {
    /**
     * 
     * @type {Array<CommonAffinitySpec>}
     * @memberof ResponseOBZone
     */
    'affinities'?: Array<CommonAffinitySpec>;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBZone
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBZone
     */
    'namespace': string;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ResponseOBZone
     */
    'nodeSelector'?: Array<CommonKVPair>;
    /**
     * 
     * @type {Array<ResponseOBServer>}
     * @memberof ResponseOBZone
     */
    'observers'?: Array<ResponseOBServer>;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBZone
     */
    'replicas': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBZone
     */
    'rootService'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBZone
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBZone
     */
    'statusDetail': string;
    /**
     * 
     * @type {Array<CommonTolerationSpec>}
     * @memberof ResponseOBZone
     */
    'tolerations'?: Array<CommonTolerationSpec>;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBZone
     */
    'zone': string;
}
/**
 * 
 * @export
 * @interface ResponseOBZoneAvailableResource
 */
export interface ResponseOBZoneAvailableResource {
    /**
     * 
     * @type {number}
     * @memberof ResponseOBZoneAvailableResource
     */
    'availableCPU': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBZoneAvailableResource
     */
    'availableDataDisk': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBZoneAvailableResource
     */
    'availableLogDisk': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBZoneAvailableResource
     */
    'availableMemory': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseOBZoneAvailableResource
     */
    'obZone': string;
    /**
     * 
     * @type {number}
     * @memberof ResponseOBZoneAvailableResource
     */
    'serverCount': number;
}
/**
 * 
 * @export
 * @interface ResponseParameterSpec
 */
export interface ResponseParameterSpec {
    /**
     * 
     * @type {string}
     * @memberof ResponseParameterSpec
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseParameterSpec
     */
    'specValue': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseParameterSpec
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ResponseResourceSpecRender
 */
export interface ResponseResourceSpecRender {
    /**
     * 
     * @type {number}
     * @memberof ResponseResourceSpecRender
     */
    'cpu': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseResourceSpecRender
     */
    'memory': number;
}
/**
 * 
 * @export
 * @interface ResponseRestoreSource
 */
export interface ResponseRestoreSource {
    /**
     * 
     * @type {string}
     * @memberof ResponseRestoreSource
     */
    'archiveSource': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRestoreSource
     */
    'bakDataSource': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRestoreSource
     */
    'bakEncryptionSecret'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRestoreSource
     */
    'ossAccessSecret'?: string;
    /**
     * Enum: OSS, NFS
     * @type {string}
     * @memberof ResponseRestoreSource
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRestoreSource
     */
    'until'?: string;
}
/**
 * 
 * @export
 * @interface ResponseStatisticData
 */
export interface ResponseStatisticData {
    /**
     * 
     * @type {Array<ModelsOBBackupPolicy>}
     * @memberof ResponseStatisticData
     */
    'backupPolicies': Array<ModelsOBBackupPolicy>;
    /**
     * 
     * @type {Array<ModelsOBCluster>}
     * @memberof ResponseStatisticData
     */
    'clusters': Array<ModelsOBCluster>;
    /**
     * 
     * @type {Array<ResponseK8sNode>}
     * @memberof ResponseStatisticData
     */
    'k8sNodes': Array<ResponseK8sNode>;
    /**
     * 
     * @type {string}
     * @memberof ResponseStatisticData
     */
    'operatorVersion'?: string;
    /**
     * 
     * @type {Array<ModelsOBServer>}
     * @memberof ResponseStatisticData
     */
    'servers': Array<ModelsOBServer>;
    /**
     * 
     * @type {Array<ModelsOBTenant>}
     * @memberof ResponseStatisticData
     */
    'tenants': Array<ModelsOBTenant>;
    /**
     * 
     * @type {Array<ModelsK8sEvent>}
     * @memberof ResponseStatisticData
     */
    'warningEvents': Array<ModelsK8sEvent>;
    /**
     * 
     * @type {Array<ModelsOBZone>}
     * @memberof ResponseStatisticData
     */
    'zones': Array<ModelsOBZone>;
}
/**
 * 
 * @export
 * @interface ResponseStorageClass
 */
export interface ResponseStorageClass {
    /**
     * 
     * @type {boolean}
     * @memberof ResponseStorageClass
     */
    'allowVolumeExpansion': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseStorageClass
     */
    'mountOptions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResponseStorageClass
     */
    'name': string;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof ResponseStorageClass
     */
    'parameters'?: Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof ResponseStorageClass
     */
    'provisioner': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseStorageClass
     */
    'reclaimPolicy': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseStorageClass
     */
    'volumeBindingMode': string;
}
/**
 * 
 * @export
 * @interface ResponseStorageSpec
 */
export interface ResponseStorageSpec {
    /**
     * 
     * @type {number}
     * @memberof ResponseStorageSpec
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof ResponseStorageSpec
     */
    'storageClass': string;
}
/**
 * 
 * @export
 * @interface RouteRouteParam
 */
export interface RouteRouteParam {
    /**
     * 
     * @type {Array<string>}
     * @memberof RouteRouteParam
     */
    'aggregateLabels': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof RouteRouteParam
     */
    'groupInterval': number;
    /**
     * 
     * @type {number}
     * @memberof RouteRouteParam
     */
    'groupWait': number;
    /**
     * 
     * @type {string}
     * @memberof RouteRouteParam
     */
    'id'?: string;
    /**
     * 
     * @type {Array<AlarmMatcher>}
     * @memberof RouteRouteParam
     */
    'matchers': Array<AlarmMatcher>;
    /**
     * 
     * @type {string}
     * @memberof RouteRouteParam
     */
    'receiver': string;
    /**
     * 
     * @type {number}
     * @memberof RouteRouteParam
     */
    'repeatInterval': number;
}
/**
 * 
 * @export
 * @interface RouteRouteResponse
 */
export interface RouteRouteResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof RouteRouteResponse
     */
    'aggregateLabels': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof RouteRouteResponse
     */
    'groupInterval': number;
    /**
     * 
     * @type {number}
     * @memberof RouteRouteResponse
     */
    'groupWait': number;
    /**
     * 
     * @type {string}
     * @memberof RouteRouteResponse
     */
    'id': string;
    /**
     * 
     * @type {Array<AlarmMatcher>}
     * @memberof RouteRouteResponse
     */
    'matchers': Array<AlarmMatcher>;
    /**
     * 
     * @type {string}
     * @memberof RouteRouteResponse
     */
    'receiver': string;
    /**
     * 
     * @type {number}
     * @memberof RouteRouteResponse
     */
    'repeatInterval': number;
}
/**
 * 
 * @export
 * @interface RuleRule
 */
export interface RuleRule {
    /**
     * 
     * @type {string}
     * @memberof RuleRule
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof RuleRule
     */
    'duration': number;
    /**
     * 
     * @type {OceanbaseOBInstanceType}
     * @memberof RuleRule
     */
    'instanceType': OceanbaseOBInstanceType;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof RuleRule
     */
    'labels': Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof RuleRule
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RuleRule
     */
    'query': string;
    /**
     * 
     * @type {AlarmSeverity}
     * @memberof RuleRule
     */
    'severity': AlarmSeverity;
    /**
     * 
     * @type {string}
     * @memberof RuleRule
     */
    'summary': string;
    /**
     * 
     * @type {RuleRuleType}
     * @memberof RuleRule
     */
    'type'?: RuleRuleType;
}


/**
 * 
 * @export
 * @interface RuleRuleFilter
 */
export interface RuleRuleFilter {
    /**
     * 
     * @type {OceanbaseOBInstanceType}
     * @memberof RuleRuleFilter
     */
    'instanceType'?: OceanbaseOBInstanceType;
    /**
     * 
     * @type {string}
     * @memberof RuleRuleFilter
     */
    'keyword'?: string;
    /**
     * 
     * @type {AlarmSeverity}
     * @memberof RuleRuleFilter
     */
    'severity'?: AlarmSeverity;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RuleRuleHealth = {
    HealthUnknown: 'unknown',
    HealthOK: 'ok',
    HealthError: 'error'
} as const;

export type RuleRuleHealth = typeof RuleRuleHealth[keyof typeof RuleRuleHealth];


/**
 * 
 * @export
 * @interface RuleRuleResponse
 */
export interface RuleRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof RuleRuleResponse
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof RuleRuleResponse
     */
    'duration': number;
    /**
     * 
     * @type {number}
     * @memberof RuleRuleResponse
     */
    'evaluationTime': number;
    /**
     * 
     * @type {RuleRuleHealth}
     * @memberof RuleRuleResponse
     */
    'health': RuleRuleHealth;
    /**
     * 
     * @type {OceanbaseOBInstanceType}
     * @memberof RuleRuleResponse
     */
    'instanceType': OceanbaseOBInstanceType;
    /**
     * 
     * @type {number}
     * @memberof RuleRuleResponse
     */
    'keepFiringFor': number;
    /**
     * 
     * @type {Array<CommonKVPair>}
     * @memberof RuleRuleResponse
     */
    'labels': Array<CommonKVPair>;
    /**
     * 
     * @type {string}
     * @memberof RuleRuleResponse
     */
    'lastError'?: string;
    /**
     * 
     * @type {number}
     * @memberof RuleRuleResponse
     */
    'lastEvaluation': number;
    /**
     * 
     * @type {string}
     * @memberof RuleRuleResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RuleRuleResponse
     */
    'query': string;
    /**
     * 
     * @type {AlarmSeverity}
     * @memberof RuleRuleResponse
     */
    'severity': AlarmSeverity;
    /**
     * 
     * @type {RuleRuleState}
     * @memberof RuleRuleResponse
     */
    'state': RuleRuleState;
    /**
     * 
     * @type {string}
     * @memberof RuleRuleResponse
     */
    'summary': string;
    /**
     * 
     * @type {RuleRuleType}
     * @memberof RuleRuleResponse
     */
    'type'?: RuleRuleType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RuleRuleState = {
    StateActive: 'active',
    StateInactive: 'inactive'
} as const;

export type RuleRuleState = typeof RuleRuleState[keyof typeof RuleRuleState];


/**
 * 
 * @export
 * @enum {string}
 */

export const RuleRuleType = {
    TypeBuiltin: 'builtin',
    TypeCustomized: 'customized'
} as const;

export type RuleRuleType = typeof RuleRuleType[keyof typeof RuleRuleType];


/**
 * 
 * @export
 * @interface SilenceSilencerFilter
 */
export interface SilenceSilencerFilter {
    /**
     * 
     * @type {OceanbaseOBInstance}
     * @memberof SilenceSilencerFilter
     */
    'instance'?: OceanbaseOBInstance;
    /**
     * 
     * @type {OceanbaseOBInstanceType}
     * @memberof SilenceSilencerFilter
     */
    'instanceType'?: OceanbaseOBInstanceType;
    /**
     * 
     * @type {string}
     * @memberof SilenceSilencerFilter
     */
    'keyword'?: string;
}


/**
 * 
 * @export
 * @interface SilenceSilencerParam
 */
export interface SilenceSilencerParam {
    /**
     * 
     * @type {string}
     * @memberof SilenceSilencerParam
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof SilenceSilencerParam
     */
    'createdBy': string;
    /**
     * 
     * @type {number}
     * @memberof SilenceSilencerParam
     */
    'endsAt': number;
    /**
     * 
     * @type {string}
     * @memberof SilenceSilencerParam
     */
    'id'?: string;
    /**
     * 
     * @type {Array<OceanbaseOBInstance>}
     * @memberof SilenceSilencerParam
     */
    'instances': Array<OceanbaseOBInstance>;
    /**
     * 
     * @type {Array<AlarmMatcher>}
     * @memberof SilenceSilencerParam
     */
    'matchers': Array<AlarmMatcher>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SilenceSilencerParam
     */
    'rules': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SilenceSilencerParam
     */
    'startsAt': number;
}
/**
 * 
 * @export
 * @interface SilenceSilencerResponse
 */
export interface SilenceSilencerResponse {
    /**
     * 
     * @type {string}
     * @memberof SilenceSilencerResponse
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof SilenceSilencerResponse
     */
    'createdBy': string;
    /**
     * 
     * @type {number}
     * @memberof SilenceSilencerResponse
     */
    'endsAt': number;
    /**
     * 
     * @type {string}
     * @memberof SilenceSilencerResponse
     */
    'id': string;
    /**
     * 
     * @type {Array<OceanbaseOBInstance>}
     * @memberof SilenceSilencerResponse
     */
    'instances': Array<OceanbaseOBInstance>;
    /**
     * 
     * @type {Array<AlarmMatcher>}
     * @memberof SilenceSilencerResponse
     */
    'matchers': Array<AlarmMatcher>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SilenceSilencerResponse
     */
    'rules': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SilenceSilencerResponse
     */
    'startsAt': number;
    /**
     * 
     * @type {SilenceStatus}
     * @memberof SilenceSilencerResponse
     */
    'status': SilenceStatus;
    /**
     * 
     * @type {number}
     * @memberof SilenceSilencerResponse
     */
    'updatedAt': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SilenceState = {
    StateActive: 'active',
    StateExpired: 'expired',
    StatePending: 'pending'
} as const;

export type SilenceState = typeof SilenceState[keyof typeof SilenceState];


/**
 * 
 * @export
 * @interface SilenceStatus
 */
export interface SilenceStatus {
    /**
     * 
     * @type {SilenceState}
     * @memberof SilenceStatus
     */
    'state': SilenceState;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SqlIndexCategory = {
    IndexCategoryPrimaryKey: 'primaryKey',
    IndexCategoryGlobalNormal: 'globalNormal',
    IndexCategoryGlobalUnique: 'globalUnique',
    IndexCategoryLocalNormal: 'localNormal',
    IndexCategoryLocalUnique: 'localUnique'
} as const;

export type SqlIndexCategory = typeof SqlIndexCategory[keyof typeof SqlIndexCategory];


/**
 * 
 * @export
 * @interface SqlIndexInfo
 */
export interface SqlIndexInfo {
    /**
     * 
     * @type {SqlIndexCategory}
     * @memberof SqlIndexInfo
     */
    'category': SqlIndexCategory;
    /**
     * 
     * @type {Array<string>}
     * @memberof SqlIndexInfo
     */
    'columns': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SqlIndexInfo
     */
    'indexName': string;
    /**
     * 
     * @type {SqlIndexStatus}
     * @memberof SqlIndexInfo
     */
    'status': SqlIndexStatus;
    /**
     * 
     * @type {string}
     * @memberof SqlIndexInfo
     */
    'tableName': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SqlIndexStatus = {
    IndexStatusCreating: 'creating',
    IndexStatusAvailable: 'available',
    IndexStatusError: 'error'
} as const;

export type SqlIndexStatus = typeof SqlIndexStatus[keyof typeof SqlIndexStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const SqlMetricCategory = {
    Meta: 'meta',
    Latency: 'latency',
    Execution: 'execution'
} as const;

export type SqlMetricCategory = typeof SqlMetricCategory[keyof typeof SqlMetricCategory];


/**
 * 
 * @export
 * @enum {string}
 */

export const SqlPlanCategory = {
    PlanCategoryLocal: 'local',
    PlanCategoryRemote: 'remote',
    PlanCategoryDistributed: 'distributed'
} as const;

export type SqlPlanCategory = typeof SqlPlanCategory[keyof typeof SqlPlanCategory];


/**
 * 
 * @export
 * @interface SqlPlanDetail
 */
export interface SqlPlanDetail {
    /**
     * 
     * @type {SqlPlanCategory}
     * @memberof SqlPlanDetail
     */
    'category': SqlPlanCategory;
    /**
     * 
     * @type {number}
     * @memberof SqlPlanDetail
     */
    'generatedTime': number;
    /**
     * 
     * @type {number}
     * @memberof SqlPlanDetail
     */
    'mergedVersion': number;
    /**
     * 
     * @type {SqlPlanOperator}
     * @memberof SqlPlanDetail
     */
    'planDetail': SqlPlanOperator;
    /**
     * 
     * @type {string}
     * @memberof SqlPlanDetail
     */
    'planHash': string;
    /**
     * 
     * @type {Array<SqlPlanStatisticByServer>}
     * @memberof SqlPlanDetail
     */
    'planStatistics': Array<SqlPlanStatisticByServer>;
}


/**
 * 
 * @export
 * @interface SqlPlanDetailParam
 */
export interface SqlPlanDetailParam {
    /**
     * 
     * @type {string}
     * @memberof SqlPlanDetailParam
     */
    'database'?: string;
    /**
     * 
     * @type {number}
     * @memberof SqlPlanDetailParam
     */
    'endTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof SqlPlanDetailParam
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof SqlPlanDetailParam
     */
    'obcluster': string;
    /**
     * 
     * @type {string}
     * @memberof SqlPlanDetailParam
     */
    'obtenant'?: string;
    /**
     * 
     * @type {string}
     * @memberof SqlPlanDetailParam
     */
    'planHash': string;
    /**
     * 
     * @type {number}
     * @memberof SqlPlanDetailParam
     */
    'startTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof SqlPlanDetailParam
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @interface SqlPlanOperator
 */
export interface SqlPlanOperator {
    /**
     * 
     * @type {Array<SqlPlanOperator>}
     * @memberof SqlPlanOperator
     */
    'childOperators'?: Array<SqlPlanOperator>;
    /**
     * 
     * @type {number}
     * @memberof SqlPlanOperator
     */
    'cost': number;
    /**
     * 
     * @type {number}
     * @memberof SqlPlanOperator
     */
    'estimatedRows': number;
    /**
     * 
     * @type {string}
     * @memberof SqlPlanOperator
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SqlPlanOperator
     */
    'operator': string;
    /**
     * 
     * @type {string}
     * @memberof SqlPlanOperator
     */
    'outputOrFilter'?: string;
}
/**
 * 
 * @export
 * @interface SqlPlanStatistic
 */
export interface SqlPlanStatistic {
    /**
     * 
     * @type {SqlPlanCategory}
     * @memberof SqlPlanStatistic
     */
    'category': SqlPlanCategory;
    /**
     * 
     * @type {number}
     * @memberof SqlPlanStatistic
     */
    'cost': number;
    /**
     * 
     * @type {number}
     * @memberof SqlPlanStatistic
     */
    'cpuTime': number;
    /**
     * 
     * @type {number}
     * @memberof SqlPlanStatistic
     */
    'generatedTime': number;
    /**
     * 
     * @type {number}
     * @memberof SqlPlanStatistic
     */
    'mergedVersion': number;
    /**
     * 
     * @type {string}
     * @memberof SqlPlanStatistic
     */
    'planHash': string;
}


/**
 * 
 * @export
 * @interface SqlPlanStatisticByServer
 */
export interface SqlPlanStatisticByServer {
    /**
     * 
     * @type {SqlPlanCategory}
     * @memberof SqlPlanStatisticByServer
     */
    'category': SqlPlanCategory;
    /**
     * 
     * @type {number}
     * @memberof SqlPlanStatisticByServer
     */
    'cost': number;
    /**
     * 
     * @type {number}
     * @memberof SqlPlanStatisticByServer
     */
    'cpuTime': number;
    /**
     * 
     * @type {number}
     * @memberof SqlPlanStatisticByServer
     */
    'generatedTime': number;
    /**
     * 
     * @type {number}
     * @memberof SqlPlanStatisticByServer
     */
    'mergedVersion': number;
    /**
     * 
     * @type {string}
     * @memberof SqlPlanStatisticByServer
     */
    'planHash': string;
    /**
     * 
     * @type {number}
     * @memberof SqlPlanStatisticByServer
     */
    'planId': number;
    /**
     * 
     * @type {string}
     * @memberof SqlPlanStatisticByServer
     */
    'server': string;
}


/**
 * 
 * @export
 * @interface SqlRequestStatisticInfo
 */
export interface SqlRequestStatisticInfo {
    /**
     * 
     * @type {string}
     * @memberof SqlRequestStatisticInfo
     */
    'database': string;
    /**
     * 
     * @type {Array<SqlSqlStatisticMetric>}
     * @memberof SqlRequestStatisticInfo
     */
    'executionStatistics': Array<SqlSqlStatisticMetric>;
    /**
     * 
     * @type {ResponseMetricData}
     * @memberof SqlRequestStatisticInfo
     */
    'executionTrend': ResponseMetricData;
    /**
     * 
     * @type {Array<SqlSqlStatisticMetric>}
     * @memberof SqlRequestStatisticInfo
     */
    'latencyStatistics': Array<SqlSqlStatisticMetric>;
    /**
     * 
     * @type {ResponseMetricData}
     * @memberof SqlRequestStatisticInfo
     */
    'latencyTrend': ResponseMetricData;
    /**
     * 
     * @type {Array<SqlSqlStatisticMetric>}
     * @memberof SqlRequestStatisticInfo
     */
    'planCategoryStatistics': Array<SqlSqlStatisticMetric>;
    /**
     * 
     * @type {string}
     * @memberof SqlRequestStatisticInfo
     */
    'tenant': string;
    /**
     * 
     * @type {string}
     * @memberof SqlRequestStatisticInfo
     */
    'user': string;
}
/**
 * 
 * @export
 * @interface SqlSqlDetailParam
 */
export interface SqlSqlDetailParam {
    /**
     * 
     * @type {string}
     * @memberof SqlSqlDetailParam
     */
    'database'?: string;
    /**
     * 
     * @type {number}
     * @memberof SqlSqlDetailParam
     */
    'endTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof SqlSqlDetailParam
     */
    'interval': number;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlDetailParam
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlDetailParam
     */
    'obcluster': string;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlDetailParam
     */
    'obtenant'?: string;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlDetailParam
     */
    'sqlId': string;
    /**
     * 
     * @type {number}
     * @memberof SqlSqlDetailParam
     */
    'startTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlDetailParam
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @interface SqlSqlDetailedInfo
 */
export interface SqlSqlDetailedInfo {
    /**
     * 
     * @type {Array<SqlSqlDiagnoseInfo>}
     * @memberof SqlSqlDetailedInfo
     */
    'diagnoseInfo'?: Array<SqlSqlDiagnoseInfo>;
    /**
     * 
     * @type {Array<ResponseMetricData>}
     * @memberof SqlSqlDetailedInfo
     */
    'executionTrend': Array<ResponseMetricData>;
    /**
     * 
     * @type {Array<SqlIndexInfo>}
     * @memberof SqlSqlDetailedInfo
     */
    'indexies'?: Array<SqlIndexInfo>;
    /**
     * 
     * @type {Array<ResponseMetricData>}
     * @memberof SqlSqlDetailedInfo
     */
    'latencyTrend': Array<ResponseMetricData>;
    /**
     * 
     * @type {Array<SqlPlanStatistic>}
     * @memberof SqlSqlDetailedInfo
     */
    'plans': Array<SqlPlanStatistic>;
}
/**
 * 
 * @export
 * @interface SqlSqlDiagnoseInfo
 */
export interface SqlSqlDiagnoseInfo {
    /**
     * 
     * @type {string}
     * @memberof SqlSqlDiagnoseInfo
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlDiagnoseInfo
     */
    'suggestion'?: string;
}
/**
 * 
 * @export
 * @interface SqlSqlFilter
 */
export interface SqlSqlFilter {
    /**
     * 
     * @type {string}
     * @memberof SqlSqlFilter
     */
    'database'?: string;
    /**
     * 
     * @type {number}
     * @memberof SqlSqlFilter
     */
    'endTime'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SqlSqlFilter
     */
    'includeInnerSql'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlFilter
     */
    'keyword'?: string;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlFilter
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlFilter
     */
    'obcluster': string;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlFilter
     */
    'obtenant'?: string;
    /**
     * 
     * @type {number}
     * @memberof SqlSqlFilter
     */
    'startTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlFilter
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @interface SqlSqlInfo
 */
export interface SqlSqlInfo {
    /**
     * 
     * @type {string}
     * @memberof SqlSqlInfo
     */
    'database': string;
    /**
     * 
     * @type {Array<SqlSqlDiagnoseInfo>}
     * @memberof SqlSqlInfo
     */
    'diagnoseInfo'?: Array<SqlSqlDiagnoseInfo>;
    /**
     * 
     * @type {Array<SqlSqlStatisticMetric>}
     * @memberof SqlSqlInfo
     */
    'executionStatistics': Array<SqlSqlStatisticMetric>;
    /**
     * 
     * @type {boolean}
     * @memberof SqlSqlInfo
     */
    'isInner': boolean;
    /**
     * 
     * @type {Array<SqlSqlStatisticMetric>}
     * @memberof SqlSqlInfo
     */
    'latencyStatistics': Array<SqlSqlStatisticMetric>;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlInfo
     */
    'observer': string;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlInfo
     */
    'sqlID': string;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlInfo
     */
    'sqlText': string;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlInfo
     */
    'sqlType': string;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlInfo
     */
    'tenant': string;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlInfo
     */
    'user': string;
}
/**
 * 
 * @export
 * @interface SqlSqlMetricMeta
 */
export interface SqlSqlMetricMeta {
    /**
     * 
     * @type {SqlMetricCategory}
     * @memberof SqlSqlMetricMeta
     */
    'category': SqlMetricCategory;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlMetricMeta
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof SqlSqlMetricMeta
     */
    'displayByDefault': boolean;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlMetricMeta
     */
    'name': string;
}


/**
 * 
 * @export
 * @interface SqlSqlMetricMetaCategory
 */
export interface SqlSqlMetricMetaCategory {
    /**
     * 
     * @type {SqlMetricCategory}
     * @memberof SqlSqlMetricMetaCategory
     */
    'category': SqlMetricCategory;
    /**
     * 
     * @type {Array<SqlSqlMetricMeta>}
     * @memberof SqlSqlMetricMetaCategory
     */
    'metrics': Array<SqlSqlMetricMeta>;
}


/**
 * 
 * @export
 * @interface SqlSqlRequestStatisticParam
 */
export interface SqlSqlRequestStatisticParam {
    /**
     * 
     * @type {string}
     * @memberof SqlSqlRequestStatisticParam
     */
    'database'?: string;
    /**
     * 
     * @type {number}
     * @memberof SqlSqlRequestStatisticParam
     */
    'endTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlRequestStatisticParam
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlRequestStatisticParam
     */
    'obcluster': string;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlRequestStatisticParam
     */
    'obtenant'?: string;
    /**
     * 
     * @type {number}
     * @memberof SqlSqlRequestStatisticParam
     */
    'startTime'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof SqlSqlRequestStatisticParam
     */
    'statisticScopes': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SqlSqlRequestStatisticParam
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @interface SqlSqlStatisticMetric
 */
export interface SqlSqlStatisticMetric {
    /**
     * 
     * @type {string}
     * @memberof SqlSqlStatisticMetric
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof SqlSqlStatisticMetric
     */
    'value': number;
}

/**
 * AccessControlApi - axios parameter creator
 * @export
 */
export const AccessControlApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an account
         * @summary Create an account
         * @param {AcCreateAccountParam} account Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (account: AcCreateAccountParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            assertParamExists('createAccount', 'account', account)
            const localVarPath = `/api/v1/ac/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(account, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an role
         * @summary Create an role
         * @param {AcCreateRoleParam} role Role information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (role: AcCreateRoleParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('createRole', 'role', role)
            const localVarPath = `/api/v1/ac/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an account
         * @summary Delete an account
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deleteAccount', 'username', username)
            const localVarPath = `/api/v1/ac/accounts/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an role
         * @summary Delete an role
         * @param {string} name Role name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteRole', 'name', name)
            const localVarPath = `/api/v1/ac/roles/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get account info
         * @summary get account info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ac/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all accounts
         * @summary List all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllAccounts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ac/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all policies
         * @summary List all policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllPolicies: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ac/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all roles
         * @summary List all roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ac/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch an account
         * @summary Patch an account
         * @param {string} username Username
         * @param {AcPatchAccountParam} account Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccount: async (username: string, account: AcPatchAccountParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('patchAccount', 'username', username)
            // verify required parameter 'account' is not null or undefined
            assertParamExists('patchAccount', 'account', account)
            const localVarPath = `/api/v1/ac/accounts/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(account, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch an role
         * @summary Patch an role
         * @param {string} name Role name
         * @param {AcPatchRoleParam} role Role information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRole: async (name: string, role: AcPatchRoleParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('patchRole', 'name', name)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('patchRole', 'role', role)
            const localVarPath = `/api/v1/ac/roles/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset user\'s own password
         * @summary Reset user\'s own password
         * @param {ParamResetPasswordParam} resetParam reset password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetParam: ParamResetPasswordParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetParam' is not null or undefined
            assertParamExists('resetPassword', 'resetParam', resetParam)
            const localVarPath = `/api/v1/ac/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessControlApi - functional programming interface
 * @export
 */
export const AccessControlApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessControlApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an account
         * @summary Create an account
         * @param {AcCreateAccountParam} account Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(account: AcCreateAccountParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(account, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.createAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an role
         * @summary Create an role
         * @param {AcCreateRoleParam} role Role information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(role: AcCreateRoleParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRole200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.createRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an account
         * @summary Delete an account
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.deleteAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an role
         * @summary Delete an role
         * @param {string} name Role name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRole200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.deleteRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get account info
         * @summary get account info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.getAccountInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all accounts
         * @summary List all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllAccounts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllAccounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllAccounts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.listAllAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all policies
         * @summary List all policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllPolicies(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllPolicies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllPolicies(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.listAllPolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all roles
         * @summary List all roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllRoles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllRoles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllRoles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.listAllRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Patch an account
         * @summary Patch an account
         * @param {string} username Username
         * @param {AcPatchAccountParam} account Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccount(username: string, account: AcPatchAccountParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAccount(username, account, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.patchAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Patch an role
         * @summary Patch an role
         * @param {string} name Role name
         * @param {AcPatchRoleParam} role Role information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRole(name: string, role: AcPatchRoleParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRole200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRole(name, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.patchRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset user\'s own password
         * @summary Reset user\'s own password
         * @param {ParamResetPasswordParam} resetParam reset password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetParam: ParamResetPasswordParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetParam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccessControlApi - factory interface
 * @export
 */
export const AccessControlApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessControlApiFp(configuration)
    return {
        /**
         * Create an account
         * @summary Create an account
         * @param {AcCreateAccountParam} account Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(account: AcCreateAccountParam, options?: any): AxiosPromise<CreateAccount200Response> {
            return localVarFp.createAccount(account, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an role
         * @summary Create an role
         * @param {AcCreateRoleParam} role Role information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(role: AcCreateRoleParam, options?: any): AxiosPromise<CreateRole200Response> {
            return localVarFp.createRole(role, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an account
         * @summary Delete an account
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(username: string, options?: any): AxiosPromise<CreateAccount200Response> {
            return localVarFp.deleteAccount(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an role
         * @summary Delete an role
         * @param {string} name Role name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(name: string, options?: any): AxiosPromise<CreateRole200Response> {
            return localVarFp.deleteRole(name, options).then((request) => request(axios, basePath));
        },
        /**
         * get account info
         * @summary get account info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInfo(options?: any): AxiosPromise<CreateAccount200Response> {
            return localVarFp.getAccountInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * List all accounts
         * @summary List all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllAccounts(options?: any): AxiosPromise<ListAllAccounts200Response> {
            return localVarFp.listAllAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         * List all policies
         * @summary List all policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllPolicies(options?: any): AxiosPromise<ListAllPolicies200Response> {
            return localVarFp.listAllPolicies(options).then((request) => request(axios, basePath));
        },
        /**
         * List all roles
         * @summary List all roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllRoles(options?: any): AxiosPromise<ListAllRoles200Response> {
            return localVarFp.listAllRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * Patch an account
         * @summary Patch an account
         * @param {string} username Username
         * @param {AcPatchAccountParam} account Account information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccount(username: string, account: AcPatchAccountParam, options?: any): AxiosPromise<CreateAccount200Response> {
            return localVarFp.patchAccount(username, account, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch an role
         * @summary Patch an role
         * @param {string} name Role name
         * @param {AcPatchRoleParam} role Role information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRole(name: string, role: AcPatchRoleParam, options?: any): AxiosPromise<CreateRole200Response> {
            return localVarFp.patchRole(name, role, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset user\'s own password
         * @summary Reset user\'s own password
         * @param {ParamResetPasswordParam} resetParam reset password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(resetParam: ParamResetPasswordParam, options?: any): AxiosPromise<CreateAccount200Response> {
            return localVarFp.resetPassword(resetParam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessControlApi - object-oriented interface
 * @export
 * @class AccessControlApi
 * @extends {BaseAPI}
 */
export class AccessControlApi extends BaseAPI {
    /**
     * Create an account
     * @summary Create an account
     * @param {AcCreateAccountParam} account Account information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public createAccount(account: AcCreateAccountParam, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).createAccount(account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an role
     * @summary Create an role
     * @param {AcCreateRoleParam} role Role information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public createRole(role: AcCreateRoleParam, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).createRole(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an account
     * @summary Delete an account
     * @param {string} username Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public deleteAccount(username: string, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).deleteAccount(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an role
     * @summary Delete an role
     * @param {string} name Role name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public deleteRole(name: string, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).deleteRole(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get account info
     * @summary get account info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public getAccountInfo(options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).getAccountInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all accounts
     * @summary List all accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public listAllAccounts(options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).listAllAccounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all policies
     * @summary List all policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public listAllPolicies(options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).listAllPolicies(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all roles
     * @summary List all roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public listAllRoles(options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).listAllRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch an account
     * @summary Patch an account
     * @param {string} username Username
     * @param {AcPatchAccountParam} account Account information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public patchAccount(username: string, account: AcPatchAccountParam, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).patchAccount(username, account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch an role
     * @summary Patch an role
     * @param {string} name Role name
     * @param {AcPatchRoleParam} role Role information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public patchRole(name: string, role: AcPatchRoleParam, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).patchRole(name, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset user\'s own password
     * @summary Reset user\'s own password
     * @param {ParamResetPasswordParam} resetParam reset password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public resetPassword(resetParam: ParamResetPasswordParam, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).resetPassword(resetParam, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AlarmApi - axios parameter creator
 * @export
 */
export const AlarmApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create or update alarm receiver.
         * @summary Create or update alarm receiver
         * @param {ReceiverReceiver} body receiver
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateReceiver: async (body: ReceiverReceiver, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrUpdateReceiver', 'body', body)
            const localVarPath = `/api/v1/alarm/receiver/receivers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update alarm route.
         * @summary Create or update alarm route
         * @param {RouteRouteParam} body route
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateRoute: async (body: RouteRouteParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrUpdateRoute', 'body', body)
            const localVarPath = `/api/v1/alarm/route/routes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update alarm rule.
         * @summary Create or update alarm rule
         * @param {RuleRule} body rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateRule: async (body: RuleRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrUpdateRule', 'body', body)
            const localVarPath = `/api/v1/alarm/rule/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update alarm silencer.
         * @summary Create or update alarm silencer
         * @param {SilenceSilencerParam} body silencer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateSilencer: async (body: SilenceSilencerParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrUpdateSilencer', 'body', body)
            const localVarPath = `/api/v1/alarm/silence/silencers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete alarm receiver by receiver name.
         * @summary Delete alarm receiver
         * @param {string} name receiver name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReceiver: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteReceiver', 'name', name)
            const localVarPath = `/api/v1/alarm/receiver/receivers/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete alarm channel by channel name.
         * @summary Delete alarm channel
         * @param {string} id route id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoute: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRoute', 'id', id)
            const localVarPath = `/api/v1/alarm/route/routes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete alarm rule by rule name.
         * @summary Delete alarm rule
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteRule', 'name', name)
            const localVarPath = `/api/v1/alarm/rule/rules/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete alarm silencer by silencer id.
         * @summary Delete alarm silencer
         * @param {string} id silencer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSilencer: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSilencer', 'id', id)
            const localVarPath = `/api/v1/alarm/silence/silencers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Diagnose alert, trigger a job to do data collection and analization on background.
         * @summary Diagnose alert
         * @param {AlertAnalyzeParam} body alert analyze param
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseAlert: async (body: AlertAnalyzeParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('diagnoseAlert', 'body', body)
            const localVarPath = `/api/v1/alarm/alert/diagnose`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get alarm receiver, query by receiver name.
         * @summary Get alarm receiver
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceiver: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getReceiver', 'name', name)
            const localVarPath = `/api/v1/alarm/receiver/receivers/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get alarm receiver template.
         * @summary Get alarm receiver template
         * @param {string} type receiver type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceiverTemplate: async (type: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getReceiverTemplate', 'type', type)
            const localVarPath = `/api/v1/alarm/receiver/templates/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get alarm route, query by route name.
         * @summary Get alarm route
         * @param {string} id route id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoute: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoute', 'id', id)
            const localVarPath = `/api/v1/alarm/route/routes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get alarm rule, query by rule name.
         * @summary Get alarm rule
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRule', 'name', name)
            const localVarPath = `/api/v1/alarm/rule/rules/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get alarm silencer, query by silencer id.
         * @summary Get alarm silencer
         * @param {string} id silencer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSilencer: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSilencer', 'id', id)
            const localVarPath = `/api/v1/alarm/silence/silencers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List alerts, filter with alarm objects, severity, time and keywords.
         * @summary List alerts
         * @param {AlertAlertFilter} [body] alert filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts: async (body?: AlertAlertFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alarm/alert/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List alarm receiver templates.
         * @summary List alarm receiver templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReceiverTemplates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alarm/receiver/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List alarm receivers, do not support filter, list all receivers at once.
         * @summary List alarm receivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReceivers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alarm/receiver/receivers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List alarm routes, do not support filter, list all routes at once.
         * @summary List alarm routes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoutes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alarm/route/routes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List alarm rules, filter with alarm objects type, severity and keywords.
         * @summary List alarm rules
         * @param {RuleRuleFilter} [body] rule filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRules: async (body?: RuleRuleFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alarm/rule/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List alarm silencers, filter with alarm objects and keywords.
         * @summary List alarm silencers
         * @param {SilenceSilencerFilter} [body] silencer filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSilencers: async (body?: SilenceSilencerFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/alarm/silence/silencers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlarmApi - functional programming interface
 * @export
 */
export const AlarmApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlarmApiAxiosParamCreator(configuration)
    return {
        /**
         * Create or update alarm receiver.
         * @summary Create or update alarm receiver
         * @param {ReceiverReceiver} body receiver
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateReceiver(body: ReceiverReceiver, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateReceiver200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateReceiver(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.createOrUpdateReceiver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update alarm route.
         * @summary Create or update alarm route
         * @param {RouteRouteParam} body route
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateRoute(body: RouteRouteParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateRoute200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateRoute(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.createOrUpdateRoute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update alarm rule.
         * @summary Create or update alarm rule
         * @param {RuleRule} body rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateRule(body: RuleRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateRule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateRule(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.createOrUpdateRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update alarm silencer.
         * @summary Create or update alarm silencer
         * @param {SilenceSilencerParam} body silencer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateSilencer(body: SilenceSilencerParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateSilencer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateSilencer(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.createOrUpdateSilencer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete alarm receiver by receiver name.
         * @summary Delete alarm receiver
         * @param {string} name receiver name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReceiver(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReceiver(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.deleteReceiver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete alarm channel by channel name.
         * @summary Delete alarm channel
         * @param {string} id route id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoute(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoute(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.deleteRoute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete alarm rule by rule name.
         * @summary Delete alarm rule
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRule(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRule(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.deleteRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete alarm silencer by silencer id.
         * @summary Delete alarm silencer
         * @param {string} id silencer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSilencer(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSilencer(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.deleteSilencer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Diagnose alert, trigger a job to do data collection and analization on background.
         * @summary Diagnose alert
         * @param {AlertAnalyzeParam} body alert analyze param
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diagnoseAlert(body: AlertAnalyzeParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiagnoseAlert200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diagnoseAlert(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.diagnoseAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get alarm receiver, query by receiver name.
         * @summary Get alarm receiver
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReceiver(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateReceiver200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReceiver(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.getReceiver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get alarm receiver template.
         * @summary Get alarm receiver template
         * @param {string} type receiver type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReceiverTemplate(type: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReceiverTemplate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReceiverTemplate(type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.getReceiverTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get alarm route, query by route name.
         * @summary Get alarm route
         * @param {string} id route id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoute(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateRoute200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoute(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.getRoute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get alarm rule, query by rule name.
         * @summary Get alarm rule
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRule(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateRule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRule(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.getRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get alarm silencer, query by silencer id.
         * @summary Get alarm silencer
         * @param {string} id silencer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSilencer(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateSilencer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSilencer(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.getSilencer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List alerts, filter with alarm objects, severity, time and keywords.
         * @summary List alerts
         * @param {AlertAlertFilter} [body] alert filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlerts(body?: AlertAlertFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAlerts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlerts(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.listAlerts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List alarm receiver templates.
         * @summary List alarm receiver templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReceiverTemplates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListReceiverTemplates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReceiverTemplates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.listReceiverTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List alarm receivers, do not support filter, list all receivers at once.
         * @summary List alarm receivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReceivers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListReceivers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReceivers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.listReceivers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List alarm routes, do not support filter, list all routes at once.
         * @summary List alarm routes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoutes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRoutes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoutes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.listRoutes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List alarm rules, filter with alarm objects type, severity and keywords.
         * @summary List alarm rules
         * @param {RuleRuleFilter} [body] rule filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRules(body?: RuleRuleFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRules(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.listRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List alarm silencers, filter with alarm objects and keywords.
         * @summary List alarm silencers
         * @param {SilenceSilencerFilter} [body] silencer filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSilencers(body?: SilenceSilencerFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSilencers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSilencers(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlarmApi.listSilencers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AlarmApi - factory interface
 * @export
 */
export const AlarmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlarmApiFp(configuration)
    return {
        /**
         * Create or update alarm receiver.
         * @summary Create or update alarm receiver
         * @param {ReceiverReceiver} body receiver
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateReceiver(body: ReceiverReceiver, options?: any): AxiosPromise<CreateOrUpdateReceiver200Response> {
            return localVarFp.createOrUpdateReceiver(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update alarm route.
         * @summary Create or update alarm route
         * @param {RouteRouteParam} body route
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateRoute(body: RouteRouteParam, options?: any): AxiosPromise<CreateOrUpdateRoute200Response> {
            return localVarFp.createOrUpdateRoute(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update alarm rule.
         * @summary Create or update alarm rule
         * @param {RuleRule} body rule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateRule(body: RuleRule, options?: any): AxiosPromise<CreateOrUpdateRule200Response> {
            return localVarFp.createOrUpdateRule(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update alarm silencer.
         * @summary Create or update alarm silencer
         * @param {SilenceSilencerParam} body silencer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateSilencer(body: SilenceSilencerParam, options?: any): AxiosPromise<CreateOrUpdateSilencer200Response> {
            return localVarFp.createOrUpdateSilencer(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete alarm receiver by receiver name.
         * @summary Delete alarm receiver
         * @param {string} name receiver name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReceiver(name: string, options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.deleteReceiver(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete alarm channel by channel name.
         * @summary Delete alarm channel
         * @param {string} id route id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoute(id: string, options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.deleteRoute(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete alarm rule by rule name.
         * @summary Delete alarm rule
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule(name: string, options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.deleteRule(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete alarm silencer by silencer id.
         * @summary Delete alarm silencer
         * @param {string} id silencer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSilencer(id: string, options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.deleteSilencer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Diagnose alert, trigger a job to do data collection and analization on background.
         * @summary Diagnose alert
         * @param {AlertAnalyzeParam} body alert analyze param
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diagnoseAlert(body: AlertAnalyzeParam, options?: any): AxiosPromise<DiagnoseAlert200Response> {
            return localVarFp.diagnoseAlert(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get alarm receiver, query by receiver name.
         * @summary Get alarm receiver
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceiver(name: string, options?: any): AxiosPromise<CreateOrUpdateReceiver200Response> {
            return localVarFp.getReceiver(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get alarm receiver template.
         * @summary Get alarm receiver template
         * @param {string} type receiver type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceiverTemplate(type: string, options?: any): AxiosPromise<GetReceiverTemplate200Response> {
            return localVarFp.getReceiverTemplate(type, options).then((request) => request(axios, basePath));
        },
        /**
         * Get alarm route, query by route name.
         * @summary Get alarm route
         * @param {string} id route id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoute(id: string, options?: any): AxiosPromise<CreateOrUpdateRoute200Response> {
            return localVarFp.getRoute(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get alarm rule, query by rule name.
         * @summary Get alarm rule
         * @param {string} name rule name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule(name: string, options?: any): AxiosPromise<CreateOrUpdateRule200Response> {
            return localVarFp.getRule(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get alarm silencer, query by silencer id.
         * @summary Get alarm silencer
         * @param {string} id silencer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSilencer(id: string, options?: any): AxiosPromise<CreateOrUpdateSilencer200Response> {
            return localVarFp.getSilencer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List alerts, filter with alarm objects, severity, time and keywords.
         * @summary List alerts
         * @param {AlertAlertFilter} [body] alert filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts(body?: AlertAlertFilter, options?: any): AxiosPromise<ListAlerts200Response> {
            return localVarFp.listAlerts(body, options).then((request) => request(axios, basePath));
        },
        /**
         * List alarm receiver templates.
         * @summary List alarm receiver templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReceiverTemplates(options?: any): AxiosPromise<ListReceiverTemplates200Response> {
            return localVarFp.listReceiverTemplates(options).then((request) => request(axios, basePath));
        },
        /**
         * List alarm receivers, do not support filter, list all receivers at once.
         * @summary List alarm receivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReceivers(options?: any): AxiosPromise<ListReceivers200Response> {
            return localVarFp.listReceivers(options).then((request) => request(axios, basePath));
        },
        /**
         * List alarm routes, do not support filter, list all routes at once.
         * @summary List alarm routes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoutes(options?: any): AxiosPromise<ListRoutes200Response> {
            return localVarFp.listRoutes(options).then((request) => request(axios, basePath));
        },
        /**
         * List alarm rules, filter with alarm objects type, severity and keywords.
         * @summary List alarm rules
         * @param {RuleRuleFilter} [body] rule filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRules(body?: RuleRuleFilter, options?: any): AxiosPromise<ListRules200Response> {
            return localVarFp.listRules(body, options).then((request) => request(axios, basePath));
        },
        /**
         * List alarm silencers, filter with alarm objects and keywords.
         * @summary List alarm silencers
         * @param {SilenceSilencerFilter} [body] silencer filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSilencers(body?: SilenceSilencerFilter, options?: any): AxiosPromise<ListSilencers200Response> {
            return localVarFp.listSilencers(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlarmApi - object-oriented interface
 * @export
 * @class AlarmApi
 * @extends {BaseAPI}
 */
export class AlarmApi extends BaseAPI {
    /**
     * Create or update alarm receiver.
     * @summary Create or update alarm receiver
     * @param {ReceiverReceiver} body receiver
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public createOrUpdateReceiver(body: ReceiverReceiver, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).createOrUpdateReceiver(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update alarm route.
     * @summary Create or update alarm route
     * @param {RouteRouteParam} body route
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public createOrUpdateRoute(body: RouteRouteParam, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).createOrUpdateRoute(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update alarm rule.
     * @summary Create or update alarm rule
     * @param {RuleRule} body rule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public createOrUpdateRule(body: RuleRule, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).createOrUpdateRule(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update alarm silencer.
     * @summary Create or update alarm silencer
     * @param {SilenceSilencerParam} body silencer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public createOrUpdateSilencer(body: SilenceSilencerParam, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).createOrUpdateSilencer(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete alarm receiver by receiver name.
     * @summary Delete alarm receiver
     * @param {string} name receiver name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public deleteReceiver(name: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).deleteReceiver(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete alarm channel by channel name.
     * @summary Delete alarm channel
     * @param {string} id route id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public deleteRoute(id: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).deleteRoute(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete alarm rule by rule name.
     * @summary Delete alarm rule
     * @param {string} name rule name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public deleteRule(name: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).deleteRule(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete alarm silencer by silencer id.
     * @summary Delete alarm silencer
     * @param {string} id silencer id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public deleteSilencer(id: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).deleteSilencer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Diagnose alert, trigger a job to do data collection and analization on background.
     * @summary Diagnose alert
     * @param {AlertAnalyzeParam} body alert analyze param
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public diagnoseAlert(body: AlertAnalyzeParam, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).diagnoseAlert(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get alarm receiver, query by receiver name.
     * @summary Get alarm receiver
     * @param {string} name rule name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public getReceiver(name: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).getReceiver(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get alarm receiver template.
     * @summary Get alarm receiver template
     * @param {string} type receiver type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public getReceiverTemplate(type: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).getReceiverTemplate(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get alarm route, query by route name.
     * @summary Get alarm route
     * @param {string} id route id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public getRoute(id: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).getRoute(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get alarm rule, query by rule name.
     * @summary Get alarm rule
     * @param {string} name rule name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public getRule(name: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).getRule(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get alarm silencer, query by silencer id.
     * @summary Get alarm silencer
     * @param {string} id silencer id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public getSilencer(id: string, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).getSilencer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List alerts, filter with alarm objects, severity, time and keywords.
     * @summary List alerts
     * @param {AlertAlertFilter} [body] alert filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public listAlerts(body?: AlertAlertFilter, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).listAlerts(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List alarm receiver templates.
     * @summary List alarm receiver templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public listReceiverTemplates(options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).listReceiverTemplates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List alarm receivers, do not support filter, list all receivers at once.
     * @summary List alarm receivers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public listReceivers(options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).listReceivers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List alarm routes, do not support filter, list all routes at once.
     * @summary List alarm routes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public listRoutes(options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).listRoutes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List alarm rules, filter with alarm objects type, severity and keywords.
     * @summary List alarm rules
     * @param {RuleRuleFilter} [body] rule filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public listRules(body?: RuleRuleFilter, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).listRules(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List alarm silencers, filter with alarm objects and keywords.
     * @summary List alarm silencers
     * @param {SilenceSilencerFilter} [body] silencer filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlarmApi
     */
    public listSilencers(body?: SilenceSilencerFilter, options?: RawAxiosRequestConfig) {
        return AlarmApiFp(this.configuration).listSilencers(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClusterApi - axios parameter creator
 * @export
 */
export const ClusterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create k8s namespace
         * @summary create k8s namespace
         * @param {ParamCreateNamespaceParam} body create obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createK8sNamespace: async (body: ParamCreateNamespaceParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createK8sNamespace', 'body', body)
            const localVarPath = `/api/v1/cluster/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list k8s events
         * @summary list k8s event
         * @param {ListK8sEventsObjectTypeEnum} [objectType] related object types
         * @param {ListK8sEventsTypeEnum} [type] event level
         * @param {string} [name] Object name
         * @param {string} [namespace] Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sEvents: async (objectType?: ListK8sEventsObjectTypeEnum, type?: ListK8sEventsTypeEnum, name?: string, namespace?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/cluster/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)

            if (objectType !== undefined) {
                localVarQueryParameter['objectType'] = objectType;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list k8s namespaces
         * @summary list k8s namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sNamespaces: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/cluster/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list k8s nodes
         * @summary list k8s nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sNodes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/cluster/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list k8s storage classes
         * @summary list k8s storage classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sStorageClasses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/cluster/storageClasses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterApi - functional programming interface
 * @export
 */
export const ClusterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClusterApiAxiosParamCreator(configuration)
    return {
        /**
         * create k8s namespace
         * @summary create k8s namespace
         * @param {ParamCreateNamespaceParam} body create obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createK8sNamespace(body: ParamCreateNamespaceParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createK8sNamespace(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterApi.createK8sNamespace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list k8s events
         * @summary list k8s event
         * @param {ListK8sEventsObjectTypeEnum} [objectType] related object types
         * @param {ListK8sEventsTypeEnum} [type] event level
         * @param {string} [name] Object name
         * @param {string} [namespace] Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listK8sEvents(objectType?: ListK8sEventsObjectTypeEnum, type?: ListK8sEventsTypeEnum, name?: string, namespace?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListK8sEvents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listK8sEvents(objectType, type, name, namespace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterApi.listK8sEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list k8s namespaces
         * @summary list k8s namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listK8sNamespaces(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListK8sNamespaces200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listK8sNamespaces(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterApi.listK8sNamespaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list k8s nodes
         * @summary list k8s nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listK8sNodes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListK8sNodes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listK8sNodes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterApi.listK8sNodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list k8s storage classes
         * @summary list k8s storage classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listK8sStorageClasses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListK8sStorageClasses200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listK8sStorageClasses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClusterApi.listK8sStorageClasses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClusterApi - factory interface
 * @export
 */
export const ClusterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClusterApiFp(configuration)
    return {
        /**
         * create k8s namespace
         * @summary create k8s namespace
         * @param {ParamCreateNamespaceParam} body create obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createK8sNamespace(body: ParamCreateNamespaceParam, options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.createK8sNamespace(body, options).then((request) => request(axios, basePath));
        },
        /**
         * list k8s events
         * @summary list k8s event
         * @param {ListK8sEventsObjectTypeEnum} [objectType] related object types
         * @param {ListK8sEventsTypeEnum} [type] event level
         * @param {string} [name] Object name
         * @param {string} [namespace] Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sEvents(objectType?: ListK8sEventsObjectTypeEnum, type?: ListK8sEventsTypeEnum, name?: string, namespace?: string, options?: any): AxiosPromise<ListK8sEvents200Response> {
            return localVarFp.listK8sEvents(objectType, type, name, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * list k8s namespaces
         * @summary list k8s namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sNamespaces(options?: any): AxiosPromise<ListK8sNamespaces200Response> {
            return localVarFp.listK8sNamespaces(options).then((request) => request(axios, basePath));
        },
        /**
         * list k8s nodes
         * @summary list k8s nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sNodes(options?: any): AxiosPromise<ListK8sNodes200Response> {
            return localVarFp.listK8sNodes(options).then((request) => request(axios, basePath));
        },
        /**
         * list k8s storage classes
         * @summary list k8s storage classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listK8sStorageClasses(options?: any): AxiosPromise<ListK8sStorageClasses200Response> {
            return localVarFp.listK8sStorageClasses(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClusterApi - object-oriented interface
 * @export
 * @class ClusterApi
 * @extends {BaseAPI}
 */
export class ClusterApi extends BaseAPI {
    /**
     * create k8s namespace
     * @summary create k8s namespace
     * @param {ParamCreateNamespaceParam} body create obcluster request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public createK8sNamespace(body: ParamCreateNamespaceParam, options?: RawAxiosRequestConfig) {
        return ClusterApiFp(this.configuration).createK8sNamespace(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list k8s events
     * @summary list k8s event
     * @param {ListK8sEventsObjectTypeEnum} [objectType] related object types
     * @param {ListK8sEventsTypeEnum} [type] event level
     * @param {string} [name] Object name
     * @param {string} [namespace] Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public listK8sEvents(objectType?: ListK8sEventsObjectTypeEnum, type?: ListK8sEventsTypeEnum, name?: string, namespace?: string, options?: RawAxiosRequestConfig) {
        return ClusterApiFp(this.configuration).listK8sEvents(objectType, type, name, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list k8s namespaces
     * @summary list k8s namespaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public listK8sNamespaces(options?: RawAxiosRequestConfig) {
        return ClusterApiFp(this.configuration).listK8sNamespaces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list k8s nodes
     * @summary list k8s nodes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public listK8sNodes(options?: RawAxiosRequestConfig) {
        return ClusterApiFp(this.configuration).listK8sNodes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list k8s storage classes
     * @summary list k8s storage classes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public listK8sStorageClasses(options?: RawAxiosRequestConfig) {
        return ClusterApiFp(this.configuration).listK8sStorageClasses(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListK8sEventsObjectTypeEnum = {
    OBCLUSTER: 'OBCLUSTER',
    OBTENANT: 'OBTENANT',
    OBBACKUPPOLICY: 'OBBACKUPPOLICY',
    OBPROXY: 'OBPROXY'
} as const;
export type ListK8sEventsObjectTypeEnum = typeof ListK8sEventsObjectTypeEnum[keyof typeof ListK8sEventsObjectTypeEnum];
/**
 * @export
 */
export const ListK8sEventsTypeEnum = {
    NORMAL: 'NORMAL',
    WARNING: 'WARNING'
} as const;
export type ListK8sEventsTypeEnum = typeof ListK8sEventsTypeEnum[keyof typeof ListK8sEventsTypeEnum];


/**
 * InfoApi - axios parameter creator
 * @export
 */
export const InfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set configurable infos
         * @summary Set configurable infos
         * @param {ParamConfigurableInfo} body metric query request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureInfo: async (body: ParamConfigurableInfo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('configureInfo', 'body', body)
            const localVarPath = `/api/v1/configurable-infos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get process info of OceanBase Dashboard, including process name etc.
         * @summary Get process info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get statistic data
         * @summary get statistic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatistics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 * @export
 */
export const InfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoApiAxiosParamCreator(configuration)
    return {
        /**
         * Set configurable infos
         * @summary Set configurable infos
         * @param {ParamConfigurableInfo} body metric query request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configureInfo(body: ParamConfigurableInfo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configureInfo(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.configureInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get process info of OceanBase Dashboard, including process name etc.
         * @summary Get process info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProcessInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.getProcessInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get statistic data
         * @summary get statistic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatistics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatistics200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatistics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.getStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfoApi - factory interface
 * @export
 */
export const InfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoApiFp(configuration)
    return {
        /**
         * Set configurable infos
         * @summary Set configurable infos
         * @param {ParamConfigurableInfo} body metric query request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureInfo(body: ParamConfigurableInfo, options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.configureInfo(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get process info of OceanBase Dashboard, including process name etc.
         * @summary Get process info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInfo(options?: any): AxiosPromise<GetProcessInfo200Response> {
            return localVarFp.getProcessInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * get statistic data
         * @summary get statistic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatistics(options?: any): AxiosPromise<GetStatistics200Response> {
            return localVarFp.getStatistics(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoApi - object-oriented interface
 * @export
 * @class InfoApi
 * @extends {BaseAPI}
 */
export class InfoApi extends BaseAPI {
    /**
     * Set configurable infos
     * @summary Set configurable infos
     * @param {ParamConfigurableInfo} body metric query request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public configureInfo(body: ParamConfigurableInfo, options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).configureInfo(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get process info of OceanBase Dashboard, including process name etc.
     * @summary Get process info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public getProcessInfo(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).getProcessInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get statistic data
     * @summary get statistic data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public getStatistics(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).getStatistics(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InspectionApi - axios parameter creator
 * @export
 */
export const InspectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create or update inspection policy
         * @summary create or update inspection policy
         * @param {InspectionPolicy} body inspection policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateInspectionPolicy: async (body: InspectionPolicy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrUpdateInspectionPolicy', 'body', body)
            const localVarPath = `/api/v1/inspection/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete inspection policy
         * @summary delete inspection policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInspectionPolicy: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/inspection/policies/{namespace}/{name}/{scenario}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get inspection policy
         * @summary get inspection policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInspectionPolicy: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/inspection/policies/{namespace}/{name}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get inspection report
         * @summary get inspection report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInspectionReport: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/inspection/reports/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list inspection policies
         * @summary list inspection policies
         * @param {string} [namespace] Namespace
         * @param {string} [name] Object name
         * @param {string} [obclusterName] obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInspectionPolicies: async (namespace?: string, name?: string, obclusterName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/inspection/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (obclusterName !== undefined) {
                localVarQueryParameter['obclusterName'] = obclusterName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list inspection reports
         * @summary list inspection reports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInspectionReports: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/inspection/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * trigger inspection
         * @summary trigger inspection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerInspection: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/inspection/policies/{namespace}/{name}/{scenario}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InspectionApi - functional programming interface
 * @export
 */
export const InspectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InspectionApiAxiosParamCreator(configuration)
    return {
        /**
         * create or update inspection policy
         * @summary create or update inspection policy
         * @param {InspectionPolicy} body inspection policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateInspectionPolicy(body: InspectionPolicy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateInspectionPolicy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateInspectionPolicy(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InspectionApi.createOrUpdateInspectionPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete inspection policy
         * @summary delete inspection policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInspectionPolicy(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteInspectionPolicy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInspectionPolicy(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InspectionApi.deleteInspectionPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get inspection policy
         * @summary get inspection policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInspectionPolicy(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateInspectionPolicy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInspectionPolicy(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InspectionApi.getInspectionPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get inspection report
         * @summary get inspection report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInspectionReport(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInspectionReport200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInspectionReport(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InspectionApi.getInspectionReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list inspection policies
         * @summary list inspection policies
         * @param {string} [namespace] Namespace
         * @param {string} [name] Object name
         * @param {string} [obclusterName] obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInspectionPolicies(namespace?: string, name?: string, obclusterName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListInspectionPolicies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInspectionPolicies(namespace, name, obclusterName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InspectionApi.listInspectionPolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list inspection reports
         * @summary list inspection reports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInspectionReports(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListInspectionReports200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInspectionReports(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InspectionApi.listInspectionReports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * trigger inspection
         * @summary trigger inspection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerInspection(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrUpdateInspectionPolicy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerInspection(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InspectionApi.triggerInspection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InspectionApi - factory interface
 * @export
 */
export const InspectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InspectionApiFp(configuration)
    return {
        /**
         * create or update inspection policy
         * @summary create or update inspection policy
         * @param {InspectionPolicy} body inspection policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateInspectionPolicy(body: InspectionPolicy, options?: any): AxiosPromise<CreateOrUpdateInspectionPolicy200Response> {
            return localVarFp.createOrUpdateInspectionPolicy(body, options).then((request) => request(axios, basePath));
        },
        /**
         * delete inspection policy
         * @summary delete inspection policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInspectionPolicy(options?: any): AxiosPromise<DeleteInspectionPolicy200Response> {
            return localVarFp.deleteInspectionPolicy(options).then((request) => request(axios, basePath));
        },
        /**
         * get inspection policy
         * @summary get inspection policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInspectionPolicy(options?: any): AxiosPromise<CreateOrUpdateInspectionPolicy200Response> {
            return localVarFp.getInspectionPolicy(options).then((request) => request(axios, basePath));
        },
        /**
         * get inspection report
         * @summary get inspection report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInspectionReport(options?: any): AxiosPromise<GetInspectionReport200Response> {
            return localVarFp.getInspectionReport(options).then((request) => request(axios, basePath));
        },
        /**
         * list inspection policies
         * @summary list inspection policies
         * @param {string} [namespace] Namespace
         * @param {string} [name] Object name
         * @param {string} [obclusterName] obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInspectionPolicies(namespace?: string, name?: string, obclusterName?: string, options?: any): AxiosPromise<ListInspectionPolicies200Response> {
            return localVarFp.listInspectionPolicies(namespace, name, obclusterName, options).then((request) => request(axios, basePath));
        },
        /**
         * list inspection reports
         * @summary list inspection reports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInspectionReports(options?: any): AxiosPromise<ListInspectionReports200Response> {
            return localVarFp.listInspectionReports(options).then((request) => request(axios, basePath));
        },
        /**
         * trigger inspection
         * @summary trigger inspection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerInspection(options?: any): AxiosPromise<CreateOrUpdateInspectionPolicy200Response> {
            return localVarFp.triggerInspection(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InspectionApi - object-oriented interface
 * @export
 * @class InspectionApi
 * @extends {BaseAPI}
 */
export class InspectionApi extends BaseAPI {
    /**
     * create or update inspection policy
     * @summary create or update inspection policy
     * @param {InspectionPolicy} body inspection policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectionApi
     */
    public createOrUpdateInspectionPolicy(body: InspectionPolicy, options?: RawAxiosRequestConfig) {
        return InspectionApiFp(this.configuration).createOrUpdateInspectionPolicy(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete inspection policy
     * @summary delete inspection policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectionApi
     */
    public deleteInspectionPolicy(options?: RawAxiosRequestConfig) {
        return InspectionApiFp(this.configuration).deleteInspectionPolicy(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get inspection policy
     * @summary get inspection policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectionApi
     */
    public getInspectionPolicy(options?: RawAxiosRequestConfig) {
        return InspectionApiFp(this.configuration).getInspectionPolicy(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get inspection report
     * @summary get inspection report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectionApi
     */
    public getInspectionReport(options?: RawAxiosRequestConfig) {
        return InspectionApiFp(this.configuration).getInspectionReport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list inspection policies
     * @summary list inspection policies
     * @param {string} [namespace] Namespace
     * @param {string} [name] Object name
     * @param {string} [obclusterName] obcluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectionApi
     */
    public listInspectionPolicies(namespace?: string, name?: string, obclusterName?: string, options?: RawAxiosRequestConfig) {
        return InspectionApiFp(this.configuration).listInspectionPolicies(namespace, name, obclusterName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list inspection reports
     * @summary list inspection reports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectionApi
     */
    public listInspectionReports(options?: RawAxiosRequestConfig) {
        return InspectionApiFp(this.configuration).listInspectionReports(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * trigger inspection
     * @summary trigger inspection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectionApi
     */
    public triggerInspection(options?: RawAxiosRequestConfig) {
        return InspectionApiFp(this.configuration).triggerInspection(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobApi - axios parameter creator
 * @export
 */
export const JobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a job by id
         * @summary Delete a job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/jobs/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get job by id
         * @summary Get job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/jobs/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobApi - functional programming interface
 * @export
 */
export const JobApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a job by id
         * @summary Delete a job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJob(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteInspectionPolicy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJob(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.deleteJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get job by id
         * @summary Get job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJob(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiagnoseAlert200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJob(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.getJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobApi - factory interface
 * @export
 */
export const JobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobApiFp(configuration)
    return {
        /**
         * Delete a job by id
         * @summary Delete a job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob(options?: any): AxiosPromise<DeleteInspectionPolicy200Response> {
            return localVarFp.deleteJob(options).then((request) => request(axios, basePath));
        },
        /**
         * Get job by id
         * @summary Get job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(options?: any): AxiosPromise<DiagnoseAlert200Response> {
            return localVarFp.getJob(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobApi - object-oriented interface
 * @export
 * @class JobApi
 * @extends {BaseAPI}
 */
export class JobApi extends BaseAPI {
    /**
     * Delete a job by id
     * @summary Delete a job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public deleteJob(options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).deleteJob(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get job by id
     * @summary Get job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public getJob(options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).getJob(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetricApi - axios parameter creator
 * @export
 */
export const MetricApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * list all metrics meta info, return by groups
         * @summary list all metrics
         * @param {ListAllMetricsScopeEnum} scope metrics scope
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllMetrics: async (scope: ListAllMetricsScopeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('listAllMetrics', 'scope', scope)
            const localVarPath = `/api/v1/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * query metric data
         * @summary query metrics
         * @param {ParamMetricQuery} body metric query request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryMetrics: async (body: ParamMetricQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('queryMetrics', 'body', body)
            const localVarPath = `/api/v1/metrics/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricApi - functional programming interface
 * @export
 */
export const MetricApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricApiAxiosParamCreator(configuration)
    return {
        /**
         * list all metrics meta info, return by groups
         * @summary list all metrics
         * @param {ListAllMetricsScopeEnum} scope metrics scope
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllMetrics(scope: ListAllMetricsScopeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllMetrics200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllMetrics(scope, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricApi.listAllMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * query metric data
         * @summary query metrics
         * @param {ParamMetricQuery} body metric query request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryMetrics(body: ParamMetricQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryMetrics200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryMetrics(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricApi.queryMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetricApi - factory interface
 * @export
 */
export const MetricApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricApiFp(configuration)
    return {
        /**
         * list all metrics meta info, return by groups
         * @summary list all metrics
         * @param {ListAllMetricsScopeEnum} scope metrics scope
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllMetrics(scope: ListAllMetricsScopeEnum, options?: any): AxiosPromise<ListAllMetrics200Response> {
            return localVarFp.listAllMetrics(scope, options).then((request) => request(axios, basePath));
        },
        /**
         * query metric data
         * @summary query metrics
         * @param {ParamMetricQuery} body metric query request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryMetrics(body: ParamMetricQuery, options?: any): AxiosPromise<QueryMetrics200Response> {
            return localVarFp.queryMetrics(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricApi - object-oriented interface
 * @export
 * @class MetricApi
 * @extends {BaseAPI}
 */
export class MetricApi extends BaseAPI {
    /**
     * list all metrics meta info, return by groups
     * @summary list all metrics
     * @param {ListAllMetricsScopeEnum} scope metrics scope
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricApi
     */
    public listAllMetrics(scope: ListAllMetricsScopeEnum, options?: RawAxiosRequestConfig) {
        return MetricApiFp(this.configuration).listAllMetrics(scope, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * query metric data
     * @summary query metrics
     * @param {ParamMetricQuery} body metric query request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricApi
     */
    public queryMetrics(body: ParamMetricQuery, options?: RawAxiosRequestConfig) {
        return MetricApiFp(this.configuration).queryMetrics(body, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListAllMetricsScopeEnum = {
    OBCLUSTER: 'OBCLUSTER',
    OBTENANT: 'OBTENANT'
} as const;
export type ListAllMetricsScopeEnum = typeof ListAllMetricsScopeEnum[keyof typeof ListAllMetricsScopeEnum];


/**
 * OBClusterApi - axios parameter creator
 * @export
 */
export const OBClusterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * add obzone
         * @summary add obzone
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamZoneTopology} body add obzone request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOBZone: async (namespace: string, name: string, body: ParamZoneTopology, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('addOBZone', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addOBZone', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addOBZone', 'body', body)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}/obzones`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create obcluster
         * @summary create obcluster
         * @param {ParamCreateOBClusterParam} body create obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBCluster: async (body: ParamCreateOBClusterParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOBCluster', 'body', body)
            const localVarPath = `/api/v1/obclusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete obcluster
         * @summary delete obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBCluster: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteOBCluster', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteOBCluster', 'name', name)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete specified observers from the obcluster
         * @summary delete observers
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamDeleteOBServersParam} body delete observers request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBServers: async (namespace: string, name: string, body: ParamDeleteOBServersParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteOBServers', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteOBServers', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('deleteOBServers', 'body', body)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}/observers`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete obzone
         * @summary delete obzone
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {string} obzoneName obzone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBZone: async (namespace: string, name: string, obzoneName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteOBZone', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteOBZone', 'name', name)
            // verify required parameter 'obzoneName' is not null or undefined
            assertParamExists('deleteOBZone', 'obzoneName', obzoneName)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}/obzones/{obzoneName}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"obzoneName"}}`, encodeURIComponent(String(obzoneName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get obcluster detailed info
         * @summary get obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOBCluster: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getOBCluster', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getOBCluster', 'name', name)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get obcluster statistic info
         * @summary get obcluster statistic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOBClusterStatistic: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/obclusters/statistic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List OBCluster Parameters by namespace and name
         * @summary List OBCluster Parameters
         * @param {string} namespace namespace of obcluster resource
         * @param {string} name name of obcluster resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBClusterParameters: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listOBClusterParameters', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listOBClusterParameters', 'name', name)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}/parameters`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list related events of specific obcluster, including obzone and observer.
         * @summary list related events
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBClusterRelatedEvents: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listOBClusterRelatedEvents', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listOBClusterRelatedEvents', 'name', name)
            const localVarPath = `/api/v1/obclusters/{namespace}/{name}/related-events`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list resource usages of specific obcluster, such as cpu, memory, storage, etc. The old router ending with /essential-parameters is deprecated
         * @summary list resource usages, the old router ending with /essential-parameters is deprecated
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBClusterResources: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listOBClusterResources', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listOBClusterResources', 'name', name)
            const localVarPath = `/api/v1/obclusters/{namespace}/{name}/resource-usages`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list obclusters
         * @summary list obclusters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBClusters: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/obclusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch obcluster configuration including resources, storage, monitor and parameters
         * @summary patch obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamPatchOBClusterParam} body patch obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOBCluster: async (namespace: string, name: string, body: ParamPatchOBClusterParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('patchOBCluster', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('patchOBCluster', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchOBCluster', 'body', body)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * restart specified observers in the obcluster
         * @summary restart observers
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamRestartOBServersParam} body restart observers request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartOBServers: async (namespace: string, name: string, body: ParamRestartOBServersParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('restartOBServers', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('restartOBServers', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('restartOBServers', 'body', body)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}/restart`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * scale observer
         * @summary scale observer
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {string} obzoneName obzone name
         * @param {ParamScaleOBServerParam} body scale observer request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scaleOBServer: async (namespace: string, name: string, obzoneName: string, body: ParamScaleOBServerParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('scaleOBServer', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('scaleOBServer', 'name', name)
            // verify required parameter 'obzoneName' is not null or undefined
            assertParamExists('scaleOBServer', 'obzoneName', obzoneName)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('scaleOBServer', 'body', body)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}/obzones/{obzoneName}/scale`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"obzoneName"}}`, encodeURIComponent(String(obzoneName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * upgrade obcluster
         * @summary upgrade obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamUpgradeOBClusterParam} body upgrade obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeOBCluster: async (namespace: string, name: string, body: ParamUpgradeOBClusterParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('upgradeOBCluster', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('upgradeOBCluster', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('upgradeOBCluster', 'body', body)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OBClusterApi - functional programming interface
 * @export
 */
export const OBClusterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OBClusterApiAxiosParamCreator(configuration)
    return {
        /**
         * add obzone
         * @summary add obzone
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamZoneTopology} body add obzone request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOBZone(namespace: string, name: string, body: ParamZoneTopology, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBCluster200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOBZone(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.addOBZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create obcluster
         * @summary create obcluster
         * @param {ParamCreateOBClusterParam} body create obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOBCluster(body: ParamCreateOBClusterParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBCluster200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOBCluster(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.createOBCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete obcluster
         * @summary delete obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOBCluster(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteInspectionPolicy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOBCluster(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.deleteOBCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete specified observers from the obcluster
         * @summary delete observers
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamDeleteOBServersParam} body delete observers request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOBServers(namespace: string, name: string, body: ParamDeleteOBServersParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBCluster200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOBServers(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.deleteOBServers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete obzone
         * @summary delete obzone
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {string} obzoneName obzone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOBZone(namespace: string, name: string, obzoneName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBCluster200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOBZone(namespace, name, obzoneName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.deleteOBZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get obcluster detailed info
         * @summary get obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOBCluster(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBCluster200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOBCluster(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.getOBCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get obcluster statistic info
         * @summary get obcluster statistic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOBClusterStatistic(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOBClusterStatistic200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOBClusterStatistic(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.getOBClusterStatistic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List OBCluster Parameters by namespace and name
         * @summary List OBCluster Parameters
         * @param {string} namespace namespace of obcluster resource
         * @param {string} name name of obcluster resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOBClusterParameters(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOBClusterParameters200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOBClusterParameters(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.listOBClusterParameters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list related events of specific obcluster, including obzone and observer.
         * @summary list related events
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOBClusterRelatedEvents(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListK8sEvents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOBClusterRelatedEvents(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.listOBClusterRelatedEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list resource usages of specific obcluster, such as cpu, memory, storage, etc. The old router ending with /essential-parameters is deprecated
         * @summary list resource usages, the old router ending with /essential-parameters is deprecated
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOBClusterResources(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOBClusterResources200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOBClusterResources(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.listOBClusterResources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list obclusters
         * @summary list obclusters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOBClusters(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOBClusters200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOBClusters(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.listOBClusters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * patch obcluster configuration including resources, storage, monitor and parameters
         * @summary patch obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamPatchOBClusterParam} body patch obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOBCluster(namespace: string, name: string, body: ParamPatchOBClusterParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBCluster200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOBCluster(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.patchOBCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * restart specified observers in the obcluster
         * @summary restart observers
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamRestartOBServersParam} body restart observers request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartOBServers(namespace: string, name: string, body: ParamRestartOBServersParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBCluster200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartOBServers(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.restartOBServers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * scale observer
         * @summary scale observer
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {string} obzoneName obzone name
         * @param {ParamScaleOBServerParam} body scale observer request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scaleOBServer(namespace: string, name: string, obzoneName: string, body: ParamScaleOBServerParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBCluster200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scaleOBServer(namespace, name, obzoneName, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.scaleOBServer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * upgrade obcluster
         * @summary upgrade obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamUpgradeOBClusterParam} body upgrade obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upgradeOBCluster(namespace: string, name: string, body: ParamUpgradeOBClusterParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBCluster200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upgradeOBCluster(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBClusterApi.upgradeOBCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OBClusterApi - factory interface
 * @export
 */
export const OBClusterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OBClusterApiFp(configuration)
    return {
        /**
         * add obzone
         * @summary add obzone
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamZoneTopology} body add obzone request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOBZone(namespace: string, name: string, body: ParamZoneTopology, options?: any): AxiosPromise<CreateOBCluster200Response> {
            return localVarFp.addOBZone(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * create obcluster
         * @summary create obcluster
         * @param {ParamCreateOBClusterParam} body create obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBCluster(body: ParamCreateOBClusterParam, options?: any): AxiosPromise<CreateOBCluster200Response> {
            return localVarFp.createOBCluster(body, options).then((request) => request(axios, basePath));
        },
        /**
         * delete obcluster
         * @summary delete obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBCluster(namespace: string, name: string, options?: any): AxiosPromise<DeleteInspectionPolicy200Response> {
            return localVarFp.deleteOBCluster(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * delete specified observers from the obcluster
         * @summary delete observers
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamDeleteOBServersParam} body delete observers request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBServers(namespace: string, name: string, body: ParamDeleteOBServersParam, options?: any): AxiosPromise<CreateOBCluster200Response> {
            return localVarFp.deleteOBServers(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * delete obzone
         * @summary delete obzone
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {string} obzoneName obzone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBZone(namespace: string, name: string, obzoneName: string, options?: any): AxiosPromise<CreateOBCluster200Response> {
            return localVarFp.deleteOBZone(namespace, name, obzoneName, options).then((request) => request(axios, basePath));
        },
        /**
         * get obcluster detailed info
         * @summary get obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOBCluster(namespace: string, name: string, options?: any): AxiosPromise<CreateOBCluster200Response> {
            return localVarFp.getOBCluster(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * get obcluster statistic info
         * @summary get obcluster statistic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOBClusterStatistic(options?: any): AxiosPromise<GetOBClusterStatistic200Response> {
            return localVarFp.getOBClusterStatistic(options).then((request) => request(axios, basePath));
        },
        /**
         * List OBCluster Parameters by namespace and name
         * @summary List OBCluster Parameters
         * @param {string} namespace namespace of obcluster resource
         * @param {string} name name of obcluster resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBClusterParameters(namespace: string, name: string, options?: any): AxiosPromise<ListOBClusterParameters200Response> {
            return localVarFp.listOBClusterParameters(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * list related events of specific obcluster, including obzone and observer.
         * @summary list related events
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBClusterRelatedEvents(namespace: string, name: string, options?: any): AxiosPromise<ListK8sEvents200Response> {
            return localVarFp.listOBClusterRelatedEvents(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * list resource usages of specific obcluster, such as cpu, memory, storage, etc. The old router ending with /essential-parameters is deprecated
         * @summary list resource usages, the old router ending with /essential-parameters is deprecated
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBClusterResources(namespace: string, name: string, options?: any): AxiosPromise<ListOBClusterResources200Response> {
            return localVarFp.listOBClusterResources(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * list obclusters
         * @summary list obclusters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBClusters(options?: any): AxiosPromise<ListOBClusters200Response> {
            return localVarFp.listOBClusters(options).then((request) => request(axios, basePath));
        },
        /**
         * patch obcluster configuration including resources, storage, monitor and parameters
         * @summary patch obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamPatchOBClusterParam} body patch obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOBCluster(namespace: string, name: string, body: ParamPatchOBClusterParam, options?: any): AxiosPromise<CreateOBCluster200Response> {
            return localVarFp.patchOBCluster(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * restart specified observers in the obcluster
         * @summary restart observers
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamRestartOBServersParam} body restart observers request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartOBServers(namespace: string, name: string, body: ParamRestartOBServersParam, options?: any): AxiosPromise<CreateOBCluster200Response> {
            return localVarFp.restartOBServers(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * scale observer
         * @summary scale observer
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {string} obzoneName obzone name
         * @param {ParamScaleOBServerParam} body scale observer request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scaleOBServer(namespace: string, name: string, obzoneName: string, body: ParamScaleOBServerParam, options?: any): AxiosPromise<CreateOBCluster200Response> {
            return localVarFp.scaleOBServer(namespace, name, obzoneName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * upgrade obcluster
         * @summary upgrade obcluster
         * @param {string} namespace obcluster namespace
         * @param {string} name obcluster name
         * @param {ParamUpgradeOBClusterParam} body upgrade obcluster request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeOBCluster(namespace: string, name: string, body: ParamUpgradeOBClusterParam, options?: any): AxiosPromise<CreateOBCluster200Response> {
            return localVarFp.upgradeOBCluster(namespace, name, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OBClusterApi - object-oriented interface
 * @export
 * @class OBClusterApi
 * @extends {BaseAPI}
 */
export class OBClusterApi extends BaseAPI {
    /**
     * add obzone
     * @summary add obzone
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {ParamZoneTopology} body add obzone request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public addOBZone(namespace: string, name: string, body: ParamZoneTopology, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).addOBZone(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create obcluster
     * @summary create obcluster
     * @param {ParamCreateOBClusterParam} body create obcluster request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public createOBCluster(body: ParamCreateOBClusterParam, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).createOBCluster(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete obcluster
     * @summary delete obcluster
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public deleteOBCluster(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).deleteOBCluster(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete specified observers from the obcluster
     * @summary delete observers
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {ParamDeleteOBServersParam} body delete observers request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public deleteOBServers(namespace: string, name: string, body: ParamDeleteOBServersParam, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).deleteOBServers(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete obzone
     * @summary delete obzone
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {string} obzoneName obzone name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public deleteOBZone(namespace: string, name: string, obzoneName: string, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).deleteOBZone(namespace, name, obzoneName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get obcluster detailed info
     * @summary get obcluster
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public getOBCluster(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).getOBCluster(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get obcluster statistic info
     * @summary get obcluster statistic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public getOBClusterStatistic(options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).getOBClusterStatistic(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List OBCluster Parameters by namespace and name
     * @summary List OBCluster Parameters
     * @param {string} namespace namespace of obcluster resource
     * @param {string} name name of obcluster resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public listOBClusterParameters(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).listOBClusterParameters(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list related events of specific obcluster, including obzone and observer.
     * @summary list related events
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public listOBClusterRelatedEvents(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).listOBClusterRelatedEvents(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list resource usages of specific obcluster, such as cpu, memory, storage, etc. The old router ending with /essential-parameters is deprecated
     * @summary list resource usages, the old router ending with /essential-parameters is deprecated
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public listOBClusterResources(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).listOBClusterResources(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list obclusters
     * @summary list obclusters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public listOBClusters(options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).listOBClusters(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch obcluster configuration including resources, storage, monitor and parameters
     * @summary patch obcluster
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {ParamPatchOBClusterParam} body patch obcluster request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public patchOBCluster(namespace: string, name: string, body: ParamPatchOBClusterParam, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).patchOBCluster(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * restart specified observers in the obcluster
     * @summary restart observers
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {ParamRestartOBServersParam} body restart observers request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public restartOBServers(namespace: string, name: string, body: ParamRestartOBServersParam, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).restartOBServers(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * scale observer
     * @summary scale observer
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {string} obzoneName obzone name
     * @param {ParamScaleOBServerParam} body scale observer request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public scaleOBServer(namespace: string, name: string, obzoneName: string, body: ParamScaleOBServerParam, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).scaleOBServer(namespace, name, obzoneName, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * upgrade obcluster
     * @summary upgrade obcluster
     * @param {string} namespace obcluster namespace
     * @param {string} name obcluster name
     * @param {ParamUpgradeOBClusterParam} body upgrade obcluster request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBClusterApi
     */
    public upgradeOBCluster(namespace: string, name: string, body: ParamUpgradeOBClusterParam, options?: RawAxiosRequestConfig) {
        return OBClusterApiFp(this.configuration).upgradeOBCluster(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OBProxyApi - axios parameter creator
 * @export
 */
export const OBProxyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create OBProxy with the specified parameters
         * @summary Create OBProxy
         * @param {ObproxyCreateOBProxyParam} body Request body for creating obproxy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBPROXY: async (body: ObproxyCreateOBProxyParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOBPROXY', 'body', body)
            const localVarPath = `/api/v1/obproxies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete OBProxy by namespace and name
         * @summary Delete OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBProxy: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteOBProxy', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteOBProxy', 'name', name)
            const localVarPath = `/api/v1/obproxies/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get OBProxy by namespace and name
         * @summary Get OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOBProxy: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getOBProxy', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getOBProxy', 'name', name)
            const localVarPath = `/api/v1/obproxies/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list obproxies
         * @summary list obproxies
         * @param {string} [ns] ns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBProxies: async (ns?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/obproxies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)

            if (ns !== undefined) {
                localVarQueryParameter['ns'] = ns;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List OBProxy Parameters by namespace and name
         * @summary List OBProxy Parameters
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBProxyParameters: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listOBProxyParameters', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listOBProxyParameters', 'name', name)
            const localVarPath = `/api/v1/obproxies/{namespace}/{name}/parameters`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch OBProxy with the specified parameters
         * @summary Patch OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {ObproxyPatchOBProxyParam} body Request body for patching obproxy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOBProxy: async (namespace: string, name: string, body: ObproxyPatchOBProxyParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('patchOBProxy', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('patchOBProxy', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchOBProxy', 'body', body)
            const localVarPath = `/api/v1/obproxies/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OBProxyApi - functional programming interface
 * @export
 */
export const OBProxyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OBProxyApiAxiosParamCreator(configuration)
    return {
        /**
         * Create OBProxy with the specified parameters
         * @summary Create OBProxy
         * @param {ObproxyCreateOBProxyParam} body Request body for creating obproxy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOBPROXY(body: ObproxyCreateOBProxyParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBPROXY200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOBPROXY(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBProxyApi.createOBPROXY']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete OBProxy by namespace and name
         * @summary Delete OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOBProxy(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBPROXY200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOBProxy(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBProxyApi.deleteOBProxy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get OBProxy by namespace and name
         * @summary Get OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOBProxy(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBPROXY200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOBProxy(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBProxyApi.getOBProxy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list obproxies
         * @summary list obproxies
         * @param {string} [ns] ns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOBProxies(ns?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOBProxies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOBProxies(ns, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBProxyApi.listOBProxies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List OBProxy Parameters by namespace and name
         * @summary List OBProxy Parameters
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOBProxyParameters(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOBProxyParameters200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOBProxyParameters(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBProxyApi.listOBProxyParameters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Patch OBProxy with the specified parameters
         * @summary Patch OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {ObproxyPatchOBProxyParam} body Request body for patching obproxy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOBProxy(namespace: string, name: string, body: ObproxyPatchOBProxyParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOBPROXY200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOBProxy(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBProxyApi.patchOBProxy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OBProxyApi - factory interface
 * @export
 */
export const OBProxyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OBProxyApiFp(configuration)
    return {
        /**
         * Create OBProxy with the specified parameters
         * @summary Create OBProxy
         * @param {ObproxyCreateOBProxyParam} body Request body for creating obproxy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBPROXY(body: ObproxyCreateOBProxyParam, options?: any): AxiosPromise<CreateOBPROXY200Response> {
            return localVarFp.createOBPROXY(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete OBProxy by namespace and name
         * @summary Delete OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBProxy(namespace: string, name: string, options?: any): AxiosPromise<CreateOBPROXY200Response> {
            return localVarFp.deleteOBProxy(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get OBProxy by namespace and name
         * @summary Get OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOBProxy(namespace: string, name: string, options?: any): AxiosPromise<CreateOBPROXY200Response> {
            return localVarFp.getOBProxy(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * list obproxies
         * @summary list obproxies
         * @param {string} [ns] ns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBProxies(ns?: string, options?: any): AxiosPromise<ListOBProxies200Response> {
            return localVarFp.listOBProxies(ns, options).then((request) => request(axios, basePath));
        },
        /**
         * List OBProxy Parameters by namespace and name
         * @summary List OBProxy Parameters
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBProxyParameters(namespace: string, name: string, options?: any): AxiosPromise<ListOBProxyParameters200Response> {
            return localVarFp.listOBProxyParameters(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch OBProxy with the specified parameters
         * @summary Patch OBProxy
         * @param {string} namespace namespace of obproxy deployment
         * @param {string} name name of obproxy deployment
         * @param {ObproxyPatchOBProxyParam} body Request body for patching obproxy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOBProxy(namespace: string, name: string, body: ObproxyPatchOBProxyParam, options?: any): AxiosPromise<CreateOBPROXY200Response> {
            return localVarFp.patchOBProxy(namespace, name, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OBProxyApi - object-oriented interface
 * @export
 * @class OBProxyApi
 * @extends {BaseAPI}
 */
export class OBProxyApi extends BaseAPI {
    /**
     * Create OBProxy with the specified parameters
     * @summary Create OBProxy
     * @param {ObproxyCreateOBProxyParam} body Request body for creating obproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBProxyApi
     */
    public createOBPROXY(body: ObproxyCreateOBProxyParam, options?: RawAxiosRequestConfig) {
        return OBProxyApiFp(this.configuration).createOBPROXY(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete OBProxy by namespace and name
     * @summary Delete OBProxy
     * @param {string} namespace namespace of obproxy deployment
     * @param {string} name name of obproxy deployment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBProxyApi
     */
    public deleteOBProxy(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBProxyApiFp(this.configuration).deleteOBProxy(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get OBProxy by namespace and name
     * @summary Get OBProxy
     * @param {string} namespace namespace of obproxy deployment
     * @param {string} name name of obproxy deployment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBProxyApi
     */
    public getOBProxy(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBProxyApiFp(this.configuration).getOBProxy(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list obproxies
     * @summary list obproxies
     * @param {string} [ns] ns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBProxyApi
     */
    public listOBProxies(ns?: string, options?: RawAxiosRequestConfig) {
        return OBProxyApiFp(this.configuration).listOBProxies(ns, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List OBProxy Parameters by namespace and name
     * @summary List OBProxy Parameters
     * @param {string} namespace namespace of obproxy deployment
     * @param {string} name name of obproxy deployment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBProxyApi
     */
    public listOBProxyParameters(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBProxyApiFp(this.configuration).listOBProxyParameters(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch OBProxy with the specified parameters
     * @summary Patch OBProxy
     * @param {string} namespace namespace of obproxy deployment
     * @param {string} name name of obproxy deployment
     * @param {ObproxyPatchOBProxyParam} body Request body for patching obproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBProxyApi
     */
    public patchOBProxy(namespace: string, name: string, body: ObproxyPatchOBProxyParam, options?: RawAxiosRequestConfig) {
        return OBProxyApiFp(this.configuration).patchOBProxy(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OBTenantApi - axios parameter creator
 * @export
 */
export const OBTenantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change tenant role of specific tenant, if a tenant is a standby tenant, it can be changed to primary tenant, vice versa
         * @summary Change tenant role of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamChangeTenantRole} body target role to change to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeTenantRole: async (namespace: string, name: string, body: ParamChangeTenantRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('changeTenantRole', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('changeTenantRole', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('changeTenantRole', 'body', body)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/role`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change root password of specific tenant, encrypted by AES
         * @summary Change root password of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamChangeUserPassword} body new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPassword: async (namespace: string, name: string, body: ParamChangeUserPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('changeUserPassword', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('changeUserPassword', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('changeUserPassword', 'body', body)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/userCredentials`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create backup policy of specific tenant, passwords should be encrypted by AES
         * @summary Create backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamCreateBackupPolicy} body create backup policy request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBackupPolicy: async (namespace: string, name: string, body: ParamCreateBackupPolicy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('createBackupPolicy', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createBackupPolicy', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createBackupPolicy', 'body', body)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/backupPolicy`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an obtenant pool in a specific namespace
         * @summary Create obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {ParamTenantPoolSpec} body create obtenant pool request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBTenantPool: async (namespace: string, name: string, zoneName: string, body: ParamTenantPoolSpec, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('createOBTenantPool', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createOBTenantPool', 'name', name)
            // verify required parameter 'zoneName' is not null or undefined
            assertParamExists('createOBTenantPool', 'zoneName', zoneName)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOBTenantPool', 'body', body)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/pools/{zoneName}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"zoneName"}}`, encodeURIComponent(String(zoneName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an obtenant in a specific namespace, passwords should be encrypted by AES
         * @summary Create tenant
         * @param {ParamCreateOBTenantParam} body create obtenant request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant: async (body: ParamCreateOBTenantParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createTenant', 'body', body)
            const localVarPath = `/api/v1/obtenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete backup policy of specific tenant
         * @summary Delete backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} [force] force delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackupPolicy: async (namespace: string, name: string, force?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteBackupPolicy', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteBackupPolicy', 'name', name)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/backupPolicy`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an obtenant pool in a specific namespace
         * @summary Delete obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBTenantPool: async (namespace: string, name: string, zoneName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteOBTenantPool', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteOBTenantPool', 'name', name)
            // verify required parameter 'zoneName' is not null or undefined
            assertParamExists('deleteOBTenantPool', 'zoneName', zoneName)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/pools/{zoneName}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"zoneName"}}`, encodeURIComponent(String(zoneName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an obtenant in a specific namespace, ask user to confrim the deletion carefully
         * @summary Delete tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenant: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteTenant', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteTenant', 'name', name)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get backup policy of specific tenant
         * @summary Get backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupPolicy: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getBackupPolicy', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getBackupPolicy', 'name', name)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/backupPolicy`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List statistics information of tenants
         * @summary List statistics information of tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOBTenantStatistic: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/obtenants/statistic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an obtenant in a specific namespace
         * @summary Get tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenant: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getTenant', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getTenant', 'name', name)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all tenants and return them
         * @summary List all tenants
         * @param {string} [obcluster] obcluster to filter
         * @param {string} [ns] namespace to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTenants: async (obcluster?: string, ns?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/obtenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)

            if (obcluster !== undefined) {
                localVarQueryParameter['obcluster'] = obcluster;
            }

            if (ns !== undefined) {
                localVarQueryParameter['ns'] = ns;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List backup jobs of specific tenant
         * @summary List backup jobs of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ListBackupJobsTypeEnum} type backup job type
         * @param {number} [limit] limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBackupJobs: async (namespace: string, name: string, type: ListBackupJobsTypeEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listBackupJobs', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listBackupJobs', 'name', name)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('listBackupJobs', 'type', type)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/backup/{type}/jobs`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the databases under obtenant
         * @summary List obtenant databases
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBTenantDatabases: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listOBTenantDatabases', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listOBTenantDatabases', 'name', name)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/databases`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List related events of specific tenant, including restore, backup and backup policy events
         * @summary List related events of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBTenantRelatedEvents: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listOBTenantRelatedEvents', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listOBTenantRelatedEvents', 'name', name)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/related-events`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the users under obtenant
         * @summary List obtenant users
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBTenantUsers: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listOBTenantUsers', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listOBTenantUsers', 'name', name)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/users`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch an obtenant pool in a specific namespace
         * @summary Patch obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {ParamTenantPoolSpec} body patch obtenant pool request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOBTenantPool: async (namespace: string, name: string, zoneName: string, body: ParamTenantPoolSpec, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('patchOBTenantPool', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('patchOBTenantPool', 'name', name)
            // verify required parameter 'zoneName' is not null or undefined
            assertParamExists('patchOBTenantPool', 'zoneName', zoneName)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchOBTenantPool', 'body', body)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/pools/{zoneName}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"zoneName"}}`, encodeURIComponent(String(zoneName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch tenant\'s configuration
         * @summary Patch tenant\'s configuration
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamPatchTenant} body patch tenant body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTenant: async (namespace: string, name: string, body: ParamPatchTenant, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('patchTenant', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('patchTenant', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchTenant', 'body', body)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replay standby log of specific standby tenant
         * @summary Replay standby log of specific standby tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamReplayStandbyLog} body target timestamp to replay to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replayStandbyLog: async (namespace: string, name: string, body: ParamReplayStandbyLog, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('replayStandbyLog', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('replayStandbyLog', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('replayStandbyLog', 'body', body)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/logreplay`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update backup policy of specific tenant
         * @summary Update backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamUpdateBackupPolicy} body update backup policy request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBackupPolicy: async (namespace: string, name: string, body: ParamUpdateBackupPolicy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateBackupPolicy', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateBackupPolicy', 'name', name)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateBackupPolicy', 'body', body)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/backupPolicy`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upgrade tenant compatibility version of specific tenant to match the version of cluster
         * @summary Upgrade tenant compatibility version of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeTenantVersion: async (namespace: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('upgradeTenantVersion', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('upgradeTenantVersion', 'name', name)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/version`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OBTenantApi - functional programming interface
 * @export
 */
export const OBTenantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OBTenantApiAxiosParamCreator(configuration)
    return {
        /**
         * Change tenant role of specific tenant, if a tenant is a standby tenant, it can be changed to primary tenant, vice versa
         * @summary Change tenant role of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamChangeTenantRole} body target role to change to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeTenantRole(namespace: string, name: string, body: ParamChangeTenantRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeTenantRole(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.changeTenantRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change root password of specific tenant, encrypted by AES
         * @summary Change root password of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamChangeUserPassword} body new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeUserPassword(namespace: string, name: string, body: ParamChangeUserPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeUserPassword(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.changeUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create backup policy of specific tenant, passwords should be encrypted by AES
         * @summary Create backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamCreateBackupPolicy} body create backup policy request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBackupPolicy(namespace: string, name: string, body: ParamCreateBackupPolicy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBackupPolicy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBackupPolicy(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.createBackupPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an obtenant pool in a specific namespace
         * @summary Create obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {ParamTenantPoolSpec} body create obtenant pool request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOBTenantPool(namespace: string, name: string, zoneName: string, body: ParamTenantPoolSpec, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOBTenantPool(namespace, name, zoneName, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.createOBTenantPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an obtenant in a specific namespace, passwords should be encrypted by AES
         * @summary Create tenant
         * @param {ParamCreateOBTenantParam} body create obtenant request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTenant(body: ParamCreateOBTenantParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTenant(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.createTenant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete backup policy of specific tenant
         * @summary Delete backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} [force] force delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBackupPolicy(namespace: string, name: string, force?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBackupPolicy(namespace, name, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.deleteBackupPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an obtenant pool in a specific namespace
         * @summary Delete obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOBTenantPool(namespace: string, name: string, zoneName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOBTenantPool(namespace, name, zoneName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.deleteOBTenantPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an obtenant in a specific namespace, ask user to confrim the deletion carefully
         * @summary Delete tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTenant(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTenant(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.deleteTenant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get backup policy of specific tenant
         * @summary Get backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackupPolicy(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBackupPolicy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackupPolicy(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.getBackupPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List statistics information of tenants
         * @summary List statistics information of tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOBTenantStatistic(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOBTenantStatistic200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOBTenantStatistic(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.getOBTenantStatistic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an obtenant in a specific namespace
         * @summary Get tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTenant(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTenant(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.getTenant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all tenants and return them
         * @summary List all tenants
         * @param {string} [obcluster] obcluster to filter
         * @param {string} [ns] namespace to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllTenants(obcluster?: string, ns?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllTenants200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllTenants(obcluster, ns, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.listAllTenants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List backup jobs of specific tenant
         * @summary List backup jobs of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ListBackupJobsTypeEnum} type backup job type
         * @param {number} [limit] limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBackupJobs(namespace: string, name: string, type: ListBackupJobsTypeEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBackupJobs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBackupJobs(namespace, name, type, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.listBackupJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all the databases under obtenant
         * @summary List obtenant databases
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOBTenantDatabases(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOBTenantDatabases200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOBTenantDatabases(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.listOBTenantDatabases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List related events of specific tenant, including restore, backup and backup policy events
         * @summary List related events of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOBTenantRelatedEvents(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListK8sEvents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOBTenantRelatedEvents(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.listOBTenantRelatedEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all the users under obtenant
         * @summary List obtenant users
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOBTenantUsers(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOBTenantDatabases200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOBTenantUsers(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.listOBTenantUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Patch an obtenant pool in a specific namespace
         * @summary Patch obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {ParamTenantPoolSpec} body patch obtenant pool request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOBTenantPool(namespace: string, name: string, zoneName: string, body: ParamTenantPoolSpec, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOBTenantPool(namespace, name, zoneName, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.patchOBTenantPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Patch tenant\'s configuration
         * @summary Patch tenant\'s configuration
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamPatchTenant} body patch tenant body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchTenant(namespace: string, name: string, body: ParamPatchTenant, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchTenant(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.patchTenant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replay standby log of specific standby tenant
         * @summary Replay standby log of specific standby tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamReplayStandbyLog} body target timestamp to replay to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replayStandbyLog(namespace: string, name: string, body: ParamReplayStandbyLog, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replayStandbyLog(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.replayStandbyLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update backup policy of specific tenant
         * @summary Update backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamUpdateBackupPolicy} body update backup policy request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBackupPolicy(namespace: string, name: string, body: ParamUpdateBackupPolicy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBackupPolicy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBackupPolicy(namespace, name, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.updateBackupPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upgrade tenant compatibility version of specific tenant to match the version of cluster
         * @summary Upgrade tenant compatibility version of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upgradeTenantVersion(namespace: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTenant200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upgradeTenantVersion(namespace, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OBTenantApi.upgradeTenantVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OBTenantApi - factory interface
 * @export
 */
export const OBTenantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OBTenantApiFp(configuration)
    return {
        /**
         * Change tenant role of specific tenant, if a tenant is a standby tenant, it can be changed to primary tenant, vice versa
         * @summary Change tenant role of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamChangeTenantRole} body target role to change to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeTenantRole(namespace: string, name: string, body: ParamChangeTenantRole, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.changeTenantRole(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Change root password of specific tenant, encrypted by AES
         * @summary Change root password of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamChangeUserPassword} body new password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPassword(namespace: string, name: string, body: ParamChangeUserPassword, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.changeUserPassword(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create backup policy of specific tenant, passwords should be encrypted by AES
         * @summary Create backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamCreateBackupPolicy} body create backup policy request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBackupPolicy(namespace: string, name: string, body: ParamCreateBackupPolicy, options?: any): AxiosPromise<GetBackupPolicy200Response> {
            return localVarFp.createBackupPolicy(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an obtenant pool in a specific namespace
         * @summary Create obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {ParamTenantPoolSpec} body create obtenant pool request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBTenantPool(namespace: string, name: string, zoneName: string, body: ParamTenantPoolSpec, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.createOBTenantPool(namespace, name, zoneName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an obtenant in a specific namespace, passwords should be encrypted by AES
         * @summary Create tenant
         * @param {ParamCreateOBTenantParam} body create obtenant request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant(body: ParamCreateOBTenantParam, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.createTenant(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete backup policy of specific tenant
         * @summary Delete backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} [force] force delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackupPolicy(namespace: string, name: string, force?: string, options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.deleteBackupPolicy(namespace, name, force, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an obtenant pool in a specific namespace
         * @summary Delete obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOBTenantPool(namespace: string, name: string, zoneName: string, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.deleteOBTenantPool(namespace, name, zoneName, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an obtenant in a specific namespace, ask user to confrim the deletion carefully
         * @summary Delete tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenant(namespace: string, name: string, options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.deleteTenant(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get backup policy of specific tenant
         * @summary Get backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupPolicy(namespace: string, name: string, options?: any): AxiosPromise<GetBackupPolicy200Response> {
            return localVarFp.getBackupPolicy(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * List statistics information of tenants
         * @summary List statistics information of tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOBTenantStatistic(options?: any): AxiosPromise<GetOBTenantStatistic200Response> {
            return localVarFp.getOBTenantStatistic(options).then((request) => request(axios, basePath));
        },
        /**
         * Get an obtenant in a specific namespace
         * @summary Get tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenant(namespace: string, name: string, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.getTenant(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * List all tenants and return them
         * @summary List all tenants
         * @param {string} [obcluster] obcluster to filter
         * @param {string} [ns] namespace to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTenants(obcluster?: string, ns?: string, options?: any): AxiosPromise<ListAllTenants200Response> {
            return localVarFp.listAllTenants(obcluster, ns, options).then((request) => request(axios, basePath));
        },
        /**
         * List backup jobs of specific tenant
         * @summary List backup jobs of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ListBackupJobsTypeEnum} type backup job type
         * @param {number} [limit] limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBackupJobs(namespace: string, name: string, type: ListBackupJobsTypeEnum, limit?: number, options?: any): AxiosPromise<ListBackupJobs200Response> {
            return localVarFp.listBackupJobs(namespace, name, type, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the databases under obtenant
         * @summary List obtenant databases
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBTenantDatabases(namespace: string, name: string, options?: any): AxiosPromise<ListOBTenantDatabases200Response> {
            return localVarFp.listOBTenantDatabases(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * List related events of specific tenant, including restore, backup and backup policy events
         * @summary List related events of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBTenantRelatedEvents(namespace: string, name: string, options?: any): AxiosPromise<ListK8sEvents200Response> {
            return localVarFp.listOBTenantRelatedEvents(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the users under obtenant
         * @summary List obtenant users
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOBTenantUsers(namespace: string, name: string, options?: any): AxiosPromise<ListOBTenantDatabases200Response> {
            return localVarFp.listOBTenantUsers(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch an obtenant pool in a specific namespace
         * @summary Patch obtenant pool
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {string} zoneName obzone name
         * @param {ParamTenantPoolSpec} body patch obtenant pool request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOBTenantPool(namespace: string, name: string, zoneName: string, body: ParamTenantPoolSpec, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.patchOBTenantPool(namespace, name, zoneName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch tenant\'s configuration
         * @summary Patch tenant\'s configuration
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamPatchTenant} body patch tenant body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTenant(namespace: string, name: string, body: ParamPatchTenant, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.patchTenant(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Replay standby log of specific standby tenant
         * @summary Replay standby log of specific standby tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamReplayStandbyLog} body target timestamp to replay to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replayStandbyLog(namespace: string, name: string, body: ParamReplayStandbyLog, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.replayStandbyLog(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update backup policy of specific tenant
         * @summary Update backup policy of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {ParamUpdateBackupPolicy} body update backup policy request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBackupPolicy(namespace: string, name: string, body: ParamUpdateBackupPolicy, options?: any): AxiosPromise<GetBackupPolicy200Response> {
            return localVarFp.updateBackupPolicy(namespace, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Upgrade tenant compatibility version of specific tenant to match the version of cluster
         * @summary Upgrade tenant compatibility version of specific tenant
         * @param {string} namespace obtenant namespace
         * @param {string} name obtenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeTenantVersion(namespace: string, name: string, options?: any): AxiosPromise<CreateTenant200Response> {
            return localVarFp.upgradeTenantVersion(namespace, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OBTenantApi - object-oriented interface
 * @export
 * @class OBTenantApi
 * @extends {BaseAPI}
 */
export class OBTenantApi extends BaseAPI {
    /**
     * Change tenant role of specific tenant, if a tenant is a standby tenant, it can be changed to primary tenant, vice versa
     * @summary Change tenant role of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {ParamChangeTenantRole} body target role to change to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public changeTenantRole(namespace: string, name: string, body: ParamChangeTenantRole, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).changeTenantRole(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change root password of specific tenant, encrypted by AES
     * @summary Change root password of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {ParamChangeUserPassword} body new password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public changeUserPassword(namespace: string, name: string, body: ParamChangeUserPassword, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).changeUserPassword(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create backup policy of specific tenant, passwords should be encrypted by AES
     * @summary Create backup policy of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {ParamCreateBackupPolicy} body create backup policy request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public createBackupPolicy(namespace: string, name: string, body: ParamCreateBackupPolicy, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).createBackupPolicy(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an obtenant pool in a specific namespace
     * @summary Create obtenant pool
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {string} zoneName obzone name
     * @param {ParamTenantPoolSpec} body create obtenant pool request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public createOBTenantPool(namespace: string, name: string, zoneName: string, body: ParamTenantPoolSpec, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).createOBTenantPool(namespace, name, zoneName, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an obtenant in a specific namespace, passwords should be encrypted by AES
     * @summary Create tenant
     * @param {ParamCreateOBTenantParam} body create obtenant request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public createTenant(body: ParamCreateOBTenantParam, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).createTenant(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete backup policy of specific tenant
     * @summary Delete backup policy of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {string} [force] force delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public deleteBackupPolicy(namespace: string, name: string, force?: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).deleteBackupPolicy(namespace, name, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an obtenant pool in a specific namespace
     * @summary Delete obtenant pool
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {string} zoneName obzone name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public deleteOBTenantPool(namespace: string, name: string, zoneName: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).deleteOBTenantPool(namespace, name, zoneName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an obtenant in a specific namespace, ask user to confrim the deletion carefully
     * @summary Delete tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public deleteTenant(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).deleteTenant(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get backup policy of specific tenant
     * @summary Get backup policy of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public getBackupPolicy(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).getBackupPolicy(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List statistics information of tenants
     * @summary List statistics information of tenants
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public getOBTenantStatistic(options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).getOBTenantStatistic(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an obtenant in a specific namespace
     * @summary Get tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public getTenant(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).getTenant(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all tenants and return them
     * @summary List all tenants
     * @param {string} [obcluster] obcluster to filter
     * @param {string} [ns] namespace to filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public listAllTenants(obcluster?: string, ns?: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).listAllTenants(obcluster, ns, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List backup jobs of specific tenant
     * @summary List backup jobs of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {ListBackupJobsTypeEnum} type backup job type
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public listBackupJobs(namespace: string, name: string, type: ListBackupJobsTypeEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).listBackupJobs(namespace, name, type, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the databases under obtenant
     * @summary List obtenant databases
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public listOBTenantDatabases(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).listOBTenantDatabases(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List related events of specific tenant, including restore, backup and backup policy events
     * @summary List related events of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public listOBTenantRelatedEvents(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).listOBTenantRelatedEvents(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the users under obtenant
     * @summary List obtenant users
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public listOBTenantUsers(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).listOBTenantUsers(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch an obtenant pool in a specific namespace
     * @summary Patch obtenant pool
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {string} zoneName obzone name
     * @param {ParamTenantPoolSpec} body patch obtenant pool request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public patchOBTenantPool(namespace: string, name: string, zoneName: string, body: ParamTenantPoolSpec, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).patchOBTenantPool(namespace, name, zoneName, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch tenant\'s configuration
     * @summary Patch tenant\'s configuration
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {ParamPatchTenant} body patch tenant body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public patchTenant(namespace: string, name: string, body: ParamPatchTenant, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).patchTenant(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replay standby log of specific standby tenant
     * @summary Replay standby log of specific standby tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {ParamReplayStandbyLog} body target timestamp to replay to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public replayStandbyLog(namespace: string, name: string, body: ParamReplayStandbyLog, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).replayStandbyLog(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update backup policy of specific tenant
     * @summary Update backup policy of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {ParamUpdateBackupPolicy} body update backup policy request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public updateBackupPolicy(namespace: string, name: string, body: ParamUpdateBackupPolicy, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).updateBackupPolicy(namespace, name, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upgrade tenant compatibility version of specific tenant to match the version of cluster
     * @summary Upgrade tenant compatibility version of specific tenant
     * @param {string} namespace obtenant namespace
     * @param {string} name obtenant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OBTenantApi
     */
    public upgradeTenantVersion(namespace: string, name: string, options?: RawAxiosRequestConfig) {
        return OBTenantApiFp(this.configuration).upgradeTenantVersion(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListBackupJobsTypeEnum = {
    FULL: 'FULL',
    INC: 'INC',
    CLEAN: 'CLEAN',
    ARCHIVE: 'ARCHIVE'
} as const;
export type ListBackupJobsTypeEnum = typeof ListBackupJobsTypeEnum[keyof typeof ListBackupJobsTypeEnum];


/**
 * SqlApi - axios parameter creator
 * @export
 */
export const SqlApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * list sqls metrics
         * @summary list sql metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSqlMetrics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sql/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list suspicious sqls
         * @summary list suspicious sqls
         * @param {SqlSqlFilter} body sql filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSuspiciousSqls: async (body: SqlSqlFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('listSuspiciousSqls', 'body', body)
            const localVarPath = `/api/v1/sql/suspiciousSqls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list top sqls ordering by spcecific metrics
         * @summary list top sqls
         * @param {SqlSqlFilter} body sql filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTopSqls: async (body: SqlSqlFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('listTopSqls', 'body', body)
            const localVarPath = `/api/v1/sql/topSqls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * query detailed statistic info of a plan
         * @summary query plan detail info
         * @param {SqlPlanDetailParam} body param for query detailed plan info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPlanDetailInfo: async (body: SqlPlanDetailParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('queryPlanDetailInfo', 'body', body)
            const localVarPath = `/api/v1/sql/queryPlanDetailInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * query detailed statistic info of a SQL
         * @summary query SQL detail info
         * @param {SqlSqlDetailParam} body param for query detailed sql info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySqlDetailInfo: async (body: SqlSqlDetailParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('querySqlDetailInfo', 'body', body)
            const localVarPath = `/api/v1/sql/querySqlDetailInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list request statistics
         * @summary list request statistics
         * @param {SqlSqlRequestStatisticParam} body sql request statistic param
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestStatistics: async (body: SqlSqlRequestStatisticParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('requestStatistics', 'body', body)
            const localVarPath = `/api/v1/sql/requestStatistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SqlApi - functional programming interface
 * @export
 */
export const SqlApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SqlApiAxiosParamCreator(configuration)
    return {
        /**
         * list sqls metrics
         * @summary list sql metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSqlMetrics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSqlMetrics200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSqlMetrics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SqlApi.listSqlMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list suspicious sqls
         * @summary list suspicious sqls
         * @param {SqlSqlFilter} body sql filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSuspiciousSqls(body: SqlSqlFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSuspiciousSqls200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSuspiciousSqls(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SqlApi.listSuspiciousSqls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list top sqls ordering by spcecific metrics
         * @summary list top sqls
         * @param {SqlSqlFilter} body sql filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTopSqls(body: SqlSqlFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSuspiciousSqls200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTopSqls(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SqlApi.listTopSqls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * query detailed statistic info of a plan
         * @summary query plan detail info
         * @param {SqlPlanDetailParam} body param for query detailed plan info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryPlanDetailInfo(body: SqlPlanDetailParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryPlanDetailInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryPlanDetailInfo(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SqlApi.queryPlanDetailInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * query detailed statistic info of a SQL
         * @summary query SQL detail info
         * @param {SqlSqlDetailParam} body param for query detailed sql info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async querySqlDetailInfo(body: SqlSqlDetailParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySqlDetailInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.querySqlDetailInfo(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SqlApi.querySqlDetailInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * list request statistics
         * @summary list request statistics
         * @param {SqlSqlRequestStatisticParam} body sql request statistic param
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestStatistics(body: SqlSqlRequestStatisticParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestStatistics200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestStatistics(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SqlApi.requestStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SqlApi - factory interface
 * @export
 */
export const SqlApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SqlApiFp(configuration)
    return {
        /**
         * list sqls metrics
         * @summary list sql metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSqlMetrics(options?: any): AxiosPromise<ListSqlMetrics200Response> {
            return localVarFp.listSqlMetrics(options).then((request) => request(axios, basePath));
        },
        /**
         * list suspicious sqls
         * @summary list suspicious sqls
         * @param {SqlSqlFilter} body sql filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSuspiciousSqls(body: SqlSqlFilter, options?: any): AxiosPromise<ListSuspiciousSqls200Response> {
            return localVarFp.listSuspiciousSqls(body, options).then((request) => request(axios, basePath));
        },
        /**
         * list top sqls ordering by spcecific metrics
         * @summary list top sqls
         * @param {SqlSqlFilter} body sql filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTopSqls(body: SqlSqlFilter, options?: any): AxiosPromise<ListSuspiciousSqls200Response> {
            return localVarFp.listTopSqls(body, options).then((request) => request(axios, basePath));
        },
        /**
         * query detailed statistic info of a plan
         * @summary query plan detail info
         * @param {SqlPlanDetailParam} body param for query detailed plan info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPlanDetailInfo(body: SqlPlanDetailParam, options?: any): AxiosPromise<QueryPlanDetailInfo200Response> {
            return localVarFp.queryPlanDetailInfo(body, options).then((request) => request(axios, basePath));
        },
        /**
         * query detailed statistic info of a SQL
         * @summary query SQL detail info
         * @param {SqlSqlDetailParam} body param for query detailed sql info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySqlDetailInfo(body: SqlSqlDetailParam, options?: any): AxiosPromise<QuerySqlDetailInfo200Response> {
            return localVarFp.querySqlDetailInfo(body, options).then((request) => request(axios, basePath));
        },
        /**
         * list request statistics
         * @summary list request statistics
         * @param {SqlSqlRequestStatisticParam} body sql request statistic param
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestStatistics(body: SqlSqlRequestStatisticParam, options?: any): AxiosPromise<RequestStatistics200Response> {
            return localVarFp.requestStatistics(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SqlApi - object-oriented interface
 * @export
 * @class SqlApi
 * @extends {BaseAPI}
 */
export class SqlApi extends BaseAPI {
    /**
     * list sqls metrics
     * @summary list sql metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SqlApi
     */
    public listSqlMetrics(options?: RawAxiosRequestConfig) {
        return SqlApiFp(this.configuration).listSqlMetrics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list suspicious sqls
     * @summary list suspicious sqls
     * @param {SqlSqlFilter} body sql filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SqlApi
     */
    public listSuspiciousSqls(body: SqlSqlFilter, options?: RawAxiosRequestConfig) {
        return SqlApiFp(this.configuration).listSuspiciousSqls(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list top sqls ordering by spcecific metrics
     * @summary list top sqls
     * @param {SqlSqlFilter} body sql filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SqlApi
     */
    public listTopSqls(body: SqlSqlFilter, options?: RawAxiosRequestConfig) {
        return SqlApiFp(this.configuration).listTopSqls(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * query detailed statistic info of a plan
     * @summary query plan detail info
     * @param {SqlPlanDetailParam} body param for query detailed plan info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SqlApi
     */
    public queryPlanDetailInfo(body: SqlPlanDetailParam, options?: RawAxiosRequestConfig) {
        return SqlApiFp(this.configuration).queryPlanDetailInfo(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * query detailed statistic info of a SQL
     * @summary query SQL detail info
     * @param {SqlSqlDetailParam} body param for query detailed sql info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SqlApi
     */
    public querySqlDetailInfo(body: SqlSqlDetailParam, options?: RawAxiosRequestConfig) {
        return SqlApiFp(this.configuration).querySqlDetailInfo(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list request statistics
     * @summary list request statistics
     * @param {SqlSqlRequestStatisticParam} body sql request statistic param
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SqlApi
     */
    public requestStatistics(body: SqlSqlRequestStatisticParam, options?: RawAxiosRequestConfig) {
        return SqlApiFp(this.configuration).requestStatistics(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StorageApi - axios parameter creator
 * @export
 */
export const StorageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get file by id
         * @summary Get file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/storage/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageApi - functional programming interface
 * @export
 */
export const StorageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageApiAxiosParamCreator(configuration)
    return {
        /**
         * Get file by id
         * @summary Get file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageApi.getFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StorageApi - factory interface
 * @export
 */
export const StorageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageApiFp(configuration)
    return {
        /**
         * Get file by id
         * @summary Get file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(options?: any): AxiosPromise<File> {
            return localVarFp.getFile(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageApi - object-oriented interface
 * @export
 * @class StorageApi
 * @extends {BaseAPI}
 */
export class StorageApi extends BaseAPI {
    /**
     * Get file by id
     * @summary Get file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApi
     */
    public getFile(options?: RawAxiosRequestConfig) {
        return StorageApiFp(this.configuration).getFile(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TerminalApi - axios parameter creator
 * @export
 */
export const TerminalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Connect to oceanbase database in websocket
         * @summary Connect to oceanbase database
         * @param {string} terminalId terminalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectDatabase: async (terminalId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terminalId' is not null or undefined
            assertParamExists('connectDatabase', 'terminalId', terminalId)
            const localVarPath = `/api/v1/conn/{terminalId}`
                .replace(`{${"terminalId"}}`, encodeURIComponent(String(terminalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create oceanbase cluster connection terminal
         * @summary Create oceanbase cluster connection
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {CreateOBClusterConnectionChannelEnum} [channel] channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBClusterConnection: async (namespace: string, name: string, channel?: CreateOBClusterConnectionChannelEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('createOBClusterConnection', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createOBClusterConnection', 'name', name)
            const localVarPath = `/api/v1/obclusters/namespace/{namespace}/name/{name}/terminal`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create oceanbase tenant connection terminal
         * @summary Create oceanbase tenant connection
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {CreateOBTenantConnectionChannelEnum} [channel] channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBTenantConnection: async (namespace: string, name: string, channel?: CreateOBTenantConnectionChannelEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('createOBTenantConnection', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createOBTenantConnection', 'name', name)
            const localVarPath = `/api/v1/obtenants/{namespace}/{name}/terminal`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TerminalApi - functional programming interface
 * @export
 */
export const TerminalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TerminalApiAxiosParamCreator(configuration)
    return {
        /**
         * Connect to oceanbase database in websocket
         * @summary Connect to oceanbase database
         * @param {string} terminalId terminalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectDatabase(terminalId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectDatabase200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectDatabase(terminalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerminalApi.connectDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create oceanbase cluster connection terminal
         * @summary Create oceanbase cluster connection
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {CreateOBClusterConnectionChannelEnum} [channel] channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOBClusterConnection(namespace: string, name: string, channel?: CreateOBClusterConnectionChannelEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectDatabase200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOBClusterConnection(namespace, name, channel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerminalApi.createOBClusterConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create oceanbase tenant connection terminal
         * @summary Create oceanbase tenant connection
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {CreateOBTenantConnectionChannelEnum} [channel] channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOBTenantConnection(namespace: string, name: string, channel?: CreateOBTenantConnectionChannelEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectDatabase200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOBTenantConnection(namespace, name, channel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TerminalApi.createOBTenantConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TerminalApi - factory interface
 * @export
 */
export const TerminalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TerminalApiFp(configuration)
    return {
        /**
         * Connect to oceanbase database in websocket
         * @summary Connect to oceanbase database
         * @param {string} terminalId terminalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectDatabase(terminalId: string, options?: any): AxiosPromise<ConnectDatabase200Response> {
            return localVarFp.connectDatabase(terminalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create oceanbase cluster connection terminal
         * @summary Create oceanbase cluster connection
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {CreateOBClusterConnectionChannelEnum} [channel] channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBClusterConnection(namespace: string, name: string, channel?: CreateOBClusterConnectionChannelEnum, options?: any): AxiosPromise<ConnectDatabase200Response> {
            return localVarFp.createOBClusterConnection(namespace, name, channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Create oceanbase tenant connection terminal
         * @summary Create oceanbase tenant connection
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {CreateOBTenantConnectionChannelEnum} [channel] channel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOBTenantConnection(namespace: string, name: string, channel?: CreateOBTenantConnectionChannelEnum, options?: any): AxiosPromise<ConnectDatabase200Response> {
            return localVarFp.createOBTenantConnection(namespace, name, channel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TerminalApi - object-oriented interface
 * @export
 * @class TerminalApi
 * @extends {BaseAPI}
 */
export class TerminalApi extends BaseAPI {
    /**
     * Connect to oceanbase database in websocket
     * @summary Connect to oceanbase database
     * @param {string} terminalId terminalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApi
     */
    public connectDatabase(terminalId: string, options?: RawAxiosRequestConfig) {
        return TerminalApiFp(this.configuration).connectDatabase(terminalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create oceanbase cluster connection terminal
     * @summary Create oceanbase cluster connection
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {CreateOBClusterConnectionChannelEnum} [channel] channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApi
     */
    public createOBClusterConnection(namespace: string, name: string, channel?: CreateOBClusterConnectionChannelEnum, options?: RawAxiosRequestConfig) {
        return TerminalApiFp(this.configuration).createOBClusterConnection(namespace, name, channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create oceanbase tenant connection terminal
     * @summary Create oceanbase tenant connection
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {CreateOBTenantConnectionChannelEnum} [channel] channel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalApi
     */
    public createOBTenantConnection(namespace: string, name: string, channel?: CreateOBTenantConnectionChannelEnum, options?: RawAxiosRequestConfig) {
        return TerminalApiFp(this.configuration).createOBTenantConnection(namespace, name, channel, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CreateOBClusterConnectionChannelEnum = {
    TERMINAL: 'TERMINAL',
    ODC: 'ODC'
} as const;
export type CreateOBClusterConnectionChannelEnum = typeof CreateOBClusterConnectionChannelEnum[keyof typeof CreateOBClusterConnectionChannelEnum];
/**
 * @export
 */
export const CreateOBTenantConnectionChannelEnum = {
    TERMINAL: 'TERMINAL',
    ODC: 'ODC'
} as const;
export type CreateOBTenantConnectionChannelEnum = typeof CreateOBTenantConnectionChannelEnum[keyof typeof CreateOBTenantConnectionChannelEnum];


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User login and return access token with cookie.
         * @summary User login
         * @param {ParamLoginParam} loginInfo login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginInfo: ParamLoginParam, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginInfo' is not null or undefined
            assertParamExists('login', 'loginInfo', loginInfo)
            const localVarPath = `/api/v1/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User logout and clear session.
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Cookie", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * User login and return access token with cookie.
         * @summary User login
         * @param {ParamLoginParam} loginInfo login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginInfo: ParamLoginParam, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginInfo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User logout and clear session.
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * User login and return access token with cookie.
         * @summary User login
         * @param {ParamLoginParam} loginInfo login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginInfo: ParamLoginParam, options?: any): AxiosPromise<CreateAccount200Response> {
            return localVarFp.login(loginInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * User logout and clear session.
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<ResponseAPIResponse> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * User login and return access token with cookie.
     * @summary User login
     * @param {ParamLoginParam} loginInfo login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public login(loginInfo: ParamLoginParam, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).login(loginInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User logout and clear session.
     * @summary User logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public logout(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Log alerts sent by alertmanager.
         * @summary Log alerts
         * @param {PayloadWebhookPayload} body payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logAlerts: async (body: PayloadWebhookPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('logAlerts', 'body', body)
            const localVarPath = `/api/v1/webhook/alert/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * Log alerts sent by alertmanager.
         * @summary Log alerts
         * @param {PayloadWebhookPayload} body payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logAlerts(body: PayloadWebhookPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProcessInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logAlerts(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.logAlerts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * Log alerts sent by alertmanager.
         * @summary Log alerts
         * @param {PayloadWebhookPayload} body payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logAlerts(body: PayloadWebhookPayload, options?: any): AxiosPromise<GetProcessInfo200Response> {
            return localVarFp.logAlerts(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * Log alerts sent by alertmanager.
     * @summary Log alerts
     * @param {PayloadWebhookPayload} body payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public logAlerts(body: PayloadWebhookPayload, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).logAlerts(body, options).then((request) => request(this.axios, this.basePath));
    }
}



