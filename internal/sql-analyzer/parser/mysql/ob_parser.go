// Code generated from /work/obparser/obmysql/sql/OBParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package mysql // OBParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type OBParser struct {
	*antlr.BaseParser
}

var OBParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func obparserParserInit() {
	staticData := &OBParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "'@'", "'''", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "'||'", "'&&'", "'='", "':='", "'<=>'", "'>='",
		"'>'", "'<='", "'<'", "", "'<<'", "'>>'", "", "", "", "", "'.'",
	}
	staticData.SymbolicNames = []string{
		"", "ACCESSIBLE", "ADD", "AGAINST", "ALTER", "ALWAYS", "AND", "ANALYZE",
		"ALL", "AS", "ASENSITIVE", "ASC", "BETWEEN", "BEFORE", "BIGINT", "BINARY",
		"BLOB", "BOTH", "BULK", "BY", "CALL", "CASCADE", "CASE", "CHANGE", "CHARACTER",
		"CHECK", "CIPHER", "CONDITION", "CONSTRAINT", "CONTINUE", "CONVERT",
		"COLLATE", "COLUMN", "COLUMNS", "CREATE", "CROSS", "CYCLE", "CURRENT_DATE",
		"CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "WITH_ROWID", "CURSOR",
		"DAY_HOUR", "DAY_MICROSECOND", "DAY_MINUTE", "DAY_SECOND", "DATABASE",
		"DATABASES", "NUMBER", "DECIMAL", "DECLARE", "DEFAULT", "DELAYED", "DELETE",
		"DESC", "DESCRIBE", "DETERMINISTIC", "DIV", "DISTINCT", "DISTINCTROW",
		"DOUBLE", "DROP", "DUAL", "EACH", "ENCLOSED", "ELSE", "ELSEIF", "ESCAPED",
		"EXISTS", "EXIT", "EXPLAIN", "FETCH", "FIELDS", "FOREIGN", "FLOAT",
		"FLOAT4", "FLOAT8", "FOR", "FORCE", "FROM", "FULL", "FULLTEXT", "GET",
		"GENERATED", "GRANT", "GROUP", "HAVING", "HIGH_PRIORITY", "HOUR_MICROSECOND",
		"HOUR_MINUTE", "HOUR_SECOND", "ID", "IF", "IFIGNORE", "IN", "INDEX",
		"INNER", "INFILE", "INOUT", "INSENSITIVE", "INTEGER", "INT1", "INT2",
		"INT3", "INT4", "INT8", "INTERVAL", "INSERT", "INTO", "IO_AFTER_GTIDS",
		"IO_BEFORE_GTIDS", "IS", "ISSUER", "ITERATE", "JOIN", "KEY", "KEYS",
		"KILL", "LANGUAGE", "LEADING", "LEAVE", "LEFT", "LIMIT", "LIKE", "LINEAR",
		"LINES", "BISON_LIST", "LOAD", "LOCAL", "LOCALTIME", "LOCALTIMESTAMP",
		"LOCK_", "LONG", "LONGBLOB", "LONGTEXT", "LOOP", "LOW_PRIORITY", "MASTER_BIND",
		"MASTER_SSL_VERIFY_SERVER_CERT", "MATCH", "MAXVALUE", "MEDIUMBLOB",
		"MEDIUMINT", "MERGE", "MEDIUMTEXT", "MIDDLEINT", "MINUTE_MICROSECOND",
		"MINUTE_SECOND", "MOD", "MODE", "MODIFIES", "NATURAL", "NO_WRITE_TO_BINLOG",
		"ON", "OPTION", "OPTIMIZE", "OPTIONALLY", "OR", "ORDER", "OUT", "OUTER",
		"OUTFILE", "PARSER", "PROCEDURE", "PURGE", "PARTITION", "PRECISION",
		"PRIMARY", "PUBLIC", "RANGE", "READ", "READ_WRITE", "READS", "REAL",
		"RELEASE", "REFERENCES", "REGEXP", "RENAME", "REPLACE", "REPEAT", "REQUIRE",
		"RESIGNAL", "RESTRICT", "RETURN", "REVOKE", "RIGHT", "ROWS", "SECOND_MICROSECOND",
		"SELECT", "SCHEMA", "SCHEMAS", "SEPARATOR", "SET", "SENSITIVE", "SHOW",
		"SIGNAL", "SMALLINT", "SPATIAL", "SPECIFIC", "SQL", "SQLEXCEPTION",
		"SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", "SQL_CALC_FOUND_ROWS", "SQL_SMALL_RESULT",
		"SEARCH", "SSL", "STARTING", "STORED", "STRAIGHT_JOIN", "SUBJECT", "SYNONYM",
		"SYSDATE", "TERMINATED", "TEXT", "TINYBLOB", "TINYINT", "TINYTEXT",
		"TABLE", "TABLEGROUP", "THEN", "TO", "TRAILING", "TRIGGER", "UNDO",
		"UNION", "UNIQUE", "UNLOCK", "UNSIGNED", "UPDATE", "USAGE", "USE", "USING",
		"UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", "VALUES", "VARBINARY", "VARCHAR",
		"VARYING", "VIRTUAL", "WHERE", "WHEN", "WHILE", "WINDOW", "WITH", "WRITE",
		"XOR", "X509", "YEAR_MONTH", "ZEROFILL", "GLOBAL_ALIAS", "SESSION_ALIAS",
		"UnderlineUTF8", "UnderlineUTF8MB4", "UnderlineGBK", "UnderlineGB18030",
		"UnderlineBINARY", "UnderlineUTF16", "STRONG", "WEAK", "FROZEN", "EXCEPT",
		"MINUS", "INTERSECT", "ISNULL", "RETURNING", "NOT", "NULLX", "INTNUM",
		"AUDIT", "WARNINGS", "FORMAT", "UNINSTALL", "UNDOFILE", "MASTER_SSL_CA",
		"YEAR", "STOP", "STORAGE_FORMAT_WORK_VERSION", "AT", "RELAY_LOG_POS",
		"POOL", "CURDATE", "ZONE_TYPE", "LOCATION", "WEIGHT_STRING", "CHANGED",
		"MASTER_SSL_CAPATH", "REWRITE_MERGE_VERSION", "NTH_VALUE", "SERIAL",
		"PROGRESSIVE_MERGE_NUM", "TABLET_MAX_SIZE", "ILOGCACHE", "AUTHORS",
		"MIGRATE", "CONSISTENT", "SUSPEND", "SECURITY", "REMOTE_OSS", "SET_SLAVE_CLUSTER",
		"FAST", "PREVIEW", "TRUNCATE", "CONSTRAINT_SCHEMA", "MASTER_SSL_CERT",
		"TABLE_NAME", "DO", "MASTER_RETRY_COUNT", "REPLICA", "KILL_EXPR", "OLD_KEY",
		"DISABLE", "PORT", "REBUILD", "FOLLOWER", "LOWER_OVER", "ROOT", "REDOFILE",
		"MASTER_SERVER_ID", "NCHAR", "KEY_BLOCK_SIZE", "MIGRATION", "SUBPARTITION",
		"MYSQL_DRIVER", "ROW_NUMBER", "COMPRESSION", "BIT", "MAX_DISK_SIZE",
		"SAMPLE", "UNLOCKED", "CLASS_ORIGIN", "RUDUNDANT", "ACTION", "REDUNDANT",
		"UPGRADE", "VALIDATE", "START", "TEMPTABLE", "RECYCLEBIN", "PROFILES",
		"TIMESTAMP_VALUE", "ERRORS", "LEAVES", "UNDEFINED", "EVERY", "BYTE",
		"FLUSH", "MIN_ROWS", "ERROR_P", "MAX_USER_CONNECTIONS", "MAX_CPU", "LOCKED",
		"IO", "BTREE", "SLOT_IDX", "APPROXNUM", "HASH", "ROTATE", "COLLATION",
		"MASTER", "ENCRYPTION", "MAX", "TRANSACTION", "SQL_TSI_MONTH", "IGNORE",
		"MAX_QUERIES_PER_HOUR", "COMMENT", "CTX_ID", "MIN_IOPS", "NVARCHAR",
		"OFF", "PAUSE", "QUICK", "DUPLICATE", "WAIT", "DES_KEY_FILE", "ENGINES",
		"RETURNS", "MASTER_USER", "SOCKET", "MASTER_DELAY", "FILE_ID", "FIRST",
		"TABLET", "CLIENT", "ENGINE_", "TABLES", "TRADITIONAL", "BOOTSTRAP",
		"STDDEV", "DATAFILE", "VARCHARACTER", "INVOKER", "DEPTH", "NORMAL",
		"COLUMN_NAME", "TRIGGERS", "RESET", "EVENT", "COALESCE", "RESPECT",
		"STATUS", "UNBOUNDED", "WRAPPER", "TIMESTAMP", "PARTITIONS", "SUBSTR",
		"CHUNK", "FILEX", "BACKUPSET", "UNIT", "PRIVILEGES", "LOWER_ON", "LESS",
		"SWITCH", "DIAGNOSTICS", "REDO_BUFFER_SIZE", "NO", "MAJOR", "ACTIVE",
		"ROUTINE", "FOLLOWING", "READ_ONLY", "ROLLBACK", "PARTITION_ID", "DUMP",
		"APPROX_COUNT_DISTINCT_SYNOPSIS", "GROUPING", "ARCHIVELOG", "MATCHED",
		"MAX_CONNECTIONS_PER_HOUR", "SECOND", "UNKNOWN", "POINT", "PL", "POLYGON",
		"TABLE_ID", "CONTEXT", "FINAL_COUNT", "MASTER_CONNECT_RETRY", "POSITION",
		"DISCARD", "PREV", "RECOVER", "PROCESS", "DEALLOCATE", "OLD_PASSWORD",
		"LISTAGG", "SLOW", "SUM", "OPTIONS", "MIN", "RELOAD", "ONE", "DELAY_KEY_WRITE",
		"ORIG_DEFAULT", "RLIKE", "SQL_TSI_HOUR", "TIMESTAMPDIFF", "RESTORE",
		"OFFSET", "TEMPORARY", "VARIANCE", "SNAPSHOT", "SERVER_TYPE", "COMMITTED",
		"INDEXES", "FREEZE", "SCOPE", "IDC", "VIEW", "ONE_SHOT", "ACCOUNT",
		"LOCALITY", "REVERSE", "CLUSTER_ID", "NOARCHIVELOG", "MAX_SIZE", "PAGE",
		"NAME", "ROW_COUNT", "LAST", "LOGONLY_REPLICA_NUM", "DELAY", "SUBDATE",
		"INCREMENTAL", "ROLLING", "CONTAINS", "GENERAL", "VISIBLE", "SIGNED",
		"SERVER", "NEXT", "ENDS", "GLOBAL", "SHUTDOWN", "VERBOSE", "CLUSTER_NAME",
		"MASTER_PORT", "MYSQL_ERRNO", "LOWER_COMMA", "XA", "TIME", "DATETIME",
		"BOOL", "DIRECTORY", "DATA_TABLE_ID", "VALID", "MASTER_SSL_KEY", "MASTER_PASSWORD",
		"PLAN", "SHARE", "MULTIPOLYGON", "STDDEV_SAMP", "USE_BLOOM_FILTER",
		"CONSTRAINT_CATALOG", "CLUSTER", "EXCHANGE", "GRANTS", "CAST", "SERVER_PORT",
		"SQL_CACHE", "MAX_USED_PART_ID", "INSTANCE", "FUNCTION", "NOWAIT", "INVISIBLE",
		"DENSE_RANK", "COUNT", "NAMES", "CHAR", "LOWER_THAN_NEG", "P_ENTITY",
		"ISOLATE", "MAX_ROWS", "CTXCAT", "ISOLATION", "REPLICATION", "REMOVE",
		"STATS_AUTO_RECALC", "CONSISTENT_MODE", "MODIFY", "UNCOMMITTED", "PHYSICAL",
		"NO_WAIT", "UNIT_NUM", "MAX_IOPS", "SPFILE", "REPEATABLE", "COMPLETION",
		"ROOTTABLE", "SUBSTRING", "ZONE", "TEMPLATE", "DATE_SUB", "EXPIRE_INFO",
		"EXPIRE", "ENABLE", "HOSTS", "SCHEMA_NAME", "EXPANSION", "REORGANIZE",
		"BLOCK_SIZE", "INNER_PARSE", "MINOR", "RESUME", "INT", "STATS_PERSISTENT",
		"NODEGROUP", "PARTITIONING", "SUPER", "COMMIT", "SAVEPOINT", "UNTIL",
		"USER", "MEMTABLE", "CHARSET", "MOVE", "XML", "IPC", "TRIM", "RANK",
		"DEFAULT_AUTH", "EXTENT_SIZE", "BINLOG", "LEAK_MOD", "CLOG", "GEOMETRYCOLLECTION",
		"STORAGE", "MEDIUM", "USE_FRM", "CLIENT_VERSION", "MASTER_HEARTBEAT_PERIOD",
		"SUBPARTITIONS", "CUBE", "BALANCE", "QUERY", "SQL_TSI_QUARTER", "REPAIR",
		"MASTER_SSL_CIPHER", "KEY_VERSION", "CATALOG_NAME", "NDBCLUSTER", "CONNECTION",
		"COMPACT", "SYNCHRONIZATION", "INCR", "CANCEL", "SIMPLE", "BEGI", "VARIABLES",
		"SQL_TSI_WEEK", "P_CHUNK", "SYSTEM", "ROOTSERVICE", "PLUGIN_DIR", "ASCII",
		"INFO", "SQL_THREAD", "TYPES", "LEADER", "LOWER_KEY", "FOUND", "EXTRACT",
		"FIXED", "CACHE", "CURRENT", "RETURNED_SQLSTATE", "END", "PRESERVE",
		"SQL_BUFFER_RESULT", "JSON", "SOME", "INDEX_TABLE_ID", "FREQUENCY",
		"LOCKS", "MANUAL", "GEOMETRY", "IDENTIFIED", "STORAGE_FORMAT_VERSION",
		"OVER", "MAX_SESSION_NUM", "USER_RESOURCES", "DESTINATION", "SONAME",
		"OUTLINE", "MASTER_LOG_FILE", "SLAVE", "GTS", "EXPORT", "AVG_ROW_LENGTH",
		"FLASHBACK", "SESSION_USER", "TABLEGROUPS", "CURTIME", "REPLICA_TYPE",
		"AGGREGATE", "PERCENT_RANK", "ENUM", "NATIONAL", "RECYCLE", "REGION",
		"MUTEX", "LOWER_PARENS", "NDB", "SYSTEM_USER", "MAX_UPDATES_PER_HOUR",
		"CURSOR_NAME", "CONCURRENT", "DUMPFILE", "NUMERIC", "COMPRESSED", "LINESTRING",
		"DYNAMIC", "CHAIN", "NEG", "LAG", "BASELINE_ID", "NEW", "SQL_TSI_YEAR",
		"THAN", "CPU", "HOST", "VALUE", "LOGS", "SERIALIZABLE", "AUTO_INCREMENT",
		"BACKUP", "LOGFILE", "ROW_FORMAT", "SET_MASTER_CLUSTER", "MINUTE", "SWAPS",
		"TASK", "INNODB", "IO_THREAD", "HISTOGRAM", "PCTFREE", "PARAMETERS",
		"TABLESPACE", "AUTO", "PASSWORD", "ROW", "MESSAGE_TEXT", "DISK", "FAULTS",
		"HOUR", "REFRESH", "COLUMN_STAT", "ANY", "ERROR_CODE", "PHASE", "ENTITY",
		"PROFILE", "LAST_VALUE", "RESTART", "TRACE", "DATE_ADD", "BLOCK_INDEX",
		"SERVER_IP", "CODE", "PLUGINS", "ADDDATE", "VIRTUAL_COLUMN_ID", "COLUMN_FORMAT",
		"MAX_MEMORY", "CLEAN", "MASTER_SSL", "CLEAR", "CHECKSUM", "INSTALL",
		"MONTH", "AFTER", "CLOSE", "SET_TP", "OWNER", "BLOOM_FILTER", "ILOG",
		"META", "STARTS", "PLANREGRESS", "AUTOEXTEND_SIZE", "SOURCE", "POW",
		"IGNORE_SERVER_IDS", "REPLICA_NUM", "LOWER_THAN_COMP", "BINDING", "MICROSECOND",
		"UNDO_BUFFER_SIZE", "SWITCHOVER", "EXTENDED_NOADDR", "GLOBAL_NAME",
		"SPLIT", "BASELINE", "MEMORY", "SEED", "RTREE", "RESOURCE", "STDDEV_POP",
		"RUN", "SQL_AFTER_GTIDS", "OPEN", "SQL_TSI_DAY", "STRING", "RELAY_THREAD",
		"BREADTH", "UNUSUAL", "RELAYLOG", "SQL_BEFORE_GTIDS", "PRIMARY_ZONE",
		"TABLE_CHECKSUM", "ZONE_LIST", "DATABASE_ID", "TP_NO", "BOOLEAN", "AVG",
		"MULTILINESTRING", "APPROX_COUNT_DISTINCT_SYNOPSIS_MERGE", "NOW", "PROXY",
		"DUPLICATE_SCOPE", "STATS_SAMPLE_PAGES", "TABLET_SIZE", "BASE", "KVCACHE",
		"RELAY", "CONTRIBUTORS", "PARTIAL", "REPORT", "ESCAPE", "MASTER_AUTO_POSITION",
		"DISKGROUP", "TP_NAME", "ACTIVATE", "SQL_AFTER_MTS_GAPS", "EFFECTIVE",
		"FIRST_VALUE", "SQL_TSI_MINUTE", "UNICODE", "QUARTER", "ANALYSE", "DEFINER",
		"NONE", "PROCESSLIST", "TYPE", "INSERT_METHOD", "EXTENDED", "LEVEL",
		"TIME_ZONE_INFO", "TIMESTAMPADD", "LOWER_INTO", "GET_FORMAT", "PREPARE",
		"STANDBY", "MATERIALIZED", "WORK", "HANDLER", "CUME_DIST", "LEAK", "INITIAL_SIZE",
		"RELAY_LOG_FILE", "STORING", "IMPORT", "MIN_MEMORY", "HELP", "CREATE_TIMESTAMP",
		"RANDOM", "SOUNDS", "TABLE_MODE", "COPY", "SESSION", "SQL_NO_CACHE",
		"EXECUTE", "PRECEDING", "SWITCHES", "PACK_KEYS", "SQL_ID", "TENANT_ID",
		"CHECKPOINT", "DAY", "GROUP_CONCAT", "LEAD", "EVENTS", "RECURSIVE",
		"ONLY", "TABLEGROUP_ID", "MASTER_SSL_CRL", "RESOURCE_POOL_LIST", "TRACING",
		"NTILE", "BUCKETS", "IS_TENANT_SYS_POOL", "SCHEDULE", "JOB", "MASTER_LOG_POS",
		"SUBCLASS_ORIGIN", "MULTIPOINT", "BLOCK", "SQL_TSI_SECOND", "DATE",
		"ROLLUP", "MIN_CPU", "OCCUR", "DATA", "MASTER_HOST", "ALGORITHM", "EXPIRED",
		"CONSTRAINT_NAME", "APPROX_COUNT_DISTINCT", "BASIC", "DEFAULT_TABLEGROUP",
		"LIST_", "WEEK", "NULLS", "DEC", "MASTER_SSL_CRLPATH", "CASCADED", "PLUGIN",
		"TENANT", "DECIMAL_VAL", "BOOL_VALUE", "At", "Quote", "HEX_STRING_VALUE",
		"DATE_VALUE", "HINT_VALUE", "Comma", "Plus", "And", "Or", "Star", "Not",
		"LeftParen", "Minus", "Div", "Caret", "Colon", "Dot", "Mod", "RightParen",
		"Tilde", "DELIMITER", "CNNOP", "AND_OP", "COMP_EQ", "SET_VAR", "COMP_NSEQ",
		"COMP_GE", "COMP_GT", "COMP_LE", "COMP_LT", "COMP_NE", "SHIFT_LEFT",
		"SHIFT_RIGHT", "QUESTIONMARK", "SYSTEM_VARIABLE", "USER_VARIABLE", "NAME_OB",
		"PARSER_SYNTAX_ERROR", "STRING_VALUE", "In_c_comment", "ANTLR_SKIP",
		"Blank", "LOAD_DATA_HINT_BEGIN", "REPLACE_HINT_BEGIN", "INSERT_HINT_BEGIN",
		"SELECT_HINT_BEGIN", "UPDATE_HINT_BEGIN", "DELETE_HINT_BEGIN", "HINT_END",
		"NO_REWRITE", "READ_CONSISTENCY", "INDEX_HINT", "QUERY_TIMEOUT", "FROZEN_VERSION",
		"TOPK", "HOTSPOT", "LOG_LEVEL", "LEADING_HINT", "ORDERED", "FULL_HINT",
		"USE_PLAN_CACHE", "USE_MERGE", "NO_USE_MERGE", "USE_HASH", "NO_USE_HASH",
		"USE_NL", "NO_USE_NL", "USE_BNL", "NO_USE_BNL", "USE_NL_MATERIALIZATION",
		"NO_USE_NL_MATERIALIZATION", "USE_HASH_AGGREGATION", "NO_USE_HASH_AGGREGATION",
		"MERGE_HINT", "NO_MERGE_HINT", "NO_EXPAND", "USE_CONCAT", "UNNEST",
		"NO_UNNEST", "PLACE_GROUP_BY", "NO_PLACE_GROUP_BY", "NO_PRED_DEDUCE",
		"USE_JIT", "NO_USE_JIT", "USE_LATE_MATERIALIZATION", "NO_USE_LATE_MATERIALIZATION",
		"TRACE_LOG", "STAT", "USE_PX", "NO_USE_PX", "TRANS_PARAM", "PX_JOIN_FILTER",
		"FORCE_REFRESH_LOCATION_CACHE", "QB_NAME", "MAX_CONCURRENT", "PARALLEL",
		"PQ_DISTRIBUTE", "LOAD_BATCH_SIZE", "RANDOM_LOCAL", "BROADCAST", "HINT_HINT_BEGIN",
	}
	staticData.RuleNames = []string{
		"sql_stmt", "stmt_list", "stmt", "expr_list", "expr_as_list", "expr_with_opt_alias",
		"column_ref", "complex_string_literal", "charset_introducer", "literal",
		"number_literal", "expr_const", "conf_const", "global_or_session_alias",
		"bool_pri", "predicate", "bit_expr", "simple_expr", "expr", "not", "not2",
		"sub_query_flag", "in_expr", "case_expr", "window_function", "first_or_last",
		"respect_or_ignore", "win_fun_first_last_params", "win_fun_lead_lag_params",
		"new_generalized_window_clause", "new_generalized_window_clause_with_blanket",
		"named_windows", "named_window", "generalized_window_clause", "win_rows_or_range",
		"win_preceding_or_following", "win_interval", "win_bounding", "win_window",
		"case_arg", "when_clause_list", "when_clause", "case_default", "func_expr",
		"sys_interval_func", "utc_timestamp_func", "sysdate_func", "cur_timestamp_func",
		"now_synonyms_func", "cur_time_func", "cur_date_func", "substr_or_substring",
		"substr_params", "date_params", "timestamp_params", "delete_stmt", "multi_delete_table",
		"update_stmt", "update_asgn_list", "update_asgn_factor", "create_resource_stmt",
		"opt_resource_unit_option_list", "resource_unit_option", "opt_create_resource_pool_option_list",
		"create_resource_pool_option", "alter_resource_pool_option_list", "unit_id_list",
		"alter_resource_pool_option", "alter_resource_stmt", "drop_resource_stmt",
		"create_tenant_stmt", "opt_tenant_option_list", "tenant_option", "zone_list",
		"resource_pool_list", "alter_tenant_stmt", "drop_tenant_stmt", "create_database_stmt",
		"database_key", "database_factor", "database_option_list", "charset_key",
		"database_option", "read_only_or_write", "drop_database_stmt", "alter_database_stmt",
		"load_data_stmt", "load_data_with_opt_hint", "lines_or_rows", "field_or_vars_list",
		"field_or_vars", "load_set_list", "load_set_element", "use_database_stmt",
		"create_synonym_stmt", "synonym_name", "synonym_object", "drop_synonym_stmt",
		"temporary_option", "create_table_like_stmt", "create_table_stmt", "ret_type",
		"create_function_stmt", "drop_function_stmt", "table_element_list",
		"table_element", "opt_reference_option_list", "reference_option", "reference_action",
		"match_action", "column_definition", "opt_generated_column_attribute_list",
		"generated_column_attribute", "column_definition_ref", "column_definition_list",
		"cast_data_type", "cast_datetime_type_i", "data_type", "string_list",
		"text_string", "int_type_i", "float_type_i", "datetime_type_i", "date_year_type_i",
		"text_type_i", "blob_type_i", "string_length_i", "collation_name", "trans_param_name",
		"trans_param_value", "charset_name", "charset_name_or_default", "collation",
		"opt_column_attribute_list", "column_attribute", "now_or_signed_literal",
		"signed_literal", "opt_comma", "table_option_list_space_seperated",
		"table_option_list", "primary_zone_name", "tablespace", "locality_name",
		"table_option", "relation_name_or_string", "opt_equal_mark", "partition_option",
		"opt_partition_option", "hash_partition_option", "list_partition_option",
		"key_partition_option", "range_partition_option", "opt_column_partition_option",
		"column_partition_option", "aux_column_list", "vertical_column_name",
		"column_name_list", "subpartition_option", "opt_list_partition_list",
		"opt_list_subpartition_list", "opt_range_partition_list", "opt_range_subpartition_list",
		"list_partition_list", "list_subpartition_list", "list_subpartition_element",
		"list_partition_element", "list_partition_expr", "list_expr", "range_partition_list",
		"range_partition_element", "range_subpartition_element", "range_subpartition_list",
		"range_partition_expr", "range_expr_list", "range_expr", "int_or_decimal",
		"tg_hash_partition_option", "tg_key_partition_option", "tg_range_partition_option",
		"tg_list_partition_option", "tg_subpartition_option", "row_format_option",
		"create_tablegroup_stmt", "drop_tablegroup_stmt", "alter_tablegroup_stmt",
		"tablegroup_option_list_space_seperated", "tablegroup_option_list",
		"tablegroup_option", "alter_tablegroup_actions", "alter_tablegroup_action",
		"default_tablegroup", "create_view_stmt", "view_select_stmt", "view_name",
		"create_index_stmt", "index_name", "opt_constraint_name", "constraint_name",
		"sort_column_list", "sort_column_key", "opt_index_options", "index_option",
		"index_using_algorithm", "drop_table_stmt", "table_or_tables", "drop_view_stmt",
		"table_list", "drop_index_stmt", "insert_stmt", "single_table_insert",
		"values_clause", "value_or_values", "replace_with_opt_hint", "insert_with_opt_hint",
		"column_list", "insert_vals_list", "insert_vals", "expr_or_default",
		"select_stmt", "select_into", "select_with_parens", "select_no_parens",
		"no_table_select", "select_clause", "select_clause_set_with_order_and_limit",
		"select_clause_set", "select_clause_set_right", "select_clause_set_left",
		"no_table_select_with_order_and_limit", "simple_select_with_order_and_limit",
		"select_with_parens_with_order_and_limit", "select_with_opt_hint", "update_with_opt_hint",
		"delete_with_opt_hint", "simple_select", "set_type_union", "set_type_other",
		"set_type", "set_expression_option", "opt_hint_value", "limit_clause",
		"into_clause", "into_opt", "into_var_list", "into_var", "field_opt",
		"field_term_list", "field_term", "line_opt", "line_term_list", "line_term",
		"hint_list_with_end", "opt_hint_list", "hint_options", "name_list",
		"hint_option", "consistency_level", "use_plan_cache_type", "use_jit_type",
		"distribute_method", "limit_expr", "opt_for_update_wait", "parameterized_trim",
		"groupby_clause", "sort_list_for_group_by", "sort_key_for_group_by",
		"order_by", "sort_list", "sort_key", "query_expression_option_list",
		"query_expression_option", "projection", "select_expr_list", "from_list",
		"table_references", "table_reference", "table_factor", "tbl_name", "dml_table_name",
		"seed", "opt_seed", "sample_percent", "sample_clause", "table_subquery",
		"use_partition", "index_hint_type", "key_or_index", "index_hint_scope",
		"index_element", "index_list", "index_hint_definition", "index_hint_list",
		"relation_factor", "relation_with_star_list", "relation_factor_with_star",
		"normal_relation_factor", "dot_relation_factor", "relation_factor_in_hint",
		"qb_name_option", "relation_factor_in_hint_list", "relation_sep_option",
		"relation_factor_in_pq_hint", "relation_factor_in_leading_hint", "relation_factor_in_leading_hint_list",
		"relation_factor_in_leading_hint_list_entry", "relation_factor_in_use_join_hint_list",
		"tracing_num_list", "join_condition", "joined_table", "natural_join_type",
		"inner_join_type", "outer_join_type", "analyze_stmt", "create_outline_stmt",
		"alter_outline_stmt", "drop_outline_stmt", "explain_stmt", "explain_or_desc",
		"explainable_stmt", "format_name", "show_stmt", "databases_or_schemas",
		"opt_for_grant_user", "columns_or_fields", "database_or_schema", "index_or_indexes_or_keys",
		"from_or_in", "help_stmt", "create_tablespace_stmt", "permanent_tablespace",
		"permanent_tablespace_option", "drop_tablespace_stmt", "alter_tablespace_actions",
		"alter_tablespace_action", "alter_tablespace_stmt", "rotate_master_key_stmt",
		"permanent_tablespace_options", "create_user_stmt", "user_specification_list",
		"user_specification", "require_specification", "tls_option_list", "tls_option",
		"user", "opt_host_name", "user_with_host_name", "password", "drop_user_stmt",
		"user_list", "set_password_stmt", "opt_for_user", "rename_user_stmt",
		"rename_info", "rename_list", "lock_user_stmt", "lock_spec_mysql57",
		"lock_tables_stmt", "unlock_tables_stmt", "lock_table_list", "lock_table",
		"lock_type", "begin_stmt", "commit_stmt", "rollback_stmt", "kill_stmt",
		"grant_stmt", "grant_privileges", "priv_type_list", "priv_type", "priv_level",
		"grant_options", "revoke_stmt", "prepare_stmt", "stmt_name", "preparable_stmt",
		"variable_set_stmt", "sys_var_and_val_list", "var_and_val_list", "set_expr_or_default",
		"var_and_val", "sys_var_and_val", "scope_or_scope_alias", "to_or_eq",
		"execute_stmt", "argument_list", "argument", "deallocate_prepare_stmt",
		"deallocate_or_drop", "truncate_table_stmt", "rename_table_stmt", "rename_table_actions",
		"rename_table_action", "alter_table_stmt", "alter_table_actions", "alter_table_action",
		"alter_constraint_option", "alter_partition_option", "opt_partition_range_or_list",
		"alter_tg_partition_option", "drop_partition_name_list", "modify_partition_info",
		"modify_tg_partition_info", "alter_index_option", "alter_foreign_key_action",
		"visibility_option", "alter_column_option", "alter_tablegroup_option",
		"alter_column_behavior", "flashback_stmt", "purge_stmt", "optimize_stmt",
		"dump_memory_stmt", "alter_system_stmt", "change_tenant_name_or_tenant_id",
		"cache_type", "balance_task_type", "tenant_list_tuple", "tenant_name_list",
		"flush_scope", "server_info_list", "server_info", "server_action", "server_list",
		"zone_action", "ip_port", "zone_desc", "server_or_zone", "add_or_alter_zone_option",
		"add_or_alter_zone_options", "alter_or_change_or_modify", "partition_id_desc",
		"partition_id_or_server_or_zone", "migrate_action", "change_actions",
		"change_action", "replica_type", "suspend_or_resume", "baseline_id_expr",
		"sql_id_expr", "baseline_asgn_factor", "tenant_name", "cache_name",
		"file_id", "cancel_task_type", "alter_system_set_parameter_actions",
		"alter_system_set_parameter_action", "alter_system_settp_actions", "settp_option",
		"cluster_role", "partition_role", "upgrade_action", "set_names_stmt",
		"set_charset_stmt", "set_transaction_stmt", "transaction_characteristics",
		"transaction_access_mode", "isolation_level", "create_savepoint_stmt",
		"rollback_savepoint_stmt", "release_savepoint_stmt", "alter_cluster_stmt",
		"cluster_action", "switchover_cluster_stmt", "commit_switchover_clause",
		"cluster_name", "var_name", "column_name", "relation_name", "function_name",
		"column_label", "date_unit", "unreserved_keyword", "unreserved_keyword_normal",
		"unreserved_keyword_special", "empty", "forward_expr", "forward_sql_stmt",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 985, 8307, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2,
		266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7,
		270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2,
		275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7,
		279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2,
		284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7,
		288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2,
		293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7,
		297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2,
		302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7,
		306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2,
		311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7,
		315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2,
		320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7,
		324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2,
		329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7,
		333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2,
		338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7,
		342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2,
		347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7,
		351, 2, 352, 7, 352, 2, 353, 7, 353, 2, 354, 7, 354, 2, 355, 7, 355, 2,
		356, 7, 356, 2, 357, 7, 357, 2, 358, 7, 358, 2, 359, 7, 359, 2, 360, 7,
		360, 2, 361, 7, 361, 2, 362, 7, 362, 2, 363, 7, 363, 2, 364, 7, 364, 2,
		365, 7, 365, 2, 366, 7, 366, 2, 367, 7, 367, 2, 368, 7, 368, 2, 369, 7,
		369, 2, 370, 7, 370, 2, 371, 7, 371, 2, 372, 7, 372, 2, 373, 7, 373, 2,
		374, 7, 374, 2, 375, 7, 375, 2, 376, 7, 376, 2, 377, 7, 377, 2, 378, 7,
		378, 2, 379, 7, 379, 2, 380, 7, 380, 2, 381, 7, 381, 2, 382, 7, 382, 2,
		383, 7, 383, 2, 384, 7, 384, 2, 385, 7, 385, 2, 386, 7, 386, 2, 387, 7,
		387, 2, 388, 7, 388, 2, 389, 7, 389, 2, 390, 7, 390, 2, 391, 7, 391, 2,
		392, 7, 392, 2, 393, 7, 393, 2, 394, 7, 394, 2, 395, 7, 395, 2, 396, 7,
		396, 2, 397, 7, 397, 2, 398, 7, 398, 2, 399, 7, 399, 2, 400, 7, 400, 2,
		401, 7, 401, 2, 402, 7, 402, 2, 403, 7, 403, 2, 404, 7, 404, 2, 405, 7,
		405, 2, 406, 7, 406, 2, 407, 7, 407, 2, 408, 7, 408, 2, 409, 7, 409, 2,
		410, 7, 410, 2, 411, 7, 411, 2, 412, 7, 412, 2, 413, 7, 413, 2, 414, 7,
		414, 2, 415, 7, 415, 2, 416, 7, 416, 2, 417, 7, 417, 2, 418, 7, 418, 2,
		419, 7, 419, 2, 420, 7, 420, 2, 421, 7, 421, 2, 422, 7, 422, 2, 423, 7,
		423, 2, 424, 7, 424, 2, 425, 7, 425, 2, 426, 7, 426, 2, 427, 7, 427, 2,
		428, 7, 428, 2, 429, 7, 429, 2, 430, 7, 430, 2, 431, 7, 431, 2, 432, 7,
		432, 2, 433, 7, 433, 2, 434, 7, 434, 2, 435, 7, 435, 2, 436, 7, 436, 2,
		437, 7, 437, 2, 438, 7, 438, 2, 439, 7, 439, 2, 440, 7, 440, 2, 441, 7,
		441, 2, 442, 7, 442, 2, 443, 7, 443, 2, 444, 7, 444, 2, 445, 7, 445, 2,
		446, 7, 446, 2, 447, 7, 447, 2, 448, 7, 448, 2, 449, 7, 449, 2, 450, 7,
		450, 2, 451, 7, 451, 2, 452, 7, 452, 2, 453, 7, 453, 2, 454, 7, 454, 2,
		455, 7, 455, 2, 456, 7, 456, 2, 457, 7, 457, 2, 458, 7, 458, 2, 459, 7,
		459, 2, 460, 7, 460, 2, 461, 7, 461, 2, 462, 7, 462, 2, 463, 7, 463, 2,
		464, 7, 464, 2, 465, 7, 465, 2, 466, 7, 466, 2, 467, 7, 467, 2, 468, 7,
		468, 2, 469, 7, 469, 2, 470, 7, 470, 2, 471, 7, 471, 2, 472, 7, 472, 2,
		473, 7, 473, 2, 474, 7, 474, 2, 475, 7, 475, 2, 476, 7, 476, 1, 0, 1, 0,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 965, 8, 1, 3, 1,
		967, 8, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 3, 2, 1042, 8, 2, 1, 3, 1, 3, 1, 3, 5, 3, 1047, 8, 3,
		10, 3, 12, 3, 1050, 9, 3, 1, 4, 1, 4, 1, 4, 5, 4, 1055, 8, 4, 10, 4, 12,
		4, 1058, 9, 4, 1, 5, 1, 5, 1, 5, 3, 5, 1063, 8, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 3, 5, 1069, 8, 5, 1, 5, 1, 5, 3, 5, 1073, 8, 5, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 1101,
		8, 6, 1, 7, 3, 7, 1104, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 1110, 8, 7,
		1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9,
		1123, 8, 9, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 3, 11, 1134, 8, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3,
		12, 1153, 8, 12, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 5, 14, 1231, 8, 14, 10, 14, 12, 14,
		1234, 9, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 3, 15, 1290, 8, 15, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 5, 16, 1343, 8, 16, 10, 16, 12, 16,
		1346, 9, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 1396, 8,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 1404, 8, 17, 1, 17,
		1, 17, 1, 17, 1, 17, 1, 17, 5, 17, 1411, 8, 17, 10, 17, 12, 17, 1414, 9,
		17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
		1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1441, 8, 18, 1, 18, 1, 18, 1, 18,
		1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 5, 18, 1458, 8, 18, 10, 18, 12, 18, 1461, 9, 18, 1, 19, 1, 19,
		1, 20, 1, 20, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1474,
		8, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 3,
		24, 1485, 8, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24,
		1494, 8, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1,
		24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24,
		1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1,
		24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 1533, 8, 24,
		1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 1543, 8,
		24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 1553,
		8, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 1563,
		8, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 1573,
		8, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 1583,
		8, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 1593,
		8, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 1603,
		8, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 1613,
		8, 24, 1, 24, 1, 24, 3, 24, 1617, 8, 24, 1, 24, 1, 24, 3, 24, 1621, 8,
		24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 1630, 8, 24,
		1, 24, 1, 24, 3, 24, 1634, 8, 24, 1, 24, 1, 24, 3, 24, 1638, 8, 24, 1,
		24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24,
		1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1,
		24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24,
		1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1,
		24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24,
		1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1,
		24, 3, 24, 1704, 8, 24, 1, 24, 1, 24, 1, 24, 3, 24, 1709, 8, 24, 1, 24,
		1, 24, 1, 24, 3, 24, 1714, 8, 24, 1, 25, 1, 25, 1, 26, 1, 26, 1, 27, 1,
		27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27,
		3, 27, 1732, 8, 27, 3, 27, 1734, 8, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28,
		1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 1756, 8, 28, 3, 28, 1758, 8,
		28, 1, 29, 1, 29, 3, 29, 1762, 8, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1773, 8, 30, 1, 31, 1, 31, 1, 31, 5,
		31, 1778, 8, 31, 10, 31, 12, 31, 1781, 9, 31, 1, 32, 1, 32, 1, 32, 1, 32,
		1, 33, 1, 33, 1, 33, 3, 33, 1790, 8, 33, 1, 33, 3, 33, 1793, 8, 33, 1,
		33, 3, 33, 1796, 8, 33, 1, 34, 1, 34, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36,
		1, 36, 1, 36, 3, 36, 1807, 8, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 3,
		37, 1814, 8, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38,
		1, 38, 3, 38, 1825, 8, 38, 1, 39, 3, 39, 1828, 8, 39, 1, 40, 4, 40, 1831,
		8, 40, 11, 40, 12, 40, 1832, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 42,
		1, 42, 1, 42, 3, 42, 1843, 8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 1855, 8, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 3, 43, 1862, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 1897, 8, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 1905, 8, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 3, 43, 1913, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 3, 43, 1921, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 3, 43, 1929, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43,
		1937, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 1945, 8,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 1953, 8, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3,
		43, 1966, 8, 43, 1, 43, 1, 43, 3, 43, 1970, 8, 43, 1, 43, 1, 43, 3, 43,
		1974, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 3, 43, 2186, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 3, 43, 2195, 8, 43, 1, 43, 1, 43, 1, 43, 3, 43, 2200, 8, 43,
		1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1,
		44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 2218, 8, 44, 1, 45, 1, 45,
		1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 2227, 8, 45, 1, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 2236, 8, 46, 1, 47, 1, 47, 1, 47,
		1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3,
		47, 2251, 8, 47, 3, 47, 2253, 8, 47, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3,
		49, 2270, 8, 49, 3, 49, 2272, 8, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50,
		1, 50, 1, 50, 3, 50, 2281, 8, 50, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 2305, 8, 52, 1, 53, 1,
		53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54,
		1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 2326, 8, 55, 1,
		55, 3, 55, 2329, 8, 55, 1, 55, 3, 55, 2332, 8, 55, 1, 55, 1, 55, 1, 55,
		1, 55, 1, 55, 1, 55, 3, 55, 2340, 8, 55, 3, 55, 2342, 8, 55, 1, 56, 1,
		56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 2353, 8, 56,
		1, 57, 1, 57, 3, 57, 2357, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1,
		57, 1, 57, 3, 57, 2366, 8, 57, 1, 57, 3, 57, 2369, 8, 57, 1, 57, 3, 57,
		2372, 8, 57, 1, 58, 1, 58, 1, 58, 5, 58, 2377, 8, 58, 10, 58, 12, 58, 2380,
		9, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1,
		60, 1, 60, 3, 60, 2393, 8, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60,
		3, 60, 2401, 8, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3,
		60, 2410, 8, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 2418,
		8, 60, 3, 60, 2420, 8, 60, 1, 61, 1, 61, 1, 61, 3, 61, 2425, 8, 61, 1,
		61, 1, 61, 1, 61, 5, 61, 2430, 8, 61, 10, 61, 12, 61, 2433, 9, 61, 1, 62,
		1, 62, 3, 62, 2437, 8, 62, 1, 62, 1, 62, 1, 62, 3, 62, 2442, 8, 62, 1,
		62, 1, 62, 1, 62, 3, 62, 2447, 8, 62, 1, 62, 1, 62, 1, 62, 3, 62, 2452,
		8, 62, 1, 62, 1, 62, 1, 62, 3, 62, 2457, 8, 62, 1, 62, 1, 62, 1, 62, 3,
		62, 2462, 8, 62, 1, 62, 1, 62, 1, 62, 3, 62, 2467, 8, 62, 1, 62, 1, 62,
		1, 62, 3, 62, 2472, 8, 62, 1, 62, 3, 62, 2475, 8, 62, 1, 63, 1, 63, 1,
		63, 3, 63, 2480, 8, 63, 1, 63, 1, 63, 1, 63, 5, 63, 2485, 8, 63, 10, 63,
		12, 63, 2488, 9, 63, 1, 64, 1, 64, 3, 64, 2492, 8, 64, 1, 64, 1, 64, 1,
		64, 3, 64, 2497, 8, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2502, 8, 64, 1, 64,
		1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2510, 8, 64, 1, 64, 1, 64, 1,
		64, 3, 64, 2515, 8, 64, 1, 64, 3, 64, 2518, 8, 64, 1, 65, 1, 65, 1, 65,
		5, 65, 2523, 8, 65, 10, 65, 12, 65, 2526, 9, 65, 1, 66, 1, 66, 1, 66, 5,
		66, 2531, 8, 66, 10, 66, 12, 66, 2534, 9, 66, 1, 67, 1, 67, 3, 67, 2538,
		8, 67, 1, 67, 1, 67, 1, 67, 3, 67, 2543, 8, 67, 1, 67, 1, 67, 1, 67, 1,
		67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 2553, 8, 67, 1, 67, 1, 67, 3, 67,
		2557, 8, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 2563, 8, 67, 1, 68, 1,
		68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 2574, 8, 68,
		1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1,
		68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68,
		2596, 8, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 3, 69, 2603, 8, 69, 1,
		69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 3, 69, 2611, 8, 69, 1, 69, 3, 69,
		2614, 8, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 2622, 8,
		70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 2630, 8, 70, 1, 70,
		1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 2639, 8, 70, 1, 71, 1,
		71, 1, 71, 3, 71, 2644, 8, 71, 1, 71, 1, 71, 1, 71, 5, 71, 2649, 8, 71,
		10, 71, 12, 71, 2652, 9, 71, 1, 72, 1, 72, 3, 72, 2656, 8, 72, 1, 72, 1,
		72, 1, 72, 3, 72, 2661, 8, 72, 1, 72, 1, 72, 3, 72, 2665, 8, 72, 1, 72,
		1, 72, 3, 72, 2669, 8, 72, 1, 72, 1, 72, 1, 72, 3, 72, 2674, 8, 72, 1,
		72, 1, 72, 1, 72, 3, 72, 2679, 8, 72, 1, 72, 1, 72, 1, 72, 3, 72, 2684,
		8, 72, 1, 72, 1, 72, 1, 72, 3, 72, 2689, 8, 72, 1, 72, 1, 72, 1, 72, 3,
		72, 2694, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 2702,
		8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 2710, 8, 72, 1,
		72, 1, 72, 1, 72, 1, 72, 3, 72, 2716, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72,
		3, 72, 2722, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 2728, 8, 72, 1,
		72, 3, 72, 2731, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73, 5, 73, 2737, 8, 73,
		10, 73, 12, 73, 2740, 9, 73, 1, 74, 1, 74, 1, 74, 5, 74, 2745, 8, 74, 10,
		74, 12, 74, 2748, 9, 74, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 2754, 8, 75,
		1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 2761, 8, 75, 1, 75, 1, 75, 3,
		75, 2765, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 2771, 8, 75, 1, 75,
		1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 2778, 8, 75, 1, 75, 1, 75, 3, 75, 2782,
		8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1,
		75, 1, 75, 1, 75, 1, 75, 3, 75, 2797, 8, 75, 1, 76, 1, 76, 1, 76, 1, 76,
		3, 76, 2803, 8, 76, 1, 76, 1, 76, 3, 76, 2807, 8, 76, 1, 77, 1, 77, 1,
		77, 1, 77, 1, 77, 1, 77, 3, 77, 2815, 8, 77, 1, 77, 1, 77, 3, 77, 2819,
		8, 77, 1, 78, 1, 78, 1, 79, 1, 79, 1, 80, 4, 80, 2826, 8, 80, 11, 80, 12,
		80, 2827, 1, 81, 1, 81, 1, 81, 3, 81, 2833, 8, 81, 1, 82, 3, 82, 2836,
		8, 82, 1, 82, 1, 82, 3, 82, 2840, 8, 82, 1, 82, 1, 82, 1, 82, 3, 82, 2845,
		8, 82, 1, 82, 1, 82, 3, 82, 2849, 8, 82, 1, 82, 1, 82, 1, 82, 3, 82, 2854,
		8, 82, 1, 82, 1, 82, 1, 82, 3, 82, 2859, 8, 82, 1, 82, 1, 82, 1, 82, 1,
		82, 1, 82, 3, 82, 2866, 8, 82, 1, 82, 3, 82, 2869, 8, 82, 1, 83, 1, 83,
		1, 83, 1, 83, 3, 83, 2875, 8, 83, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 2881,
		8, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 3, 85, 2888, 8, 85, 1, 85, 3,
		85, 2891, 8, 85, 1, 85, 1, 85, 1, 86, 1, 86, 3, 86, 2897, 8, 86, 1, 86,
		1, 86, 1, 86, 3, 86, 2902, 8, 86, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86, 2908,
		8, 86, 1, 86, 1, 86, 1, 86, 3, 86, 2913, 8, 86, 1, 86, 1, 86, 1, 86, 1,
		86, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86, 2923, 8, 86, 1, 86, 1, 86, 1, 86,
		1, 86, 1, 86, 1, 86, 3, 86, 2931, 8, 86, 1, 86, 1, 86, 3, 86, 2935, 8,
		86, 1, 87, 1, 87, 1, 87, 1, 87, 3, 87, 2941, 8, 87, 1, 88, 1, 88, 1, 89,
		1, 89, 1, 89, 5, 89, 2948, 8, 89, 10, 89, 12, 89, 2951, 9, 89, 1, 90, 1,
		90, 3, 90, 2955, 8, 90, 1, 91, 1, 91, 1, 91, 5, 91, 2960, 8, 91, 10, 91,
		12, 91, 2963, 9, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1,
		94, 1, 94, 1, 94, 3, 94, 2975, 8, 94, 1, 94, 3, 94, 2978, 8, 94, 1, 94,
		1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 2986, 8, 94, 1, 94, 1, 94, 1,
		94, 3, 94, 2991, 8, 94, 1, 94, 3, 94, 2994, 8, 94, 1, 94, 1, 94, 1, 94,
		1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 3004, 8, 94, 1, 94, 1, 94, 1,
		94, 3, 94, 3009, 8, 94, 1, 94, 3, 94, 3012, 8, 94, 1, 94, 1, 94, 1, 94,
		1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 3022, 8, 94, 1, 94, 1, 94, 1,
		94, 3, 94, 3027, 8, 94, 1, 94, 3, 94, 3030, 8, 94, 1, 94, 1, 94, 1, 94,
		1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 3042, 8, 94, 3,
		94, 3044, 8, 94, 1, 95, 1, 95, 3, 95, 3048, 8, 95, 1, 96, 1, 96, 3, 96,
		3052, 8, 96, 1, 97, 1, 97, 3, 97, 3056, 8, 97, 1, 97, 1, 97, 1, 97, 3,
		97, 3061, 8, 97, 1, 97, 1, 97, 3, 97, 3065, 8, 97, 1, 97, 1, 97, 1, 97,
		1, 97, 1, 97, 3, 97, 3072, 8, 97, 3, 97, 3074, 8, 97, 1, 98, 3, 98, 3077,
		8, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 3086, 8,
		99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99,
		1, 99, 3, 99, 3099, 8, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3,
		99, 3107, 8, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		3, 100, 3116, 8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 3123,
		8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 3, 100, 3134, 8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3,
		100, 3141, 8, 100, 1, 100, 1, 100, 3, 100, 3145, 8, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 3156, 8,
		100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 3162, 8, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 3173, 8,
		100, 1, 100, 1, 100, 1, 100, 3, 100, 3178, 8, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 3189, 8, 100, 1,
		100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1,
		100, 3, 100, 3201, 8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 3207,
		8, 100, 1, 101, 1, 101, 1, 102, 1, 102, 3, 102, 3213, 8, 102, 1, 102, 1,
		102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103, 1,
		103, 3, 103, 3226, 8, 103, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 5, 104,
		3233, 8, 104, 10, 104, 12, 104, 3236, 9, 104, 1, 105, 1, 105, 1, 105, 3,
		105, 3241, 8, 105, 1, 105, 1, 105, 1, 105, 3, 105, 3246, 8, 105, 1, 105,
		1, 105, 1, 105, 1, 105, 3, 105, 3252, 8, 105, 1, 105, 1, 105, 3, 105, 3256,
		8, 105, 1, 105, 1, 105, 3, 105, 3260, 8, 105, 1, 105, 3, 105, 3263, 8,
		105, 1, 105, 1, 105, 1, 105, 1, 105, 3, 105, 3269, 8, 105, 1, 105, 1, 105,
		3, 105, 3273, 8, 105, 1, 105, 3, 105, 3276, 8, 105, 1, 105, 3, 105, 3279,
		8, 105, 1, 105, 1, 105, 1, 105, 1, 105, 3, 105, 3285, 8, 105, 1, 105, 1,
		105, 3, 105, 3289, 8, 105, 1, 105, 1, 105, 3, 105, 3293, 8, 105, 1, 105,
		3, 105, 3296, 8, 105, 1, 105, 3, 105, 3299, 8, 105, 1, 105, 1, 105, 1,
		105, 1, 105, 3, 105, 3305, 8, 105, 1, 105, 1, 105, 3, 105, 3309, 8, 105,
		1, 105, 3, 105, 3312, 8, 105, 1, 105, 3, 105, 3315, 8, 105, 1, 105, 1,
		105, 1, 105, 1, 105, 3, 105, 3321, 8, 105, 1, 105, 1, 105, 1, 105, 1, 105,
		1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 3, 105, 3332, 8, 105, 1, 105, 1,
		105, 1, 105, 3, 105, 3337, 8, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105,
		1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 3, 105, 3349, 8, 105, 1, 105, 1,
		105, 1, 105, 3, 105, 3354, 8, 105, 3, 105, 3356, 8, 105, 1, 106, 1, 106,
		1, 106, 1, 106, 1, 106, 5, 106, 3363, 8, 106, 10, 106, 12, 106, 3366, 9,
		106, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 3, 107, 3374, 8, 107,
		1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108,
		3384, 8, 108, 1, 109, 1, 109, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 3,
		110, 3393, 8, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 3, 110, 3400,
		8, 110, 1, 110, 1, 110, 1, 110, 1, 110, 3, 110, 3406, 8, 110, 1, 110, 1,
		110, 1, 110, 1, 110, 1, 110, 3, 110, 3413, 8, 110, 1, 110, 1, 110, 1, 110,
		3, 110, 3418, 8, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 3, 110, 3425,
		8, 110, 3, 110, 3427, 8, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 5,
		111, 3434, 8, 111, 10, 111, 12, 111, 3437, 9, 111, 1, 112, 1, 112, 1, 112,
		1, 112, 1, 112, 1, 112, 3, 112, 3445, 8, 112, 1, 112, 1, 112, 1, 112, 1,
		112, 1, 112, 1, 112, 3, 112, 3453, 8, 112, 1, 113, 1, 113, 1, 113, 1, 113,
		1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 3, 113, 3466, 8,
		113, 1, 114, 1, 114, 1, 114, 5, 114, 3471, 8, 114, 10, 114, 12, 114, 3474,
		9, 114, 1, 115, 1, 115, 3, 115, 3478, 8, 115, 1, 115, 1, 115, 3, 115, 3482,
		8, 115, 1, 115, 3, 115, 3485, 8, 115, 1, 115, 1, 115, 1, 115, 1, 115, 3,
		115, 3491, 8, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115,
		1, 115, 1, 115, 3, 115, 3502, 8, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1,
		115, 1, 115, 1, 115, 1, 115, 1, 115, 3, 115, 3513, 8, 115, 1, 115, 1, 115,
		3, 115, 3517, 8, 115, 1, 115, 1, 115, 3, 115, 3521, 8, 115, 1, 115, 3,
		115, 3524, 8, 115, 1, 116, 1, 116, 1, 117, 1, 117, 1, 117, 1, 117, 3, 117,
		3532, 8, 117, 1, 117, 3, 117, 3535, 8, 117, 1, 117, 3, 117, 3538, 8, 117,
		1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117,
		3, 117, 3549, 8, 117, 1, 117, 3, 117, 3552, 8, 117, 1, 117, 3, 117, 3555,
		8, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117,
		1, 117, 3, 117, 3566, 8, 117, 1, 117, 3, 117, 3569, 8, 117, 1, 117, 3,
		117, 3572, 8, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117,
		1, 117, 1, 117, 3, 117, 3583, 8, 117, 1, 117, 3, 117, 3586, 8, 117, 1,
		117, 3, 117, 3589, 8, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117,
		3, 117, 3597, 8, 117, 1, 117, 1, 117, 1, 117, 3, 117, 3602, 8, 117, 1,
		117, 3, 117, 3605, 8, 117, 1, 117, 1, 117, 1, 117, 3, 117, 3610, 8, 117,
		1, 117, 3, 117, 3613, 8, 117, 1, 117, 1, 117, 1, 117, 3, 117, 3618, 8,
		117, 1, 117, 1, 117, 1, 117, 3, 117, 3623, 8, 117, 1, 117, 3, 117, 3626,
		8, 117, 1, 117, 1, 117, 3, 117, 3630, 8, 117, 1, 117, 1, 117, 3, 117, 3634,
		8, 117, 1, 117, 3, 117, 3637, 8, 117, 1, 117, 1, 117, 1, 117, 3, 117, 3642,
		8, 117, 1, 117, 3, 117, 3645, 8, 117, 1, 117, 1, 117, 3, 117, 3649, 8,
		117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 3, 117, 3658,
		8, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 3, 117, 3665, 8, 117, 1,
		117, 1, 117, 1, 117, 3, 117, 3670, 8, 117, 1, 117, 3, 117, 3673, 8, 117,
		1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 3, 117, 3680, 8, 117, 1, 117, 1,
		117, 1, 117, 3, 117, 3685, 8, 117, 1, 117, 3, 117, 3688, 8, 117, 3, 117,
		3690, 8, 117, 1, 118, 1, 118, 1, 118, 5, 118, 3695, 8, 118, 10, 118, 12,
		118, 3698, 9, 118, 1, 119, 1, 119, 1, 120, 1, 120, 1, 121, 1, 121, 1, 121,
		1, 121, 1, 121, 1, 121, 1, 121, 3, 121, 3711, 8, 121, 1, 122, 1, 122, 1,
		123, 1, 123, 1, 123, 1, 123, 1, 123, 3, 123, 3720, 8, 123, 3, 123, 3722,
		8, 123, 1, 124, 1, 124, 1, 125, 1, 125, 1, 126, 1, 126, 1, 126, 1, 126,
		1, 127, 1, 127, 1, 128, 1, 128, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129,
		1, 129, 3, 129, 3742, 8, 129, 1, 130, 1, 130, 1, 131, 1, 131, 3, 131, 3748,
		8, 131, 1, 132, 1, 132, 1, 132, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133,
		5, 133, 3758, 8, 133, 10, 133, 12, 133, 3761, 9, 133, 1, 134, 1, 134, 1,
		134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1,
		134, 3, 134, 3775, 8, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134,
		1, 134, 1, 134, 1, 134, 3, 134, 3786, 8, 134, 1, 135, 1, 135, 3, 135, 3790,
		8, 135, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 3, 136, 3797, 8, 136, 1,
		137, 3, 137, 3800, 8, 137, 1, 138, 1, 138, 1, 138, 1, 138, 3, 138, 3806,
		8, 138, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 3, 139, 3813, 8, 139, 1,
		140, 1, 140, 1, 140, 3, 140, 3818, 8, 140, 1, 141, 1, 141, 1, 142, 1, 142,
		1, 143, 1, 143, 3, 143, 3826, 8, 143, 1, 143, 1, 143, 1, 143, 3, 143, 3831,
		8, 143, 1, 143, 1, 143, 1, 143, 3, 143, 3836, 8, 143, 1, 143, 1, 143, 3,
		143, 3840, 8, 143, 1, 143, 1, 143, 3, 143, 3844, 8, 143, 1, 143, 1, 143,
		1, 143, 1, 143, 1, 143, 1, 143, 3, 143, 3852, 8, 143, 1, 143, 1, 143, 1,
		143, 3, 143, 3857, 8, 143, 1, 143, 1, 143, 1, 143, 3, 143, 3862, 8, 143,
		1, 143, 1, 143, 1, 143, 3, 143, 3867, 8, 143, 1, 143, 1, 143, 1, 143, 3,
		143, 3872, 8, 143, 1, 143, 1, 143, 1, 143, 3, 143, 3877, 8, 143, 1, 143,
		1, 143, 1, 143, 3, 143, 3882, 8, 143, 1, 143, 1, 143, 1, 143, 3, 143, 3887,
		8, 143, 1, 143, 1, 143, 3, 143, 3891, 8, 143, 1, 143, 1, 143, 3, 143, 3895,
		8, 143, 1, 143, 1, 143, 1, 143, 3, 143, 3900, 8, 143, 1, 143, 1, 143, 3,
		143, 3904, 8, 143, 1, 143, 1, 143, 1, 143, 3, 143, 3909, 8, 143, 1, 143,
		1, 143, 1, 143, 3, 143, 3914, 8, 143, 1, 143, 1, 143, 1, 143, 3, 143, 3919,
		8, 143, 1, 143, 1, 143, 1, 143, 3, 143, 3924, 8, 143, 1, 143, 1, 143, 1,
		143, 1, 143, 3, 143, 3930, 8, 143, 1, 143, 1, 143, 1, 143, 3, 143, 3935,
		8, 143, 1, 143, 1, 143, 1, 143, 3, 143, 3940, 8, 143, 1, 143, 1, 143, 1,
		143, 3, 143, 3945, 8, 143, 1, 143, 1, 143, 1, 143, 3, 143, 3950, 8, 143,
		1, 144, 1, 144, 1, 144, 3, 144, 3955, 8, 144, 1, 145, 3, 145, 3958, 8,
		145, 1, 146, 1, 146, 1, 146, 1, 146, 3, 146, 3964, 8, 146, 1, 147, 1, 147,
		1, 147, 1, 147, 3, 147, 3970, 8, 147, 1, 148, 1, 148, 1, 148, 1, 148, 1,
		148, 1, 148, 1, 148, 1, 148, 1, 148, 3, 148, 3981, 8, 148, 1, 149, 1, 149,
		1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 3, 149, 3992, 8,
		149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1,
		149, 1, 149, 1, 149, 1, 149, 3, 149, 4006, 8, 149, 1, 149, 1, 149, 3, 149,
		4010, 8, 149, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 1,
		150, 1, 150, 3, 150, 4021, 8, 150, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150,
		1, 150, 1, 150, 1, 150, 3, 150, 4031, 8, 150, 3, 150, 4033, 8, 150, 1,
		151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 3,
		151, 4044, 8, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151,
		1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 3, 151, 4058, 8, 151, 1, 151, 1,
		151, 3, 151, 4062, 8, 151, 1, 152, 3, 152, 4065, 8, 152, 1, 153, 1, 153,
		1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153,
		1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 3, 153, 4083, 8, 153, 1, 154, 1,
		154, 1, 154, 5, 154, 4088, 8, 154, 10, 154, 12, 154, 4091, 9, 154, 1, 155,
		1, 155, 1, 155, 1, 155, 1, 155, 3, 155, 4098, 8, 155, 1, 156, 1, 156, 1,
		156, 5, 156, 4103, 8, 156, 10, 156, 12, 156, 4106, 9, 156, 1, 157, 1, 157,
		1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157,
		1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157,
		1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157,
		3, 157, 4137, 8, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1,
		157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1,
		157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1,
		157, 1, 157, 1, 157, 1, 157, 1, 157, 3, 157, 4168, 8, 157, 1, 157, 3, 157,
		4171, 8, 157, 1, 158, 1, 158, 1, 158, 1, 158, 1, 159, 1, 159, 1, 159, 1,
		159, 1, 160, 1, 160, 1, 160, 1, 160, 1, 161, 1, 161, 1, 161, 1, 161, 1,
		162, 1, 162, 1, 162, 5, 162, 4192, 8, 162, 10, 162, 12, 162, 4195, 9, 162,
		1, 163, 1, 163, 1, 163, 5, 163, 4200, 8, 163, 10, 163, 12, 163, 4203, 9,
		163, 1, 164, 1, 164, 1, 164, 1, 164, 1, 164, 1, 164, 1, 165, 1, 165, 1,
		165, 1, 165, 1, 165, 1, 165, 1, 165, 3, 165, 4218, 8, 165, 1, 166, 1, 166,
		1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 3, 166, 4227, 8, 166, 1, 167, 1,
		167, 1, 167, 5, 167, 4232, 8, 167, 10, 167, 12, 167, 4235, 9, 167, 1, 168,
		1, 168, 1, 168, 5, 168, 4240, 8, 168, 10, 168, 12, 168, 4243, 9, 168, 1,
		169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 3, 169, 4253,
		8, 169, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 171,
		1, 171, 1, 171, 5, 171, 4265, 8, 171, 10, 171, 12, 171, 4268, 9, 171, 1,
		172, 1, 172, 1, 172, 1, 172, 1, 172, 3, 172, 4275, 8, 172, 1, 173, 1, 173,
		1, 173, 5, 173, 4280, 8, 173, 10, 173, 12, 173, 4283, 9, 173, 1, 174, 1,
		174, 3, 174, 4287, 8, 174, 1, 175, 1, 175, 1, 176, 1, 176, 1, 176, 1, 176,
		1, 176, 1, 176, 3, 176, 4297, 8, 176, 1, 177, 1, 177, 1, 177, 1, 177, 1,
		177, 1, 177, 1, 177, 3, 177, 4306, 8, 177, 1, 178, 1, 178, 1, 178, 1, 178,
		1, 178, 1, 178, 3, 178, 4314, 8, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1,
		178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 3, 178, 4326, 8, 178, 1, 178,
		1, 178, 3, 178, 4330, 8, 178, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1,
		179, 3, 179, 4338, 8, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179,
		1, 179, 1, 179, 1, 179, 1, 179, 3, 179, 4350, 8, 179, 1, 179, 1, 179, 3,
		179, 4354, 8, 179, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180,
		1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180,
		1, 180, 1, 180, 1, 180, 3, 180, 4375, 8, 180, 1, 180, 1, 180, 1, 180, 1,
		180, 1, 180, 1, 180, 3, 180, 4383, 8, 180, 1, 180, 1, 180, 1, 180, 1, 180,
		1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180,
		1, 180, 1, 180, 3, 180, 4400, 8, 180, 1, 181, 1, 181, 1, 182, 1, 182, 1,
		182, 1, 182, 1, 182, 1, 182, 3, 182, 4410, 8, 182, 1, 182, 1, 182, 3, 182,
		4414, 8, 182, 1, 182, 1, 182, 1, 182, 1, 182, 3, 182, 4420, 8, 182, 1,
		183, 1, 183, 1, 183, 1, 183, 3, 183, 4426, 8, 183, 1, 183, 1, 183, 1, 184,
		1, 184, 1, 184, 1, 184, 1, 184, 3, 184, 4435, 8, 184, 1, 184, 1, 184, 1,
		184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1,
		184, 3, 184, 4449, 8, 184, 1, 185, 1, 185, 1, 185, 1, 185, 3, 185, 4455,
		8, 185, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 3, 186, 4462, 8, 186, 1,
		187, 1, 187, 3, 187, 4466, 8, 187, 1, 187, 1, 187, 3, 187, 4470, 8, 187,
		1, 187, 1, 187, 3, 187, 4474, 8, 187, 1, 187, 1, 187, 1, 187, 3, 187, 4479,
		8, 187, 1, 187, 1, 187, 1, 187, 3, 187, 4484, 8, 187, 1, 187, 1, 187, 1,
		187, 3, 187, 4489, 8, 187, 1, 187, 3, 187, 4492, 8, 187, 1, 188, 1, 188,
		1, 188, 5, 188, 4497, 8, 188, 10, 188, 12, 188, 4500, 9, 188, 1, 189, 3,
		189, 4503, 8, 189, 1, 189, 1, 189, 1, 190, 3, 190, 4508, 8, 190, 1, 190,
		1, 190, 3, 190, 4512, 8, 190, 1, 190, 1, 190, 3, 190, 4516, 8, 190, 1,
		190, 1, 190, 3, 190, 4520, 8, 190, 1, 190, 3, 190, 4523, 8, 190, 1, 191,
		1, 191, 1, 191, 3, 191, 4528, 8, 191, 1, 191, 3, 191, 4531, 8, 191, 1,
		191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 3, 191, 4539, 8, 191, 1, 191,
		1, 191, 1, 191, 3, 191, 4544, 8, 191, 1, 191, 1, 191, 1, 191, 1, 192, 1,
		192, 1, 193, 1, 193, 1, 194, 1, 194, 3, 194, 4555, 8, 194, 1, 194, 1, 194,
		1, 194, 1, 194, 1, 194, 3, 194, 4562, 8, 194, 1, 194, 1, 194, 3, 194, 4566,
		8, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 3, 194, 4574, 8,
		194, 1, 194, 1, 194, 1, 195, 1, 195, 1, 196, 3, 196, 4581, 8, 196, 1, 197,
		1, 197, 1, 198, 1, 198, 1, 198, 5, 198, 4588, 8, 198, 10, 198, 12, 198,
		4591, 9, 198, 1, 199, 1, 199, 1, 199, 1, 199, 3, 199, 4597, 8, 199, 1,
		199, 3, 199, 4600, 8, 199, 1, 199, 1, 199, 3, 199, 4604, 8, 199, 1, 200,
		4, 200, 4607, 8, 200, 11, 200, 12, 200, 4608, 1, 201, 1, 201, 1, 201, 1,
		201, 3, 201, 4615, 8, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201,
		1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201,
		1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 3, 201, 4638, 8, 201, 1,
		201, 1, 201, 1, 201, 3, 201, 4643, 8, 201, 1, 201, 1, 201, 1, 201, 3, 201,
		4648, 8, 201, 1, 201, 1, 201, 1, 201, 3, 201, 4653, 8, 201, 1, 201, 3,
		201, 4656, 8, 201, 1, 202, 1, 202, 1, 202, 1, 202, 3, 202, 4662, 8, 202,
		1, 203, 1, 203, 3, 203, 4666, 8, 203, 1, 203, 1, 203, 1, 203, 3, 203, 4671,
		8, 203, 1, 203, 1, 203, 3, 203, 4675, 8, 203, 1, 204, 1, 204, 1, 205, 1,
		205, 3, 205, 4681, 8, 205, 1, 205, 1, 205, 1, 205, 3, 205, 4686, 8, 205,
		1, 205, 1, 205, 3, 205, 4690, 8, 205, 1, 206, 1, 206, 1, 206, 5, 206, 4695,
		8, 206, 10, 206, 12, 206, 4698, 9, 206, 1, 207, 1, 207, 1, 207, 1, 207,
		1, 207, 1, 207, 1, 208, 1, 208, 3, 208, 4708, 8, 208, 1, 208, 3, 208, 4711,
		8, 208, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 3, 208, 4719, 8,
		208, 1, 208, 1, 208, 3, 208, 4723, 8, 208, 1, 208, 3, 208, 4726, 8, 208,
		1, 208, 1, 208, 3, 208, 4730, 8, 208, 1, 209, 1, 209, 1, 209, 1, 209, 1,
		209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1,
		209, 1, 209, 1, 209, 1, 209, 1, 209, 3, 209, 4750, 8, 209, 1, 210, 1, 210,
		1, 210, 1, 210, 3, 210, 4756, 8, 210, 1, 211, 1, 211, 1, 212, 1, 212, 1,
		212, 3, 212, 4763, 8, 212, 1, 213, 1, 213, 1, 213, 3, 213, 4768, 8, 213,
		1, 214, 1, 214, 1, 214, 5, 214, 4773, 8, 214, 10, 214, 12, 214, 4776, 9,
		214, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1,
		215, 1, 215, 1, 215, 5, 215, 4789, 8, 215, 10, 215, 12, 215, 4792, 9, 215,
		1, 216, 1, 216, 1, 216, 3, 216, 4797, 8, 216, 1, 216, 1, 216, 1, 216, 5,
		216, 4802, 8, 216, 10, 216, 12, 216, 4805, 9, 216, 1, 217, 1, 217, 3, 217,
		4809, 8, 217, 1, 218, 1, 218, 1, 218, 3, 218, 4814, 8, 218, 1, 219, 1,
		219, 1, 219, 1, 220, 1, 220, 1, 220, 1, 220, 1, 220, 1, 220, 1, 220, 1,
		220, 3, 220, 4827, 8, 220, 1, 221, 1, 221, 1, 221, 1, 221, 3, 221, 4833,
		8, 221, 1, 221, 1, 221, 1, 221, 1, 221, 3, 221, 4839, 8, 221, 1, 221, 1,
		221, 1, 221, 1, 221, 3, 221, 4845, 8, 221, 3, 221, 4847, 8, 221, 1, 222,
		1, 222, 3, 222, 4851, 8, 222, 1, 222, 1, 222, 1, 222, 1, 222, 1, 222, 3,
		222, 4858, 8, 222, 1, 222, 1, 222, 1, 222, 1, 222, 1, 222, 1, 222, 1, 222,
		1, 222, 3, 222, 4868, 8, 222, 1, 222, 1, 222, 3, 222, 4872, 8, 222, 3,
		222, 4874, 8, 222, 1, 223, 1, 223, 1, 223, 1, 223, 1, 223, 3, 223, 4881,
		8, 223, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 3, 224, 4888, 8, 224, 1,
		224, 1, 224, 3, 224, 4892, 8, 224, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225,
		1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225,
		1, 225, 1, 225, 3, 225, 4910, 8, 225, 1, 225, 1, 225, 1, 225, 1, 225, 5,
		225, 4916, 8, 225, 10, 225, 12, 225, 4919, 9, 225, 1, 226, 1, 226, 1, 226,
		3, 226, 4924, 8, 226, 1, 227, 1, 227, 1, 227, 3, 227, 4929, 8, 227, 1,
		228, 1, 228, 1, 228, 1, 228, 1, 228, 3, 228, 4936, 8, 228, 1, 228, 1, 228,
		3, 228, 4940, 8, 228, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 3, 229, 4947,
		8, 229, 1, 229, 1, 229, 3, 229, 4951, 8, 229, 1, 230, 1, 230, 1, 230, 1,
		230, 1, 230, 3, 230, 4958, 8, 230, 1, 230, 1, 230, 3, 230, 4962, 8, 230,
		1, 231, 1, 231, 1, 231, 3, 231, 4967, 8, 231, 1, 232, 1, 232, 1, 232, 3,
		232, 4972, 8, 232, 1, 233, 1, 233, 1, 233, 3, 233, 4977, 8, 233, 1, 234,
		1, 234, 3, 234, 4981, 8, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1,
		234, 1, 234, 1, 234, 3, 234, 4991, 8, 234, 1, 234, 1, 234, 1, 234, 3, 234,
		4996, 8, 234, 1, 234, 1, 234, 3, 234, 5000, 8, 234, 1, 234, 1, 234, 3,
		234, 5004, 8, 234, 1, 235, 1, 235, 1, 236, 1, 236, 1, 237, 1, 237, 1, 237,
		1, 237, 3, 237, 5014, 8, 237, 1, 238, 3, 238, 5017, 8, 238, 1, 239, 3,
		239, 5020, 8, 239, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240,
		1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 3, 240, 5034, 8, 240, 1, 241, 1,
		241, 1, 241, 1, 241, 1, 241, 1, 241, 3, 241, 5042, 8, 241, 1, 241, 1, 241,
		1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 3, 241, 5052, 8, 241, 1,
		242, 3, 242, 5055, 8, 242, 1, 243, 1, 243, 1, 243, 5, 243, 5060, 8, 243,
		10, 243, 12, 243, 5063, 9, 243, 1, 244, 1, 244, 3, 244, 5067, 8, 244, 1,
		245, 1, 245, 1, 245, 1, 245, 3, 245, 5073, 8, 245, 1, 246, 4, 246, 5076,
		8, 246, 11, 246, 12, 246, 5077, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247,
		1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 3, 247,
		5093, 8, 247, 1, 248, 1, 248, 1, 248, 3, 248, 5098, 8, 248, 1, 249, 4,
		249, 5101, 8, 249, 11, 249, 12, 249, 5102, 1, 250, 1, 250, 1, 250, 1, 250,
		1, 250, 1, 250, 3, 250, 5111, 8, 250, 1, 251, 1, 251, 1, 251, 1, 251, 1,
		251, 3, 251, 5118, 8, 251, 1, 251, 1, 251, 1, 252, 1, 252, 1, 252, 3, 252,
		5125, 8, 252, 1, 252, 1, 252, 1, 252, 5, 252, 5130, 8, 252, 10, 252, 12,
		252, 5133, 9, 252, 1, 253, 4, 253, 5136, 8, 253, 11, 253, 12, 253, 5137,
		1, 254, 1, 254, 1, 254, 1, 254, 1, 254, 1, 254, 1, 254, 1, 254, 5, 254,
		5148, 8, 254, 10, 254, 12, 254, 5151, 9, 254, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 3, 255, 5281,
		8, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 3, 255, 5288, 8, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 3, 255, 5295, 8, 255, 1, 255, 1, 255,
		1, 255, 1, 255, 1, 255, 3, 255, 5302, 8, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 3, 255, 5309, 8, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255,
		3, 255, 5316, 8, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 3, 255, 5323,
		8, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 3, 255, 5330, 8, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 3, 255, 5337, 8, 255, 1, 255, 1, 255,
		1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255,
		1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255,
		1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 3, 255, 5364, 8, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 255, 3, 255, 5388, 8, 255, 1, 255, 1, 255, 1, 255, 1, 255,
		3, 255, 5394, 8, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 3, 255, 5404, 8, 255, 1, 256, 1, 256, 1, 257, 1, 257, 1, 258,
		1, 258, 1, 259, 1, 259, 1, 260, 1, 260, 1, 261, 1, 261, 1, 261, 1, 261,
		1, 261, 1, 261, 1, 261, 3, 261, 5423, 8, 261, 1, 262, 1, 262, 1, 262, 1,
		262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1,
		262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1,
		262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 3, 262, 5454,
		8, 262, 1, 263, 1, 263, 1, 263, 3, 263, 5459, 8, 263, 1, 264, 1, 264, 1,
		264, 5, 264, 5464, 8, 264, 10, 264, 12, 264, 5467, 9, 264, 1, 265, 1, 265,
		3, 265, 5471, 8, 265, 1, 266, 1, 266, 1, 266, 1, 266, 1, 267, 1, 267, 1,
		267, 5, 267, 5480, 8, 267, 10, 267, 12, 267, 5483, 9, 267, 1, 268, 1, 268,
		3, 268, 5487, 8, 268, 1, 269, 1, 269, 1, 269, 1, 269, 3, 269, 5493, 8,
		269, 1, 270, 1, 270, 1, 271, 1, 271, 1, 271, 3, 271, 5500, 8, 271, 1, 271,
		1, 271, 1, 271, 1, 271, 3, 271, 5506, 8, 271, 1, 271, 1, 271, 1, 271, 3,
		271, 5511, 8, 271, 1, 272, 1, 272, 1, 272, 5, 272, 5516, 8, 272, 10, 272,
		12, 272, 5519, 9, 272, 1, 273, 1, 273, 1, 274, 1, 274, 1, 274, 5, 274,
		5526, 8, 274, 10, 274, 12, 274, 5529, 9, 274, 1, 275, 1, 275, 3, 275, 5533,
		8, 275, 1, 276, 1, 276, 1, 276, 1, 276, 1, 276, 1, 276, 1, 276, 3, 276,
		5542, 8, 276, 1, 277, 1, 277, 3, 277, 5546, 8, 277, 1, 277, 1, 277, 1,
		277, 3, 277, 5551, 8, 277, 1, 277, 3, 277, 5554, 8, 277, 1, 277, 1, 277,
		3, 277, 5558, 8, 277, 1, 277, 1, 277, 1, 277, 3, 277, 5563, 8, 277, 1,
		277, 1, 277, 1, 277, 3, 277, 5568, 8, 277, 1, 277, 1, 277, 3, 277, 5572,
		8, 277, 1, 277, 1, 277, 3, 277, 5576, 8, 277, 1, 277, 1, 277, 3, 277, 5580,
		8, 277, 1, 277, 1, 277, 1, 277, 1, 277, 3, 277, 5586, 8, 277, 1, 277, 1,
		277, 3, 277, 5590, 8, 277, 1, 277, 1, 277, 1, 277, 3, 277, 5595, 8, 277,
		3, 277, 5597, 8, 277, 1, 278, 1, 278, 3, 278, 5601, 8, 278, 1, 279, 1,
		279, 1, 279, 1, 279, 1, 279, 1, 280, 3, 280, 5609, 8, 280, 1, 281, 1, 281,
		1, 282, 1, 282, 3, 282, 5615, 8, 282, 1, 282, 3, 282, 5618, 8, 282, 1,
		282, 1, 282, 1, 282, 1, 282, 1, 283, 1, 283, 3, 283, 5626, 8, 283, 1, 283,
		1, 283, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 285, 1, 285, 1, 286,
		1, 286, 1, 287, 1, 287, 1, 287, 1, 287, 1, 287, 1, 287, 1, 287, 1, 287,
		1, 287, 3, 287, 5648, 8, 287, 1, 288, 1, 288, 1, 289, 1, 289, 1, 289, 5,
		289, 5655, 8, 289, 10, 289, 12, 289, 5658, 9, 289, 1, 290, 1, 290, 1, 290,
		1, 290, 1, 290, 3, 290, 5665, 8, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1,
		290, 1, 290, 1, 290, 1, 290, 1, 290, 3, 290, 5676, 8, 290, 1, 291, 1, 291,
		1, 291, 1, 291, 3, 291, 5682, 8, 291, 1, 292, 1, 292, 3, 292, 5686, 8,
		292, 1, 293, 1, 293, 1, 293, 5, 293, 5691, 8, 293, 10, 293, 12, 293, 5694,
		9, 293, 1, 294, 1, 294, 1, 294, 3, 294, 5699, 8, 294, 1, 294, 1, 294, 1,
		294, 1, 294, 1, 294, 3, 294, 5706, 8, 294, 3, 294, 5708, 8, 294, 1, 295,
		1, 295, 1, 295, 1, 295, 1, 295, 3, 295, 5715, 8, 295, 1, 296, 1, 296, 1,
		296, 1, 297, 1, 297, 1, 297, 1, 298, 1, 298, 1, 298, 3, 298, 5726, 8, 298,
		1, 299, 1, 299, 1, 299, 1, 299, 5, 299, 5732, 8, 299, 10, 299, 12, 299,
		5735, 9, 299, 1, 300, 3, 300, 5738, 8, 300, 1, 301, 1, 301, 1, 301, 1,
		301, 1, 301, 3, 301, 5745, 8, 301, 1, 302, 1, 302, 1, 302, 1, 302, 1, 303,
		1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303,
		1, 303, 1, 303, 3, 303, 5763, 8, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1,
		303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1,
		303, 1, 303, 1, 303, 5, 303, 5781, 8, 303, 10, 303, 12, 303, 5784, 9, 303,
		1, 304, 1, 304, 1, 304, 1, 304, 1, 304, 3, 304, 5791, 8, 304, 1, 305, 1,
		305, 1, 305, 1, 305, 1, 305, 1, 305, 3, 305, 5799, 8, 305, 1, 305, 1, 305,
		1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 5, 305,
		5811, 8, 305, 10, 305, 12, 305, 5814, 9, 305, 1, 306, 1, 306, 1, 306, 1,
		306, 1, 306, 3, 306, 5821, 8, 306, 1, 307, 1, 307, 1, 307, 1, 307, 1, 307,
		1, 307, 1, 307, 3, 307, 5830, 8, 307, 1, 308, 1, 308, 1, 308, 1, 308, 1,
		308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1,
		308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1,
		308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 3, 308, 5860, 8, 308, 1, 308,
		1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308,
		1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308,
		1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 5, 308,
		5889, 8, 308, 10, 308, 12, 308, 5892, 9, 308, 1, 309, 1, 309, 1, 309, 1,
		309, 3, 309, 5898, 8, 309, 1, 309, 3, 309, 5901, 8, 309, 1, 310, 1, 310,
		1, 310, 1, 310, 1, 310, 3, 310, 5908, 8, 310, 1, 311, 1, 311, 3, 311, 5912,
		8, 311, 1, 311, 1, 311, 1, 311, 3, 311, 5917, 8, 311, 1, 311, 1, 311, 1,
		311, 3, 311, 5922, 8, 311, 1, 311, 3, 311, 5925, 8, 311, 1, 312, 1, 312,
		1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312,
		1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 3, 312,
		5946, 8, 312, 1, 313, 1, 313, 1, 313, 3, 313, 5951, 8, 313, 1, 313, 1,
		313, 1, 313, 1, 313, 1, 313, 1, 313, 3, 313, 5959, 8, 313, 1, 313, 1, 313,
		1, 313, 3, 313, 5964, 8, 313, 1, 313, 1, 313, 1, 313, 1, 313, 1, 313, 1,
		313, 1, 313, 1, 313, 3, 313, 5974, 8, 313, 1, 314, 1, 314, 1, 314, 1, 314,
		1, 314, 1, 314, 1, 314, 3, 314, 5983, 8, 314, 1, 315, 1, 315, 1, 315, 1,
		315, 1, 316, 1, 316, 1, 316, 1, 316, 3, 316, 5993, 8, 316, 1, 316, 1, 316,
		1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316,
		1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316,
		1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316,
		1, 316, 1, 316, 1, 316, 1, 316, 3, 316, 6028, 8, 316, 1, 317, 1, 317, 1,
		318, 1, 318, 1, 318, 1, 318, 3, 318, 6036, 8, 318, 1, 319, 1, 319, 1, 320,
		1, 320, 3, 320, 6042, 8, 320, 1, 320, 1, 320, 1, 320, 1, 320, 3, 320, 6048,
		8, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320,
		3, 320, 6058, 8, 320, 1, 320, 1, 320, 1, 320, 3, 320, 6063, 8, 320, 1,
		320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 3, 320, 6073,
		8, 320, 1, 320, 1, 320, 3, 320, 6077, 8, 320, 1, 320, 1, 320, 1, 320, 1,
		320, 1, 320, 1, 320, 3, 320, 6085, 8, 320, 1, 320, 1, 320, 1, 320, 1, 320,
		1, 320, 1, 320, 1, 320, 1, 320, 3, 320, 6095, 8, 320, 1, 320, 1, 320, 1,
		320, 1, 320, 1, 320, 1, 320, 3, 320, 6103, 8, 320, 1, 320, 1, 320, 1, 320,
		1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 3, 320, 6113, 8, 320, 1, 320, 1,
		320, 1, 320, 1, 320, 1, 320, 1, 320, 3, 320, 6121, 8, 320, 1, 320, 1, 320,
		1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 3, 320, 6131, 8, 320, 1,
		320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 3, 320, 6139, 8, 320, 1, 320,
		1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 3, 320, 6149, 8,
		320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1,
		320, 1, 320, 1, 320, 3, 320, 6162, 8, 320, 1, 320, 1, 320, 3, 320, 6166,
		8, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320,
		1, 320, 3, 320, 6177, 8, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1,
		320, 1, 320, 1, 320, 1, 320, 3, 320, 6188, 8, 320, 1, 320, 1, 320, 1, 320,
		1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320,
		1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320,
		1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 3, 320, 6216, 8, 320, 1, 320, 1,
		320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 3, 320, 6226, 8, 320,
		1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320,
		1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320,
		1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 3, 320, 6253, 8,
		320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1,
		320, 1, 320, 3, 320, 6265, 8, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320,
		1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 3, 320, 6277, 8, 320, 1, 320, 1,
		320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 3,
		320, 6289, 8, 320, 1, 320, 3, 320, 6292, 8, 320, 1, 320, 1, 320, 1, 320,
		1, 320, 1, 320, 1, 320, 1, 320, 3, 320, 6301, 8, 320, 1, 320, 1, 320, 1,
		320, 1, 320, 3, 320, 6307, 8, 320, 1, 320, 1, 320, 3, 320, 6311, 8, 320,
		1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320,
		1, 320, 1, 320, 3, 320, 6324, 8, 320, 1, 320, 1, 320, 3, 320, 6328, 8,
		320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1,
		320, 3, 320, 6339, 8, 320, 1, 320, 1, 320, 1, 320, 3, 320, 6344, 8, 320,
		1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 3, 320, 6352, 8, 320, 1,
		320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 3,
		320, 6363, 8, 320, 1, 321, 1, 321, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322,
		1, 322, 1, 322, 3, 322, 6374, 8, 322, 1, 323, 1, 323, 1, 324, 1, 324, 1,
		325, 1, 325, 1, 326, 1, 326, 1, 327, 1, 327, 1, 327, 1, 327, 3, 327, 6388,
		8, 327, 1, 328, 1, 328, 1, 328, 1, 328, 1, 328, 1, 329, 3, 329, 6396, 8,
		329, 1, 330, 1, 330, 3, 330, 6400, 8, 330, 1, 330, 1, 330, 1, 331, 1, 331,
		1, 331, 1, 331, 1, 332, 1, 332, 1, 332, 1, 332, 1, 332, 3, 332, 6413, 8,
		332, 1, 333, 3, 333, 6416, 8, 333, 1, 333, 1, 333, 1, 334, 1, 334, 1, 334,
		1, 334, 1, 334, 1, 335, 1, 335, 1, 335, 1, 335, 1, 335, 1, 335, 1, 335,
		1, 336, 1, 336, 1, 336, 5, 336, 6435, 8, 336, 10, 336, 12, 336, 6438, 9,
		336, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 3, 337, 6446, 8, 337,
		1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 3, 337, 6455, 8,
		337, 1, 337, 1, 337, 1, 337, 3, 337, 6460, 8, 337, 1, 338, 1, 338, 1, 338,
		5, 338, 6465, 8, 338, 10, 338, 12, 338, 6468, 9, 338, 1, 339, 1, 339, 3,
		339, 6472, 8, 339, 1, 339, 1, 339, 3, 339, 6476, 8, 339, 1, 339, 1, 339,
		1, 339, 1, 339, 1, 339, 1, 339, 3, 339, 6484, 8, 339, 1, 339, 1, 339, 1,
		339, 1, 339, 1, 339, 3, 339, 6491, 8, 339, 1, 340, 1, 340, 1, 340, 1, 340,
		1, 340, 1, 340, 1, 340, 1, 340, 3, 340, 6501, 8, 340, 1, 341, 1, 341, 1,
		341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 5, 341, 6511, 8, 341, 10,
		341, 12, 341, 6514, 9, 341, 1, 342, 1, 342, 1, 342, 1, 342, 1, 342, 1,
		342, 3, 342, 6522, 8, 342, 1, 343, 1, 343, 1, 343, 3, 343, 6527, 8, 343,
		1, 344, 3, 344, 6530, 8, 344, 1, 345, 1, 345, 3, 345, 6534, 8, 345, 1,
		346, 1, 346, 1, 347, 1, 347, 1, 347, 1, 347, 1, 348, 1, 348, 1, 348, 5,
		348, 6545, 8, 348, 10, 348, 12, 348, 6548, 9, 348, 1, 349, 1, 349, 1, 349,
		1, 349, 1, 349, 1, 349, 3, 349, 6556, 8, 349, 1, 349, 1, 349, 1, 349, 1,
		349, 1, 349, 1, 349, 1, 349, 1, 349, 3, 349, 6566, 8, 349, 1, 349, 1, 349,
		1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349,
		1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 3, 349, 6586, 8,
		349, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350, 3, 350, 6593, 8, 350, 1, 351,
		1, 351, 1, 351, 1, 351, 1, 352, 1, 352, 3, 352, 6601, 8, 352, 1, 352, 1,
		352, 1, 352, 3, 352, 6606, 8, 352, 1, 353, 1, 353, 1, 353, 5, 353, 6611,
		8, 353, 10, 353, 12, 353, 6614, 9, 353, 1, 354, 1, 354, 1, 354, 1, 354,
		1, 354, 1, 354, 1, 355, 1, 355, 1, 356, 1, 356, 1, 356, 1, 356, 1, 357,
		1, 357, 1, 357, 1, 358, 1, 358, 1, 358, 5, 358, 6634, 8, 358, 10, 358,
		12, 358, 6637, 9, 358, 1, 359, 1, 359, 1, 359, 1, 359, 1, 359, 3, 359,
		6644, 8, 359, 1, 359, 1, 359, 1, 359, 3, 359, 6649, 8, 359, 1, 360, 1,
		360, 3, 360, 6653, 8, 360, 1, 360, 1, 360, 1, 360, 3, 360, 6658, 8, 360,
		1, 361, 1, 361, 3, 361, 6662, 8, 361, 1, 361, 1, 361, 1, 361, 1, 361, 1,
		361, 1, 361, 1, 361, 1, 361, 1, 361, 1, 361, 1, 361, 1, 361, 1, 361, 1,
		361, 1, 361, 1, 361, 1, 361, 3, 361, 6681, 8, 361, 3, 361, 6683, 8, 361,
		1, 362, 1, 362, 3, 362, 6687, 8, 362, 1, 363, 1, 363, 3, 363, 6691, 8,
		363, 1, 364, 1, 364, 1, 364, 1, 364, 1, 364, 1, 364, 1, 364, 1, 364, 3,
		364, 6701, 8, 364, 1, 365, 1, 365, 1, 365, 1, 365, 1, 365, 1, 365, 1, 365,
		1, 365, 1, 366, 1, 366, 1, 366, 3, 366, 6714, 8, 366, 3, 366, 6716, 8,
		366, 1, 367, 1, 367, 1, 367, 5, 367, 6721, 8, 367, 10, 367, 12, 367, 6724,
		9, 367, 1, 368, 1, 368, 1, 368, 1, 368, 1, 368, 1, 368, 1, 368, 1, 368,
		1, 368, 1, 368, 1, 368, 1, 368, 1, 368, 1, 368, 1, 368, 1, 368, 1, 368,
		1, 368, 1, 368, 1, 368, 1, 368, 1, 368, 1, 368, 3, 368, 6749, 8, 368, 1,
		369, 1, 369, 1, 369, 1, 369, 1, 369, 1, 369, 1, 369, 1, 369, 1, 369, 1,
		369, 1, 369, 1, 369, 1, 369, 3, 369, 6764, 8, 369, 1, 370, 1, 370, 1, 370,
		1, 370, 3, 370, 6770, 8, 370, 1, 371, 1, 371, 1, 371, 1, 371, 1, 371, 1,
		371, 1, 371, 1, 371, 1, 371, 1, 371, 3, 371, 6782, 8, 371, 1, 371, 1, 371,
		1, 371, 1, 371, 1, 371, 3, 371, 6789, 8, 371, 1, 372, 1, 372, 1, 372, 1,
		372, 1, 372, 1, 373, 1, 373, 1, 374, 1, 374, 3, 374, 6800, 8, 374, 1, 375,
		1, 375, 1, 375, 1, 376, 1, 376, 1, 376, 5, 376, 6808, 8, 376, 10, 376,
		12, 376, 6811, 9, 376, 1, 377, 1, 377, 1, 377, 5, 377, 6816, 8, 377, 10,
		377, 12, 377, 6819, 9, 377, 1, 378, 1, 378, 1, 378, 1, 378, 1, 378, 3,
		378, 6826, 8, 378, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379,
		1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379,
		1, 379, 3, 379, 6845, 8, 379, 1, 380, 1, 380, 1, 380, 1, 380, 1, 380, 1,
		380, 1, 380, 1, 380, 3, 380, 6855, 8, 380, 1, 381, 1, 381, 1, 381, 1, 381,
		1, 381, 1, 381, 3, 381, 6863, 8, 381, 1, 382, 1, 382, 1, 383, 1, 383, 1,
		383, 1, 383, 3, 383, 6871, 8, 383, 1, 384, 1, 384, 1, 384, 5, 384, 6876,
		8, 384, 10, 384, 12, 384, 6879, 9, 384, 1, 385, 1, 385, 1, 386, 1, 386,
		1, 386, 1, 386, 1, 387, 1, 387, 1, 388, 1, 388, 3, 388, 6891, 8, 388, 1,
		388, 1, 388, 1, 389, 1, 389, 1, 389, 1, 389, 1, 390, 1, 390, 1, 390, 5,
		390, 6902, 8, 390, 10, 390, 12, 390, 6905, 9, 390, 1, 391, 1, 391, 1, 391,
		1, 391, 1, 392, 1, 392, 1, 392, 1, 392, 1, 392, 1, 393, 1, 393, 1, 393,
		3, 393, 6919, 8, 393, 1, 393, 1, 393, 1, 393, 5, 393, 6924, 8, 393, 10,
		393, 12, 393, 6927, 9, 393, 1, 394, 3, 394, 6930, 8, 394, 1, 394, 1, 394,
		1, 394, 1, 394, 1, 394, 3, 394, 6937, 8, 394, 1, 394, 1, 394, 1, 394, 1,
		394, 1, 394, 3, 394, 6944, 8, 394, 1, 395, 1, 395, 1, 395, 1, 395, 1, 395,
		1, 395, 1, 395, 1, 395, 1, 395, 1, 395, 1, 395, 1, 395, 1, 395, 1, 395,
		3, 395, 6960, 8, 395, 1, 396, 1, 396, 1, 396, 1, 396, 1, 396, 1, 396, 1,
		396, 1, 396, 1, 396, 1, 396, 1, 396, 1, 396, 1, 396, 1, 396, 1, 396, 1,
		396, 3, 396, 6978, 8, 396, 1, 397, 1, 397, 3, 397, 6982, 8, 397, 1, 398,
		1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398,
		1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 3, 398, 7000, 8, 398, 1,
		399, 1, 399, 1, 399, 1, 399, 1, 399, 3, 399, 7007, 8, 399, 1, 400, 1, 400,
		1, 400, 1, 400, 3, 400, 7013, 8, 400, 1, 401, 1, 401, 1, 401, 1, 401, 3,
		401, 7019, 8, 401, 1, 402, 1, 402, 1, 402, 3, 402, 7024, 8, 402, 1, 402,
		3, 402, 7027, 8, 402, 1, 402, 1, 402, 1, 402, 1, 402, 3, 402, 7033, 8,
		402, 1, 402, 1, 402, 1, 402, 3, 402, 7038, 8, 402, 1, 402, 3, 402, 7041,
		8, 402, 1, 402, 3, 402, 7044, 8, 402, 1, 402, 1, 402, 1, 402, 1, 402, 3,
		402, 7050, 8, 402, 1, 402, 1, 402, 1, 402, 3, 402, 7055, 8, 402, 1, 402,
		1, 402, 3, 402, 7059, 8, 402, 1, 402, 3, 402, 7062, 8, 402, 1, 402, 3,
		402, 7065, 8, 402, 1, 402, 1, 402, 1, 402, 1, 402, 3, 402, 7071, 8, 402,
		1, 402, 1, 402, 1, 402, 3, 402, 7076, 8, 402, 1, 402, 3, 402, 7079, 8,
		402, 1, 402, 3, 402, 7082, 8, 402, 1, 402, 1, 402, 1, 402, 1, 402, 3, 402,
		7088, 8, 402, 1, 402, 1, 402, 1, 402, 1, 402, 1, 402, 1, 402, 1, 402, 3,
		402, 7097, 8, 402, 1, 402, 1, 402, 1, 402, 1, 402, 1, 402, 1, 402, 3, 402,
		7105, 8, 402, 1, 402, 1, 402, 1, 402, 1, 402, 1, 402, 1, 402, 1, 402, 1,
		402, 1, 402, 1, 402, 1, 402, 3, 402, 7118, 8, 402, 1, 403, 1, 403, 1, 403,
		1, 403, 1, 403, 1, 403, 1, 403, 3, 403, 7127, 8, 403, 1, 403, 1, 403, 1,
		403, 3, 403, 7132, 8, 403, 1, 403, 1, 403, 1, 403, 1, 403, 1, 403, 1, 403,
		1, 403, 1, 403, 1, 403, 1, 403, 3, 403, 7144, 8, 403, 1, 403, 1, 403, 1,
		403, 3, 403, 7149, 8, 403, 3, 403, 7151, 8, 403, 1, 404, 1, 404, 1, 405,
		1, 405, 3, 405, 7157, 8, 405, 1, 405, 1, 405, 1, 405, 3, 405, 7162, 8,
		405, 1, 405, 1, 405, 1, 405, 1, 405, 1, 405, 1, 405, 3, 405, 7170, 8, 405,
		1, 405, 1, 405, 3, 405, 7174, 8, 405, 1, 405, 1, 405, 3, 405, 7178, 8,
		405, 1, 405, 1, 405, 1, 405, 1, 405, 1, 405, 3, 405, 7185, 8, 405, 1, 405,
		1, 405, 1, 405, 1, 405, 1, 405, 3, 405, 7192, 8, 405, 1, 405, 3, 405, 7195,
		8, 405, 1, 406, 1, 406, 1, 406, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407,
		3, 407, 7205, 8, 407, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1,
		408, 1, 408, 1, 408, 3, 408, 7216, 8, 408, 1, 408, 1, 408, 1, 408, 1, 408,
		1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 3, 408, 7227, 8, 408, 1, 408, 1,
		408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 3, 408, 7238,
		8, 408, 3, 408, 7240, 8, 408, 1, 409, 1, 409, 1, 409, 1, 409, 1, 409, 1,
		409, 1, 409, 1, 409, 1, 409, 1, 409, 1, 409, 1, 409, 1, 409, 1, 409, 1,
		409, 3, 409, 7257, 8, 409, 1, 410, 1, 410, 1, 410, 1, 410, 1, 410, 1, 410,
		1, 410, 1, 410, 1, 410, 3, 410, 7268, 8, 410, 1, 411, 1, 411, 1, 411, 1,
		411, 1, 411, 1, 411, 1, 411, 1, 411, 1, 411, 1, 411, 1, 411, 1, 411, 1,
		411, 1, 411, 1, 411, 1, 411, 1, 411, 1, 411, 1, 411, 1, 411, 1, 411, 1,
		411, 1, 411, 1, 411, 1, 411, 1, 411, 1, 411, 1, 411, 1, 411, 1, 411, 1,
		411, 1, 411, 1, 411, 1, 411, 1, 411, 1, 411, 3, 411, 7306, 8, 411, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 3, 412, 7313, 8, 412, 1, 412, 1, 412, 1,
		412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 3, 412, 7324, 8, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 3, 412, 7336, 8, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1,
		412, 1, 412, 3, 412, 7345, 8, 412, 1, 412, 3, 412, 7348, 8, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 3, 412, 7355, 8, 412, 1, 412, 1, 412, 1,
		412, 1, 412, 1, 412, 1, 412, 3, 412, 7363, 8, 412, 1, 412, 3, 412, 7366,
		8, 412, 1, 412, 3, 412, 7369, 8, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1,
		412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 3,
		412, 7384, 8, 412, 1, 412, 3, 412, 7387, 8, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 3, 412, 7412, 8, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1,
		412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 3, 412, 7424, 8, 412, 1, 412,
		3, 412, 7427, 8, 412, 1, 412, 3, 412, 7430, 8, 412, 1, 412, 1, 412, 1,
		412, 1, 412, 1, 412, 1, 412, 1, 412, 3, 412, 7439, 8, 412, 1, 412, 1, 412,
		1, 412, 3, 412, 7444, 8, 412, 1, 412, 1, 412, 3, 412, 7448, 8, 412, 1,
		412, 1, 412, 1, 412, 1, 412, 1, 412, 3, 412, 7455, 8, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 3, 412, 7462, 8, 412, 1, 412, 1, 412, 1, 412, 1,
		412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 3, 412, 7474, 8, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		3, 412, 7494, 8, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1,
		412, 1, 412, 1, 412, 3, 412, 7505, 8, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 3, 412, 7513, 8, 412, 1, 412, 3, 412, 7516, 8, 412, 1,
		412, 1, 412, 1, 412, 1, 412, 1, 412, 3, 412, 7523, 8, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 3, 412, 7531, 8, 412, 1, 412, 1, 412, 1,
		412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1,
		412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 3, 412, 7552,
		8, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 3, 412,
		7561, 8, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 3, 412, 7569,
		8, 412, 1, 412, 1, 412, 1, 412, 3, 412, 7574, 8, 412, 1, 412, 1, 412, 1,
		412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 3,
		412, 7587, 8, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 3, 412, 7597, 8, 412, 1, 412, 1, 412, 1, 412, 3, 412, 7602, 8,
		412, 1, 412, 1, 412, 1, 412, 1, 412, 3, 412, 7608, 8, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 3, 412, 7631, 8, 412, 1, 412, 1, 412, 1, 412, 3, 412, 7636, 8,
		412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1,
		412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1,
		412, 3, 412, 7656, 8, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 3, 412, 7728, 8, 412, 1, 412, 1, 412, 3, 412, 7732, 8, 412, 1,
		412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 3, 412, 7742,
		8, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412,
		1, 412, 1, 412, 3, 412, 7790, 8, 412, 1, 413, 1, 413, 1, 413, 3, 413, 7795,
		8, 413, 1, 413, 3, 413, 7798, 8, 413, 1, 414, 1, 414, 1, 415, 1, 415, 1,
		416, 1, 416, 3, 416, 7806, 8, 416, 1, 416, 1, 416, 1, 416, 1, 416, 1, 417,
		1, 417, 1, 417, 5, 417, 7815, 8, 417, 10, 417, 12, 417, 7818, 9, 417, 1,
		418, 3, 418, 7821, 8, 418, 1, 419, 1, 419, 1, 419, 5, 419, 7826, 8, 419,
		10, 419, 12, 419, 7829, 9, 419, 1, 420, 1, 420, 3, 420, 7833, 8, 420, 1,
		420, 1, 420, 1, 420, 3, 420, 7838, 8, 420, 1, 420, 1, 420, 1, 420, 3, 420,
		7843, 8, 420, 1, 420, 1, 420, 1, 420, 1, 420, 3, 420, 7849, 8, 420, 1,
		420, 1, 420, 1, 420, 3, 420, 7854, 8, 420, 1, 420, 1, 420, 3, 420, 7858,
		8, 420, 1, 421, 1, 421, 1, 421, 1, 421, 1, 421, 1, 421, 1, 421, 1, 421,
		1, 421, 3, 421, 7869, 8, 421, 1, 422, 1, 422, 1, 422, 5, 422, 7874, 8,
		422, 10, 422, 12, 422, 7877, 9, 422, 1, 423, 1, 423, 1, 423, 1, 423, 1,
		423, 3, 423, 7884, 8, 423, 1, 424, 1, 424, 3, 424, 7888, 8, 424, 1, 424,
		1, 424, 1, 425, 1, 425, 3, 425, 7894, 8, 425, 1, 425, 1, 425, 1, 426, 1,
		426, 3, 426, 7900, 8, 426, 1, 427, 1, 427, 3, 427, 7904, 8, 427, 1, 427,
		1, 427, 1, 427, 3, 427, 7909, 8, 427, 1, 427, 1, 427, 1, 427, 3, 427, 7914,
		8, 427, 1, 427, 3, 427, 7917, 8, 427, 1, 428, 1, 428, 1, 428, 3, 428, 7922,
		8, 428, 1, 428, 1, 428, 1, 428, 5, 428, 7927, 8, 428, 10, 428, 12, 428,
		7930, 9, 428, 1, 429, 1, 429, 1, 430, 1, 430, 3, 430, 7936, 8, 430, 1,
		430, 1, 430, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 3, 431, 7945, 8, 431,
		1, 431, 1, 431, 3, 431, 7949, 8, 431, 3, 431, 7951, 8, 431, 1, 432, 1,
		432, 1, 433, 1, 433, 1, 433, 1, 433, 3, 433, 7959, 8, 433, 1, 434, 1, 434,
		1, 435, 1, 435, 3, 435, 7965, 8, 435, 1, 435, 1, 435, 1, 436, 1, 436, 1,
		437, 1, 437, 3, 437, 7973, 8, 437, 1, 437, 1, 437, 1, 438, 1, 438, 3, 438,
		7979, 8, 438, 1, 438, 1, 438, 1, 439, 1, 439, 1, 439, 1, 439, 1, 440, 1,
		440, 3, 440, 7989, 8, 440, 1, 440, 1, 440, 1, 441, 1, 441, 3, 441, 7995,
		8, 441, 1, 441, 1, 441, 1, 442, 1, 442, 3, 442, 8001, 8, 442, 1, 442, 1,
		442, 1, 443, 1, 443, 1, 443, 3, 443, 8008, 8, 443, 1, 444, 1, 444, 1, 444,
		5, 444, 8013, 8, 444, 10, 444, 12, 444, 8016, 9, 444, 1, 445, 1, 445, 1,
		445, 1, 445, 1, 445, 3, 445, 8023, 8, 445, 1, 445, 1, 445, 1, 445, 1, 445,
		1, 445, 1, 445, 1, 445, 1, 445, 1, 445, 3, 445, 8034, 8, 445, 1, 445, 3,
		445, 8037, 8, 445, 1, 445, 3, 445, 8040, 8, 445, 1, 445, 1, 445, 1, 445,
		1, 445, 1, 445, 3, 445, 8047, 8, 445, 1, 445, 1, 445, 1, 445, 1, 445, 1,
		445, 1, 445, 1, 445, 1, 445, 1, 445, 3, 445, 8058, 8, 445, 1, 445, 3, 445,
		8061, 8, 445, 1, 445, 3, 445, 8064, 8, 445, 1, 445, 1, 445, 1, 445, 1,
		445, 1, 445, 3, 445, 8071, 8, 445, 1, 445, 1, 445, 1, 445, 1, 445, 1, 445,
		1, 445, 1, 445, 1, 445, 1, 445, 3, 445, 8082, 8, 445, 1, 445, 3, 445, 8085,
		8, 445, 1, 445, 3, 445, 8088, 8, 445, 3, 445, 8090, 8, 445, 1, 446, 1,
		446, 1, 446, 3, 446, 8095, 8, 446, 1, 446, 1, 446, 1, 446, 5, 446, 8100,
		8, 446, 10, 446, 12, 446, 8103, 9, 446, 1, 447, 1, 447, 3, 447, 8107, 8,
		447, 1, 447, 1, 447, 1, 447, 3, 447, 8112, 8, 447, 1, 447, 1, 447, 1, 447,
		3, 447, 8117, 8, 447, 1, 447, 1, 447, 1, 447, 3, 447, 8122, 8, 447, 1,
		447, 1, 447, 1, 447, 3, 447, 8127, 8, 447, 1, 447, 3, 447, 8130, 8, 447,
		1, 448, 1, 448, 1, 449, 1, 449, 1, 450, 1, 450, 1, 451, 1, 451, 1, 451,
		1, 451, 3, 451, 8142, 8, 451, 1, 452, 1, 452, 1, 452, 1, 452, 1, 453, 1,
		453, 3, 453, 8150, 8, 453, 1, 453, 1, 453, 1, 453, 1, 454, 1, 454, 1, 454,
		1, 454, 1, 454, 1, 454, 1, 454, 1, 454, 1, 454, 1, 454, 1, 454, 1, 454,
		1, 454, 1, 454, 1, 454, 1, 454, 3, 454, 8171, 8, 454, 1, 455, 1, 455, 1,
		455, 1, 455, 3, 455, 8177, 8, 455, 1, 456, 1, 456, 1, 456, 1, 456, 1, 456,
		1, 456, 1, 456, 3, 456, 8186, 8, 456, 1, 457, 1, 457, 1, 457, 1, 458, 1,
		458, 1, 458, 1, 458, 1, 458, 1, 458, 1, 458, 1, 458, 1, 458, 1, 458, 1,
		458, 3, 458, 8202, 8, 458, 1, 459, 1, 459, 1, 459, 1, 459, 1, 460, 1, 460,
		1, 460, 1, 460, 1, 460, 1, 460, 3, 460, 8214, 8, 460, 1, 460, 1, 460, 3,
		460, 8218, 8, 460, 1, 461, 1, 461, 1, 461, 1, 461, 1, 461, 1, 461, 1, 461,
		1, 461, 1, 461, 1, 461, 3, 461, 8230, 8, 461, 1, 462, 1, 462, 1, 462, 1,
		462, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463, 3,
		463, 8244, 8, 463, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463,
		1, 463, 1, 463, 3, 463, 8255, 8, 463, 1, 463, 1, 463, 1, 463, 1, 463, 1,
		463, 1, 463, 1, 463, 1, 463, 3, 463, 8265, 8, 463, 1, 464, 1, 464, 3, 464,
		8269, 8, 464, 1, 465, 1, 465, 3, 465, 8273, 8, 465, 1, 466, 1, 466, 3,
		466, 8277, 8, 466, 1, 467, 1, 467, 3, 467, 8281, 8, 467, 1, 468, 1, 468,
		1, 469, 1, 469, 3, 469, 8287, 8, 469, 1, 470, 1, 470, 1, 471, 1, 471, 3,
		471, 8293, 8, 471, 1, 472, 1, 472, 1, 473, 1, 473, 1, 474, 1, 474, 1, 475,
		1, 475, 1, 475, 1, 476, 1, 476, 1, 476, 1, 476, 0, 22, 28, 32, 34, 36,
		122, 126, 142, 212, 222, 266, 430, 432, 450, 504, 508, 606, 610, 616, 682,
		786, 856, 892, 477, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
		28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62,
		64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98,
		100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128,
		130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158,
		160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188,
		190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218,
		220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248,
		250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278,
		280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308,
		310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338,
		340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368,
		370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392, 394, 396, 398,
		400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422, 424, 426, 428,
		430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452, 454, 456, 458,
		460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 482, 484, 486, 488,
		490, 492, 494, 496, 498, 500, 502, 504, 506, 508, 510, 512, 514, 516, 518,
		520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548,
		550, 552, 554, 556, 558, 560, 562, 564, 566, 568, 570, 572, 574, 576, 578,
		580, 582, 584, 586, 588, 590, 592, 594, 596, 598, 600, 602, 604, 606, 608,
		610, 612, 614, 616, 618, 620, 622, 624, 626, 628, 630, 632, 634, 636, 638,
		640, 642, 644, 646, 648, 650, 652, 654, 656, 658, 660, 662, 664, 666, 668,
		670, 672, 674, 676, 678, 680, 682, 684, 686, 688, 690, 692, 694, 696, 698,
		700, 702, 704, 706, 708, 710, 712, 714, 716, 718, 720, 722, 724, 726, 728,
		730, 732, 734, 736, 738, 740, 742, 744, 746, 748, 750, 752, 754, 756, 758,
		760, 762, 764, 766, 768, 770, 772, 774, 776, 778, 780, 782, 784, 786, 788,
		790, 792, 794, 796, 798, 800, 802, 804, 806, 808, 810, 812, 814, 816, 818,
		820, 822, 824, 826, 828, 830, 832, 834, 836, 838, 840, 842, 844, 846, 848,
		850, 852, 854, 856, 858, 860, 862, 864, 866, 868, 870, 872, 874, 876, 878,
		880, 882, 884, 886, 888, 890, 892, 894, 896, 898, 900, 902, 904, 906, 908,
		910, 912, 914, 916, 918, 920, 922, 924, 926, 928, 930, 932, 934, 936, 938,
		940, 942, 944, 946, 948, 950, 952, 0, 71, 1, 0, 255, 260, 2, 0, 271, 271,
		883, 883, 1, 0, 253, 254, 1, 0, 269, 269, 2, 0, 269, 269, 895, 895, 3,
		0, 8, 8, 635, 635, 712, 712, 3, 0, 8, 8, 59, 59, 228, 228, 2, 0, 59, 59,
		228, 228, 2, 0, 385, 385, 484, 484, 2, 0, 367, 367, 403, 403, 2, 0, 170,
		170, 187, 187, 2, 0, 424, 424, 837, 837, 2, 0, 39, 39, 130, 131, 2, 0,
		409, 409, 554, 554, 2, 0, 47, 47, 190, 190, 2, 0, 129, 129, 301, 301, 2,
		0, 179, 179, 367, 367, 2, 0, 126, 126, 187, 187, 4, 0, 50, 50, 101, 101,
		174, 174, 767, 767, 3, 0, 81, 81, 611, 611, 791, 791, 2, 0, 210, 210, 242,
		242, 2, 0, 505, 506, 863, 863, 2, 0, 230, 230, 493, 493, 2, 0, 887, 887,
		923, 923, 5, 0, 14, 14, 101, 101, 143, 143, 197, 197, 218, 218, 2, 0, 407,
		407, 505, 506, 4, 0, 135, 135, 145, 145, 216, 216, 219, 219, 4, 0, 16,
		16, 134, 134, 142, 142, 217, 217, 2, 0, 921, 921, 923, 923, 3, 0, 15, 15,
		921, 921, 923, 923, 2, 0, 52, 52, 923, 923, 5, 0, 52, 52, 336, 336, 607,
		607, 674, 674, 676, 676, 2, 0, 82, 82, 228, 228, 2, 0, 11, 11, 55, 55,
		2, 0, 464, 464, 818, 818, 2, 0, 21, 21, 183, 183, 2, 0, 220, 220, 389,
		389, 2, 0, 238, 238, 686, 686, 1, 0, 264, 266, 1, 0, 261, 263, 2, 0, 52,
		52, 806, 806, 2, 0, 79, 79, 703, 703, 5, 0, 166, 166, 359, 359, 806, 806,
		830, 830, 983, 984, 2, 0, 271, 271, 918, 918, 4, 0, 8, 8, 59, 59, 205,
		205, 228, 228, 3, 0, 8, 8, 609, 609, 787, 787, 2, 0, 79, 79, 367, 367,
		2, 0, 96, 96, 116, 116, 2, 0, 168, 168, 921, 921, 2, 0, 55, 56, 71, 71,
		2, 0, 390, 390, 634, 634, 3, 0, 129, 129, 497, 497, 834, 834, 2, 0, 48,
		48, 191, 191, 2, 0, 33, 33, 73, 73, 3, 0, 96, 96, 117, 117, 469, 469, 2,
		0, 80, 80, 95, 95, 2, 0, 132, 132, 229, 229, 2, 0, 223, 223, 908, 908,
		2, 0, 62, 62, 448, 448, 2, 0, 492, 492, 529, 529, 12, 0, 8, 8, 190, 190,
		272, 272, 286, 286, 437, 437, 513, 513, 589, 589, 705, 705, 711, 711, 721,
		721, 739, 740, 861, 861, 3, 0, 8, 8, 639, 639, 703, 703, 3, 0, 4, 4, 23,
		23, 544, 544, 2, 0, 580, 580, 833, 833, 2, 0, 299, 299, 568, 568, 2, 0,
		168, 168, 817, 817, 2, 0, 317, 317, 623, 623, 2, 0, 612, 612, 631, 631,
		16, 0, 40, 40, 47, 47, 179, 180, 186, 186, 305, 305, 361, 361, 402, 402,
		428, 428, 477, 477, 483, 483, 577, 577, 579, 579, 603, 603, 655, 655, 668,
		668, 921, 921, 14, 0, 43, 46, 89, 91, 147, 148, 188, 188, 251, 251, 278,
		278, 434, 434, 694, 694, 709, 709, 734, 734, 751, 751, 803, 803, 843, 843,
		876, 876, 63, 0, 26, 26, 33, 33, 49, 49, 73, 73, 92, 92, 113, 113, 119,
		119, 129, 129, 150, 150, 163, 163, 187, 187, 212, 212, 214, 214, 216, 216,
		250, 250, 273, 303, 305, 311, 313, 317, 319, 325, 327, 333, 335, 337, 339,
		342, 344, 357, 359, 364, 366, 366, 368, 372, 374, 393, 395, 411, 413, 414,
		416, 423, 425, 430, 433, 436, 438, 457, 460, 478, 480, 487, 489, 502, 504,
		532, 535, 565, 567, 568, 570, 587, 589, 593, 595, 611, 613, 616, 618, 623,
		625, 653, 655, 665, 667, 672, 674, 677, 679, 698, 700, 703, 705, 745, 747,
		748, 750, 813, 815, 821, 823, 829, 831, 836, 838, 846, 848, 851, 853, 853,
		855, 869, 871, 876, 879, 882, 972, 972, 9437, 0, 954, 1, 0, 0, 0, 2, 966,
		1, 0, 0, 0, 4, 1041, 1, 0, 0, 0, 6, 1043, 1, 0, 0, 0, 8, 1051, 1, 0, 0,
		0, 10, 1072, 1, 0, 0, 0, 12, 1100, 1, 0, 0, 0, 14, 1109, 1, 0, 0, 0, 16,
		1111, 1, 0, 0, 0, 18, 1122, 1, 0, 0, 0, 20, 1124, 1, 0, 0, 0, 22, 1133,
		1, 0, 0, 0, 24, 1152, 1, 0, 0, 0, 26, 1154, 1, 0, 0, 0, 28, 1156, 1, 0,
		0, 0, 30, 1289, 1, 0, 0, 0, 32, 1291, 1, 0, 0, 0, 34, 1403, 1, 0, 0, 0,
		36, 1440, 1, 0, 0, 0, 38, 1462, 1, 0, 0, 0, 40, 1464, 1, 0, 0, 0, 42, 1466,
		1, 0, 0, 0, 44, 1473, 1, 0, 0, 0, 46, 1475, 1, 0, 0, 0, 48, 1713, 1, 0,
		0, 0, 50, 1715, 1, 0, 0, 0, 52, 1717, 1, 0, 0, 0, 54, 1733, 1, 0, 0, 0,
		56, 1757, 1, 0, 0, 0, 58, 1761, 1, 0, 0, 0, 60, 1772, 1, 0, 0, 0, 62, 1774,
		1, 0, 0, 0, 64, 1782, 1, 0, 0, 0, 66, 1789, 1, 0, 0, 0, 68, 1797, 1, 0,
		0, 0, 70, 1799, 1, 0, 0, 0, 72, 1806, 1, 0, 0, 0, 74, 1813, 1, 0, 0, 0,
		76, 1824, 1, 0, 0, 0, 78, 1827, 1, 0, 0, 0, 80, 1830, 1, 0, 0, 0, 82, 1834,
		1, 0, 0, 0, 84, 1842, 1, 0, 0, 0, 86, 2199, 1, 0, 0, 0, 88, 2217, 1, 0,
		0, 0, 90, 2226, 1, 0, 0, 0, 92, 2235, 1, 0, 0, 0, 94, 2252, 1, 0, 0, 0,
		96, 2254, 1, 0, 0, 0, 98, 2271, 1, 0, 0, 0, 100, 2280, 1, 0, 0, 0, 102,
		2282, 1, 0, 0, 0, 104, 2304, 1, 0, 0, 0, 106, 2306, 1, 0, 0, 0, 108, 2312,
		1, 0, 0, 0, 110, 2341, 1, 0, 0, 0, 112, 2352, 1, 0, 0, 0, 114, 2354, 1,
		0, 0, 0, 116, 2373, 1, 0, 0, 0, 118, 2381, 1, 0, 0, 0, 120, 2419, 1, 0,
		0, 0, 122, 2424, 1, 0, 0, 0, 124, 2474, 1, 0, 0, 0, 126, 2479, 1, 0, 0,
		0, 128, 2517, 1, 0, 0, 0, 130, 2519, 1, 0, 0, 0, 132, 2527, 1, 0, 0, 0,
		134, 2562, 1, 0, 0, 0, 136, 2595, 1, 0, 0, 0, 138, 2613, 1, 0, 0, 0, 140,
		2615, 1, 0, 0, 0, 142, 2643, 1, 0, 0, 0, 144, 2730, 1, 0, 0, 0, 146, 2732,
		1, 0, 0, 0, 148, 2741, 1, 0, 0, 0, 150, 2796, 1, 0, 0, 0, 152, 2798, 1,
		0, 0, 0, 154, 2808, 1, 0, 0, 0, 156, 2820, 1, 0, 0, 0, 158, 2822, 1, 0,
		0, 0, 160, 2825, 1, 0, 0, 0, 162, 2832, 1, 0, 0, 0, 164, 2868, 1, 0, 0,
		0, 166, 2874, 1, 0, 0, 0, 168, 2876, 1, 0, 0, 0, 170, 2884, 1, 0, 0, 0,
		172, 2894, 1, 0, 0, 0, 174, 2940, 1, 0, 0, 0, 176, 2942, 1, 0, 0, 0, 178,
		2944, 1, 0, 0, 0, 180, 2954, 1, 0, 0, 0, 182, 2956, 1, 0, 0, 0, 184, 2964,
		1, 0, 0, 0, 186, 2968, 1, 0, 0, 0, 188, 3043, 1, 0, 0, 0, 190, 3047, 1,
		0, 0, 0, 192, 3051, 1, 0, 0, 0, 194, 3073, 1, 0, 0, 0, 196, 3076, 1, 0,
		0, 0, 198, 3106, 1, 0, 0, 0, 200, 3206, 1, 0, 0, 0, 202, 3208, 1, 0, 0,
		0, 204, 3210, 1, 0, 0, 0, 206, 3221, 1, 0, 0, 0, 208, 3229, 1, 0, 0, 0,
		210, 3355, 1, 0, 0, 0, 212, 3357, 1, 0, 0, 0, 214, 3373, 1, 0, 0, 0, 216,
		3383, 1, 0, 0, 0, 218, 3385, 1, 0, 0, 0, 220, 3426, 1, 0, 0, 0, 222, 3428,
		1, 0, 0, 0, 224, 3452, 1, 0, 0, 0, 226, 3465, 1, 0, 0, 0, 228, 3467, 1,
		0, 0, 0, 230, 3523, 1, 0, 0, 0, 232, 3525, 1, 0, 0, 0, 234, 3689, 1, 0,
		0, 0, 236, 3691, 1, 0, 0, 0, 238, 3699, 1, 0, 0, 0, 240, 3701, 1, 0, 0,
		0, 242, 3710, 1, 0, 0, 0, 244, 3712, 1, 0, 0, 0, 246, 3721, 1, 0, 0, 0,
		248, 3723, 1, 0, 0, 0, 250, 3725, 1, 0, 0, 0, 252, 3727, 1, 0, 0, 0, 254,
		3731, 1, 0, 0, 0, 256, 3733, 1, 0, 0, 0, 258, 3741, 1, 0, 0, 0, 260, 3743,
		1, 0, 0, 0, 262, 3747, 1, 0, 0, 0, 264, 3749, 1, 0, 0, 0, 266, 3752, 1,
		0, 0, 0, 268, 3785, 1, 0, 0, 0, 270, 3789, 1, 0, 0, 0, 272, 3796, 1, 0,
		0, 0, 274, 3799, 1, 0, 0, 0, 276, 3805, 1, 0, 0, 0, 278, 3812, 1, 0, 0,
		0, 280, 3817, 1, 0, 0, 0, 282, 3819, 1, 0, 0, 0, 284, 3821, 1, 0, 0, 0,
		286, 3949, 1, 0, 0, 0, 288, 3954, 1, 0, 0, 0, 290, 3957, 1, 0, 0, 0, 292,
		3963, 1, 0, 0, 0, 294, 3969, 1, 0, 0, 0, 296, 3971, 1, 0, 0, 0, 298, 4009,
		1, 0, 0, 0, 300, 4032, 1, 0, 0, 0, 302, 4061, 1, 0, 0, 0, 304, 4064, 1,
		0, 0, 0, 306, 4082, 1, 0, 0, 0, 308, 4084, 1, 0, 0, 0, 310, 4097, 1, 0,
		0, 0, 312, 4099, 1, 0, 0, 0, 314, 4170, 1, 0, 0, 0, 316, 4172, 1, 0, 0,
		0, 318, 4176, 1, 0, 0, 0, 320, 4180, 1, 0, 0, 0, 322, 4184, 1, 0, 0, 0,
		324, 4188, 1, 0, 0, 0, 326, 4196, 1, 0, 0, 0, 328, 4204, 1, 0, 0, 0, 330,
		4210, 1, 0, 0, 0, 332, 4226, 1, 0, 0, 0, 334, 4228, 1, 0, 0, 0, 336, 4236,
		1, 0, 0, 0, 338, 4244, 1, 0, 0, 0, 340, 4254, 1, 0, 0, 0, 342, 4261, 1,
		0, 0, 0, 344, 4274, 1, 0, 0, 0, 346, 4276, 1, 0, 0, 0, 348, 4286, 1, 0,
		0, 0, 350, 4288, 1, 0, 0, 0, 352, 4290, 1, 0, 0, 0, 354, 4298, 1, 0, 0,
		0, 356, 4329, 1, 0, 0, 0, 358, 4353, 1, 0, 0, 0, 360, 4399, 1, 0, 0, 0,
		362, 4401, 1, 0, 0, 0, 364, 4403, 1, 0, 0, 0, 366, 4421, 1, 0, 0, 0, 368,
		4448, 1, 0, 0, 0, 370, 4454, 1, 0, 0, 0, 372, 4461, 1, 0, 0, 0, 374, 4491,
		1, 0, 0, 0, 376, 4493, 1, 0, 0, 0, 378, 4502, 1, 0, 0, 0, 380, 4522, 1,
		0, 0, 0, 382, 4524, 1, 0, 0, 0, 384, 4548, 1, 0, 0, 0, 386, 4550, 1, 0,
		0, 0, 388, 4552, 1, 0, 0, 0, 390, 4577, 1, 0, 0, 0, 392, 4580, 1, 0, 0,
		0, 394, 4582, 1, 0, 0, 0, 396, 4584, 1, 0, 0, 0, 398, 4592, 1, 0, 0, 0,
		400, 4606, 1, 0, 0, 0, 402, 4655, 1, 0, 0, 0, 404, 4661, 1, 0, 0, 0, 406,
		4663, 1, 0, 0, 0, 408, 4676, 1, 0, 0, 0, 410, 4678, 1, 0, 0, 0, 412, 4691,
		1, 0, 0, 0, 414, 4699, 1, 0, 0, 0, 416, 4729, 1, 0, 0, 0, 418, 4749, 1,
		0, 0, 0, 420, 4755, 1, 0, 0, 0, 422, 4757, 1, 0, 0, 0, 424, 4762, 1, 0,
		0, 0, 426, 4767, 1, 0, 0, 0, 428, 4769, 1, 0, 0, 0, 430, 4777, 1, 0, 0,
		0, 432, 4796, 1, 0, 0, 0, 434, 4808, 1, 0, 0, 0, 436, 4813, 1, 0, 0, 0,
		438, 4815, 1, 0, 0, 0, 440, 4826, 1, 0, 0, 0, 442, 4846, 1, 0, 0, 0, 444,
		4873, 1, 0, 0, 0, 446, 4880, 1, 0, 0, 0, 448, 4891, 1, 0, 0, 0, 450, 4893,
		1, 0, 0, 0, 452, 4923, 1, 0, 0, 0, 454, 4928, 1, 0, 0, 0, 456, 4939, 1,
		0, 0, 0, 458, 4950, 1, 0, 0, 0, 460, 4961, 1, 0, 0, 0, 462, 4966, 1, 0,
		0, 0, 464, 4971, 1, 0, 0, 0, 466, 4976, 1, 0, 0, 0, 468, 4978, 1, 0, 0,
		0, 470, 5005, 1, 0, 0, 0, 472, 5007, 1, 0, 0, 0, 474, 5013, 1, 0, 0, 0,
		476, 5016, 1, 0, 0, 0, 478, 5019, 1, 0, 0, 0, 480, 5033, 1, 0, 0, 0, 482,
		5051, 1, 0, 0, 0, 484, 5054, 1, 0, 0, 0, 486, 5056, 1, 0, 0, 0, 488, 5066,
		1, 0, 0, 0, 490, 5072, 1, 0, 0, 0, 492, 5075, 1, 0, 0, 0, 494, 5092, 1,
		0, 0, 0, 496, 5097, 1, 0, 0, 0, 498, 5100, 1, 0, 0, 0, 500, 5110, 1, 0,
		0, 0, 502, 5117, 1, 0, 0, 0, 504, 5124, 1, 0, 0, 0, 506, 5135, 1, 0, 0,
		0, 508, 5139, 1, 0, 0, 0, 510, 5403, 1, 0, 0, 0, 512, 5405, 1, 0, 0, 0,
		514, 5407, 1, 0, 0, 0, 516, 5409, 1, 0, 0, 0, 518, 5411, 1, 0, 0, 0, 520,
		5413, 1, 0, 0, 0, 522, 5422, 1, 0, 0, 0, 524, 5453, 1, 0, 0, 0, 526, 5455,
		1, 0, 0, 0, 528, 5460, 1, 0, 0, 0, 530, 5468, 1, 0, 0, 0, 532, 5472, 1,
		0, 0, 0, 534, 5476, 1, 0, 0, 0, 536, 5484, 1, 0, 0, 0, 538, 5492, 1, 0,
		0, 0, 540, 5494, 1, 0, 0, 0, 542, 5510, 1, 0, 0, 0, 544, 5512, 1, 0, 0,
		0, 546, 5520, 1, 0, 0, 0, 548, 5522, 1, 0, 0, 0, 550, 5532, 1, 0, 0, 0,
		552, 5541, 1, 0, 0, 0, 554, 5596, 1, 0, 0, 0, 556, 5598, 1, 0, 0, 0, 558,
		5602, 1, 0, 0, 0, 560, 5608, 1, 0, 0, 0, 562, 5610, 1, 0, 0, 0, 564, 5612,
		1, 0, 0, 0, 566, 5623, 1, 0, 0, 0, 568, 5629, 1, 0, 0, 0, 570, 5634, 1,
		0, 0, 0, 572, 5636, 1, 0, 0, 0, 574, 5647, 1, 0, 0, 0, 576, 5649, 1, 0,
		0, 0, 578, 5651, 1, 0, 0, 0, 580, 5675, 1, 0, 0, 0, 582, 5681, 1, 0, 0,
		0, 584, 5685, 1, 0, 0, 0, 586, 5687, 1, 0, 0, 0, 588, 5707, 1, 0, 0, 0,
		590, 5714, 1, 0, 0, 0, 592, 5716, 1, 0, 0, 0, 594, 5719, 1, 0, 0, 0, 596,
		5725, 1, 0, 0, 0, 598, 5727, 1, 0, 0, 0, 600, 5737, 1, 0, 0, 0, 602, 5744,
		1, 0, 0, 0, 604, 5746, 1, 0, 0, 0, 606, 5762, 1, 0, 0, 0, 608, 5790, 1,
		0, 0, 0, 610, 5798, 1, 0, 0, 0, 612, 5820, 1, 0, 0, 0, 614, 5829, 1, 0,
		0, 0, 616, 5859, 1, 0, 0, 0, 618, 5900, 1, 0, 0, 0, 620, 5907, 1, 0, 0,
		0, 622, 5924, 1, 0, 0, 0, 624, 5945, 1, 0, 0, 0, 626, 5973, 1, 0, 0, 0,
		628, 5975, 1, 0, 0, 0, 630, 5984, 1, 0, 0, 0, 632, 6027, 1, 0, 0, 0, 634,
		6029, 1, 0, 0, 0, 636, 6035, 1, 0, 0, 0, 638, 6037, 1, 0, 0, 0, 640, 6362,
		1, 0, 0, 0, 642, 6364, 1, 0, 0, 0, 644, 6373, 1, 0, 0, 0, 646, 6375, 1,
		0, 0, 0, 648, 6377, 1, 0, 0, 0, 650, 6379, 1, 0, 0, 0, 652, 6381, 1, 0,
		0, 0, 654, 6387, 1, 0, 0, 0, 656, 6389, 1, 0, 0, 0, 658, 6395, 1, 0, 0,
		0, 660, 6397, 1, 0, 0, 0, 662, 6403, 1, 0, 0, 0, 664, 6412, 1, 0, 0, 0,
		666, 6415, 1, 0, 0, 0, 668, 6419, 1, 0, 0, 0, 670, 6424, 1, 0, 0, 0, 672,
		6431, 1, 0, 0, 0, 674, 6459, 1, 0, 0, 0, 676, 6461, 1, 0, 0, 0, 678, 6490,
		1, 0, 0, 0, 680, 6500, 1, 0, 0, 0, 682, 6502, 1, 0, 0, 0, 684, 6521, 1,
		0, 0, 0, 686, 6526, 1, 0, 0, 0, 688, 6529, 1, 0, 0, 0, 690, 6531, 1, 0,
		0, 0, 692, 6535, 1, 0, 0, 0, 694, 6537, 1, 0, 0, 0, 696, 6541, 1, 0, 0,
		0, 698, 6585, 1, 0, 0, 0, 700, 6592, 1, 0, 0, 0, 702, 6594, 1, 0, 0, 0,
		704, 6598, 1, 0, 0, 0, 706, 6607, 1, 0, 0, 0, 708, 6615, 1, 0, 0, 0, 710,
		6621, 1, 0, 0, 0, 712, 6623, 1, 0, 0, 0, 714, 6627, 1, 0, 0, 0, 716, 6630,
		1, 0, 0, 0, 718, 6648, 1, 0, 0, 0, 720, 6657, 1, 0, 0, 0, 722, 6682, 1,
		0, 0, 0, 724, 6684, 1, 0, 0, 0, 726, 6688, 1, 0, 0, 0, 728, 6700, 1, 0,
		0, 0, 730, 6702, 1, 0, 0, 0, 732, 6715, 1, 0, 0, 0, 734, 6717, 1, 0, 0,
		0, 736, 6748, 1, 0, 0, 0, 738, 6763, 1, 0, 0, 0, 740, 6769, 1, 0, 0, 0,
		742, 6788, 1, 0, 0, 0, 744, 6790, 1, 0, 0, 0, 746, 6795, 1, 0, 0, 0, 748,
		6799, 1, 0, 0, 0, 750, 6801, 1, 0, 0, 0, 752, 6804, 1, 0, 0, 0, 754, 6812,
		1, 0, 0, 0, 756, 6825, 1, 0, 0, 0, 758, 6844, 1, 0, 0, 0, 760, 6854, 1,
		0, 0, 0, 762, 6862, 1, 0, 0, 0, 764, 6864, 1, 0, 0, 0, 766, 6866, 1, 0,
		0, 0, 768, 6872, 1, 0, 0, 0, 770, 6880, 1, 0, 0, 0, 772, 6882, 1, 0, 0,
		0, 774, 6886, 1, 0, 0, 0, 776, 6888, 1, 0, 0, 0, 778, 6894, 1, 0, 0, 0,
		780, 6898, 1, 0, 0, 0, 782, 6906, 1, 0, 0, 0, 784, 6910, 1, 0, 0, 0, 786,
		6918, 1, 0, 0, 0, 788, 6943, 1, 0, 0, 0, 790, 6959, 1, 0, 0, 0, 792, 6977,
		1, 0, 0, 0, 794, 6981, 1, 0, 0, 0, 796, 6999, 1, 0, 0, 0, 798, 7006, 1,
		0, 0, 0, 800, 7012, 1, 0, 0, 0, 802, 7018, 1, 0, 0, 0, 804, 7117, 1, 0,
		0, 0, 806, 7150, 1, 0, 0, 0, 808, 7152, 1, 0, 0, 0, 810, 7194, 1, 0, 0,
		0, 812, 7196, 1, 0, 0, 0, 814, 7204, 1, 0, 0, 0, 816, 7239, 1, 0, 0, 0,
		818, 7256, 1, 0, 0, 0, 820, 7267, 1, 0, 0, 0, 822, 7305, 1, 0, 0, 0, 824,
		7789, 1, 0, 0, 0, 826, 7797, 1, 0, 0, 0, 828, 7799, 1, 0, 0, 0, 830, 7801,
		1, 0, 0, 0, 832, 7803, 1, 0, 0, 0, 834, 7811, 1, 0, 0, 0, 836, 7820, 1,
		0, 0, 0, 838, 7822, 1, 0, 0, 0, 840, 7857, 1, 0, 0, 0, 842, 7868, 1, 0,
		0, 0, 844, 7870, 1, 0, 0, 0, 846, 7883, 1, 0, 0, 0, 848, 7885, 1, 0, 0,
		0, 850, 7891, 1, 0, 0, 0, 852, 7899, 1, 0, 0, 0, 854, 7916, 1, 0, 0, 0,
		856, 7921, 1, 0, 0, 0, 858, 7931, 1, 0, 0, 0, 860, 7933, 1, 0, 0, 0, 862,
		7950, 1, 0, 0, 0, 864, 7952, 1, 0, 0, 0, 866, 7958, 1, 0, 0, 0, 868, 7960,
		1, 0, 0, 0, 870, 7962, 1, 0, 0, 0, 872, 7968, 1, 0, 0, 0, 874, 7970, 1,
		0, 0, 0, 876, 7976, 1, 0, 0, 0, 878, 7982, 1, 0, 0, 0, 880, 7986, 1, 0,
		0, 0, 882, 7992, 1, 0, 0, 0, 884, 7998, 1, 0, 0, 0, 886, 8007, 1, 0, 0,
		0, 888, 8009, 1, 0, 0, 0, 890, 8089, 1, 0, 0, 0, 892, 8094, 1, 0, 0, 0,
		894, 8129, 1, 0, 0, 0, 896, 8131, 1, 0, 0, 0, 898, 8133, 1, 0, 0, 0, 900,
		8135, 1, 0, 0, 0, 902, 8137, 1, 0, 0, 0, 904, 8143, 1, 0, 0, 0, 906, 8147,
		1, 0, 0, 0, 908, 8170, 1, 0, 0, 0, 910, 8176, 1, 0, 0, 0, 912, 8185, 1,
		0, 0, 0, 914, 8187, 1, 0, 0, 0, 916, 8201, 1, 0, 0, 0, 918, 8203, 1, 0,
		0, 0, 920, 8207, 1, 0, 0, 0, 922, 8229, 1, 0, 0, 0, 924, 8231, 1, 0, 0,
		0, 926, 8264, 1, 0, 0, 0, 928, 8268, 1, 0, 0, 0, 930, 8272, 1, 0, 0, 0,
		932, 8276, 1, 0, 0, 0, 934, 8280, 1, 0, 0, 0, 936, 8282, 1, 0, 0, 0, 938,
		8286, 1, 0, 0, 0, 940, 8288, 1, 0, 0, 0, 942, 8292, 1, 0, 0, 0, 944, 8294,
		1, 0, 0, 0, 946, 8296, 1, 0, 0, 0, 948, 8298, 1, 0, 0, 0, 950, 8300, 1,
		0, 0, 0, 952, 8303, 1, 0, 0, 0, 954, 955, 3, 2, 1, 0, 955, 1, 1, 0, 0,
		0, 956, 967, 5, 0, 0, 1, 957, 967, 5, 905, 0, 0, 958, 959, 3, 4, 2, 0,
		959, 960, 5, 0, 0, 1, 960, 967, 1, 0, 0, 0, 961, 962, 3, 4, 2, 0, 962,
		964, 5, 905, 0, 0, 963, 965, 5, 0, 0, 1, 964, 963, 1, 0, 0, 0, 964, 965,
		1, 0, 0, 0, 965, 967, 1, 0, 0, 0, 966, 956, 1, 0, 0, 0, 966, 957, 1, 0,
		0, 0, 966, 958, 1, 0, 0, 0, 966, 961, 1, 0, 0, 0, 967, 3, 1, 0, 0, 0, 968,
		1042, 3, 436, 218, 0, 969, 1042, 3, 416, 208, 0, 970, 1042, 3, 200, 100,
		0, 971, 1042, 3, 204, 102, 0, 972, 1042, 3, 206, 103, 0, 973, 1042, 3,
		198, 99, 0, 974, 1042, 3, 154, 77, 0, 975, 1042, 3, 168, 84, 0, 976, 1042,
		3, 170, 85, 0, 977, 1042, 3, 186, 93, 0, 978, 1042, 3, 114, 57, 0, 979,
		1042, 3, 110, 55, 0, 980, 1042, 3, 406, 203, 0, 981, 1042, 3, 410, 205,
		0, 982, 1042, 3, 632, 316, 0, 983, 1042, 3, 626, 313, 0, 984, 1042, 3,
		628, 314, 0, 985, 1042, 3, 630, 315, 0, 986, 1042, 3, 640, 320, 0, 987,
		1042, 3, 744, 372, 0, 988, 1042, 3, 750, 375, 0, 989, 1042, 3, 766, 383,
		0, 990, 1042, 3, 784, 392, 0, 991, 1042, 3, 824, 412, 0, 992, 1042, 3,
		772, 386, 0, 993, 1042, 3, 674, 337, 0, 994, 1042, 3, 694, 347, 0, 995,
		1042, 3, 698, 349, 0, 996, 1042, 3, 702, 351, 0, 997, 1042, 3, 708, 354,
		0, 998, 1042, 3, 730, 365, 0, 999, 1042, 3, 742, 371, 0, 1000, 1042, 3,
		722, 361, 0, 1001, 1042, 3, 724, 362, 0, 1002, 1042, 3, 726, 363, 0, 1003,
		1042, 3, 656, 328, 0, 1004, 1042, 3, 662, 331, 0, 1005, 1042, 3, 668, 334,
		0, 1006, 1042, 3, 670, 335, 0, 1007, 1042, 3, 388, 194, 0, 1008, 1042,
		3, 414, 207, 0, 1009, 1042, 3, 728, 364, 0, 1010, 1042, 3, 654, 327, 0,
		1011, 1042, 3, 382, 191, 0, 1012, 1042, 3, 140, 70, 0, 1013, 1042, 3, 150,
		75, 0, 1014, 1042, 3, 152, 76, 0, 1015, 1042, 3, 120, 60, 0, 1016, 1042,
		3, 136, 68, 0, 1017, 1042, 3, 138, 69, 0, 1018, 1042, 3, 902, 451, 0, 1019,
		1042, 3, 904, 452, 0, 1020, 1042, 3, 364, 182, 0, 1021, 1042, 3, 366, 183,
		0, 1022, 1042, 3, 368, 184, 0, 1023, 1042, 3, 778, 389, 0, 1024, 1042,
		3, 776, 388, 0, 1025, 1042, 3, 906, 453, 0, 1026, 1042, 3, 188, 94, 0,
		1027, 1042, 3, 194, 97, 0, 1028, 1042, 3, 914, 457, 0, 1029, 1042, 3, 916,
		458, 0, 1030, 1042, 3, 918, 459, 0, 1031, 1042, 3, 712, 356, 0, 1032, 1042,
		3, 714, 357, 0, 1033, 1042, 3, 816, 408, 0, 1034, 1042, 3, 818, 409, 0,
		1035, 1042, 3, 624, 312, 0, 1036, 1042, 3, 172, 86, 0, 1037, 1042, 3, 924,
		462, 0, 1038, 1042, 3, 920, 460, 0, 1039, 1042, 3, 820, 410, 0, 1040, 1042,
		3, 822, 411, 0, 1041, 968, 1, 0, 0, 0, 1041, 969, 1, 0, 0, 0, 1041, 970,
		1, 0, 0, 0, 1041, 971, 1, 0, 0, 0, 1041, 972, 1, 0, 0, 0, 1041, 973, 1,
		0, 0, 0, 1041, 974, 1, 0, 0, 0, 1041, 975, 1, 0, 0, 0, 1041, 976, 1, 0,
		0, 0, 1041, 977, 1, 0, 0, 0, 1041, 978, 1, 0, 0, 0, 1041, 979, 1, 0, 0,
		0, 1041, 980, 1, 0, 0, 0, 1041, 981, 1, 0, 0, 0, 1041, 982, 1, 0, 0, 0,
		1041, 983, 1, 0, 0, 0, 1041, 984, 1, 0, 0, 0, 1041, 985, 1, 0, 0, 0, 1041,
		986, 1, 0, 0, 0, 1041, 987, 1, 0, 0, 0, 1041, 988, 1, 0, 0, 0, 1041, 989,
		1, 0, 0, 0, 1041, 990, 1, 0, 0, 0, 1041, 991, 1, 0, 0, 0, 1041, 992, 1,
		0, 0, 0, 1041, 993, 1, 0, 0, 0, 1041, 994, 1, 0, 0, 0, 1041, 995, 1, 0,
		0, 0, 1041, 996, 1, 0, 0, 0, 1041, 997, 1, 0, 0, 0, 1041, 998, 1, 0, 0,
		0, 1041, 999, 1, 0, 0, 0, 1041, 1000, 1, 0, 0, 0, 1041, 1001, 1, 0, 0,
		0, 1041, 1002, 1, 0, 0, 0, 1041, 1003, 1, 0, 0, 0, 1041, 1004, 1, 0, 0,
		0, 1041, 1005, 1, 0, 0, 0, 1041, 1006, 1, 0, 0, 0, 1041, 1007, 1, 0, 0,
		0, 1041, 1008, 1, 0, 0, 0, 1041, 1009, 1, 0, 0, 0, 1041, 1010, 1, 0, 0,
		0, 1041, 1011, 1, 0, 0, 0, 1041, 1012, 1, 0, 0, 0, 1041, 1013, 1, 0, 0,
		0, 1041, 1014, 1, 0, 0, 0, 1041, 1015, 1, 0, 0, 0, 1041, 1016, 1, 0, 0,
		0, 1041, 1017, 1, 0, 0, 0, 1041, 1018, 1, 0, 0, 0, 1041, 1019, 1, 0, 0,
		0, 1041, 1020, 1, 0, 0, 0, 1041, 1021, 1, 0, 0, 0, 1041, 1022, 1, 0, 0,
		0, 1041, 1023, 1, 0, 0, 0, 1041, 1024, 1, 0, 0, 0, 1041, 1025, 1, 0, 0,
		0, 1041, 1026, 1, 0, 0, 0, 1041, 1027, 1, 0, 0, 0, 1041, 1028, 1, 0, 0,
		0, 1041, 1029, 1, 0, 0, 0, 1041, 1030, 1, 0, 0, 0, 1041, 1031, 1, 0, 0,
		0, 1041, 1032, 1, 0, 0, 0, 1041, 1033, 1, 0, 0, 0, 1041, 1034, 1, 0, 0,
		0, 1041, 1035, 1, 0, 0, 0, 1041, 1036, 1, 0, 0, 0, 1041, 1037, 1, 0, 0,
		0, 1041, 1038, 1, 0, 0, 0, 1041, 1039, 1, 0, 0, 0, 1041, 1040, 1, 0, 0,
		0, 1042, 5, 1, 0, 0, 0, 1043, 1048, 3, 36, 18, 0, 1044, 1045, 5, 890, 0,
		0, 1045, 1047, 3, 36, 18, 0, 1046, 1044, 1, 0, 0, 0, 1047, 1050, 1, 0,
		0, 0, 1048, 1046, 1, 0, 0, 0, 1048, 1049, 1, 0, 0, 0, 1049, 7, 1, 0, 0,
		0, 1050, 1048, 1, 0, 0, 0, 1051, 1056, 3, 10, 5, 0, 1052, 1053, 5, 890,
		0, 0, 1053, 1055, 3, 10, 5, 0, 1054, 1052, 1, 0, 0, 0, 1055, 1058, 1, 0,
		0, 0, 1056, 1054, 1, 0, 0, 0, 1056, 1057, 1, 0, 0, 0, 1057, 9, 1, 0, 0,
		0, 1058, 1056, 1, 0, 0, 0, 1059, 1073, 3, 36, 18, 0, 1060, 1062, 3, 36,
		18, 0, 1061, 1063, 5, 9, 0, 0, 1062, 1061, 1, 0, 0, 0, 1062, 1063, 1, 0,
		0, 0, 1063, 1064, 1, 0, 0, 0, 1064, 1065, 3, 938, 469, 0, 1065, 1073, 1,
		0, 0, 0, 1066, 1068, 3, 36, 18, 0, 1067, 1069, 5, 9, 0, 0, 1068, 1067,
		1, 0, 0, 0, 1068, 1069, 1, 0, 0, 0, 1069, 1070, 1, 0, 0, 0, 1070, 1071,
		5, 923, 0, 0, 1071, 1073, 1, 0, 0, 0, 1072, 1059, 1, 0, 0, 0, 1072, 1060,
		1, 0, 0, 0, 1072, 1066, 1, 0, 0, 0, 1073, 11, 1, 0, 0, 0, 1074, 1101, 3,
		932, 466, 0, 1075, 1076, 3, 934, 467, 0, 1076, 1077, 5, 901, 0, 0, 1077,
		1078, 3, 932, 466, 0, 1078, 1101, 1, 0, 0, 0, 1079, 1080, 3, 934, 467,
		0, 1080, 1081, 5, 901, 0, 0, 1081, 1082, 5, 894, 0, 0, 1082, 1101, 1, 0,
		0, 0, 1083, 1084, 3, 934, 467, 0, 1084, 1085, 5, 901, 0, 0, 1085, 1086,
		3, 934, 467, 0, 1086, 1087, 5, 901, 0, 0, 1087, 1088, 3, 932, 466, 0, 1088,
		1101, 1, 0, 0, 0, 1089, 1090, 3, 934, 467, 0, 1090, 1091, 5, 901, 0, 0,
		1091, 1092, 3, 934, 467, 0, 1092, 1093, 5, 901, 0, 0, 1093, 1094, 5, 894,
		0, 0, 1094, 1101, 1, 0, 0, 0, 1095, 1096, 5, 901, 0, 0, 1096, 1097, 3,
		934, 467, 0, 1097, 1098, 5, 901, 0, 0, 1098, 1099, 3, 932, 466, 0, 1099,
		1101, 1, 0, 0, 0, 1100, 1074, 1, 0, 0, 0, 1100, 1075, 1, 0, 0, 0, 1100,
		1079, 1, 0, 0, 0, 1100, 1083, 1, 0, 0, 0, 1100, 1089, 1, 0, 0, 0, 1100,
		1095, 1, 0, 0, 0, 1101, 13, 1, 0, 0, 0, 1102, 1104, 3, 16, 8, 0, 1103,
		1102, 1, 0, 0, 0, 1103, 1104, 1, 0, 0, 0, 1104, 1105, 1, 0, 0, 0, 1105,
		1110, 5, 923, 0, 0, 1106, 1107, 3, 16, 8, 0, 1107, 1108, 5, 887, 0, 0,
		1108, 1110, 1, 0, 0, 0, 1109, 1103, 1, 0, 0, 0, 1109, 1106, 1, 0, 0, 0,
		1110, 15, 1, 0, 0, 0, 1111, 1112, 7, 0, 0, 0, 1112, 17, 1, 0, 0, 0, 1113,
		1123, 3, 14, 7, 0, 1114, 1123, 5, 888, 0, 0, 1115, 1123, 5, 343, 0, 0,
		1116, 1123, 5, 271, 0, 0, 1117, 1123, 5, 358, 0, 0, 1118, 1123, 5, 883,
		0, 0, 1119, 1123, 5, 884, 0, 0, 1120, 1123, 5, 270, 0, 0, 1121, 1123, 5,
		887, 0, 0, 1122, 1113, 1, 0, 0, 0, 1122, 1114, 1, 0, 0, 0, 1122, 1115,
		1, 0, 0, 0, 1122, 1116, 1, 0, 0, 0, 1122, 1117, 1, 0, 0, 0, 1122, 1118,
		1, 0, 0, 0, 1122, 1119, 1, 0, 0, 0, 1122, 1120, 1, 0, 0, 0, 1122, 1121,
		1, 0, 0, 0, 1123, 19, 1, 0, 0, 0, 1124, 1125, 7, 1, 0, 0, 1125, 21, 1,
		0, 0, 0, 1126, 1134, 3, 18, 9, 0, 1127, 1134, 5, 919, 0, 0, 1128, 1134,
		5, 918, 0, 0, 1129, 1130, 3, 26, 13, 0, 1130, 1131, 5, 901, 0, 0, 1131,
		1132, 3, 932, 466, 0, 1132, 1134, 1, 0, 0, 0, 1133, 1126, 1, 0, 0, 0, 1133,
		1127, 1, 0, 0, 0, 1133, 1128, 1, 0, 0, 0, 1133, 1129, 1, 0, 0, 0, 1134,
		23, 1, 0, 0, 0, 1135, 1153, 5, 923, 0, 0, 1136, 1153, 5, 888, 0, 0, 1137,
		1153, 5, 343, 0, 0, 1138, 1153, 5, 271, 0, 0, 1139, 1153, 5, 358, 0, 0,
		1140, 1153, 5, 883, 0, 0, 1141, 1153, 5, 884, 0, 0, 1142, 1153, 5, 270,
		0, 0, 1143, 1153, 5, 919, 0, 0, 1144, 1145, 3, 26, 13, 0, 1145, 1146, 5,
		901, 0, 0, 1146, 1147, 3, 932, 466, 0, 1147, 1153, 1, 0, 0, 0, 1148, 1149,
		5, 897, 0, 0, 1149, 1153, 5, 271, 0, 0, 1150, 1151, 5, 897, 0, 0, 1151,
		1153, 5, 883, 0, 0, 1152, 1135, 1, 0, 0, 0, 1152, 1136, 1, 0, 0, 0, 1152,
		1137, 1, 0, 0, 0, 1152, 1138, 1, 0, 0, 0, 1152, 1139, 1, 0, 0, 0, 1152,
		1140, 1, 0, 0, 0, 1152, 1141, 1, 0, 0, 0, 1152, 1142, 1, 0, 0, 0, 1152,
		1143, 1, 0, 0, 0, 1152, 1144, 1, 0, 0, 0, 1152, 1148, 1, 0, 0, 0, 1152,
		1150, 1, 0, 0, 0, 1153, 25, 1, 0, 0, 0, 1154, 1155, 7, 2, 0, 0, 1155, 27,
		1, 0, 0, 0, 1156, 1157, 6, 14, -1, 0, 1157, 1158, 3, 30, 15, 0, 1158, 1232,
		1, 0, 0, 0, 1159, 1160, 10, 16, 0, 0, 1160, 1161, 5, 112, 0, 0, 1161, 1231,
		5, 270, 0, 0, 1162, 1163, 10, 15, 0, 0, 1163, 1164, 5, 112, 0, 0, 1164,
		1165, 3, 38, 19, 0, 1165, 1166, 5, 270, 0, 0, 1166, 1231, 1, 0, 0, 0, 1167,
		1168, 10, 14, 0, 0, 1168, 1169, 5, 913, 0, 0, 1169, 1231, 3, 30, 15, 0,
		1170, 1171, 10, 13, 0, 0, 1171, 1172, 5, 913, 0, 0, 1172, 1173, 3, 42,
		21, 0, 1173, 1174, 5, 896, 0, 0, 1174, 1175, 3, 442, 221, 0, 1175, 1176,
		5, 903, 0, 0, 1176, 1231, 1, 0, 0, 0, 1177, 1178, 10, 12, 0, 0, 1178, 1179,
		5, 914, 0, 0, 1179, 1231, 3, 30, 15, 0, 1180, 1181, 10, 11, 0, 0, 1181,
		1182, 5, 914, 0, 0, 1182, 1183, 3, 42, 21, 0, 1183, 1184, 5, 896, 0, 0,
		1184, 1185, 3, 442, 221, 0, 1185, 1186, 5, 903, 0, 0, 1186, 1231, 1, 0,
		0, 0, 1187, 1188, 10, 10, 0, 0, 1188, 1189, 5, 908, 0, 0, 1189, 1231, 3,
		30, 15, 0, 1190, 1191, 10, 9, 0, 0, 1191, 1192, 5, 908, 0, 0, 1192, 1193,
		3, 42, 21, 0, 1193, 1194, 5, 896, 0, 0, 1194, 1195, 3, 442, 221, 0, 1195,
		1196, 5, 903, 0, 0, 1196, 1231, 1, 0, 0, 0, 1197, 1198, 10, 8, 0, 0, 1198,
		1199, 5, 910, 0, 0, 1199, 1231, 3, 30, 15, 0, 1200, 1201, 10, 7, 0, 0,
		1201, 1202, 5, 911, 0, 0, 1202, 1231, 3, 30, 15, 0, 1203, 1204, 10, 6,
		0, 0, 1204, 1205, 5, 911, 0, 0, 1205, 1206, 3, 42, 21, 0, 1206, 1207, 5,
		896, 0, 0, 1207, 1208, 3, 442, 221, 0, 1208, 1209, 5, 903, 0, 0, 1209,
		1231, 1, 0, 0, 0, 1210, 1211, 10, 5, 0, 0, 1211, 1212, 5, 912, 0, 0, 1212,
		1231, 3, 30, 15, 0, 1213, 1214, 10, 4, 0, 0, 1214, 1215, 5, 912, 0, 0,
		1215, 1216, 3, 42, 21, 0, 1216, 1217, 5, 896, 0, 0, 1217, 1218, 3, 442,
		221, 0, 1218, 1219, 5, 903, 0, 0, 1219, 1231, 1, 0, 0, 0, 1220, 1221, 10,
		3, 0, 0, 1221, 1222, 5, 915, 0, 0, 1222, 1231, 3, 30, 15, 0, 1223, 1224,
		10, 2, 0, 0, 1224, 1225, 5, 915, 0, 0, 1225, 1226, 3, 42, 21, 0, 1226,
		1227, 5, 896, 0, 0, 1227, 1228, 3, 442, 221, 0, 1228, 1229, 5, 903, 0,
		0, 1229, 1231, 1, 0, 0, 0, 1230, 1159, 1, 0, 0, 0, 1230, 1162, 1, 0, 0,
		0, 1230, 1167, 1, 0, 0, 0, 1230, 1170, 1, 0, 0, 0, 1230, 1177, 1, 0, 0,
		0, 1230, 1180, 1, 0, 0, 0, 1230, 1187, 1, 0, 0, 0, 1230, 1190, 1, 0, 0,
		0, 1230, 1197, 1, 0, 0, 0, 1230, 1200, 1, 0, 0, 0, 1230, 1203, 1, 0, 0,
		0, 1230, 1210, 1, 0, 0, 0, 1230, 1213, 1, 0, 0, 0, 1230, 1220, 1, 0, 0,
		0, 1230, 1223, 1, 0, 0, 0, 1231, 1234, 1, 0, 0, 0, 1232, 1230, 1, 0, 0,
		0, 1232, 1233, 1, 0, 0, 0, 1233, 29, 1, 0, 0, 0, 1234, 1232, 1, 0, 0, 0,
		1235, 1236, 3, 32, 16, 0, 1236, 1237, 5, 95, 0, 0, 1237, 1238, 3, 44, 22,
		0, 1238, 1290, 1, 0, 0, 0, 1239, 1240, 3, 32, 16, 0, 1240, 1241, 3, 38,
		19, 0, 1241, 1242, 5, 95, 0, 0, 1242, 1243, 3, 44, 22, 0, 1243, 1290, 1,
		0, 0, 0, 1244, 1245, 3, 32, 16, 0, 1245, 1246, 3, 38, 19, 0, 1246, 1247,
		5, 12, 0, 0, 1247, 1248, 3, 32, 16, 0, 1248, 1249, 5, 6, 0, 0, 1249, 1250,
		3, 30, 15, 0, 1250, 1290, 1, 0, 0, 0, 1251, 1252, 3, 32, 16, 0, 1252, 1253,
		5, 12, 0, 0, 1253, 1254, 3, 32, 16, 0, 1254, 1255, 5, 6, 0, 0, 1255, 1256,
		3, 30, 15, 0, 1256, 1290, 1, 0, 0, 0, 1257, 1258, 3, 32, 16, 0, 1258, 1259,
		5, 124, 0, 0, 1259, 1260, 3, 34, 17, 0, 1260, 1290, 1, 0, 0, 0, 1261, 1262,
		3, 32, 16, 0, 1262, 1263, 5, 124, 0, 0, 1263, 1264, 3, 34, 17, 0, 1264,
		1265, 5, 793, 0, 0, 1265, 1266, 3, 34, 17, 0, 1266, 1290, 1, 0, 0, 0, 1267,
		1268, 3, 32, 16, 0, 1268, 1269, 3, 38, 19, 0, 1269, 1270, 5, 124, 0, 0,
		1270, 1271, 3, 34, 17, 0, 1271, 1290, 1, 0, 0, 0, 1272, 1273, 3, 32, 16,
		0, 1273, 1274, 3, 38, 19, 0, 1274, 1275, 5, 124, 0, 0, 1275, 1276, 3, 34,
		17, 0, 1276, 1277, 5, 793, 0, 0, 1277, 1278, 3, 34, 17, 0, 1278, 1290,
		1, 0, 0, 0, 1279, 1280, 3, 32, 16, 0, 1280, 1281, 5, 177, 0, 0, 1281, 1282,
		3, 32, 16, 0, 1282, 1290, 1, 0, 0, 0, 1283, 1284, 3, 32, 16, 0, 1284, 1285,
		3, 38, 19, 0, 1285, 1286, 5, 177, 0, 0, 1286, 1287, 3, 32, 16, 0, 1287,
		1290, 1, 0, 0, 0, 1288, 1290, 3, 32, 16, 0, 1289, 1235, 1, 0, 0, 0, 1289,
		1239, 1, 0, 0, 0, 1289, 1244, 1, 0, 0, 0, 1289, 1251, 1, 0, 0, 0, 1289,
		1257, 1, 0, 0, 0, 1289, 1261, 1, 0, 0, 0, 1289, 1267, 1, 0, 0, 0, 1289,
		1272, 1, 0, 0, 0, 1289, 1279, 1, 0, 0, 0, 1289, 1283, 1, 0, 0, 0, 1289,
		1288, 1, 0, 0, 0, 1290, 31, 1, 0, 0, 0, 1291, 1292, 6, 16, -1, 0, 1292,
		1293, 3, 34, 17, 0, 1293, 1344, 1, 0, 0, 0, 1294, 1295, 10, 15, 0, 0, 1295,
		1296, 5, 893, 0, 0, 1296, 1343, 3, 32, 16, 16, 1297, 1298, 10, 14, 0, 0,
		1298, 1299, 5, 892, 0, 0, 1299, 1343, 3, 32, 16, 15, 1300, 1301, 10, 13,
		0, 0, 1301, 1302, 5, 916, 0, 0, 1302, 1343, 3, 32, 16, 14, 1303, 1304,
		10, 12, 0, 0, 1304, 1305, 5, 917, 0, 0, 1305, 1343, 3, 32, 16, 13, 1306,
		1307, 10, 11, 0, 0, 1307, 1308, 5, 891, 0, 0, 1308, 1343, 3, 32, 16, 12,
		1309, 1310, 10, 10, 0, 0, 1310, 1311, 5, 897, 0, 0, 1311, 1343, 3, 32,
		16, 11, 1312, 1313, 10, 7, 0, 0, 1313, 1314, 5, 894, 0, 0, 1314, 1343,
		3, 32, 16, 8, 1315, 1316, 10, 6, 0, 0, 1316, 1317, 5, 898, 0, 0, 1317,
		1343, 3, 32, 16, 7, 1318, 1319, 10, 5, 0, 0, 1319, 1320, 5, 902, 0, 0,
		1320, 1343, 3, 32, 16, 6, 1321, 1322, 10, 4, 0, 0, 1322, 1323, 5, 149,
		0, 0, 1323, 1343, 3, 32, 16, 5, 1324, 1325, 10, 3, 0, 0, 1325, 1326, 5,
		58, 0, 0, 1326, 1343, 3, 32, 16, 4, 1327, 1328, 10, 2, 0, 0, 1328, 1329,
		5, 899, 0, 0, 1329, 1343, 3, 32, 16, 3, 1330, 1331, 10, 9, 0, 0, 1331,
		1332, 5, 891, 0, 0, 1332, 1333, 5, 107, 0, 0, 1333, 1334, 3, 36, 18, 0,
		1334, 1335, 3, 940, 470, 0, 1335, 1343, 1, 0, 0, 0, 1336, 1337, 10, 8,
		0, 0, 1337, 1338, 5, 897, 0, 0, 1338, 1339, 5, 107, 0, 0, 1339, 1340, 3,
		36, 18, 0, 1340, 1341, 3, 940, 470, 0, 1341, 1343, 1, 0, 0, 0, 1342, 1294,
		1, 0, 0, 0, 1342, 1297, 1, 0, 0, 0, 1342, 1300, 1, 0, 0, 0, 1342, 1303,
		1, 0, 0, 0, 1342, 1306, 1, 0, 0, 0, 1342, 1309, 1, 0, 0, 0, 1342, 1312,
		1, 0, 0, 0, 1342, 1315, 1, 0, 0, 0, 1342, 1318, 1, 0, 0, 0, 1342, 1321,
		1, 0, 0, 0, 1342, 1324, 1, 0, 0, 0, 1342, 1327, 1, 0, 0, 0, 1342, 1330,
		1, 0, 0, 0, 1342, 1336, 1, 0, 0, 0, 1343, 1346, 1, 0, 0, 0, 1344, 1342,
		1, 0, 0, 0, 1344, 1345, 1, 0, 0, 0, 1345, 33, 1, 0, 0, 0, 1346, 1344, 1,
		0, 0, 0, 1347, 1348, 6, 17, -1, 0, 1348, 1349, 5, 15, 0, 0, 1349, 1404,
		3, 34, 17, 18, 1350, 1404, 3, 12, 6, 0, 1351, 1404, 3, 22, 11, 0, 1352,
		1353, 5, 891, 0, 0, 1353, 1404, 3, 34, 17, 14, 1354, 1355, 5, 897, 0, 0,
		1355, 1404, 3, 34, 17, 13, 1356, 1357, 5, 904, 0, 0, 1357, 1404, 3, 34,
		17, 12, 1358, 1359, 3, 40, 20, 0, 1359, 1360, 3, 34, 17, 11, 1360, 1404,
		1, 0, 0, 0, 1361, 1404, 3, 440, 220, 0, 1362, 1363, 5, 896, 0, 0, 1363,
		1364, 3, 36, 18, 0, 1364, 1365, 5, 903, 0, 0, 1365, 1404, 1, 0, 0, 0, 1366,
		1367, 5, 896, 0, 0, 1367, 1368, 3, 6, 3, 0, 1368, 1369, 5, 890, 0, 0, 1369,
		1370, 3, 36, 18, 0, 1370, 1371, 5, 903, 0, 0, 1371, 1404, 1, 0, 0, 0, 1372,
		1373, 5, 705, 0, 0, 1373, 1374, 5, 896, 0, 0, 1374, 1375, 3, 6, 3, 0, 1375,
		1376, 5, 890, 0, 0, 1376, 1377, 3, 36, 18, 0, 1377, 1378, 5, 903, 0, 0,
		1378, 1404, 1, 0, 0, 0, 1379, 1380, 5, 69, 0, 0, 1380, 1404, 3, 440, 220,
		0, 1381, 1382, 5, 140, 0, 0, 1382, 1383, 5, 896, 0, 0, 1383, 1384, 3, 428,
		214, 0, 1384, 1385, 5, 903, 0, 0, 1385, 1386, 5, 3, 0, 0, 1386, 1387, 5,
		896, 0, 0, 1387, 1395, 5, 923, 0, 0, 1388, 1389, 5, 95, 0, 0, 1389, 1390,
		5, 152, 0, 0, 1390, 1391, 5, 119, 0, 0, 1391, 1396, 5, 150, 0, 0, 1392,
		1393, 5, 95, 0, 0, 1393, 1394, 5, 778, 0, 0, 1394, 1396, 5, 150, 0, 0,
		1395, 1388, 1, 0, 0, 0, 1395, 1392, 1, 0, 0, 0, 1395, 1396, 1, 0, 0, 0,
		1396, 1397, 1, 0, 0, 0, 1397, 1398, 5, 903, 0, 0, 1398, 1404, 1, 0, 0,
		0, 1399, 1404, 3, 46, 23, 0, 1400, 1404, 3, 86, 43, 0, 1401, 1404, 3, 48,
		24, 0, 1402, 1404, 5, 920, 0, 0, 1403, 1347, 1, 0, 0, 0, 1403, 1350, 1,
		0, 0, 0, 1403, 1351, 1, 0, 0, 0, 1403, 1352, 1, 0, 0, 0, 1403, 1354, 1,
		0, 0, 0, 1403, 1356, 1, 0, 0, 0, 1403, 1358, 1, 0, 0, 0, 1403, 1361, 1,
		0, 0, 0, 1403, 1362, 1, 0, 0, 0, 1403, 1366, 1, 0, 0, 0, 1403, 1372, 1,
		0, 0, 0, 1403, 1379, 1, 0, 0, 0, 1403, 1381, 1, 0, 0, 0, 1403, 1399, 1,
		0, 0, 0, 1403, 1400, 1, 0, 0, 0, 1403, 1401, 1, 0, 0, 0, 1403, 1402, 1,
		0, 0, 0, 1404, 1412, 1, 0, 0, 0, 1405, 1406, 10, 15, 0, 0, 1406, 1407,
		5, 906, 0, 0, 1407, 1411, 3, 34, 17, 16, 1408, 1409, 10, 19, 0, 0, 1409,
		1411, 3, 264, 132, 0, 1410, 1405, 1, 0, 0, 0, 1410, 1408, 1, 0, 0, 0, 1411,
		1414, 1, 0, 0, 0, 1412, 1410, 1, 0, 0, 0, 1412, 1413, 1, 0, 0, 0, 1413,
		35, 1, 0, 0, 0, 1414, 1412, 1, 0, 0, 0, 1415, 1416, 6, 18, -1, 0, 1416,
		1417, 5, 269, 0, 0, 1417, 1441, 3, 36, 18, 7, 1418, 1419, 3, 28, 14, 0,
		1419, 1420, 5, 112, 0, 0, 1420, 1421, 5, 884, 0, 0, 1421, 1441, 1, 0, 0,
		0, 1422, 1423, 3, 28, 14, 0, 1423, 1424, 5, 112, 0, 0, 1424, 1425, 3, 38,
		19, 0, 1425, 1426, 5, 884, 0, 0, 1426, 1441, 1, 0, 0, 0, 1427, 1428, 3,
		28, 14, 0, 1428, 1429, 5, 112, 0, 0, 1429, 1430, 5, 435, 0, 0, 1430, 1441,
		1, 0, 0, 0, 1431, 1432, 3, 28, 14, 0, 1432, 1433, 5, 112, 0, 0, 1433, 1434,
		3, 38, 19, 0, 1434, 1435, 5, 435, 0, 0, 1435, 1441, 1, 0, 0, 0, 1436, 1441,
		3, 28, 14, 0, 1437, 1438, 5, 920, 0, 0, 1438, 1439, 5, 909, 0, 0, 1439,
		1441, 3, 36, 18, 1, 1440, 1415, 1, 0, 0, 0, 1440, 1418, 1, 0, 0, 0, 1440,
		1422, 1, 0, 0, 0, 1440, 1427, 1, 0, 0, 0, 1440, 1431, 1, 0, 0, 0, 1440,
		1436, 1, 0, 0, 0, 1440, 1437, 1, 0, 0, 0, 1441, 1459, 1, 0, 0, 0, 1442,
		1443, 10, 12, 0, 0, 1443, 1444, 5, 6, 0, 0, 1444, 1458, 3, 36, 18, 13,
		1445, 1446, 10, 11, 0, 0, 1446, 1447, 5, 907, 0, 0, 1447, 1458, 3, 36,
		18, 12, 1448, 1449, 10, 10, 0, 0, 1449, 1450, 5, 158, 0, 0, 1450, 1458,
		3, 36, 18, 11, 1451, 1452, 10, 9, 0, 0, 1452, 1453, 5, 906, 0, 0, 1453,
		1458, 3, 36, 18, 10, 1454, 1455, 10, 8, 0, 0, 1455, 1456, 5, 249, 0, 0,
		1456, 1458, 3, 36, 18, 9, 1457, 1442, 1, 0, 0, 0, 1457, 1445, 1, 0, 0,
		0, 1457, 1448, 1, 0, 0, 0, 1457, 1451, 1, 0, 0, 0, 1457, 1454, 1, 0, 0,
		0, 1458, 1461, 1, 0, 0, 0, 1459, 1457, 1, 0, 0, 0, 1459, 1460, 1, 0, 0,
		0, 1460, 37, 1, 0, 0, 0, 1461, 1459, 1, 0, 0, 0, 1462, 1463, 7, 3, 0, 0,
		1463, 39, 1, 0, 0, 0, 1464, 1465, 7, 4, 0, 0, 1465, 41, 1, 0, 0, 0, 1466,
		1467, 7, 5, 0, 0, 1467, 43, 1, 0, 0, 0, 1468, 1474, 3, 440, 220, 0, 1469,
		1470, 5, 896, 0, 0, 1470, 1471, 3, 6, 3, 0, 1471, 1472, 5, 903, 0, 0, 1472,
		1474, 1, 0, 0, 0, 1473, 1468, 1, 0, 0, 0, 1473, 1469, 1, 0, 0, 0, 1474,
		45, 1, 0, 0, 0, 1475, 1476, 5, 22, 0, 0, 1476, 1477, 3, 78, 39, 0, 1477,
		1478, 3, 80, 40, 0, 1478, 1479, 3, 84, 42, 0, 1479, 1480, 5, 631, 0, 0,
		1480, 47, 1, 0, 0, 0, 1481, 1482, 5, 531, 0, 0, 1482, 1484, 5, 896, 0,
		0, 1483, 1485, 5, 8, 0, 0, 1484, 1483, 1, 0, 0, 0, 1484, 1485, 1, 0, 0,
		0, 1485, 1486, 1, 0, 0, 0, 1486, 1487, 5, 894, 0, 0, 1487, 1488, 5, 903,
		0, 0, 1488, 1489, 5, 643, 0, 0, 1489, 1714, 3, 58, 29, 0, 1490, 1491, 5,
		531, 0, 0, 1491, 1493, 5, 896, 0, 0, 1492, 1494, 5, 8, 0, 0, 1493, 1492,
		1, 0, 0, 0, 1493, 1494, 1, 0, 0, 0, 1494, 1495, 1, 0, 0, 0, 1495, 1496,
		3, 36, 18, 0, 1496, 1497, 5, 903, 0, 0, 1497, 1498, 5, 643, 0, 0, 1498,
		1499, 3, 58, 29, 0, 1499, 1714, 1, 0, 0, 0, 1500, 1501, 5, 531, 0, 0, 1501,
		1502, 5, 896, 0, 0, 1502, 1503, 5, 59, 0, 0, 1503, 1504, 3, 6, 3, 0, 1504,
		1505, 5, 903, 0, 0, 1505, 1506, 5, 643, 0, 0, 1506, 1507, 3, 58, 29, 0,
		1507, 1714, 1, 0, 0, 0, 1508, 1509, 5, 872, 0, 0, 1509, 1510, 5, 896, 0,
		0, 1510, 1511, 3, 6, 3, 0, 1511, 1512, 5, 903, 0, 0, 1512, 1513, 5, 643,
		0, 0, 1513, 1514, 3, 58, 29, 0, 1514, 1714, 1, 0, 0, 0, 1515, 1516, 5,
		429, 0, 0, 1516, 1517, 5, 896, 0, 0, 1517, 1518, 3, 6, 3, 0, 1518, 1519,
		5, 903, 0, 0, 1519, 1520, 5, 643, 0, 0, 1520, 1521, 3, 58, 29, 0, 1521,
		1714, 1, 0, 0, 0, 1522, 1523, 5, 781, 0, 0, 1523, 1524, 5, 896, 0, 0, 1524,
		1525, 3, 36, 18, 0, 1525, 1526, 5, 903, 0, 0, 1526, 1527, 5, 643, 0, 0,
		1527, 1528, 3, 58, 29, 0, 1528, 1714, 1, 0, 0, 0, 1529, 1530, 5, 452, 0,
		0, 1530, 1532, 5, 896, 0, 0, 1531, 1533, 7, 6, 0, 0, 1532, 1531, 1, 0,
		0, 0, 1532, 1533, 1, 0, 0, 0, 1533, 1534, 1, 0, 0, 0, 1534, 1535, 3, 36,
		18, 0, 1535, 1536, 5, 903, 0, 0, 1536, 1537, 5, 643, 0, 0, 1537, 1538,
		3, 58, 29, 0, 1538, 1714, 1, 0, 0, 0, 1539, 1540, 5, 364, 0, 0, 1540, 1542,
		5, 896, 0, 0, 1541, 1543, 7, 6, 0, 0, 1542, 1541, 1, 0, 0, 0, 1542, 1543,
		1, 0, 0, 0, 1543, 1544, 1, 0, 0, 0, 1544, 1545, 3, 36, 18, 0, 1545, 1546,
		5, 903, 0, 0, 1546, 1547, 5, 643, 0, 0, 1547, 1548, 3, 58, 29, 0, 1548,
		1714, 1, 0, 0, 0, 1549, 1550, 5, 454, 0, 0, 1550, 1552, 5, 896, 0, 0, 1551,
		1553, 7, 6, 0, 0, 1552, 1551, 1, 0, 0, 0, 1552, 1553, 1, 0, 0, 0, 1553,
		1554, 1, 0, 0, 0, 1554, 1555, 3, 36, 18, 0, 1555, 1556, 5, 903, 0, 0, 1556,
		1557, 5, 643, 0, 0, 1557, 1558, 3, 58, 29, 0, 1558, 1714, 1, 0, 0, 0, 1559,
		1560, 5, 779, 0, 0, 1560, 1562, 5, 896, 0, 0, 1561, 1563, 7, 6, 0, 0, 1562,
		1561, 1, 0, 0, 0, 1562, 1563, 1, 0, 0, 0, 1563, 1564, 1, 0, 0, 0, 1564,
		1565, 3, 36, 18, 0, 1565, 1566, 5, 903, 0, 0, 1566, 1567, 5, 643, 0, 0,
		1567, 1568, 3, 58, 29, 0, 1568, 1714, 1, 0, 0, 0, 1569, 1570, 5, 392, 0,
		0, 1570, 1572, 5, 896, 0, 0, 1571, 1573, 7, 6, 0, 0, 1572, 1571, 1, 0,
		0, 0, 1572, 1573, 1, 0, 0, 0, 1573, 1574, 1, 0, 0, 0, 1574, 1575, 3, 36,
		18, 0, 1575, 1576, 5, 903, 0, 0, 1576, 1577, 5, 643, 0, 0, 1577, 1578,
		3, 58, 29, 0, 1578, 1714, 1, 0, 0, 0, 1579, 1580, 5, 465, 0, 0, 1580, 1582,
		5, 896, 0, 0, 1581, 1583, 7, 6, 0, 0, 1582, 1581, 1, 0, 0, 0, 1582, 1583,
		1, 0, 0, 0, 1583, 1584, 1, 0, 0, 0, 1584, 1585, 3, 36, 18, 0, 1585, 1586,
		5, 903, 0, 0, 1586, 1587, 5, 643, 0, 0, 1587, 1588, 3, 58, 29, 0, 1588,
		1714, 1, 0, 0, 0, 1589, 1590, 5, 762, 0, 0, 1590, 1592, 5, 896, 0, 0, 1591,
		1593, 7, 6, 0, 0, 1592, 1591, 1, 0, 0, 0, 1592, 1593, 1, 0, 0, 0, 1593,
		1594, 1, 0, 0, 0, 1594, 1595, 3, 36, 18, 0, 1595, 1596, 5, 903, 0, 0, 1596,
		1597, 5, 643, 0, 0, 1597, 1598, 3, 58, 29, 0, 1598, 1714, 1, 0, 0, 0, 1599,
		1600, 5, 516, 0, 0, 1600, 1602, 5, 896, 0, 0, 1601, 1603, 7, 6, 0, 0, 1602,
		1601, 1, 0, 0, 0, 1602, 1603, 1, 0, 0, 0, 1603, 1604, 1, 0, 0, 0, 1604,
		1605, 3, 36, 18, 0, 1605, 1606, 5, 903, 0, 0, 1606, 1607, 5, 643, 0, 0,
		1607, 1608, 3, 58, 29, 0, 1608, 1714, 1, 0, 0, 0, 1609, 1610, 5, 844, 0,
		0, 1610, 1612, 5, 896, 0, 0, 1611, 1613, 7, 7, 0, 0, 1612, 1611, 1, 0,
		0, 0, 1612, 1613, 1, 0, 0, 0, 1613, 1614, 1, 0, 0, 0, 1614, 1616, 3, 6,
		3, 0, 1615, 1617, 3, 532, 266, 0, 1616, 1615, 1, 0, 0, 0, 1616, 1617, 1,
		0, 0, 0, 1617, 1620, 1, 0, 0, 0, 1618, 1619, 5, 192, 0, 0, 1619, 1621,
		5, 923, 0, 0, 1620, 1618, 1, 0, 0, 0, 1620, 1621, 1, 0, 0, 0, 1621, 1622,
		1, 0, 0, 0, 1622, 1623, 5, 903, 0, 0, 1623, 1624, 5, 643, 0, 0, 1624, 1625,
		3, 58, 29, 0, 1625, 1714, 1, 0, 0, 0, 1626, 1627, 5, 450, 0, 0, 1627, 1629,
		5, 896, 0, 0, 1628, 1630, 7, 7, 0, 0, 1629, 1628, 1, 0, 0, 0, 1629, 1630,
		1, 0, 0, 0, 1630, 1631, 1, 0, 0, 0, 1631, 1633, 3, 6, 3, 0, 1632, 1634,
		3, 532, 266, 0, 1633, 1632, 1, 0, 0, 0, 1633, 1634, 1, 0, 0, 0, 1634, 1637,
		1, 0, 0, 0, 1635, 1636, 5, 192, 0, 0, 1636, 1638, 5, 923, 0, 0, 1637, 1635,
		1, 0, 0, 0, 1637, 1638, 1, 0, 0, 0, 1638, 1639, 1, 0, 0, 0, 1639, 1640,
		5, 903, 0, 0, 1640, 1641, 5, 643, 0, 0, 1641, 1642, 3, 58, 29, 0, 1642,
		1714, 1, 0, 0, 0, 1643, 1644, 5, 584, 0, 0, 1644, 1645, 5, 896, 0, 0, 1645,
		1646, 5, 903, 0, 0, 1646, 1647, 5, 643, 0, 0, 1647, 1714, 3, 58, 29, 0,
		1648, 1649, 5, 530, 0, 0, 1649, 1650, 5, 896, 0, 0, 1650, 1651, 5, 903,
		0, 0, 1651, 1652, 5, 643, 0, 0, 1652, 1714, 3, 58, 29, 0, 1653, 1654, 5,
		660, 0, 0, 1654, 1655, 5, 896, 0, 0, 1655, 1656, 5, 903, 0, 0, 1656, 1657,
		5, 643, 0, 0, 1657, 1714, 3, 58, 29, 0, 1658, 1659, 5, 327, 0, 0, 1659,
		1660, 5, 896, 0, 0, 1660, 1661, 5, 903, 0, 0, 1661, 1662, 5, 643, 0, 0,
		1662, 1714, 3, 58, 29, 0, 1663, 1664, 5, 853, 0, 0, 1664, 1665, 5, 896,
		0, 0, 1665, 1666, 3, 36, 18, 0, 1666, 1667, 5, 903, 0, 0, 1667, 1668, 5,
		643, 0, 0, 1668, 1669, 3, 58, 29, 0, 1669, 1714, 1, 0, 0, 0, 1670, 1671,
		5, 821, 0, 0, 1671, 1672, 5, 896, 0, 0, 1672, 1673, 5, 903, 0, 0, 1673,
		1674, 5, 643, 0, 0, 1674, 1714, 3, 58, 29, 0, 1675, 1676, 5, 800, 0, 0,
		1676, 1677, 3, 54, 27, 0, 1677, 1678, 5, 643, 0, 0, 1678, 1679, 3, 58,
		29, 0, 1679, 1714, 1, 0, 0, 0, 1680, 1681, 5, 717, 0, 0, 1681, 1682, 3,
		54, 27, 0, 1682, 1683, 5, 643, 0, 0, 1683, 1684, 3, 58, 29, 0, 1684, 1714,
		1, 0, 0, 0, 1685, 1686, 5, 845, 0, 0, 1686, 1687, 3, 56, 28, 0, 1687, 1688,
		5, 643, 0, 0, 1688, 1689, 3, 58, 29, 0, 1689, 1714, 1, 0, 0, 0, 1690, 1691,
		5, 679, 0, 0, 1691, 1692, 3, 56, 28, 0, 1692, 1693, 5, 643, 0, 0, 1693,
		1694, 3, 58, 29, 0, 1694, 1714, 1, 0, 0, 0, 1695, 1696, 5, 291, 0, 0, 1696,
		1697, 5, 896, 0, 0, 1697, 1698, 3, 36, 18, 0, 1698, 1699, 5, 890, 0, 0,
		1699, 1700, 3, 36, 18, 0, 1700, 1703, 5, 903, 0, 0, 1701, 1702, 5, 80,
		0, 0, 1702, 1704, 3, 50, 25, 0, 1703, 1701, 1, 0, 0, 0, 1703, 1704, 1,
		0, 0, 0, 1704, 1708, 1, 0, 0, 0, 1705, 1706, 3, 52, 26, 0, 1706, 1707,
		5, 877, 0, 0, 1707, 1709, 1, 0, 0, 0, 1708, 1705, 1, 0, 0, 0, 1708, 1709,
		1, 0, 0, 0, 1709, 1710, 1, 0, 0, 0, 1710, 1711, 5, 643, 0, 0, 1711, 1712,
		3, 58, 29, 0, 1712, 1714, 1, 0, 0, 0, 1713, 1481, 1, 0, 0, 0, 1713, 1490,
		1, 0, 0, 0, 1713, 1500, 1, 0, 0, 0, 1713, 1508, 1, 0, 0, 0, 1713, 1515,
		1, 0, 0, 0, 1713, 1522, 1, 0, 0, 0, 1713, 1529, 1, 0, 0, 0, 1713, 1539,
		1, 0, 0, 0, 1713, 1549, 1, 0, 0, 0, 1713, 1559, 1, 0, 0, 0, 1713, 1569,
		1, 0, 0, 0, 1713, 1579, 1, 0, 0, 0, 1713, 1589, 1, 0, 0, 0, 1713, 1599,
		1, 0, 0, 0, 1713, 1609, 1, 0, 0, 0, 1713, 1626, 1, 0, 0, 0, 1713, 1643,
		1, 0, 0, 0, 1713, 1648, 1, 0, 0, 0, 1713, 1653, 1, 0, 0, 0, 1713, 1658,
		1, 0, 0, 0, 1713, 1663, 1, 0, 0, 0, 1713, 1670, 1, 0, 0, 0, 1713, 1675,
		1, 0, 0, 0, 1713, 1680, 1, 0, 0, 0, 1713, 1685, 1, 0, 0, 0, 1713, 1690,
		1, 0, 0, 0, 1713, 1695, 1, 0, 0, 0, 1714, 49, 1, 0, 0, 0, 1715, 1716, 7,
		8, 0, 0, 1716, 51, 1, 0, 0, 0, 1717, 1718, 7, 9, 0, 0, 1718, 53, 1, 0,
		0, 0, 1719, 1720, 5, 896, 0, 0, 1720, 1721, 3, 36, 18, 0, 1721, 1722, 3,
		52, 26, 0, 1722, 1723, 5, 877, 0, 0, 1723, 1724, 5, 903, 0, 0, 1724, 1734,
		1, 0, 0, 0, 1725, 1726, 5, 896, 0, 0, 1726, 1727, 3, 36, 18, 0, 1727, 1731,
		5, 903, 0, 0, 1728, 1729, 3, 52, 26, 0, 1729, 1730, 5, 877, 0, 0, 1730,
		1732, 1, 0, 0, 0, 1731, 1728, 1, 0, 0, 0, 1731, 1732, 1, 0, 0, 0, 1732,
		1734, 1, 0, 0, 0, 1733, 1719, 1, 0, 0, 0, 1733, 1725, 1, 0, 0, 0, 1734,
		55, 1, 0, 0, 0, 1735, 1736, 5, 896, 0, 0, 1736, 1737, 3, 36, 18, 0, 1737,
		1738, 3, 52, 26, 0, 1738, 1739, 5, 877, 0, 0, 1739, 1740, 5, 903, 0, 0,
		1740, 1758, 1, 0, 0, 0, 1741, 1742, 5, 896, 0, 0, 1742, 1743, 3, 36, 18,
		0, 1743, 1744, 3, 52, 26, 0, 1744, 1745, 5, 877, 0, 0, 1745, 1746, 5, 890,
		0, 0, 1746, 1747, 3, 6, 3, 0, 1747, 1748, 5, 903, 0, 0, 1748, 1758, 1,
		0, 0, 0, 1749, 1750, 5, 896, 0, 0, 1750, 1751, 3, 6, 3, 0, 1751, 1755,
		5, 903, 0, 0, 1752, 1753, 3, 52, 26, 0, 1753, 1754, 5, 877, 0, 0, 1754,
		1756, 1, 0, 0, 0, 1755, 1752, 1, 0, 0, 0, 1755, 1756, 1, 0, 0, 0, 1756,
		1758, 1, 0, 0, 0, 1757, 1735, 1, 0, 0, 0, 1757, 1741, 1, 0, 0, 0, 1757,
		1749, 1, 0, 0, 0, 1758, 57, 1, 0, 0, 0, 1759, 1762, 5, 921, 0, 0, 1760,
		1762, 3, 60, 30, 0, 1761, 1759, 1, 0, 0, 0, 1761, 1760, 1, 0, 0, 0, 1762,
		59, 1, 0, 0, 0, 1763, 1764, 5, 896, 0, 0, 1764, 1765, 5, 921, 0, 0, 1765,
		1766, 3, 66, 33, 0, 1766, 1767, 5, 903, 0, 0, 1767, 1773, 1, 0, 0, 0, 1768,
		1769, 5, 896, 0, 0, 1769, 1770, 3, 66, 33, 0, 1770, 1771, 5, 903, 0, 0,
		1771, 1773, 1, 0, 0, 0, 1772, 1763, 1, 0, 0, 0, 1772, 1768, 1, 0, 0, 0,
		1773, 61, 1, 0, 0, 0, 1774, 1779, 3, 64, 32, 0, 1775, 1776, 5, 890, 0,
		0, 1776, 1778, 3, 64, 32, 0, 1777, 1775, 1, 0, 0, 0, 1778, 1781, 1, 0,
		0, 0, 1779, 1777, 1, 0, 0, 0, 1779, 1780, 1, 0, 0, 0, 1780, 63, 1, 0, 0,
		0, 1781, 1779, 1, 0, 0, 0, 1782, 1783, 5, 921, 0, 0, 1783, 1784, 5, 9,
		0, 0, 1784, 1785, 3, 60, 30, 0, 1785, 65, 1, 0, 0, 0, 1786, 1787, 5, 166,
		0, 0, 1787, 1788, 5, 19, 0, 0, 1788, 1790, 3, 6, 3, 0, 1789, 1786, 1, 0,
		0, 0, 1789, 1790, 1, 0, 0, 0, 1790, 1792, 1, 0, 0, 0, 1791, 1793, 3, 532,
		266, 0, 1792, 1791, 1, 0, 0, 0, 1792, 1793, 1, 0, 0, 0, 1793, 1795, 1,
		0, 0, 0, 1794, 1796, 3, 76, 38, 0, 1795, 1794, 1, 0, 0, 0, 1795, 1796,
		1, 0, 0, 0, 1796, 67, 1, 0, 0, 0, 1797, 1798, 7, 10, 0, 0, 1798, 69, 1,
		0, 0, 0, 1799, 1800, 7, 11, 0, 0, 1800, 71, 1, 0, 0, 0, 1801, 1807, 3,
		36, 18, 0, 1802, 1803, 5, 107, 0, 0, 1803, 1804, 3, 36, 18, 0, 1804, 1805,
		3, 940, 470, 0, 1805, 1807, 1, 0, 0, 0, 1806, 1801, 1, 0, 0, 0, 1806, 1802,
		1, 0, 0, 0, 1807, 73, 1, 0, 0, 0, 1808, 1809, 5, 629, 0, 0, 1809, 1814,
		5, 705, 0, 0, 1810, 1811, 3, 72, 36, 0, 1811, 1812, 3, 70, 35, 0, 1812,
		1814, 1, 0, 0, 0, 1813, 1808, 1, 0, 0, 0, 1813, 1810, 1, 0, 0, 0, 1814,
		75, 1, 0, 0, 0, 1815, 1816, 3, 68, 34, 0, 1816, 1817, 5, 12, 0, 0, 1817,
		1818, 3, 74, 37, 0, 1818, 1819, 5, 6, 0, 0, 1819, 1820, 3, 74, 37, 0, 1820,
		1825, 1, 0, 0, 0, 1821, 1822, 3, 68, 34, 0, 1822, 1823, 3, 74, 37, 0, 1823,
		1825, 1, 0, 0, 0, 1824, 1815, 1, 0, 0, 0, 1824, 1821, 1, 0, 0, 0, 1825,
		77, 1, 0, 0, 0, 1826, 1828, 3, 36, 18, 0, 1827, 1826, 1, 0, 0, 0, 1827,
		1828, 1, 0, 0, 0, 1828, 79, 1, 0, 0, 0, 1829, 1831, 3, 82, 41, 0, 1830,
		1829, 1, 0, 0, 0, 1831, 1832, 1, 0, 0, 0, 1832, 1830, 1, 0, 0, 0, 1832,
		1833, 1, 0, 0, 0, 1833, 81, 1, 0, 0, 0, 1834, 1835, 5, 244, 0, 0, 1835,
		1836, 3, 36, 18, 0, 1836, 1837, 5, 222, 0, 0, 1837, 1838, 3, 36, 18, 0,
		1838, 83, 1, 0, 0, 0, 1839, 1840, 5, 66, 0, 0, 1840, 1843, 3, 36, 18, 0,
		1841, 1843, 3, 948, 474, 0, 1842, 1839, 1, 0, 0, 0, 1842, 1841, 1, 0, 0,
		0, 1843, 85, 1, 0, 0, 0, 1844, 1845, 5, 149, 0, 0, 1845, 1846, 5, 896,
		0, 0, 1846, 1847, 3, 36, 18, 0, 1847, 1848, 5, 890, 0, 0, 1848, 1849, 3,
		36, 18, 0, 1849, 1850, 5, 903, 0, 0, 1850, 2200, 1, 0, 0, 0, 1851, 1852,
		5, 531, 0, 0, 1852, 1854, 5, 896, 0, 0, 1853, 1855, 5, 8, 0, 0, 1854, 1853,
		1, 0, 0, 0, 1854, 1855, 1, 0, 0, 0, 1855, 1856, 1, 0, 0, 0, 1856, 1857,
		5, 894, 0, 0, 1857, 2200, 5, 903, 0, 0, 1858, 1859, 5, 531, 0, 0, 1859,
		1861, 5, 896, 0, 0, 1860, 1862, 5, 8, 0, 0, 1861, 1860, 1, 0, 0, 0, 1861,
		1862, 1, 0, 0, 0, 1862, 1863, 1, 0, 0, 0, 1863, 1864, 3, 36, 18, 0, 1864,
		1865, 5, 903, 0, 0, 1865, 2200, 1, 0, 0, 0, 1866, 1867, 5, 531, 0, 0, 1867,
		1868, 5, 896, 0, 0, 1868, 1869, 5, 59, 0, 0, 1869, 1870, 3, 6, 3, 0, 1870,
		1871, 5, 903, 0, 0, 1871, 2200, 1, 0, 0, 0, 1872, 1873, 5, 531, 0, 0, 1873,
		1874, 5, 896, 0, 0, 1874, 1875, 5, 228, 0, 0, 1875, 1876, 3, 6, 3, 0, 1876,
		1877, 5, 903, 0, 0, 1877, 2200, 1, 0, 0, 0, 1878, 1879, 5, 872, 0, 0, 1879,
		1880, 5, 896, 0, 0, 1880, 1881, 3, 6, 3, 0, 1881, 1882, 5, 903, 0, 0, 1882,
		2200, 1, 0, 0, 0, 1883, 1884, 5, 429, 0, 0, 1884, 1885, 5, 896, 0, 0, 1885,
		1886, 3, 6, 3, 0, 1886, 1887, 5, 903, 0, 0, 1887, 2200, 1, 0, 0, 0, 1888,
		1889, 5, 781, 0, 0, 1889, 1890, 5, 896, 0, 0, 1890, 1891, 3, 36, 18, 0,
		1891, 1892, 5, 903, 0, 0, 1892, 2200, 1, 0, 0, 0, 1893, 1894, 5, 452, 0,
		0, 1894, 1896, 5, 896, 0, 0, 1895, 1897, 7, 6, 0, 0, 1896, 1895, 1, 0,
		0, 0, 1896, 1897, 1, 0, 0, 0, 1897, 1898, 1, 0, 0, 0, 1898, 1899, 3, 36,
		18, 0, 1899, 1900, 5, 903, 0, 0, 1900, 2200, 1, 0, 0, 0, 1901, 1902, 5,
		364, 0, 0, 1902, 1904, 5, 896, 0, 0, 1903, 1905, 7, 6, 0, 0, 1904, 1903,
		1, 0, 0, 0, 1904, 1905, 1, 0, 0, 0, 1905, 1906, 1, 0, 0, 0, 1906, 1907,
		3, 36, 18, 0, 1907, 1908, 5, 903, 0, 0, 1908, 2200, 1, 0, 0, 0, 1909, 1910,
		5, 454, 0, 0, 1910, 1912, 5, 896, 0, 0, 1911, 1913, 7, 6, 0, 0, 1912, 1911,
		1, 0, 0, 0, 1912, 1913, 1, 0, 0, 0, 1913, 1914, 1, 0, 0, 0, 1914, 1915,
		3, 36, 18, 0, 1915, 1916, 5, 903, 0, 0, 1916, 2200, 1, 0, 0, 0, 1917, 1918,
		5, 779, 0, 0, 1918, 1920, 5, 896, 0, 0, 1919, 1921, 7, 6, 0, 0, 1920, 1919,
		1, 0, 0, 0, 1920, 1921, 1, 0, 0, 0, 1921, 1922, 1, 0, 0, 0, 1922, 1923,
		3, 36, 18, 0, 1923, 1924, 5, 903, 0, 0, 1924, 2200, 1, 0, 0, 0, 1925, 1926,
		5, 392, 0, 0, 1926, 1928, 5, 896, 0, 0, 1927, 1929, 7, 6, 0, 0, 1928, 1927,
		1, 0, 0, 0, 1928, 1929, 1, 0, 0, 0, 1929, 1930, 1, 0, 0, 0, 1930, 1931,
		3, 36, 18, 0, 1931, 1932, 5, 903, 0, 0, 1932, 2200, 1, 0, 0, 0, 1933, 1934,
		5, 465, 0, 0, 1934, 1936, 5, 896, 0, 0, 1935, 1937, 7, 6, 0, 0, 1936, 1935,
		1, 0, 0, 0, 1936, 1937, 1, 0, 0, 0, 1937, 1938, 1, 0, 0, 0, 1938, 1939,
		3, 36, 18, 0, 1939, 1940, 5, 903, 0, 0, 1940, 2200, 1, 0, 0, 0, 1941, 1942,
		5, 762, 0, 0, 1942, 1944, 5, 896, 0, 0, 1943, 1945, 7, 6, 0, 0, 1944, 1943,
		1, 0, 0, 0, 1944, 1945, 1, 0, 0, 0, 1945, 1946, 1, 0, 0, 0, 1946, 1947,
		3, 36, 18, 0, 1947, 1948, 5, 903, 0, 0, 1948, 2200, 1, 0, 0, 0, 1949, 1950,
		5, 516, 0, 0, 1950, 1952, 5, 896, 0, 0, 1951, 1953, 7, 6, 0, 0, 1952, 1951,
		1, 0, 0, 0, 1952, 1953, 1, 0, 0, 0, 1953, 1954, 1, 0, 0, 0, 1954, 1955,
		3, 36, 18, 0, 1955, 1956, 5, 903, 0, 0, 1956, 2200, 1, 0, 0, 0, 1957, 1958,
		5, 430, 0, 0, 1958, 1959, 5, 896, 0, 0, 1959, 1960, 3, 36, 18, 0, 1960,
		1961, 5, 903, 0, 0, 1961, 2200, 1, 0, 0, 0, 1962, 1963, 5, 844, 0, 0, 1963,
		1965, 5, 896, 0, 0, 1964, 1966, 7, 7, 0, 0, 1965, 1964, 1, 0, 0, 0, 1965,
		1966, 1, 0, 0, 0, 1966, 1967, 1, 0, 0, 0, 1967, 1969, 3, 6, 3, 0, 1968,
		1970, 3, 532, 266, 0, 1969, 1968, 1, 0, 0, 0, 1969, 1970, 1, 0, 0, 0, 1970,
		1973, 1, 0, 0, 0, 1971, 1972, 5, 192, 0, 0, 1972, 1974, 5, 923, 0, 0, 1973,
		1971, 1, 0, 0, 0, 1973, 1974, 1, 0, 0, 0, 1974, 1975, 1, 0, 0, 0, 1975,
		1976, 5, 903, 0, 0, 1976, 2200, 1, 0, 0, 0, 1977, 1978, 5, 93, 0, 0, 1978,
		1979, 5, 896, 0, 0, 1979, 1980, 3, 36, 18, 0, 1980, 1981, 5, 890, 0, 0,
		1981, 1982, 3, 36, 18, 0, 1982, 1983, 5, 890, 0, 0, 1983, 1984, 3, 36,
		18, 0, 1984, 1985, 5, 903, 0, 0, 1985, 2200, 1, 0, 0, 0, 1986, 1987, 5,
		267, 0, 0, 1987, 1988, 5, 896, 0, 0, 1988, 1989, 3, 36, 18, 0, 1989, 1990,
		5, 903, 0, 0, 1990, 2200, 1, 0, 0, 0, 1991, 2200, 3, 94, 47, 0, 1992, 2200,
		3, 92, 46, 0, 1993, 2200, 3, 98, 49, 0, 1994, 2200, 3, 100, 50, 0, 1995,
		2200, 3, 90, 45, 0, 1996, 1997, 5, 522, 0, 0, 1997, 1998, 5, 896, 0, 0,
		1998, 1999, 3, 36, 18, 0, 1999, 2000, 5, 9, 0, 0, 2000, 2001, 3, 230, 115,
		0, 2001, 2002, 5, 903, 0, 0, 2002, 2200, 1, 0, 0, 0, 2003, 2004, 5, 108,
		0, 0, 2004, 2005, 5, 896, 0, 0, 2005, 2006, 3, 36, 18, 0, 2006, 2007, 5,
		890, 0, 0, 2007, 2008, 3, 36, 18, 0, 2008, 2009, 5, 890, 0, 0, 2009, 2010,
		3, 36, 18, 0, 2010, 2011, 5, 890, 0, 0, 2011, 2012, 3, 36, 18, 0, 2012,
		2013, 5, 903, 0, 0, 2013, 2200, 1, 0, 0, 0, 2014, 2015, 5, 122, 0, 0, 2015,
		2016, 5, 896, 0, 0, 2016, 2017, 3, 36, 18, 0, 2017, 2018, 5, 890, 0, 0,
		2018, 2019, 3, 36, 18, 0, 2019, 2020, 5, 903, 0, 0, 2020, 2200, 1, 0, 0,
		0, 2021, 2022, 5, 30, 0, 0, 2022, 2023, 5, 896, 0, 0, 2023, 2024, 3, 36,
		18, 0, 2024, 2025, 5, 890, 0, 0, 2025, 2026, 3, 230, 115, 0, 2026, 2027,
		5, 903, 0, 0, 2027, 2200, 1, 0, 0, 0, 2028, 2029, 5, 30, 0, 0, 2029, 2030,
		5, 896, 0, 0, 2030, 2031, 3, 36, 18, 0, 2031, 2032, 5, 234, 0, 0, 2032,
		2033, 3, 260, 130, 0, 2033, 2034, 5, 903, 0, 0, 2034, 2200, 1, 0, 0, 0,
		2035, 2036, 5, 443, 0, 0, 2036, 2037, 5, 896, 0, 0, 2037, 2038, 3, 32,
		16, 0, 2038, 2039, 5, 95, 0, 0, 2039, 2040, 3, 36, 18, 0, 2040, 2041, 5,
		903, 0, 0, 2041, 2200, 1, 0, 0, 0, 2042, 2043, 3, 102, 51, 0, 2043, 2044,
		5, 896, 0, 0, 2044, 2045, 3, 104, 52, 0, 2045, 2046, 5, 903, 0, 0, 2046,
		2200, 1, 0, 0, 0, 2047, 2048, 5, 583, 0, 0, 2048, 2049, 5, 896, 0, 0, 2049,
		2050, 3, 524, 262, 0, 2050, 2051, 5, 903, 0, 0, 2051, 2200, 1, 0, 0, 0,
		2052, 2053, 5, 863, 0, 0, 2053, 2054, 5, 896, 0, 0, 2054, 2055, 3, 36,
		18, 0, 2055, 2056, 5, 903, 0, 0, 2056, 2200, 1, 0, 0, 0, 2057, 2058, 5,
		278, 0, 0, 2058, 2059, 5, 896, 0, 0, 2059, 2060, 3, 36, 18, 0, 2060, 2061,
		5, 903, 0, 0, 2061, 2200, 1, 0, 0, 0, 2062, 2063, 5, 505, 0, 0, 2063, 2064,
		5, 896, 0, 0, 2064, 2065, 3, 36, 18, 0, 2065, 2066, 5, 903, 0, 0, 2066,
		2200, 1, 0, 0, 0, 2067, 2068, 5, 734, 0, 0, 2068, 2069, 5, 896, 0, 0, 2069,
		2070, 3, 36, 18, 0, 2070, 2071, 5, 903, 0, 0, 2071, 2200, 1, 0, 0, 0, 2072,
		2073, 5, 876, 0, 0, 2073, 2074, 5, 896, 0, 0, 2074, 2075, 3, 36, 18, 0,
		2075, 2076, 5, 903, 0, 0, 2076, 2200, 1, 0, 0, 0, 2077, 2078, 5, 876, 0,
		0, 2078, 2079, 5, 896, 0, 0, 2079, 2080, 3, 36, 18, 0, 2080, 2081, 5, 890,
		0, 0, 2081, 2082, 3, 36, 18, 0, 2082, 2083, 5, 903, 0, 0, 2083, 2200, 1,
		0, 0, 0, 2084, 2085, 5, 434, 0, 0, 2085, 2086, 5, 896, 0, 0, 2086, 2087,
		3, 36, 18, 0, 2087, 2088, 5, 903, 0, 0, 2088, 2200, 1, 0, 0, 0, 2089, 2090,
		5, 694, 0, 0, 2090, 2091, 5, 896, 0, 0, 2091, 2092, 3, 36, 18, 0, 2092,
		2093, 5, 903, 0, 0, 2093, 2200, 1, 0, 0, 0, 2094, 2095, 5, 751, 0, 0, 2095,
		2096, 5, 896, 0, 0, 2096, 2097, 3, 36, 18, 0, 2097, 2098, 5, 903, 0, 0,
		2098, 2200, 1, 0, 0, 0, 2099, 2100, 5, 709, 0, 0, 2100, 2101, 5, 896, 0,
		0, 2101, 2102, 3, 36, 18, 0, 2102, 2103, 5, 903, 0, 0, 2103, 2200, 1, 0,
		0, 0, 2104, 2105, 5, 720, 0, 0, 2105, 2106, 5, 896, 0, 0, 2106, 2107, 3,
		106, 53, 0, 2107, 2108, 5, 903, 0, 0, 2108, 2200, 1, 0, 0, 0, 2109, 2110,
		5, 557, 0, 0, 2110, 2111, 5, 896, 0, 0, 2111, 2112, 3, 106, 53, 0, 2112,
		2113, 5, 903, 0, 0, 2113, 2200, 1, 0, 0, 0, 2114, 2115, 5, 725, 0, 0, 2115,
		2116, 5, 896, 0, 0, 2116, 2117, 3, 106, 53, 0, 2117, 2118, 5, 903, 0, 0,
		2118, 2200, 1, 0, 0, 0, 2119, 2120, 5, 487, 0, 0, 2120, 2121, 5, 896, 0,
		0, 2121, 2122, 3, 106, 53, 0, 2122, 2123, 5, 903, 0, 0, 2123, 2200, 1,
		0, 0, 0, 2124, 2125, 5, 725, 0, 0, 2125, 2126, 5, 896, 0, 0, 2126, 2127,
		3, 36, 18, 0, 2127, 2128, 5, 890, 0, 0, 2128, 2129, 3, 36, 18, 0, 2129,
		2130, 5, 903, 0, 0, 2130, 2200, 1, 0, 0, 0, 2131, 2132, 5, 487, 0, 0, 2132,
		2133, 5, 896, 0, 0, 2133, 2134, 3, 36, 18, 0, 2134, 2135, 5, 890, 0, 0,
		2135, 2136, 3, 36, 18, 0, 2136, 2137, 5, 903, 0, 0, 2137, 2200, 1, 0, 0,
		0, 2138, 2139, 5, 461, 0, 0, 2139, 2140, 5, 896, 0, 0, 2140, 2141, 3, 108,
		54, 0, 2141, 2142, 5, 903, 0, 0, 2142, 2200, 1, 0, 0, 0, 2143, 2144, 5,
		813, 0, 0, 2144, 2145, 5, 896, 0, 0, 2145, 2146, 3, 108, 54, 0, 2146, 2147,
		5, 903, 0, 0, 2147, 2200, 1, 0, 0, 0, 2148, 2149, 5, 626, 0, 0, 2149, 2150,
		5, 896, 0, 0, 2150, 2151, 3, 940, 470, 0, 2151, 2152, 5, 80, 0, 0, 2152,
		2153, 3, 36, 18, 0, 2153, 2154, 5, 903, 0, 0, 2154, 2200, 1, 0, 0, 0, 2155,
		2156, 5, 619, 0, 0, 2156, 2157, 5, 896, 0, 0, 2157, 2158, 3, 36, 18, 0,
		2158, 2159, 5, 903, 0, 0, 2159, 2200, 1, 0, 0, 0, 2160, 2161, 5, 52, 0,
		0, 2161, 2162, 5, 896, 0, 0, 2162, 2163, 3, 226, 113, 0, 2163, 2164, 5,
		903, 0, 0, 2164, 2200, 1, 0, 0, 0, 2165, 2166, 5, 238, 0, 0, 2166, 2167,
		5, 896, 0, 0, 2167, 2168, 3, 226, 113, 0, 2168, 2169, 5, 903, 0, 0, 2169,
		2200, 1, 0, 0, 0, 2170, 2171, 5, 24, 0, 0, 2171, 2172, 5, 896, 0, 0, 2172,
		2173, 3, 6, 3, 0, 2173, 2174, 5, 903, 0, 0, 2174, 2200, 1, 0, 0, 0, 2175,
		2176, 5, 24, 0, 0, 2176, 2177, 5, 896, 0, 0, 2177, 2178, 3, 6, 3, 0, 2178,
		2179, 5, 234, 0, 0, 2179, 2180, 3, 260, 130, 0, 2180, 2181, 5, 903, 0,
		0, 2181, 2200, 1, 0, 0, 0, 2182, 2183, 3, 936, 468, 0, 2183, 2185, 5, 896,
		0, 0, 2184, 2186, 3, 8, 4, 0, 2185, 2184, 1, 0, 0, 0, 2185, 2186, 1, 0,
		0, 0, 2186, 2187, 1, 0, 0, 0, 2187, 2188, 5, 903, 0, 0, 2188, 2200, 1,
		0, 0, 0, 2189, 2190, 3, 934, 467, 0, 2190, 2191, 5, 901, 0, 0, 2191, 2192,
		3, 936, 468, 0, 2192, 2194, 5, 896, 0, 0, 2193, 2195, 3, 8, 4, 0, 2194,
		2193, 1, 0, 0, 0, 2194, 2195, 1, 0, 0, 0, 2195, 2196, 1, 0, 0, 0, 2196,
		2197, 5, 903, 0, 0, 2197, 2200, 1, 0, 0, 0, 2198, 2200, 3, 88, 44, 0, 2199,
		1844, 1, 0, 0, 0, 2199, 1851, 1, 0, 0, 0, 2199, 1858, 1, 0, 0, 0, 2199,
		1866, 1, 0, 0, 0, 2199, 1872, 1, 0, 0, 0, 2199, 1878, 1, 0, 0, 0, 2199,
		1883, 1, 0, 0, 0, 2199, 1888, 1, 0, 0, 0, 2199, 1893, 1, 0, 0, 0, 2199,
		1901, 1, 0, 0, 0, 2199, 1909, 1, 0, 0, 0, 2199, 1917, 1, 0, 0, 0, 2199,
		1925, 1, 0, 0, 0, 2199, 1933, 1, 0, 0, 0, 2199, 1941, 1, 0, 0, 0, 2199,
		1949, 1, 0, 0, 0, 2199, 1957, 1, 0, 0, 0, 2199, 1962, 1, 0, 0, 0, 2199,
		1977, 1, 0, 0, 0, 2199, 1986, 1, 0, 0, 0, 2199, 1991, 1, 0, 0, 0, 2199,
		1992, 1, 0, 0, 0, 2199, 1993, 1, 0, 0, 0, 2199, 1994, 1, 0, 0, 0, 2199,
		1995, 1, 0, 0, 0, 2199, 1996, 1, 0, 0, 0, 2199, 2003, 1, 0, 0, 0, 2199,
		2014, 1, 0, 0, 0, 2199, 2021, 1, 0, 0, 0, 2199, 2028, 1, 0, 0, 0, 2199,
		2035, 1, 0, 0, 0, 2199, 2042, 1, 0, 0, 0, 2199, 2047, 1, 0, 0, 0, 2199,
		2052, 1, 0, 0, 0, 2199, 2057, 1, 0, 0, 0, 2199, 2062, 1, 0, 0, 0, 2199,
		2067, 1, 0, 0, 0, 2199, 2072, 1, 0, 0, 0, 2199, 2077, 1, 0, 0, 0, 2199,
		2084, 1, 0, 0, 0, 2199, 2089, 1, 0, 0, 0, 2199, 2094, 1, 0, 0, 0, 2199,
		2099, 1, 0, 0, 0, 2199, 2104, 1, 0, 0, 0, 2199, 2109, 1, 0, 0, 0, 2199,
		2114, 1, 0, 0, 0, 2199, 2119, 1, 0, 0, 0, 2199, 2124, 1, 0, 0, 0, 2199,
		2131, 1, 0, 0, 0, 2199, 2138, 1, 0, 0, 0, 2199, 2143, 1, 0, 0, 0, 2199,
		2148, 1, 0, 0, 0, 2199, 2155, 1, 0, 0, 0, 2199, 2160, 1, 0, 0, 0, 2199,
		2165, 1, 0, 0, 0, 2199, 2170, 1, 0, 0, 0, 2199, 2175, 1, 0, 0, 0, 2199,
		2182, 1, 0, 0, 0, 2199, 2189, 1, 0, 0, 0, 2199, 2198, 1, 0, 0, 0, 2200,
		87, 1, 0, 0, 0, 2201, 2202, 5, 107, 0, 0, 2202, 2203, 5, 896, 0, 0, 2203,
		2204, 3, 36, 18, 0, 2204, 2205, 5, 890, 0, 0, 2205, 2206, 3, 36, 18, 0,
		2206, 2207, 5, 903, 0, 0, 2207, 2218, 1, 0, 0, 0, 2208, 2209, 5, 107, 0,
		0, 2209, 2210, 5, 896, 0, 0, 2210, 2211, 3, 36, 18, 0, 2211, 2212, 5, 890,
		0, 0, 2212, 2213, 3, 36, 18, 0, 2213, 2214, 5, 890, 0, 0, 2214, 2215, 3,
		6, 3, 0, 2215, 2216, 5, 903, 0, 0, 2216, 2218, 1, 0, 0, 0, 2217, 2201,
		1, 0, 0, 0, 2217, 2208, 1, 0, 0, 0, 2218, 89, 1, 0, 0, 0, 2219, 2220, 5,
		237, 0, 0, 2220, 2221, 5, 896, 0, 0, 2221, 2227, 5, 903, 0, 0, 2222, 2223,
		5, 237, 0, 0, 2223, 2224, 5, 896, 0, 0, 2224, 2225, 5, 271, 0, 0, 2225,
		2227, 5, 903, 0, 0, 2226, 2219, 1, 0, 0, 0, 2226, 2222, 1, 0, 0, 0, 2227,
		91, 1, 0, 0, 0, 2228, 2229, 5, 214, 0, 0, 2229, 2230, 5, 896, 0, 0, 2230,
		2236, 5, 903, 0, 0, 2231, 2232, 5, 214, 0, 0, 2232, 2233, 5, 896, 0, 0,
		2233, 2234, 5, 271, 0, 0, 2234, 2236, 5, 903, 0, 0, 2235, 2228, 1, 0, 0,
		0, 2235, 2231, 1, 0, 0, 0, 2236, 93, 1, 0, 0, 0, 2237, 2238, 5, 782, 0,
		0, 2238, 2239, 5, 896, 0, 0, 2239, 2253, 5, 903, 0, 0, 2240, 2241, 5, 782,
		0, 0, 2241, 2242, 5, 896, 0, 0, 2242, 2243, 5, 271, 0, 0, 2243, 2253, 5,
		903, 0, 0, 2244, 2250, 3, 96, 48, 0, 2245, 2246, 5, 896, 0, 0, 2246, 2247,
		5, 271, 0, 0, 2247, 2251, 5, 903, 0, 0, 2248, 2249, 5, 896, 0, 0, 2249,
		2251, 5, 903, 0, 0, 2250, 2245, 1, 0, 0, 0, 2250, 2248, 1, 0, 0, 0, 2250,
		2251, 1, 0, 0, 0, 2251, 2253, 1, 0, 0, 0, 2252, 2237, 1, 0, 0, 0, 2252,
		2240, 1, 0, 0, 0, 2252, 2244, 1, 0, 0, 0, 2253, 95, 1, 0, 0, 0, 2254, 2255,
		7, 12, 0, 0, 2255, 97, 1, 0, 0, 0, 2256, 2257, 5, 657, 0, 0, 2257, 2258,
		5, 896, 0, 0, 2258, 2272, 5, 903, 0, 0, 2259, 2260, 5, 657, 0, 0, 2260,
		2261, 5, 896, 0, 0, 2261, 2262, 5, 271, 0, 0, 2262, 2272, 5, 903, 0, 0,
		2263, 2269, 5, 38, 0, 0, 2264, 2265, 5, 896, 0, 0, 2265, 2266, 5, 271,
		0, 0, 2266, 2270, 5, 903, 0, 0, 2267, 2268, 5, 896, 0, 0, 2268, 2270, 5,
		903, 0, 0, 2269, 2264, 1, 0, 0, 0, 2269, 2267, 1, 0, 0, 0, 2269, 2270,
		1, 0, 0, 0, 2270, 2272, 1, 0, 0, 0, 2271, 2256, 1, 0, 0, 0, 2271, 2259,
		1, 0, 0, 0, 2271, 2263, 1, 0, 0, 0, 2272, 99, 1, 0, 0, 0, 2273, 2274, 5,
		284, 0, 0, 2274, 2275, 5, 896, 0, 0, 2275, 2281, 5, 903, 0, 0, 2276, 2281,
		5, 37, 0, 0, 2277, 2278, 5, 37, 0, 0, 2278, 2279, 5, 896, 0, 0, 2279, 2281,
		5, 903, 0, 0, 2280, 2273, 1, 0, 0, 0, 2280, 2276, 1, 0, 0, 0, 2280, 2277,
		1, 0, 0, 0, 2281, 101, 1, 0, 0, 0, 2282, 2283, 7, 13, 0, 0, 2283, 103,
		1, 0, 0, 0, 2284, 2285, 3, 36, 18, 0, 2285, 2286, 5, 890, 0, 0, 2286, 2287,
		3, 36, 18, 0, 2287, 2305, 1, 0, 0, 0, 2288, 2289, 3, 36, 18, 0, 2289, 2290,
		5, 890, 0, 0, 2290, 2291, 3, 36, 18, 0, 2291, 2292, 5, 890, 0, 0, 2292,
		2293, 3, 36, 18, 0, 2293, 2305, 1, 0, 0, 0, 2294, 2295, 3, 36, 18, 0, 2295,
		2296, 5, 80, 0, 0, 2296, 2297, 3, 36, 18, 0, 2297, 2305, 1, 0, 0, 0, 2298,
		2299, 3, 36, 18, 0, 2299, 2300, 5, 80, 0, 0, 2300, 2301, 3, 36, 18, 0,
		2301, 2302, 5, 78, 0, 0, 2302, 2303, 3, 36, 18, 0, 2303, 2305, 1, 0, 0,
		0, 2304, 2284, 1, 0, 0, 0, 2304, 2288, 1, 0, 0, 0, 2304, 2294, 1, 0, 0,
		0, 2304, 2298, 1, 0, 0, 0, 2305, 105, 1, 0, 0, 0, 2306, 2307, 3, 36, 18,
		0, 2307, 2308, 5, 890, 0, 0, 2308, 2309, 5, 107, 0, 0, 2309, 2310, 3, 36,
		18, 0, 2310, 2311, 3, 940, 470, 0, 2311, 107, 1, 0, 0, 0, 2312, 2313, 3,
		940, 470, 0, 2313, 2314, 5, 890, 0, 0, 2314, 2315, 3, 36, 18, 0, 2315,
		2316, 5, 890, 0, 0, 2316, 2317, 3, 36, 18, 0, 2317, 109, 1, 0, 0, 0, 2318,
		2319, 3, 466, 233, 0, 2319, 2320, 5, 80, 0, 0, 2320, 2325, 3, 554, 277,
		0, 2321, 2322, 5, 243, 0, 0, 2322, 2323, 3, 478, 239, 0, 2323, 2324, 3,
		36, 18, 0, 2324, 2326, 1, 0, 0, 0, 2325, 2321, 1, 0, 0, 0, 2325, 2326,
		1, 0, 0, 0, 2326, 2328, 1, 0, 0, 0, 2327, 2329, 3, 532, 266, 0, 2328, 2327,
		1, 0, 0, 0, 2328, 2329, 1, 0, 0, 0, 2329, 2331, 1, 0, 0, 0, 2330, 2332,
		3, 480, 240, 0, 2331, 2330, 1, 0, 0, 0, 2331, 2332, 1, 0, 0, 0, 2332, 2342,
		1, 0, 0, 0, 2333, 2334, 3, 466, 233, 0, 2334, 2339, 3, 112, 56, 0, 2335,
		2336, 5, 243, 0, 0, 2336, 2337, 3, 478, 239, 0, 2337, 2338, 3, 36, 18,
		0, 2338, 2340, 1, 0, 0, 0, 2339, 2335, 1, 0, 0, 0, 2339, 2340, 1, 0, 0,
		0, 2340, 2342, 1, 0, 0, 0, 2341, 2318, 1, 0, 0, 0, 2341, 2333, 1, 0, 0,
		0, 2342, 111, 1, 0, 0, 0, 2343, 2344, 3, 586, 293, 0, 2344, 2345, 5, 80,
		0, 0, 2345, 2346, 3, 548, 274, 0, 2346, 2353, 1, 0, 0, 0, 2347, 2348, 5,
		80, 0, 0, 2348, 2349, 3, 586, 293, 0, 2349, 2350, 5, 234, 0, 0, 2350, 2351,
		3, 548, 274, 0, 2351, 2353, 1, 0, 0, 0, 2352, 2343, 1, 0, 0, 0, 2352, 2347,
		1, 0, 0, 0, 2353, 113, 1, 0, 0, 0, 2354, 2356, 3, 464, 232, 0, 2355, 2357,
		5, 367, 0, 0, 2356, 2355, 1, 0, 0, 0, 2356, 2357, 1, 0, 0, 0, 2357, 2358,
		1, 0, 0, 0, 2358, 2359, 3, 548, 274, 0, 2359, 2360, 5, 193, 0, 0, 2360,
		2365, 3, 116, 58, 0, 2361, 2362, 5, 243, 0, 0, 2362, 2363, 3, 478, 239,
		0, 2363, 2364, 3, 36, 18, 0, 2364, 2366, 1, 0, 0, 0, 2365, 2361, 1, 0,
		0, 0, 2365, 2366, 1, 0, 0, 0, 2366, 2368, 1, 0, 0, 0, 2367, 2369, 3, 532,
		266, 0, 2368, 2367, 1, 0, 0, 0, 2368, 2369, 1, 0, 0, 0, 2369, 2371, 1,
		0, 0, 0, 2370, 2372, 3, 480, 240, 0, 2371, 2370, 1, 0, 0, 0, 2371, 2372,
		1, 0, 0, 0, 2372, 115, 1, 0, 0, 0, 2373, 2378, 3, 118, 59, 0, 2374, 2375,
		5, 890, 0, 0, 2375, 2377, 3, 118, 59, 0, 2376, 2374, 1, 0, 0, 0, 2377,
		2380, 1, 0, 0, 0, 2378, 2376, 1, 0, 0, 0, 2378, 2379, 1, 0, 0, 0, 2379,
		117, 1, 0, 0, 0, 2380, 2378, 1, 0, 0, 0, 2381, 2382, 3, 226, 113, 0, 2382,
		2383, 5, 908, 0, 0, 2383, 2384, 3, 434, 217, 0, 2384, 119, 1, 0, 0, 0,
		2385, 2386, 5, 34, 0, 0, 2386, 2387, 5, 761, 0, 0, 2387, 2392, 5, 413,
		0, 0, 2388, 2389, 5, 93, 0, 0, 2389, 2390, 3, 38, 19, 0, 2390, 2391, 5,
		69, 0, 0, 2391, 2393, 1, 0, 0, 0, 2392, 2388, 1, 0, 0, 0, 2392, 2393, 1,
		0, 0, 0, 2393, 2394, 1, 0, 0, 0, 2394, 2400, 3, 934, 467, 0, 2395, 2401,
		3, 124, 62, 0, 2396, 2397, 3, 122, 61, 0, 2397, 2398, 5, 890, 0, 0, 2398,
		2399, 3, 124, 62, 0, 2399, 2401, 1, 0, 0, 0, 2400, 2395, 1, 0, 0, 0, 2400,
		2396, 1, 0, 0, 0, 2400, 2401, 1, 0, 0, 0, 2401, 2420, 1, 0, 0, 0, 2402,
		2403, 5, 34, 0, 0, 2403, 2404, 5, 761, 0, 0, 2404, 2409, 5, 283, 0, 0,
		2405, 2406, 5, 93, 0, 0, 2406, 2407, 3, 38, 19, 0, 2407, 2408, 5, 69, 0,
		0, 2408, 2410, 1, 0, 0, 0, 2409, 2405, 1, 0, 0, 0, 2409, 2410, 1, 0, 0,
		0, 2410, 2411, 1, 0, 0, 0, 2411, 2417, 3, 934, 467, 0, 2412, 2418, 3, 128,
		64, 0, 2413, 2414, 3, 126, 63, 0, 2414, 2415, 5, 890, 0, 0, 2415, 2416,
		3, 128, 64, 0, 2416, 2418, 1, 0, 0, 0, 2417, 2412, 1, 0, 0, 0, 2417, 2413,
		1, 0, 0, 0, 2417, 2418, 1, 0, 0, 0, 2418, 2420, 1, 0, 0, 0, 2419, 2385,
		1, 0, 0, 0, 2419, 2402, 1, 0, 0, 0, 2420, 121, 1, 0, 0, 0, 2421, 2422,
		6, 61, -1, 0, 2422, 2425, 3, 124, 62, 0, 2423, 2425, 3, 948, 474, 0, 2424,
		2421, 1, 0, 0, 0, 2424, 2423, 1, 0, 0, 0, 2425, 2431, 1, 0, 0, 0, 2426,
		2427, 10, 2, 0, 0, 2427, 2428, 5, 890, 0, 0, 2428, 2430, 3, 124, 62, 0,
		2429, 2426, 1, 0, 0, 0, 2430, 2433, 1, 0, 0, 0, 2431, 2429, 1, 0, 0, 0,
		2431, 2432, 1, 0, 0, 0, 2432, 123, 1, 0, 0, 0, 2433, 2431, 1, 0, 0, 0,
		2434, 2436, 5, 865, 0, 0, 2435, 2437, 5, 908, 0, 0, 2436, 2435, 1, 0, 0,
		0, 2436, 2437, 1, 0, 0, 0, 2437, 2438, 1, 0, 0, 0, 2438, 2475, 3, 24, 12,
		0, 2439, 2441, 5, 371, 0, 0, 2440, 2442, 5, 908, 0, 0, 2441, 2440, 1, 0,
		0, 0, 2441, 2442, 1, 0, 0, 0, 2442, 2443, 1, 0, 0, 0, 2443, 2475, 3, 24,
		12, 0, 2444, 2446, 5, 827, 0, 0, 2445, 2447, 5, 908, 0, 0, 2446, 2445,
		1, 0, 0, 0, 2446, 2447, 1, 0, 0, 0, 2447, 2448, 1, 0, 0, 0, 2448, 2475,
		3, 24, 12, 0, 2449, 2451, 5, 353, 0, 0, 2450, 2452, 5, 908, 0, 0, 2451,
		2450, 1, 0, 0, 0, 2451, 2452, 1, 0, 0, 0, 2452, 2453, 1, 0, 0, 0, 2453,
		2475, 3, 24, 12, 0, 2454, 2456, 5, 728, 0, 0, 2455, 2457, 5, 908, 0, 0,
		2456, 2455, 1, 0, 0, 0, 2456, 2457, 1, 0, 0, 0, 2457, 2458, 1, 0, 0, 0,
		2458, 2475, 3, 24, 12, 0, 2459, 2461, 5, 549, 0, 0, 2460, 2462, 5, 908,
		0, 0, 2461, 2460, 1, 0, 0, 0, 2461, 2462, 1, 0, 0, 0, 2462, 2463, 1, 0,
		0, 0, 2463, 2475, 3, 24, 12, 0, 2464, 2466, 5, 330, 0, 0, 2465, 2467, 5,
		908, 0, 0, 2466, 2465, 1, 0, 0, 0, 2466, 2467, 1, 0, 0, 0, 2467, 2468,
		1, 0, 0, 0, 2468, 2475, 3, 24, 12, 0, 2469, 2471, 5, 644, 0, 0, 2470, 2472,
		5, 908, 0, 0, 2471, 2470, 1, 0, 0, 0, 2471, 2472, 1, 0, 0, 0, 2472, 2473,
		1, 0, 0, 0, 2473, 2475, 3, 24, 12, 0, 2474, 2434, 1, 0, 0, 0, 2474, 2439,
		1, 0, 0, 0, 2474, 2444, 1, 0, 0, 0, 2474, 2449, 1, 0, 0, 0, 2474, 2454,
		1, 0, 0, 0, 2474, 2459, 1, 0, 0, 0, 2474, 2464, 1, 0, 0, 0, 2474, 2469,
		1, 0, 0, 0, 2475, 125, 1, 0, 0, 0, 2476, 2477, 6, 63, -1, 0, 2477, 2480,
		3, 128, 64, 0, 2478, 2480, 3, 948, 474, 0, 2479, 2476, 1, 0, 0, 0, 2479,
		2478, 1, 0, 0, 0, 2480, 2486, 1, 0, 0, 0, 2481, 2482, 10, 2, 0, 0, 2482,
		2483, 5, 890, 0, 0, 2483, 2485, 3, 128, 64, 0, 2484, 2481, 1, 0, 0, 0,
		2485, 2488, 1, 0, 0, 0, 2486, 2484, 1, 0, 0, 0, 2486, 2487, 1, 0, 0, 0,
		2487, 127, 1, 0, 0, 0, 2488, 2486, 1, 0, 0, 0, 2489, 2491, 5, 413, 0, 0,
		2490, 2492, 5, 908, 0, 0, 2491, 2490, 1, 0, 0, 0, 2491, 2492, 1, 0, 0,
		0, 2492, 2493, 1, 0, 0, 0, 2493, 2518, 3, 288, 144, 0, 2494, 2496, 5, 548,
		0, 0, 2495, 2497, 5, 908, 0, 0, 2496, 2495, 1, 0, 0, 0, 2496, 2497, 1,
		0, 0, 0, 2497, 2498, 1, 0, 0, 0, 2498, 2518, 5, 271, 0, 0, 2499, 2501,
		5, 775, 0, 0, 2500, 2502, 5, 908, 0, 0, 2501, 2500, 1, 0, 0, 0, 2501, 2502,
		1, 0, 0, 0, 2502, 2503, 1, 0, 0, 0, 2503, 2504, 5, 896, 0, 0, 2504, 2505,
		3, 146, 73, 0, 2505, 2506, 5, 903, 0, 0, 2506, 2518, 1, 0, 0, 0, 2507,
		2509, 5, 658, 0, 0, 2508, 2510, 5, 908, 0, 0, 2509, 2508, 1, 0, 0, 0, 2509,
		2510, 1, 0, 0, 0, 2510, 2511, 1, 0, 0, 0, 2511, 2518, 5, 923, 0, 0, 2512,
		2514, 5, 855, 0, 0, 2513, 2515, 5, 908, 0, 0, 2514, 2513, 1, 0, 0, 0, 2514,
		2515, 1, 0, 0, 0, 2515, 2516, 1, 0, 0, 0, 2516, 2518, 5, 884, 0, 0, 2517,
		2489, 1, 0, 0, 0, 2517, 2494, 1, 0, 0, 0, 2517, 2499, 1, 0, 0, 0, 2517,
		2507, 1, 0, 0, 0, 2517, 2512, 1, 0, 0, 0, 2518, 129, 1, 0, 0, 0, 2519,
		2524, 3, 134, 67, 0, 2520, 2521, 5, 890, 0, 0, 2521, 2523, 3, 134, 67,
		0, 2522, 2520, 1, 0, 0, 0, 2523, 2526, 1, 0, 0, 0, 2524, 2522, 1, 0, 0,
		0, 2524, 2525, 1, 0, 0, 0, 2525, 131, 1, 0, 0, 0, 2526, 2524, 1, 0, 0,
		0, 2527, 2532, 5, 271, 0, 0, 2528, 2529, 5, 890, 0, 0, 2529, 2531, 5, 271,
		0, 0, 2530, 2528, 1, 0, 0, 0, 2531, 2534, 1, 0, 0, 0, 2532, 2530, 1, 0,
		0, 0, 2532, 2533, 1, 0, 0, 0, 2533, 133, 1, 0, 0, 0, 2534, 2532, 1, 0,
		0, 0, 2535, 2537, 5, 413, 0, 0, 2536, 2538, 5, 908, 0, 0, 2537, 2536, 1,
		0, 0, 0, 2537, 2538, 1, 0, 0, 0, 2538, 2539, 1, 0, 0, 0, 2539, 2563, 3,
		288, 144, 0, 2540, 2542, 5, 548, 0, 0, 2541, 2543, 5, 908, 0, 0, 2542,
		2541, 1, 0, 0, 0, 2542, 2543, 1, 0, 0, 0, 2543, 2544, 1, 0, 0, 0, 2544,
		2552, 5, 271, 0, 0, 2545, 2546, 5, 54, 0, 0, 2546, 2547, 5, 413, 0, 0,
		2547, 2548, 3, 290, 145, 0, 2548, 2549, 5, 896, 0, 0, 2549, 2550, 3, 132,
		66, 0, 2550, 2551, 5, 903, 0, 0, 2551, 2553, 1, 0, 0, 0, 2552, 2545, 1,
		0, 0, 0, 2552, 2553, 1, 0, 0, 0, 2553, 2563, 1, 0, 0, 0, 2554, 2556, 5,
		775, 0, 0, 2555, 2557, 5, 908, 0, 0, 2556, 2555, 1, 0, 0, 0, 2556, 2557,
		1, 0, 0, 0, 2557, 2558, 1, 0, 0, 0, 2558, 2559, 5, 896, 0, 0, 2559, 2560,
		3, 146, 73, 0, 2560, 2561, 5, 903, 0, 0, 2561, 2563, 1, 0, 0, 0, 2562,
		2535, 1, 0, 0, 0, 2562, 2540, 1, 0, 0, 0, 2562, 2554, 1, 0, 0, 0, 2563,
		135, 1, 0, 0, 0, 2564, 2565, 5, 4, 0, 0, 2565, 2566, 5, 761, 0, 0, 2566,
		2567, 5, 413, 0, 0, 2567, 2573, 3, 934, 467, 0, 2568, 2574, 3, 124, 62,
		0, 2569, 2570, 3, 122, 61, 0, 2570, 2571, 5, 890, 0, 0, 2571, 2572, 3,
		124, 62, 0, 2572, 2574, 1, 0, 0, 0, 2573, 2568, 1, 0, 0, 0, 2573, 2569,
		1, 0, 0, 0, 2573, 2574, 1, 0, 0, 0, 2574, 2596, 1, 0, 0, 0, 2575, 2576,
		5, 4, 0, 0, 2576, 2577, 5, 761, 0, 0, 2577, 2578, 5, 283, 0, 0, 2578, 2579,
		3, 934, 467, 0, 2579, 2580, 3, 130, 65, 0, 2580, 2596, 1, 0, 0, 0, 2581,
		2582, 5, 4, 0, 0, 2582, 2583, 5, 761, 0, 0, 2583, 2584, 5, 283, 0, 0, 2584,
		2585, 3, 934, 467, 0, 2585, 2586, 5, 756, 0, 0, 2586, 2587, 5, 109, 0,
		0, 2587, 2588, 5, 896, 0, 0, 2588, 2589, 3, 148, 74, 0, 2589, 2590, 5,
		903, 0, 0, 2590, 2591, 5, 154, 0, 0, 2591, 2592, 5, 896, 0, 0, 2592, 2593,
		3, 146, 73, 0, 2593, 2594, 5, 903, 0, 0, 2594, 2596, 1, 0, 0, 0, 2595,
		2564, 1, 0, 0, 0, 2595, 2575, 1, 0, 0, 0, 2595, 2581, 1, 0, 0, 0, 2596,
		137, 1, 0, 0, 0, 2597, 2598, 5, 62, 0, 0, 2598, 2599, 5, 761, 0, 0, 2599,
		2602, 5, 413, 0, 0, 2600, 2601, 5, 93, 0, 0, 2601, 2603, 5, 69, 0, 0, 2602,
		2600, 1, 0, 0, 0, 2602, 2603, 1, 0, 0, 0, 2603, 2604, 1, 0, 0, 0, 2604,
		2614, 3, 934, 467, 0, 2605, 2606, 5, 62, 0, 0, 2606, 2607, 5, 761, 0, 0,
		2607, 2610, 5, 283, 0, 0, 2608, 2609, 5, 93, 0, 0, 2609, 2611, 5, 69, 0,
		0, 2610, 2608, 1, 0, 0, 0, 2610, 2611, 1, 0, 0, 0, 2611, 2612, 1, 0, 0,
		0, 2612, 2614, 3, 934, 467, 0, 2613, 2597, 1, 0, 0, 0, 2613, 2605, 1, 0,
		0, 0, 2614, 139, 1, 0, 0, 0, 2615, 2616, 5, 34, 0, 0, 2616, 2621, 5, 882,
		0, 0, 2617, 2618, 5, 93, 0, 0, 2618, 2619, 3, 38, 19, 0, 2619, 2620, 5,
		69, 0, 0, 2620, 2622, 1, 0, 0, 0, 2621, 2617, 1, 0, 0, 0, 2621, 2622, 1,
		0, 0, 0, 2622, 2623, 1, 0, 0, 0, 2623, 2629, 3, 934, 467, 0, 2624, 2630,
		3, 144, 72, 0, 2625, 2626, 3, 142, 71, 0, 2626, 2627, 5, 890, 0, 0, 2627,
		2628, 3, 144, 72, 0, 2628, 2630, 1, 0, 0, 0, 2629, 2624, 1, 0, 0, 0, 2629,
		2625, 1, 0, 0, 0, 2629, 2630, 1, 0, 0, 0, 2630, 2638, 1, 0, 0, 0, 2631,
		2632, 5, 193, 0, 0, 2632, 2639, 3, 752, 376, 0, 2633, 2634, 5, 193, 0,
		0, 2634, 2635, 5, 613, 0, 0, 2635, 2639, 3, 752, 376, 0, 2636, 2637, 5,
		613, 0, 0, 2637, 2639, 3, 752, 376, 0, 2638, 2631, 1, 0, 0, 0, 2638, 2633,
		1, 0, 0, 0, 2638, 2636, 1, 0, 0, 0, 2638, 2639, 1, 0, 0, 0, 2639, 141,
		1, 0, 0, 0, 2640, 2641, 6, 71, -1, 0, 2641, 2644, 3, 144, 72, 0, 2642,
		2644, 3, 948, 474, 0, 2643, 2640, 1, 0, 0, 0, 2643, 2642, 1, 0, 0, 0, 2644,
		2650, 1, 0, 0, 0, 2645, 2646, 10, 2, 0, 0, 2646, 2647, 5, 890, 0, 0, 2647,
		2649, 3, 144, 72, 0, 2648, 2645, 1, 0, 0, 0, 2649, 2652, 1, 0, 0, 0, 2650,
		2648, 1, 0, 0, 0, 2650, 2651, 1, 0, 0, 0, 2651, 143, 1, 0, 0, 0, 2652,
		2650, 1, 0, 0, 0, 2653, 2655, 5, 485, 0, 0, 2654, 2656, 5, 908, 0, 0, 2655,
		2654, 1, 0, 0, 0, 2655, 2656, 1, 0, 0, 0, 2656, 2657, 1, 0, 0, 0, 2657,
		2731, 5, 271, 0, 0, 2658, 2660, 5, 476, 0, 0, 2659, 2661, 5, 908, 0, 0,
		2660, 2659, 1, 0, 0, 0, 2660, 2661, 1, 0, 0, 0, 2661, 2662, 1, 0, 0, 0,
		2662, 2664, 5, 923, 0, 0, 2663, 2665, 5, 79, 0, 0, 2664, 2663, 1, 0, 0,
		0, 2664, 2665, 1, 0, 0, 0, 2665, 2731, 1, 0, 0, 0, 2666, 2668, 5, 748,
		0, 0, 2667, 2669, 5, 908, 0, 0, 2668, 2667, 1, 0, 0, 0, 2668, 2669, 1,
		0, 0, 0, 2669, 2670, 1, 0, 0, 0, 2670, 2731, 5, 271, 0, 0, 2671, 2673,
		5, 290, 0, 0, 2672, 2674, 5, 908, 0, 0, 2673, 2672, 1, 0, 0, 0, 2673, 2674,
		1, 0, 0, 0, 2674, 2675, 1, 0, 0, 0, 2675, 2731, 5, 271, 0, 0, 2676, 2678,
		5, 642, 0, 0, 2677, 2679, 5, 908, 0, 0, 2678, 2677, 1, 0, 0, 0, 2678, 2679,
		1, 0, 0, 0, 2679, 2680, 1, 0, 0, 0, 2680, 2731, 5, 271, 0, 0, 2681, 2683,
		5, 280, 0, 0, 2682, 2684, 5, 908, 0, 0, 2683, 2682, 1, 0, 0, 0, 2683, 2684,
		1, 0, 0, 0, 2684, 2685, 1, 0, 0, 0, 2685, 2731, 5, 271, 0, 0, 2686, 2688,
		5, 773, 0, 0, 2687, 2689, 5, 908, 0, 0, 2688, 2687, 1, 0, 0, 0, 2688, 2689,
		1, 0, 0, 0, 2689, 2690, 1, 0, 0, 0, 2690, 2731, 3, 280, 140, 0, 2691, 2693,
		5, 851, 0, 0, 2692, 2694, 5, 908, 0, 0, 2693, 2692, 1, 0, 0, 0, 2693, 2694,
		1, 0, 0, 0, 2694, 2695, 1, 0, 0, 0, 2695, 2696, 5, 896, 0, 0, 2696, 2697,
		3, 148, 74, 0, 2697, 2698, 5, 903, 0, 0, 2698, 2731, 1, 0, 0, 0, 2699,
		2701, 5, 775, 0, 0, 2700, 2702, 5, 908, 0, 0, 2701, 2700, 1, 0, 0, 0, 2701,
		2702, 1, 0, 0, 0, 2702, 2703, 1, 0, 0, 0, 2703, 2704, 5, 896, 0, 0, 2704,
		2705, 3, 146, 73, 0, 2705, 2706, 5, 903, 0, 0, 2706, 2731, 1, 0, 0, 0,
		2707, 2709, 3, 162, 81, 0, 2708, 2710, 5, 908, 0, 0, 2709, 2708, 1, 0,
		0, 0, 2709, 2710, 1, 0, 0, 0, 2710, 2711, 1, 0, 0, 0, 2711, 2712, 3, 260,
		130, 0, 2712, 2731, 1, 0, 0, 0, 2713, 2715, 5, 31, 0, 0, 2714, 2716, 5,
		908, 0, 0, 2715, 2714, 1, 0, 0, 0, 2715, 2716, 1, 0, 0, 0, 2716, 2717,
		1, 0, 0, 0, 2717, 2731, 3, 254, 127, 0, 2718, 2731, 3, 166, 83, 0, 2719,
		2721, 5, 369, 0, 0, 2720, 2722, 5, 908, 0, 0, 2721, 2720, 1, 0, 0, 0, 2721,
		2722, 1, 0, 0, 0, 2722, 2723, 1, 0, 0, 0, 2723, 2731, 5, 923, 0, 0, 2724,
		2731, 3, 380, 190, 0, 2725, 2727, 5, 293, 0, 0, 2726, 2728, 5, 908, 0,
		0, 2727, 2726, 1, 0, 0, 0, 2727, 2728, 1, 0, 0, 0, 2728, 2729, 1, 0, 0,
		0, 2729, 2731, 5, 271, 0, 0, 2730, 2653, 1, 0, 0, 0, 2730, 2658, 1, 0,
		0, 0, 2730, 2666, 1, 0, 0, 0, 2730, 2671, 1, 0, 0, 0, 2730, 2676, 1, 0,
		0, 0, 2730, 2681, 1, 0, 0, 0, 2730, 2686, 1, 0, 0, 0, 2730, 2691, 1, 0,
		0, 0, 2730, 2699, 1, 0, 0, 0, 2730, 2707, 1, 0, 0, 0, 2730, 2713, 1, 0,
		0, 0, 2730, 2718, 1, 0, 0, 0, 2730, 2719, 1, 0, 0, 0, 2730, 2724, 1, 0,
		0, 0, 2730, 2725, 1, 0, 0, 0, 2731, 145, 1, 0, 0, 0, 2732, 2738, 5, 923,
		0, 0, 2733, 2734, 3, 274, 137, 0, 2734, 2735, 5, 923, 0, 0, 2735, 2737,
		1, 0, 0, 0, 2736, 2733, 1, 0, 0, 0, 2737, 2740, 1, 0, 0, 0, 2738, 2736,
		1, 0, 0, 0, 2738, 2739, 1, 0, 0, 0, 2739, 147, 1, 0, 0, 0, 2740, 2738,
		1, 0, 0, 0, 2741, 2746, 5, 923, 0, 0, 2742, 2743, 5, 890, 0, 0, 2743, 2745,
		5, 923, 0, 0, 2744, 2742, 1, 0, 0, 0, 2745, 2748, 1, 0, 0, 0, 2746, 2744,
		1, 0, 0, 0, 2746, 2747, 1, 0, 0, 0, 2747, 149, 1, 0, 0, 0, 2748, 2746,
		1, 0, 0, 0, 2749, 2750, 5, 4, 0, 0, 2750, 2751, 5, 882, 0, 0, 2751, 2753,
		3, 934, 467, 0, 2752, 2754, 5, 193, 0, 0, 2753, 2752, 1, 0, 0, 0, 2753,
		2754, 1, 0, 0, 0, 2754, 2760, 1, 0, 0, 0, 2755, 2761, 3, 144, 72, 0, 2756,
		2757, 3, 142, 71, 0, 2757, 2758, 5, 890, 0, 0, 2758, 2759, 3, 144, 72,
		0, 2759, 2761, 1, 0, 0, 0, 2760, 2755, 1, 0, 0, 0, 2760, 2756, 1, 0, 0,
		0, 2760, 2761, 1, 0, 0, 0, 2761, 2764, 1, 0, 0, 0, 2762, 2763, 5, 613,
		0, 0, 2763, 2765, 3, 752, 376, 0, 2764, 2762, 1, 0, 0, 0, 2764, 2765, 1,
		0, 0, 0, 2765, 2797, 1, 0, 0, 0, 2766, 2767, 5, 4, 0, 0, 2767, 2768, 5,
		882, 0, 0, 2768, 2770, 5, 8, 0, 0, 2769, 2771, 5, 193, 0, 0, 2770, 2769,
		1, 0, 0, 0, 2770, 2771, 1, 0, 0, 0, 2771, 2777, 1, 0, 0, 0, 2772, 2778,
		3, 144, 72, 0, 2773, 2774, 3, 142, 71, 0, 2774, 2775, 5, 890, 0, 0, 2775,
		2776, 3, 144, 72, 0, 2776, 2778, 1, 0, 0, 0, 2777, 2772, 1, 0, 0, 0, 2777,
		2773, 1, 0, 0, 0, 2777, 2778, 1, 0, 0, 0, 2778, 2781, 1, 0, 0, 0, 2779,
		2780, 5, 613, 0, 0, 2780, 2782, 3, 752, 376, 0, 2781, 2779, 1, 0, 0, 0,
		2781, 2782, 1, 0, 0, 0, 2782, 2797, 1, 0, 0, 0, 2783, 2784, 5, 4, 0, 0,
		2784, 2785, 5, 882, 0, 0, 2785, 2786, 3, 934, 467, 0, 2786, 2787, 5, 178,
		0, 0, 2787, 2788, 5, 755, 0, 0, 2788, 2789, 5, 223, 0, 0, 2789, 2790, 3,
		934, 467, 0, 2790, 2797, 1, 0, 0, 0, 2791, 2792, 5, 4, 0, 0, 2792, 2793,
		5, 882, 0, 0, 2793, 2794, 3, 934, 467, 0, 2794, 2795, 3, 710, 355, 0, 2795,
		2797, 1, 0, 0, 0, 2796, 2749, 1, 0, 0, 0, 2796, 2766, 1, 0, 0, 0, 2796,
		2783, 1, 0, 0, 0, 2796, 2791, 1, 0, 0, 0, 2797, 151, 1, 0, 0, 0, 2798,
		2799, 5, 62, 0, 0, 2799, 2802, 5, 882, 0, 0, 2800, 2801, 5, 93, 0, 0, 2801,
		2803, 5, 69, 0, 0, 2802, 2800, 1, 0, 0, 0, 2802, 2803, 1, 0, 0, 0, 2803,
		2804, 1, 0, 0, 0, 2804, 2806, 3, 934, 467, 0, 2805, 2807, 5, 79, 0, 0,
		2806, 2805, 1, 0, 0, 0, 2806, 2807, 1, 0, 0, 0, 2807, 153, 1, 0, 0, 0,
		2808, 2809, 5, 34, 0, 0, 2809, 2814, 3, 156, 78, 0, 2810, 2811, 5, 93,
		0, 0, 2811, 2812, 3, 38, 19, 0, 2812, 2813, 5, 69, 0, 0, 2813, 2815, 1,
		0, 0, 0, 2814, 2810, 1, 0, 0, 0, 2814, 2815, 1, 0, 0, 0, 2815, 2816, 1,
		0, 0, 0, 2816, 2818, 3, 158, 79, 0, 2817, 2819, 3, 160, 80, 0, 2818, 2817,
		1, 0, 0, 0, 2818, 2819, 1, 0, 0, 0, 2819, 155, 1, 0, 0, 0, 2820, 2821,
		7, 14, 0, 0, 2821, 157, 1, 0, 0, 0, 2822, 2823, 3, 934, 467, 0, 2823, 159,
		1, 0, 0, 0, 2824, 2826, 3, 164, 82, 0, 2825, 2824, 1, 0, 0, 0, 2826, 2827,
		1, 0, 0, 0, 2827, 2825, 1, 0, 0, 0, 2827, 2828, 1, 0, 0, 0, 2828, 161,
		1, 0, 0, 0, 2829, 2833, 5, 579, 0, 0, 2830, 2831, 5, 24, 0, 0, 2831, 2833,
		5, 193, 0, 0, 2832, 2829, 1, 0, 0, 0, 2832, 2830, 1, 0, 0, 0, 2833, 163,
		1, 0, 0, 0, 2834, 2836, 5, 52, 0, 0, 2835, 2834, 1, 0, 0, 0, 2835, 2836,
		1, 0, 0, 0, 2836, 2837, 1, 0, 0, 0, 2837, 2839, 3, 162, 81, 0, 2838, 2840,
		5, 908, 0, 0, 2839, 2838, 1, 0, 0, 0, 2839, 2840, 1, 0, 0, 0, 2840, 2841,
		1, 0, 0, 0, 2841, 2842, 3, 260, 130, 0, 2842, 2869, 1, 0, 0, 0, 2843, 2845,
		5, 52, 0, 0, 2844, 2843, 1, 0, 0, 0, 2844, 2845, 1, 0, 0, 0, 2845, 2846,
		1, 0, 0, 0, 2846, 2848, 5, 31, 0, 0, 2847, 2849, 5, 908, 0, 0, 2848, 2847,
		1, 0, 0, 0, 2848, 2849, 1, 0, 0, 0, 2849, 2850, 1, 0, 0, 0, 2850, 2869,
		3, 254, 127, 0, 2851, 2853, 5, 748, 0, 0, 2852, 2854, 5, 908, 0, 0, 2853,
		2852, 1, 0, 0, 0, 2853, 2854, 1, 0, 0, 0, 2854, 2855, 1, 0, 0, 0, 2855,
		2869, 5, 271, 0, 0, 2856, 2858, 5, 773, 0, 0, 2857, 2859, 5, 908, 0, 0,
		2858, 2857, 1, 0, 0, 0, 2858, 2859, 1, 0, 0, 0, 2859, 2860, 1, 0, 0, 0,
		2860, 2869, 3, 280, 140, 0, 2861, 2869, 3, 166, 83, 0, 2862, 2869, 3, 380,
		190, 0, 2863, 2865, 5, 776, 0, 0, 2864, 2866, 5, 908, 0, 0, 2865, 2864,
		1, 0, 0, 0, 2865, 2866, 1, 0, 0, 0, 2866, 2867, 1, 0, 0, 0, 2867, 2869,
		5, 271, 0, 0, 2868, 2835, 1, 0, 0, 0, 2868, 2844, 1, 0, 0, 0, 2868, 2851,
		1, 0, 0, 0, 2868, 2856, 1, 0, 0, 0, 2868, 2861, 1, 0, 0, 0, 2868, 2862,
		1, 0, 0, 0, 2868, 2863, 1, 0, 0, 0, 2869, 165, 1, 0, 0, 0, 2870, 2871,
		5, 171, 0, 0, 2871, 2875, 5, 848, 0, 0, 2872, 2873, 5, 171, 0, 0, 2873,
		2875, 5, 248, 0, 0, 2874, 2870, 1, 0, 0, 0, 2874, 2872, 1, 0, 0, 0, 2875,
		167, 1, 0, 0, 0, 2876, 2877, 5, 62, 0, 0, 2877, 2880, 3, 156, 78, 0, 2878,
		2879, 5, 93, 0, 0, 2879, 2881, 5, 69, 0, 0, 2880, 2878, 1, 0, 0, 0, 2880,
		2881, 1, 0, 0, 0, 2881, 2882, 1, 0, 0, 0, 2882, 2883, 3, 158, 79, 0, 2883,
		169, 1, 0, 0, 0, 2884, 2885, 5, 4, 0, 0, 2885, 2887, 3, 156, 78, 0, 2886,
		2888, 5, 921, 0, 0, 2887, 2886, 1, 0, 0, 0, 2887, 2888, 1, 0, 0, 0, 2888,
		2890, 1, 0, 0, 0, 2889, 2891, 5, 193, 0, 0, 2890, 2889, 1, 0, 0, 0, 2890,
		2891, 1, 0, 0, 0, 2891, 2892, 1, 0, 0, 0, 2892, 2893, 3, 160, 80, 0, 2893,
		171, 1, 0, 0, 0, 2894, 2896, 3, 174, 87, 0, 2895, 2897, 7, 15, 0, 0, 2896,
		2895, 1, 0, 0, 0, 2896, 2897, 1, 0, 0, 0, 2897, 2898, 1, 0, 0, 0, 2898,
		2899, 5, 98, 0, 0, 2899, 2901, 5, 923, 0, 0, 2900, 2902, 7, 16, 0, 0, 2901,
		2900, 1, 0, 0, 0, 2901, 2902, 1, 0, 0, 0, 2902, 2903, 1, 0, 0, 0, 2903,
		2904, 5, 109, 0, 0, 2904, 2905, 5, 220, 0, 0, 2905, 2907, 3, 584, 292,
		0, 2906, 2908, 3, 568, 284, 0, 2907, 2906, 1, 0, 0, 0, 2907, 2908, 1, 0,
		0, 0, 2908, 2912, 1, 0, 0, 0, 2909, 2910, 5, 24, 0, 0, 2910, 2911, 5, 193,
		0, 0, 2911, 2913, 3, 262, 131, 0, 2912, 2909, 1, 0, 0, 0, 2912, 2913, 1,
		0, 0, 0, 2913, 2914, 1, 0, 0, 0, 2914, 2915, 3, 490, 245, 0, 2915, 2922,
		3, 496, 248, 0, 2916, 2917, 5, 367, 0, 0, 2917, 2918, 5, 271, 0, 0, 2918,
		2923, 3, 176, 88, 0, 2919, 2920, 5, 84, 0, 0, 2920, 2921, 5, 271, 0, 0,
		2921, 2923, 3, 176, 88, 0, 2922, 2916, 1, 0, 0, 0, 2922, 2919, 1, 0, 0,
		0, 2922, 2923, 1, 0, 0, 0, 2923, 2930, 1, 0, 0, 0, 2924, 2925, 5, 896,
		0, 0, 2925, 2931, 5, 903, 0, 0, 2926, 2927, 5, 896, 0, 0, 2927, 2928, 3,
		178, 89, 0, 2928, 2929, 5, 903, 0, 0, 2929, 2931, 1, 0, 0, 0, 2930, 2924,
		1, 0, 0, 0, 2930, 2926, 1, 0, 0, 0, 2930, 2931, 1, 0, 0, 0, 2931, 2934,
		1, 0, 0, 0, 2932, 2933, 5, 193, 0, 0, 2933, 2935, 3, 182, 91, 0, 2934,
		2932, 1, 0, 0, 0, 2934, 2935, 1, 0, 0, 0, 2935, 173, 1, 0, 0, 0, 2936,
		2937, 5, 128, 0, 0, 2937, 2941, 5, 867, 0, 0, 2938, 2939, 5, 927, 0, 0,
		2939, 2941, 3, 502, 251, 0, 2940, 2936, 1, 0, 0, 0, 2940, 2938, 1, 0, 0,
		0, 2941, 175, 1, 0, 0, 0, 2942, 2943, 7, 17, 0, 0, 2943, 177, 1, 0, 0,
		0, 2944, 2949, 3, 180, 90, 0, 2945, 2946, 5, 890, 0, 0, 2946, 2948, 3,
		180, 90, 0, 2947, 2945, 1, 0, 0, 0, 2948, 2951, 1, 0, 0, 0, 2949, 2947,
		1, 0, 0, 0, 2949, 2950, 1, 0, 0, 0, 2950, 179, 1, 0, 0, 0, 2951, 2949,
		1, 0, 0, 0, 2952, 2955, 3, 226, 113, 0, 2953, 2955, 5, 920, 0, 0, 2954,
		2952, 1, 0, 0, 0, 2954, 2953, 1, 0, 0, 0, 2955, 181, 1, 0, 0, 0, 2956,
		2961, 3, 184, 92, 0, 2957, 2958, 5, 890, 0, 0, 2958, 2960, 3, 184, 92,
		0, 2959, 2957, 1, 0, 0, 0, 2960, 2963, 1, 0, 0, 0, 2961, 2959, 1, 0, 0,
		0, 2961, 2962, 1, 0, 0, 0, 2962, 183, 1, 0, 0, 0, 2963, 2961, 1, 0, 0,
		0, 2964, 2965, 3, 226, 113, 0, 2965, 2966, 5, 908, 0, 0, 2966, 2967, 3,
		434, 217, 0, 2967, 185, 1, 0, 0, 0, 2968, 2969, 5, 233, 0, 0, 2969, 2970,
		3, 158, 79, 0, 2970, 187, 1, 0, 0, 0, 2971, 2974, 5, 34, 0, 0, 2972, 2973,
		5, 158, 0, 0, 2973, 2975, 5, 179, 0, 0, 2974, 2972, 1, 0, 0, 0, 2974, 2975,
		1, 0, 0, 0, 2975, 2977, 1, 0, 0, 0, 2976, 2978, 5, 169, 0, 0, 2977, 2976,
		1, 0, 0, 0, 2977, 2978, 1, 0, 0, 0, 2978, 2979, 1, 0, 0, 0, 2979, 2980,
		5, 213, 0, 0, 2980, 2981, 3, 190, 95, 0, 2981, 2982, 5, 78, 0, 0, 2982,
		2985, 3, 192, 96, 0, 2983, 2984, 5, 885, 0, 0, 2984, 2986, 3, 848, 424,
		0, 2985, 2983, 1, 0, 0, 0, 2985, 2986, 1, 0, 0, 0, 2986, 3044, 1, 0, 0,
		0, 2987, 2990, 5, 34, 0, 0, 2988, 2989, 5, 158, 0, 0, 2989, 2991, 5, 179,
		0, 0, 2990, 2988, 1, 0, 0, 0, 2990, 2991, 1, 0, 0, 0, 2991, 2993, 1, 0,
		0, 0, 2992, 2994, 5, 169, 0, 0, 2993, 2992, 1, 0, 0, 0, 2993, 2994, 1,
		0, 0, 0, 2994, 2995, 1, 0, 0, 0, 2995, 2996, 5, 213, 0, 0, 2996, 2997,
		3, 158, 79, 0, 2997, 2998, 5, 901, 0, 0, 2998, 2999, 3, 190, 95, 0, 2999,
		3000, 5, 78, 0, 0, 3000, 3003, 3, 192, 96, 0, 3001, 3002, 5, 885, 0, 0,
		3002, 3004, 3, 848, 424, 0, 3003, 3001, 1, 0, 0, 0, 3003, 3004, 1, 0, 0,
		0, 3004, 3044, 1, 0, 0, 0, 3005, 3008, 5, 34, 0, 0, 3006, 3007, 5, 158,
		0, 0, 3007, 3009, 5, 179, 0, 0, 3008, 3006, 1, 0, 0, 0, 3008, 3009, 1,
		0, 0, 0, 3009, 3011, 1, 0, 0, 0, 3010, 3012, 5, 169, 0, 0, 3011, 3010,
		1, 0, 0, 0, 3011, 3012, 1, 0, 0, 0, 3012, 3013, 1, 0, 0, 0, 3013, 3014,
		5, 213, 0, 0, 3014, 3015, 3, 190, 95, 0, 3015, 3016, 5, 78, 0, 0, 3016,
		3017, 3, 158, 79, 0, 3017, 3018, 5, 901, 0, 0, 3018, 3021, 3, 192, 96,
		0, 3019, 3020, 5, 885, 0, 0, 3020, 3022, 3, 848, 424, 0, 3021, 3019, 1,
		0, 0, 0, 3021, 3022, 1, 0, 0, 0, 3022, 3044, 1, 0, 0, 0, 3023, 3026, 5,
		34, 0, 0, 3024, 3025, 5, 158, 0, 0, 3025, 3027, 5, 179, 0, 0, 3026, 3024,
		1, 0, 0, 0, 3026, 3027, 1, 0, 0, 0, 3027, 3029, 1, 0, 0, 0, 3028, 3030,
		5, 169, 0, 0, 3029, 3028, 1, 0, 0, 0, 3029, 3030, 1, 0, 0, 0, 3030, 3031,
		1, 0, 0, 0, 3031, 3032, 5, 213, 0, 0, 3032, 3033, 3, 158, 79, 0, 3033,
		3034, 5, 901, 0, 0, 3034, 3035, 3, 190, 95, 0, 3035, 3036, 5, 78, 0, 0,
		3036, 3037, 3, 158, 79, 0, 3037, 3038, 5, 901, 0, 0, 3038, 3041, 3, 192,
		96, 0, 3039, 3040, 5, 885, 0, 0, 3040, 3042, 3, 848, 424, 0, 3041, 3039,
		1, 0, 0, 0, 3041, 3042, 1, 0, 0, 0, 3042, 3044, 1, 0, 0, 0, 3043, 2971,
		1, 0, 0, 0, 3043, 2987, 1, 0, 0, 0, 3043, 3005, 1, 0, 0, 0, 3043, 3023,
		1, 0, 0, 0, 3044, 189, 1, 0, 0, 0, 3045, 3048, 5, 921, 0, 0, 3046, 3048,
		3, 942, 471, 0, 3047, 3045, 1, 0, 0, 0, 3047, 3046, 1, 0, 0, 0, 3048, 191,
		1, 0, 0, 0, 3049, 3052, 5, 921, 0, 0, 3050, 3052, 3, 942, 471, 0, 3051,
		3049, 1, 0, 0, 0, 3051, 3050, 1, 0, 0, 0, 3052, 193, 1, 0, 0, 0, 3053,
		3055, 5, 62, 0, 0, 3054, 3056, 5, 169, 0, 0, 3055, 3054, 1, 0, 0, 0, 3055,
		3056, 1, 0, 0, 0, 3056, 3057, 1, 0, 0, 0, 3057, 3058, 5, 213, 0, 0, 3058,
		3060, 3, 190, 95, 0, 3059, 3061, 5, 79, 0, 0, 3060, 3059, 1, 0, 0, 0, 3060,
		3061, 1, 0, 0, 0, 3061, 3074, 1, 0, 0, 0, 3062, 3064, 5, 62, 0, 0, 3063,
		3065, 5, 169, 0, 0, 3064, 3063, 1, 0, 0, 0, 3064, 3065, 1, 0, 0, 0, 3065,
		3066, 1, 0, 0, 0, 3066, 3067, 5, 213, 0, 0, 3067, 3068, 3, 158, 79, 0,
		3068, 3069, 5, 901, 0, 0, 3069, 3071, 3, 190, 95, 0, 3070, 3072, 5, 79,
		0, 0, 3071, 3070, 1, 0, 0, 0, 3071, 3072, 1, 0, 0, 0, 3072, 3074, 1, 0,
		0, 0, 3073, 3053, 1, 0, 0, 0, 3073, 3062, 1, 0, 0, 0, 3074, 195, 1, 0,
		0, 0, 3075, 3077, 5, 464, 0, 0, 3076, 3075, 1, 0, 0, 0, 3076, 3077, 1,
		0, 0, 0, 3077, 197, 1, 0, 0, 0, 3078, 3079, 5, 34, 0, 0, 3079, 3080, 3,
		196, 98, 0, 3080, 3085, 5, 220, 0, 0, 3081, 3082, 5, 93, 0, 0, 3082, 3083,
		3, 38, 19, 0, 3083, 3084, 5, 69, 0, 0, 3084, 3086, 1, 0, 0, 0, 3085, 3081,
		1, 0, 0, 0, 3085, 3086, 1, 0, 0, 0, 3086, 3087, 1, 0, 0, 0, 3087, 3088,
		3, 584, 292, 0, 3088, 3089, 5, 124, 0, 0, 3089, 3090, 3, 584, 292, 0, 3090,
		3107, 1, 0, 0, 0, 3091, 3092, 5, 34, 0, 0, 3092, 3093, 3, 196, 98, 0, 3093,
		3098, 5, 220, 0, 0, 3094, 3095, 5, 93, 0, 0, 3095, 3096, 3, 38, 19, 0,
		3096, 3097, 5, 69, 0, 0, 3097, 3099, 1, 0, 0, 0, 3098, 3094, 1, 0, 0, 0,
		3098, 3099, 1, 0, 0, 0, 3099, 3100, 1, 0, 0, 0, 3100, 3101, 3, 584, 292,
		0, 3101, 3102, 5, 896, 0, 0, 3102, 3103, 5, 124, 0, 0, 3103, 3104, 3, 584,
		292, 0, 3104, 3105, 5, 903, 0, 0, 3105, 3107, 1, 0, 0, 0, 3106, 3078, 1,
		0, 0, 0, 3106, 3091, 1, 0, 0, 0, 3107, 199, 1, 0, 0, 0, 3108, 3109, 5,
		34, 0, 0, 3109, 3110, 3, 196, 98, 0, 3110, 3115, 5, 220, 0, 0, 3111, 3112,
		5, 93, 0, 0, 3112, 3113, 3, 38, 19, 0, 3113, 3114, 5, 69, 0, 0, 3114, 3116,
		1, 0, 0, 0, 3115, 3111, 1, 0, 0, 0, 3115, 3116, 1, 0, 0, 0, 3116, 3117,
		1, 0, 0, 0, 3117, 3118, 3, 584, 292, 0, 3118, 3119, 5, 896, 0, 0, 3119,
		3120, 3, 208, 104, 0, 3120, 3122, 5, 903, 0, 0, 3121, 3123, 3, 278, 139,
		0, 3122, 3121, 1, 0, 0, 0, 3122, 3123, 1, 0, 0, 0, 3123, 3124, 1, 0, 0,
		0, 3124, 3125, 3, 294, 147, 0, 3125, 3207, 1, 0, 0, 0, 3126, 3127, 5, 34,
		0, 0, 3127, 3128, 3, 196, 98, 0, 3128, 3133, 5, 220, 0, 0, 3129, 3130,
		5, 93, 0, 0, 3130, 3131, 3, 38, 19, 0, 3131, 3132, 5, 69, 0, 0, 3132, 3134,
		1, 0, 0, 0, 3133, 3129, 1, 0, 0, 0, 3133, 3134, 1, 0, 0, 0, 3134, 3135,
		1, 0, 0, 0, 3135, 3136, 3, 584, 292, 0, 3136, 3137, 5, 896, 0, 0, 3137,
		3138, 3, 208, 104, 0, 3138, 3140, 5, 903, 0, 0, 3139, 3141, 3, 278, 139,
		0, 3140, 3139, 1, 0, 0, 0, 3140, 3141, 1, 0, 0, 0, 3141, 3142, 1, 0, 0,
		0, 3142, 3144, 3, 294, 147, 0, 3143, 3145, 5, 9, 0, 0, 3144, 3143, 1, 0,
		0, 0, 3144, 3145, 1, 0, 0, 0, 3145, 3146, 1, 0, 0, 0, 3146, 3147, 3, 436,
		218, 0, 3147, 3207, 1, 0, 0, 0, 3148, 3149, 5, 34, 0, 0, 3149, 3150, 3,
		196, 98, 0, 3150, 3155, 5, 220, 0, 0, 3151, 3152, 5, 93, 0, 0, 3152, 3153,
		3, 38, 19, 0, 3153, 3154, 5, 69, 0, 0, 3154, 3156, 1, 0, 0, 0, 3155, 3151,
		1, 0, 0, 0, 3155, 3156, 1, 0, 0, 0, 3156, 3157, 1, 0, 0, 0, 3157, 3158,
		3, 584, 292, 0, 3158, 3159, 3, 278, 139, 0, 3159, 3161, 3, 294, 147, 0,
		3160, 3162, 5, 9, 0, 0, 3161, 3160, 1, 0, 0, 0, 3161, 3162, 1, 0, 0, 0,
		3162, 3163, 1, 0, 0, 0, 3163, 3164, 3, 436, 218, 0, 3164, 3207, 1, 0, 0,
		0, 3165, 3166, 5, 34, 0, 0, 3166, 3167, 3, 196, 98, 0, 3167, 3172, 5, 220,
		0, 0, 3168, 3169, 5, 93, 0, 0, 3169, 3170, 3, 38, 19, 0, 3170, 3171, 5,
		69, 0, 0, 3171, 3173, 1, 0, 0, 0, 3172, 3168, 1, 0, 0, 0, 3172, 3173, 1,
		0, 0, 0, 3173, 3174, 1, 0, 0, 0, 3174, 3175, 3, 584, 292, 0, 3175, 3177,
		3, 292, 146, 0, 3176, 3178, 5, 9, 0, 0, 3177, 3176, 1, 0, 0, 0, 3177, 3178,
		1, 0, 0, 0, 3178, 3179, 1, 0, 0, 0, 3179, 3180, 3, 436, 218, 0, 3180, 3207,
		1, 0, 0, 0, 3181, 3182, 5, 34, 0, 0, 3182, 3183, 3, 196, 98, 0, 3183, 3188,
		5, 220, 0, 0, 3184, 3185, 5, 93, 0, 0, 3185, 3186, 3, 38, 19, 0, 3186,
		3187, 5, 69, 0, 0, 3187, 3189, 1, 0, 0, 0, 3188, 3184, 1, 0, 0, 0, 3188,
		3189, 1, 0, 0, 0, 3189, 3190, 1, 0, 0, 0, 3190, 3191, 3, 584, 292, 0, 3191,
		3192, 3, 436, 218, 0, 3192, 3207, 1, 0, 0, 0, 3193, 3194, 5, 34, 0, 0,
		3194, 3195, 3, 196, 98, 0, 3195, 3200, 5, 220, 0, 0, 3196, 3197, 5, 93,
		0, 0, 3197, 3198, 3, 38, 19, 0, 3198, 3199, 5, 69, 0, 0, 3199, 3201, 1,
		0, 0, 0, 3200, 3196, 1, 0, 0, 0, 3200, 3201, 1, 0, 0, 0, 3201, 3202, 1,
		0, 0, 0, 3202, 3203, 3, 584, 292, 0, 3203, 3204, 5, 9, 0, 0, 3204, 3205,
		3, 436, 218, 0, 3205, 3207, 1, 0, 0, 0, 3206, 3108, 1, 0, 0, 0, 3206, 3126,
		1, 0, 0, 0, 3206, 3148, 1, 0, 0, 0, 3206, 3165, 1, 0, 0, 0, 3206, 3181,
		1, 0, 0, 0, 3206, 3193, 1, 0, 0, 0, 3207, 201, 1, 0, 0, 0, 3208, 3209,
		7, 18, 0, 0, 3209, 203, 1, 0, 0, 0, 3210, 3212, 5, 34, 0, 0, 3211, 3213,
		5, 659, 0, 0, 3212, 3211, 1, 0, 0, 0, 3212, 3213, 1, 0, 0, 0, 3213, 3214,
		1, 0, 0, 0, 3214, 3215, 5, 527, 0, 0, 3215, 3216, 5, 921, 0, 0, 3216, 3217,
		5, 380, 0, 0, 3217, 3218, 3, 202, 101, 0, 3218, 3219, 5, 647, 0, 0, 3219,
		3220, 5, 923, 0, 0, 3220, 205, 1, 0, 0, 0, 3221, 3222, 5, 62, 0, 0, 3222,
		3225, 5, 527, 0, 0, 3223, 3224, 5, 93, 0, 0, 3224, 3226, 5, 69, 0, 0, 3225,
		3223, 1, 0, 0, 0, 3225, 3226, 1, 0, 0, 0, 3226, 3227, 1, 0, 0, 0, 3227,
		3228, 5, 921, 0, 0, 3228, 207, 1, 0, 0, 0, 3229, 3234, 3, 210, 105, 0,
		3230, 3231, 5, 890, 0, 0, 3231, 3233, 3, 210, 105, 0, 3232, 3230, 1, 0,
		0, 0, 3233, 3236, 1, 0, 0, 0, 3234, 3232, 1, 0, 0, 0, 3234, 3235, 1, 0,
		0, 0, 3235, 209, 1, 0, 0, 0, 3236, 3234, 1, 0, 0, 0, 3237, 3356, 3, 220,
		110, 0, 3238, 3239, 5, 28, 0, 0, 3239, 3241, 3, 392, 196, 0, 3240, 3238,
		1, 0, 0, 0, 3240, 3241, 1, 0, 0, 0, 3241, 3242, 1, 0, 0, 0, 3242, 3243,
		5, 168, 0, 0, 3243, 3245, 5, 116, 0, 0, 3244, 3246, 3, 404, 202, 0, 3245,
		3244, 1, 0, 0, 0, 3245, 3246, 1, 0, 0, 0, 3246, 3247, 1, 0, 0, 0, 3247,
		3248, 5, 896, 0, 0, 3248, 3249, 3, 312, 156, 0, 3249, 3251, 5, 903, 0,
		0, 3250, 3252, 3, 404, 202, 0, 3251, 3250, 1, 0, 0, 0, 3251, 3252, 1, 0,
		0, 0, 3252, 3255, 1, 0, 0, 0, 3253, 3254, 5, 369, 0, 0, 3254, 3256, 5,
		923, 0, 0, 3255, 3253, 1, 0, 0, 0, 3255, 3256, 1, 0, 0, 0, 3256, 3356,
		1, 0, 0, 0, 3257, 3259, 3, 572, 286, 0, 3258, 3260, 3, 390, 195, 0, 3259,
		3258, 1, 0, 0, 0, 3259, 3260, 1, 0, 0, 0, 3260, 3262, 1, 0, 0, 0, 3261,
		3263, 3, 404, 202, 0, 3262, 3261, 1, 0, 0, 0, 3262, 3263, 1, 0, 0, 0, 3263,
		3264, 1, 0, 0, 0, 3264, 3265, 5, 896, 0, 0, 3265, 3266, 3, 396, 198, 0,
		3266, 3268, 5, 903, 0, 0, 3267, 3269, 3, 400, 200, 0, 3268, 3267, 1, 0,
		0, 0, 3268, 3269, 1, 0, 0, 0, 3269, 3356, 1, 0, 0, 0, 3270, 3272, 5, 228,
		0, 0, 3271, 3273, 3, 572, 286, 0, 3272, 3271, 1, 0, 0, 0, 3272, 3273, 1,
		0, 0, 0, 3273, 3275, 1, 0, 0, 0, 3274, 3276, 3, 390, 195, 0, 3275, 3274,
		1, 0, 0, 0, 3275, 3276, 1, 0, 0, 0, 3276, 3278, 1, 0, 0, 0, 3277, 3279,
		3, 404, 202, 0, 3278, 3277, 1, 0, 0, 0, 3278, 3279, 1, 0, 0, 0, 3279, 3280,
		1, 0, 0, 0, 3280, 3281, 5, 896, 0, 0, 3281, 3282, 3, 396, 198, 0, 3282,
		3284, 5, 903, 0, 0, 3283, 3285, 3, 400, 200, 0, 3284, 3283, 1, 0, 0, 0,
		3284, 3285, 1, 0, 0, 0, 3285, 3356, 1, 0, 0, 0, 3286, 3288, 5, 28, 0, 0,
		3287, 3289, 3, 394, 197, 0, 3288, 3287, 1, 0, 0, 0, 3288, 3289, 1, 0, 0,
		0, 3289, 3290, 1, 0, 0, 0, 3290, 3292, 5, 228, 0, 0, 3291, 3293, 3, 572,
		286, 0, 3292, 3291, 1, 0, 0, 0, 3292, 3293, 1, 0, 0, 0, 3293, 3295, 1,
		0, 0, 0, 3294, 3296, 3, 390, 195, 0, 3295, 3294, 1, 0, 0, 0, 3295, 3296,
		1, 0, 0, 0, 3296, 3298, 1, 0, 0, 0, 3297, 3299, 3, 404, 202, 0, 3298, 3297,
		1, 0, 0, 0, 3298, 3299, 1, 0, 0, 0, 3299, 3300, 1, 0, 0, 0, 3300, 3301,
		5, 896, 0, 0, 3301, 3302, 3, 396, 198, 0, 3302, 3304, 5, 903, 0, 0, 3303,
		3305, 3, 400, 200, 0, 3304, 3303, 1, 0, 0, 0, 3304, 3305, 1, 0, 0, 0, 3305,
		3356, 1, 0, 0, 0, 3306, 3308, 5, 82, 0, 0, 3307, 3309, 3, 572, 286, 0,
		3308, 3307, 1, 0, 0, 0, 3308, 3309, 1, 0, 0, 0, 3309, 3311, 1, 0, 0, 0,
		3310, 3312, 3, 390, 195, 0, 3311, 3310, 1, 0, 0, 0, 3311, 3312, 1, 0, 0,
		0, 3312, 3314, 1, 0, 0, 0, 3313, 3315, 3, 404, 202, 0, 3314, 3313, 1, 0,
		0, 0, 3314, 3315, 1, 0, 0, 0, 3315, 3316, 1, 0, 0, 0, 3316, 3317, 5, 896,
		0, 0, 3317, 3318, 3, 396, 198, 0, 3318, 3320, 5, 903, 0, 0, 3319, 3321,
		3, 400, 200, 0, 3320, 3319, 1, 0, 0, 0, 3320, 3321, 1, 0, 0, 0, 3321, 3356,
		1, 0, 0, 0, 3322, 3323, 5, 28, 0, 0, 3323, 3324, 3, 394, 197, 0, 3324,
		3325, 5, 25, 0, 0, 3325, 3326, 5, 896, 0, 0, 3326, 3327, 3, 36, 18, 0,
		3327, 3328, 5, 903, 0, 0, 3328, 3356, 1, 0, 0, 0, 3329, 3330, 5, 28, 0,
		0, 3330, 3332, 3, 392, 196, 0, 3331, 3329, 1, 0, 0, 0, 3331, 3332, 1, 0,
		0, 0, 3332, 3333, 1, 0, 0, 0, 3333, 3334, 5, 74, 0, 0, 3334, 3336, 5, 116,
		0, 0, 3335, 3337, 3, 390, 195, 0, 3336, 3335, 1, 0, 0, 0, 3336, 3337, 1,
		0, 0, 0, 3337, 3338, 1, 0, 0, 0, 3338, 3339, 5, 896, 0, 0, 3339, 3340,
		3, 312, 156, 0, 3340, 3341, 5, 903, 0, 0, 3341, 3342, 5, 176, 0, 0, 3342,
		3343, 3, 584, 292, 0, 3343, 3344, 5, 896, 0, 0, 3344, 3345, 3, 312, 156,
		0, 3345, 3348, 5, 903, 0, 0, 3346, 3347, 5, 140, 0, 0, 3347, 3349, 3, 218,
		109, 0, 3348, 3346, 1, 0, 0, 0, 3348, 3349, 1, 0, 0, 0, 3349, 3353, 1,
		0, 0, 0, 3350, 3351, 3, 212, 106, 0, 3351, 3352, 3, 214, 107, 0, 3352,
		3354, 1, 0, 0, 0, 3353, 3350, 1, 0, 0, 0, 3353, 3354, 1, 0, 0, 0, 3354,
		3356, 1, 0, 0, 0, 3355, 3237, 1, 0, 0, 0, 3355, 3240, 1, 0, 0, 0, 3355,
		3257, 1, 0, 0, 0, 3355, 3270, 1, 0, 0, 0, 3355, 3286, 1, 0, 0, 0, 3355,
		3306, 1, 0, 0, 0, 3355, 3322, 1, 0, 0, 0, 3355, 3331, 1, 0, 0, 0, 3356,
		211, 1, 0, 0, 0, 3357, 3358, 6, 106, -1, 0, 3358, 3359, 3, 948, 474, 0,
		3359, 3364, 1, 0, 0, 0, 3360, 3361, 10, 2, 0, 0, 3361, 3363, 3, 214, 107,
		0, 3362, 3360, 1, 0, 0, 0, 3363, 3366, 1, 0, 0, 0, 3364, 3362, 1, 0, 0,
		0, 3364, 3365, 1, 0, 0, 0, 3365, 213, 1, 0, 0, 0, 3366, 3364, 1, 0, 0,
		0, 3367, 3368, 5, 154, 0, 0, 3368, 3369, 5, 231, 0, 0, 3369, 3374, 3, 216,
		108, 0, 3370, 3371, 5, 154, 0, 0, 3371, 3372, 5, 54, 0, 0, 3372, 3374,
		3, 216, 108, 0, 3373, 3367, 1, 0, 0, 0, 3373, 3370, 1, 0, 0, 0, 3374, 215,
		1, 0, 0, 0, 3375, 3384, 5, 183, 0, 0, 3376, 3384, 5, 21, 0, 0, 3377, 3378,
		5, 193, 0, 0, 3378, 3384, 5, 270, 0, 0, 3379, 3380, 5, 420, 0, 0, 3380,
		3384, 5, 335, 0, 0, 3381, 3382, 5, 193, 0, 0, 3382, 3384, 5, 52, 0, 0,
		3383, 3375, 1, 0, 0, 0, 3383, 3376, 1, 0, 0, 0, 3383, 3377, 1, 0, 0, 0,
		3383, 3379, 1, 0, 0, 0, 3383, 3381, 1, 0, 0, 0, 3384, 217, 1, 0, 0, 0,
		3385, 3386, 7, 19, 0, 0, 3386, 219, 1, 0, 0, 0, 3387, 3388, 3, 226, 113,
		0, 3388, 3392, 3, 234, 117, 0, 3389, 3390, 3, 266, 133, 0, 3390, 3391,
		3, 268, 134, 0, 3391, 3393, 1, 0, 0, 0, 3392, 3389, 1, 0, 0, 0, 3392, 3393,
		1, 0, 0, 0, 3393, 3399, 1, 0, 0, 0, 3394, 3400, 5, 385, 0, 0, 3395, 3396,
		5, 13, 0, 0, 3396, 3400, 3, 932, 466, 0, 3397, 3398, 5, 735, 0, 0, 3398,
		3400, 3, 932, 466, 0, 3399, 3394, 1, 0, 0, 0, 3399, 3395, 1, 0, 0, 0, 3399,
		3397, 1, 0, 0, 0, 3399, 3400, 1, 0, 0, 0, 3400, 3427, 1, 0, 0, 0, 3401,
		3402, 3, 226, 113, 0, 3402, 3405, 3, 234, 117, 0, 3403, 3404, 5, 84, 0,
		0, 3404, 3406, 5, 5, 0, 0, 3405, 3403, 1, 0, 0, 0, 3405, 3406, 1, 0, 0,
		0, 3406, 3407, 1, 0, 0, 0, 3407, 3408, 5, 9, 0, 0, 3408, 3409, 5, 896,
		0, 0, 3409, 3410, 3, 36, 18, 0, 3410, 3412, 5, 903, 0, 0, 3411, 3413, 7,
		20, 0, 0, 3412, 3411, 1, 0, 0, 0, 3412, 3413, 1, 0, 0, 0, 3413, 3417, 1,
		0, 0, 0, 3414, 3415, 3, 222, 111, 0, 3415, 3416, 3, 224, 112, 0, 3416,
		3418, 1, 0, 0, 0, 3417, 3414, 1, 0, 0, 0, 3417, 3418, 1, 0, 0, 0, 3418,
		3424, 1, 0, 0, 0, 3419, 3425, 5, 385, 0, 0, 3420, 3421, 5, 13, 0, 0, 3421,
		3425, 3, 932, 466, 0, 3422, 3423, 5, 735, 0, 0, 3423, 3425, 3, 932, 466,
		0, 3424, 3419, 1, 0, 0, 0, 3424, 3420, 1, 0, 0, 0, 3424, 3422, 1, 0, 0,
		0, 3424, 3425, 1, 0, 0, 0, 3425, 3427, 1, 0, 0, 0, 3426, 3387, 1, 0, 0,
		0, 3426, 3401, 1, 0, 0, 0, 3427, 221, 1, 0, 0, 0, 3428, 3429, 6, 111, -1,
		0, 3429, 3430, 3, 948, 474, 0, 3430, 3435, 1, 0, 0, 0, 3431, 3432, 10,
		2, 0, 0, 3432, 3434, 3, 224, 112, 0, 3433, 3431, 1, 0, 0, 0, 3434, 3437,
		1, 0, 0, 0, 3435, 3433, 1, 0, 0, 0, 3435, 3436, 1, 0, 0, 0, 3436, 223,
		1, 0, 0, 0, 3437, 3435, 1, 0, 0, 0, 3438, 3439, 5, 269, 0, 0, 3439, 3453,
		5, 270, 0, 0, 3440, 3453, 5, 270, 0, 0, 3441, 3442, 5, 228, 0, 0, 3442,
		3453, 5, 116, 0, 0, 3443, 3445, 5, 168, 0, 0, 3444, 3443, 1, 0, 0, 0, 3444,
		3445, 1, 0, 0, 0, 3445, 3446, 1, 0, 0, 0, 3446, 3453, 5, 116, 0, 0, 3447,
		3453, 5, 228, 0, 0, 3448, 3449, 5, 369, 0, 0, 3449, 3453, 5, 923, 0, 0,
		3450, 3451, 5, 92, 0, 0, 3451, 3453, 5, 271, 0, 0, 3452, 3438, 1, 0, 0,
		0, 3452, 3440, 1, 0, 0, 0, 3452, 3441, 1, 0, 0, 0, 3452, 3444, 1, 0, 0,
		0, 3452, 3447, 1, 0, 0, 0, 3452, 3448, 1, 0, 0, 0, 3452, 3450, 1, 0, 0,
		0, 3453, 225, 1, 0, 0, 0, 3454, 3466, 3, 932, 466, 0, 3455, 3456, 3, 934,
		467, 0, 3456, 3457, 5, 901, 0, 0, 3457, 3458, 3, 932, 466, 0, 3458, 3466,
		1, 0, 0, 0, 3459, 3460, 3, 934, 467, 0, 3460, 3461, 5, 901, 0, 0, 3461,
		3462, 3, 934, 467, 0, 3462, 3463, 5, 901, 0, 0, 3463, 3464, 3, 932, 466,
		0, 3464, 3466, 1, 0, 0, 0, 3465, 3454, 1, 0, 0, 0, 3465, 3455, 1, 0, 0,
		0, 3465, 3459, 1, 0, 0, 0, 3466, 227, 1, 0, 0, 0, 3467, 3472, 3, 220, 110,
		0, 3468, 3469, 5, 890, 0, 0, 3469, 3471, 3, 220, 110, 0, 3470, 3468, 1,
		0, 0, 0, 3471, 3474, 1, 0, 0, 0, 3472, 3470, 1, 0, 0, 0, 3472, 3473, 1,
		0, 0, 0, 3473, 229, 1, 0, 0, 0, 3474, 3472, 1, 0, 0, 0, 3475, 3477, 5,
		15, 0, 0, 3476, 3478, 3, 252, 126, 0, 3477, 3476, 1, 0, 0, 0, 3477, 3478,
		1, 0, 0, 0, 3478, 3524, 1, 0, 0, 0, 3479, 3481, 5, 24, 0, 0, 3480, 3482,
		3, 252, 126, 0, 3481, 3480, 1, 0, 0, 0, 3481, 3482, 1, 0, 0, 0, 3482, 3484,
		1, 0, 0, 0, 3483, 3485, 5, 15, 0, 0, 3484, 3483, 1, 0, 0, 0, 3484, 3485,
		1, 0, 0, 0, 3485, 3524, 1, 0, 0, 0, 3486, 3490, 3, 232, 116, 0, 3487, 3488,
		5, 896, 0, 0, 3488, 3489, 5, 271, 0, 0, 3489, 3491, 5, 903, 0, 0, 3490,
		3487, 1, 0, 0, 0, 3490, 3491, 1, 0, 0, 0, 3491, 3524, 1, 0, 0, 0, 3492,
		3501, 5, 49, 0, 0, 3493, 3494, 5, 896, 0, 0, 3494, 3495, 5, 271, 0, 0,
		3495, 3496, 5, 890, 0, 0, 3496, 3497, 5, 271, 0, 0, 3497, 3502, 5, 903,
		0, 0, 3498, 3499, 5, 896, 0, 0, 3499, 3500, 5, 271, 0, 0, 3500, 3502, 5,
		903, 0, 0, 3501, 3493, 1, 0, 0, 0, 3501, 3498, 1, 0, 0, 0, 3501, 3502,
		1, 0, 0, 0, 3502, 3524, 1, 0, 0, 0, 3503, 3512, 5, 50, 0, 0, 3504, 3505,
		5, 896, 0, 0, 3505, 3506, 5, 271, 0, 0, 3506, 3507, 5, 890, 0, 0, 3507,
		3508, 5, 271, 0, 0, 3508, 3513, 5, 903, 0, 0, 3509, 3510, 5, 896, 0, 0,
		3510, 3511, 5, 271, 0, 0, 3511, 3513, 5, 903, 0, 0, 3512, 3504, 1, 0, 0,
		0, 3512, 3509, 1, 0, 0, 0, 3512, 3513, 1, 0, 0, 0, 3513, 3524, 1, 0, 0,
		0, 3514, 3516, 5, 493, 0, 0, 3515, 3517, 5, 101, 0, 0, 3516, 3515, 1, 0,
		0, 0, 3516, 3517, 1, 0, 0, 0, 3517, 3524, 1, 0, 0, 0, 3518, 3520, 5, 230,
		0, 0, 3519, 3521, 5, 101, 0, 0, 3520, 3519, 1, 0, 0, 0, 3520, 3521, 1,
		0, 0, 0, 3521, 3524, 1, 0, 0, 0, 3522, 3524, 5, 61, 0, 0, 3523, 3475, 1,
		0, 0, 0, 3523, 3479, 1, 0, 0, 0, 3523, 3486, 1, 0, 0, 0, 3523, 3492, 1,
		0, 0, 0, 3523, 3503, 1, 0, 0, 0, 3523, 3514, 1, 0, 0, 0, 3523, 3518, 1,
		0, 0, 0, 3523, 3522, 1, 0, 0, 0, 3524, 231, 1, 0, 0, 0, 3525, 3526, 7,
		21, 0, 0, 3526, 233, 1, 0, 0, 0, 3527, 3531, 3, 240, 120, 0, 3528, 3529,
		5, 896, 0, 0, 3529, 3530, 5, 271, 0, 0, 3530, 3532, 5, 903, 0, 0, 3531,
		3528, 1, 0, 0, 0, 3531, 3532, 1, 0, 0, 0, 3532, 3534, 1, 0, 0, 0, 3533,
		3535, 7, 22, 0, 0, 3534, 3533, 1, 0, 0, 0, 3534, 3535, 1, 0, 0, 0, 3535,
		3537, 1, 0, 0, 0, 3536, 3538, 5, 252, 0, 0, 3537, 3536, 1, 0, 0, 0, 3537,
		3538, 1, 0, 0, 0, 3538, 3690, 1, 0, 0, 0, 3539, 3548, 3, 242, 121, 0, 3540,
		3541, 5, 896, 0, 0, 3541, 3542, 5, 271, 0, 0, 3542, 3543, 5, 890, 0, 0,
		3543, 3544, 5, 271, 0, 0, 3544, 3549, 5, 903, 0, 0, 3545, 3546, 5, 896,
		0, 0, 3546, 3547, 5, 271, 0, 0, 3547, 3549, 5, 903, 0, 0, 3548, 3540, 1,
		0, 0, 0, 3548, 3545, 1, 0, 0, 0, 3548, 3549, 1, 0, 0, 0, 3549, 3551, 1,
		0, 0, 0, 3550, 3552, 7, 22, 0, 0, 3551, 3550, 1, 0, 0, 0, 3551, 3552, 1,
		0, 0, 0, 3552, 3554, 1, 0, 0, 0, 3553, 3555, 5, 252, 0, 0, 3554, 3553,
		1, 0, 0, 0, 3554, 3555, 1, 0, 0, 0, 3555, 3690, 1, 0, 0, 0, 3556, 3565,
		5, 49, 0, 0, 3557, 3558, 5, 896, 0, 0, 3558, 3559, 5, 271, 0, 0, 3559,
		3560, 5, 890, 0, 0, 3560, 3561, 5, 271, 0, 0, 3561, 3566, 5, 903, 0, 0,
		3562, 3563, 5, 896, 0, 0, 3563, 3564, 5, 271, 0, 0, 3564, 3566, 5, 903,
		0, 0, 3565, 3557, 1, 0, 0, 0, 3565, 3562, 1, 0, 0, 0, 3565, 3566, 1, 0,
		0, 0, 3566, 3568, 1, 0, 0, 0, 3567, 3569, 7, 22, 0, 0, 3568, 3567, 1, 0,
		0, 0, 3568, 3569, 1, 0, 0, 0, 3569, 3571, 1, 0, 0, 0, 3570, 3572, 5, 252,
		0, 0, 3571, 3570, 1, 0, 0, 0, 3571, 3572, 1, 0, 0, 0, 3572, 3690, 1, 0,
		0, 0, 3573, 3582, 5, 50, 0, 0, 3574, 3575, 5, 896, 0, 0, 3575, 3576, 5,
		271, 0, 0, 3576, 3577, 5, 890, 0, 0, 3577, 3578, 5, 271, 0, 0, 3578, 3583,
		5, 903, 0, 0, 3579, 3580, 5, 896, 0, 0, 3580, 3581, 5, 271, 0, 0, 3581,
		3583, 5, 903, 0, 0, 3582, 3574, 1, 0, 0, 0, 3582, 3579, 1, 0, 0, 0, 3582,
		3583, 1, 0, 0, 0, 3583, 3585, 1, 0, 0, 0, 3584, 3586, 7, 22, 0, 0, 3585,
		3584, 1, 0, 0, 0, 3585, 3586, 1, 0, 0, 0, 3586, 3588, 1, 0, 0, 0, 3587,
		3589, 5, 252, 0, 0, 3588, 3587, 1, 0, 0, 0, 3588, 3589, 1, 0, 0, 0, 3589,
		3690, 1, 0, 0, 0, 3590, 3690, 5, 507, 0, 0, 3591, 3690, 5, 778, 0, 0, 3592,
		3596, 3, 244, 122, 0, 3593, 3594, 5, 896, 0, 0, 3594, 3595, 5, 271, 0,
		0, 3595, 3597, 5, 903, 0, 0, 3596, 3593, 1, 0, 0, 0, 3596, 3597, 1, 0,
		0, 0, 3597, 3690, 1, 0, 0, 0, 3598, 3690, 3, 246, 123, 0, 3599, 3601, 5,
		24, 0, 0, 3600, 3602, 3, 252, 126, 0, 3601, 3600, 1, 0, 0, 0, 3601, 3602,
		1, 0, 0, 0, 3602, 3604, 1, 0, 0, 0, 3603, 3605, 5, 15, 0, 0, 3604, 3603,
		1, 0, 0, 0, 3604, 3605, 1, 0, 0, 0, 3605, 3609, 1, 0, 0, 0, 3606, 3607,
		3, 162, 81, 0, 3607, 3608, 3, 260, 130, 0, 3608, 3610, 1, 0, 0, 0, 3609,
		3606, 1, 0, 0, 0, 3609, 3610, 1, 0, 0, 0, 3610, 3612, 1, 0, 0, 0, 3611,
		3613, 3, 264, 132, 0, 3612, 3611, 1, 0, 0, 0, 3612, 3613, 1, 0, 0, 0, 3613,
		3690, 1, 0, 0, 0, 3614, 3615, 5, 240, 0, 0, 3615, 3617, 3, 252, 126, 0,
		3616, 3618, 5, 15, 0, 0, 3617, 3616, 1, 0, 0, 0, 3617, 3618, 1, 0, 0, 0,
		3618, 3622, 1, 0, 0, 0, 3619, 3620, 3, 162, 81, 0, 3620, 3621, 3, 260,
		130, 0, 3621, 3623, 1, 0, 0, 0, 3622, 3619, 1, 0, 0, 0, 3622, 3623, 1,
		0, 0, 0, 3623, 3625, 1, 0, 0, 0, 3624, 3626, 3, 264, 132, 0, 3625, 3624,
		1, 0, 0, 0, 3625, 3626, 1, 0, 0, 0, 3626, 3690, 1, 0, 0, 0, 3627, 3629,
		3, 250, 125, 0, 3628, 3630, 3, 252, 126, 0, 3629, 3628, 1, 0, 0, 0, 3629,
		3630, 1, 0, 0, 0, 3630, 3690, 1, 0, 0, 0, 3631, 3633, 3, 248, 124, 0, 3632,
		3634, 3, 252, 126, 0, 3633, 3632, 1, 0, 0, 0, 3633, 3634, 1, 0, 0, 0, 3634,
		3636, 1, 0, 0, 0, 3635, 3637, 5, 15, 0, 0, 3636, 3635, 1, 0, 0, 0, 3636,
		3637, 1, 0, 0, 0, 3637, 3641, 1, 0, 0, 0, 3638, 3639, 3, 162, 81, 0, 3639,
		3640, 3, 260, 130, 0, 3640, 3642, 1, 0, 0, 0, 3641, 3638, 1, 0, 0, 0, 3641,
		3642, 1, 0, 0, 0, 3642, 3644, 1, 0, 0, 0, 3643, 3645, 3, 264, 132, 0, 3644,
		3643, 1, 0, 0, 0, 3644, 3645, 1, 0, 0, 0, 3645, 3690, 1, 0, 0, 0, 3646,
		3648, 5, 15, 0, 0, 3647, 3649, 3, 252, 126, 0, 3648, 3647, 1, 0, 0, 0,
		3648, 3649, 1, 0, 0, 0, 3649, 3690, 1, 0, 0, 0, 3650, 3651, 5, 239, 0,
		0, 3651, 3690, 3, 252, 126, 0, 3652, 3690, 5, 923, 0, 0, 3653, 3657, 5,
		329, 0, 0, 3654, 3655, 5, 896, 0, 0, 3655, 3656, 5, 271, 0, 0, 3656, 3658,
		5, 903, 0, 0, 3657, 3654, 1, 0, 0, 0, 3657, 3658, 1, 0, 0, 0, 3658, 3690,
		1, 0, 0, 0, 3659, 3660, 5, 661, 0, 0, 3660, 3661, 5, 896, 0, 0, 3661, 3662,
		3, 236, 118, 0, 3662, 3664, 5, 903, 0, 0, 3663, 3665, 5, 15, 0, 0, 3664,
		3663, 1, 0, 0, 0, 3664, 3665, 1, 0, 0, 0, 3665, 3669, 1, 0, 0, 0, 3666,
		3667, 3, 162, 81, 0, 3667, 3668, 3, 260, 130, 0, 3668, 3670, 1, 0, 0, 0,
		3669, 3666, 1, 0, 0, 0, 3669, 3670, 1, 0, 0, 0, 3670, 3672, 1, 0, 0, 0,
		3671, 3673, 3, 264, 132, 0, 3672, 3671, 1, 0, 0, 0, 3672, 3673, 1, 0, 0,
		0, 3673, 3690, 1, 0, 0, 0, 3674, 3675, 5, 193, 0, 0, 3675, 3676, 5, 896,
		0, 0, 3676, 3677, 3, 236, 118, 0, 3677, 3679, 5, 903, 0, 0, 3678, 3680,
		5, 15, 0, 0, 3679, 3678, 1, 0, 0, 0, 3679, 3680, 1, 0, 0, 0, 3680, 3684,
		1, 0, 0, 0, 3681, 3682, 3, 162, 81, 0, 3682, 3683, 3, 260, 130, 0, 3683,
		3685, 1, 0, 0, 0, 3684, 3681, 1, 0, 0, 0, 3684, 3685, 1, 0, 0, 0, 3685,
		3687, 1, 0, 0, 0, 3686, 3688, 3, 264, 132, 0, 3687, 3686, 1, 0, 0, 0, 3687,
		3688, 1, 0, 0, 0, 3688, 3690, 1, 0, 0, 0, 3689, 3527, 1, 0, 0, 0, 3689,
		3539, 1, 0, 0, 0, 3689, 3556, 1, 0, 0, 0, 3689, 3573, 1, 0, 0, 0, 3689,
		3590, 1, 0, 0, 0, 3689, 3591, 1, 0, 0, 0, 3689, 3592, 1, 0, 0, 0, 3689,
		3598, 1, 0, 0, 0, 3689, 3599, 1, 0, 0, 0, 3689, 3614, 1, 0, 0, 0, 3689,
		3627, 1, 0, 0, 0, 3689, 3631, 1, 0, 0, 0, 3689, 3646, 1, 0, 0, 0, 3689,
		3650, 1, 0, 0, 0, 3689, 3652, 1, 0, 0, 0, 3689, 3653, 1, 0, 0, 0, 3689,
		3659, 1, 0, 0, 0, 3689, 3674, 1, 0, 0, 0, 3690, 235, 1, 0, 0, 0, 3691,
		3696, 3, 238, 119, 0, 3692, 3693, 5, 890, 0, 0, 3693, 3695, 3, 238, 119,
		0, 3694, 3692, 1, 0, 0, 0, 3695, 3698, 1, 0, 0, 0, 3696, 3694, 1, 0, 0,
		0, 3696, 3697, 1, 0, 0, 0, 3697, 237, 1, 0, 0, 0, 3698, 3696, 1, 0, 0,
		0, 3699, 3700, 7, 23, 0, 0, 3700, 239, 1, 0, 0, 0, 3701, 3702, 7, 24, 0,
		0, 3702, 241, 1, 0, 0, 0, 3703, 3711, 5, 75, 0, 0, 3704, 3711, 5, 61, 0,
		0, 3705, 3711, 5, 174, 0, 0, 3706, 3707, 5, 61, 0, 0, 3707, 3711, 5, 167,
		0, 0, 3708, 3709, 5, 174, 0, 0, 3709, 3711, 5, 167, 0, 0, 3710, 3703, 1,
		0, 0, 0, 3710, 3704, 1, 0, 0, 0, 3710, 3705, 1, 0, 0, 0, 3710, 3706, 1,
		0, 0, 0, 3710, 3708, 1, 0, 0, 0, 3711, 243, 1, 0, 0, 0, 3712, 3713, 7,
		25, 0, 0, 3713, 245, 1, 0, 0, 0, 3714, 3722, 5, 863, 0, 0, 3715, 3719,
		5, 278, 0, 0, 3716, 3717, 5, 896, 0, 0, 3717, 3718, 5, 271, 0, 0, 3718,
		3720, 5, 903, 0, 0, 3719, 3716, 1, 0, 0, 0, 3719, 3720, 1, 0, 0, 0, 3720,
		3722, 1, 0, 0, 0, 3721, 3714, 1, 0, 0, 0, 3721, 3715, 1, 0, 0, 0, 3722,
		247, 1, 0, 0, 0, 3723, 3724, 7, 26, 0, 0, 3724, 249, 1, 0, 0, 0, 3725,
		3726, 7, 27, 0, 0, 3726, 251, 1, 0, 0, 0, 3727, 3728, 5, 896, 0, 0, 3728,
		3729, 3, 20, 10, 0, 3729, 3730, 5, 903, 0, 0, 3730, 253, 1, 0, 0, 0, 3731,
		3732, 7, 28, 0, 0, 3732, 255, 1, 0, 0, 0, 3733, 3734, 5, 886, 0, 0, 3734,
		3735, 5, 923, 0, 0, 3735, 3736, 5, 886, 0, 0, 3736, 257, 1, 0, 0, 0, 3737,
		3738, 5, 886, 0, 0, 3738, 3739, 5, 923, 0, 0, 3739, 3742, 5, 886, 0, 0,
		3740, 3742, 5, 271, 0, 0, 3741, 3737, 1, 0, 0, 0, 3741, 3740, 1, 0, 0,
		0, 3742, 259, 1, 0, 0, 0, 3743, 3744, 7, 29, 0, 0, 3744, 261, 1, 0, 0,
		0, 3745, 3748, 3, 260, 130, 0, 3746, 3748, 5, 52, 0, 0, 3747, 3745, 1,
		0, 0, 0, 3747, 3746, 1, 0, 0, 0, 3748, 263, 1, 0, 0, 0, 3749, 3750, 5,
		31, 0, 0, 3750, 3751, 3, 254, 127, 0, 3751, 265, 1, 0, 0, 0, 3752, 3753,
		6, 133, -1, 0, 3753, 3754, 3, 948, 474, 0, 3754, 3759, 1, 0, 0, 0, 3755,
		3756, 10, 2, 0, 0, 3756, 3758, 3, 268, 134, 0, 3757, 3755, 1, 0, 0, 0,
		3758, 3761, 1, 0, 0, 0, 3759, 3757, 1, 0, 0, 0, 3759, 3760, 1, 0, 0, 0,
		3760, 267, 1, 0, 0, 0, 3761, 3759, 1, 0, 0, 0, 3762, 3763, 3, 38, 19, 0,
		3763, 3764, 5, 270, 0, 0, 3764, 3786, 1, 0, 0, 0, 3765, 3786, 5, 270, 0,
		0, 3766, 3767, 5, 52, 0, 0, 3767, 3786, 3, 270, 135, 0, 3768, 3769, 5,
		458, 0, 0, 3769, 3786, 3, 270, 135, 0, 3770, 3786, 5, 689, 0, 0, 3771,
		3772, 5, 228, 0, 0, 3772, 3786, 5, 116, 0, 0, 3773, 3775, 5, 168, 0, 0,
		3774, 3773, 1, 0, 0, 0, 3774, 3775, 1, 0, 0, 0, 3775, 3776, 1, 0, 0, 0,
		3776, 3786, 5, 116, 0, 0, 3777, 3786, 5, 228, 0, 0, 3778, 3779, 5, 369,
		0, 0, 3779, 3786, 5, 923, 0, 0, 3780, 3781, 5, 154, 0, 0, 3781, 3782, 5,
		231, 0, 0, 3782, 3786, 3, 94, 47, 0, 3783, 3784, 5, 92, 0, 0, 3784, 3786,
		5, 271, 0, 0, 3785, 3762, 1, 0, 0, 0, 3785, 3765, 1, 0, 0, 0, 3785, 3766,
		1, 0, 0, 0, 3785, 3768, 1, 0, 0, 0, 3785, 3770, 1, 0, 0, 0, 3785, 3771,
		1, 0, 0, 0, 3785, 3774, 1, 0, 0, 0, 3785, 3777, 1, 0, 0, 0, 3785, 3778,
		1, 0, 0, 0, 3785, 3780, 1, 0, 0, 0, 3785, 3783, 1, 0, 0, 0, 3786, 269,
		1, 0, 0, 0, 3787, 3790, 3, 94, 47, 0, 3788, 3790, 3, 272, 136, 0, 3789,
		3787, 1, 0, 0, 0, 3789, 3788, 1, 0, 0, 0, 3790, 271, 1, 0, 0, 0, 3791,
		3797, 3, 18, 9, 0, 3792, 3793, 5, 891, 0, 0, 3793, 3797, 3, 20, 10, 0,
		3794, 3795, 5, 897, 0, 0, 3795, 3797, 3, 20, 10, 0, 3796, 3791, 1, 0, 0,
		0, 3796, 3792, 1, 0, 0, 0, 3796, 3794, 1, 0, 0, 0, 3797, 273, 1, 0, 0,
		0, 3798, 3800, 5, 890, 0, 0, 3799, 3798, 1, 0, 0, 0, 3799, 3800, 1, 0,
		0, 0, 3800, 275, 1, 0, 0, 0, 3801, 3806, 3, 286, 143, 0, 3802, 3803, 3,
		286, 143, 0, 3803, 3804, 3, 276, 138, 0, 3804, 3806, 1, 0, 0, 0, 3805,
		3801, 1, 0, 0, 0, 3805, 3802, 1, 0, 0, 0, 3806, 277, 1, 0, 0, 0, 3807,
		3813, 3, 276, 138, 0, 3808, 3809, 3, 286, 143, 0, 3809, 3810, 5, 890, 0,
		0, 3810, 3811, 3, 278, 139, 0, 3811, 3813, 1, 0, 0, 0, 3812, 3807, 1, 0,
		0, 0, 3812, 3808, 1, 0, 0, 0, 3813, 279, 1, 0, 0, 0, 3814, 3818, 5, 52,
		0, 0, 3815, 3818, 5, 830, 0, 0, 3816, 3818, 3, 288, 144, 0, 3817, 3814,
		1, 0, 0, 0, 3817, 3815, 1, 0, 0, 0, 3817, 3816, 1, 0, 0, 0, 3818, 281,
		1, 0, 0, 0, 3819, 3820, 5, 921, 0, 0, 3820, 283, 1, 0, 0, 0, 3821, 3822,
		7, 30, 0, 0, 3822, 285, 1, 0, 0, 0, 3823, 3825, 5, 832, 0, 0, 3824, 3826,
		5, 908, 0, 0, 3825, 3824, 1, 0, 0, 0, 3825, 3826, 1, 0, 0, 0, 3826, 3827,
		1, 0, 0, 0, 3827, 3950, 5, 923, 0, 0, 3828, 3830, 5, 784, 0, 0, 3829, 3831,
		5, 908, 0, 0, 3830, 3829, 1, 0, 0, 0, 3830, 3831, 1, 0, 0, 0, 3831, 3832,
		1, 0, 0, 0, 3832, 3950, 5, 923, 0, 0, 3833, 3835, 5, 476, 0, 0, 3834, 3836,
		5, 908, 0, 0, 3835, 3834, 1, 0, 0, 0, 3835, 3836, 1, 0, 0, 0, 3836, 3837,
		1, 0, 0, 0, 3837, 3839, 3, 284, 142, 0, 3838, 3840, 5, 79, 0, 0, 3839,
		3838, 1, 0, 0, 0, 3839, 3840, 1, 0, 0, 0, 3840, 3950, 1, 0, 0, 0, 3841,
		3843, 5, 558, 0, 0, 3842, 3844, 5, 908, 0, 0, 3843, 3842, 1, 0, 0, 0, 3843,
		3844, 1, 0, 0, 0, 3844, 3845, 1, 0, 0, 0, 3845, 3846, 5, 896, 0, 0, 3846,
		3847, 3, 36, 18, 0, 3847, 3848, 5, 903, 0, 0, 3848, 3950, 1, 0, 0, 0, 3849,
		3851, 5, 293, 0, 0, 3850, 3852, 5, 908, 0, 0, 3851, 3850, 1, 0, 0, 0, 3851,
		3852, 1, 0, 0, 0, 3852, 3853, 1, 0, 0, 0, 3853, 3950, 5, 271, 0, 0, 3854,
		3856, 5, 565, 0, 0, 3855, 3857, 5, 908, 0, 0, 3856, 3855, 1, 0, 0, 0, 3856,
		3857, 1, 0, 0, 0, 3857, 3858, 1, 0, 0, 0, 3858, 3950, 5, 271, 0, 0, 3859,
		3861, 5, 439, 0, 0, 3860, 3862, 5, 908, 0, 0, 3861, 3860, 1, 0, 0, 0, 3861,
		3862, 1, 0, 0, 0, 3862, 3863, 1, 0, 0, 0, 3863, 3950, 5, 271, 0, 0, 3864,
		3866, 5, 748, 0, 0, 3865, 3867, 5, 908, 0, 0, 3866, 3865, 1, 0, 0, 0, 3866,
		3867, 1, 0, 0, 0, 3867, 3868, 1, 0, 0, 0, 3868, 3950, 5, 271, 0, 0, 3869,
		3871, 5, 328, 0, 0, 3870, 3872, 5, 908, 0, 0, 3871, 3870, 1, 0, 0, 0, 3871,
		3872, 1, 0, 0, 0, 3872, 3873, 1, 0, 0, 0, 3873, 3950, 5, 923, 0, 0, 3874,
		3876, 5, 692, 0, 0, 3875, 3877, 5, 908, 0, 0, 3876, 3875, 1, 0, 0, 0, 3876,
		3877, 1, 0, 0, 0, 3877, 3878, 1, 0, 0, 0, 3878, 3950, 3, 362, 181, 0, 3879,
		3881, 5, 642, 0, 0, 3880, 3882, 5, 908, 0, 0, 3881, 3880, 1, 0, 0, 0, 3881,
		3882, 1, 0, 0, 0, 3882, 3883, 1, 0, 0, 0, 3883, 3950, 5, 271, 0, 0, 3884,
		3886, 5, 517, 0, 0, 3885, 3887, 5, 908, 0, 0, 3886, 3885, 1, 0, 0, 0, 3886,
		3887, 1, 0, 0, 0, 3887, 3888, 1, 0, 0, 0, 3888, 3950, 5, 884, 0, 0, 3889,
		3891, 5, 52, 0, 0, 3890, 3889, 1, 0, 0, 0, 3890, 3891, 1, 0, 0, 0, 3891,
		3892, 1, 0, 0, 0, 3892, 3894, 3, 162, 81, 0, 3893, 3895, 5, 908, 0, 0,
		3894, 3893, 1, 0, 0, 0, 3894, 3895, 1, 0, 0, 0, 3895, 3896, 1, 0, 0, 0,
		3896, 3897, 3, 260, 130, 0, 3897, 3950, 1, 0, 0, 0, 3898, 3900, 5, 52,
		0, 0, 3899, 3898, 1, 0, 0, 0, 3899, 3900, 1, 0, 0, 0, 3900, 3901, 1, 0,
		0, 0, 3901, 3903, 5, 31, 0, 0, 3902, 3904, 5, 908, 0, 0, 3903, 3902, 1,
		0, 0, 0, 3903, 3904, 1, 0, 0, 0, 3904, 3905, 1, 0, 0, 0, 3905, 3950, 3,
		254, 127, 0, 3906, 3908, 5, 369, 0, 0, 3907, 3909, 5, 908, 0, 0, 3908,
		3907, 1, 0, 0, 0, 3908, 3909, 1, 0, 0, 0, 3909, 3910, 1, 0, 0, 0, 3910,
		3950, 5, 923, 0, 0, 3911, 3913, 5, 773, 0, 0, 3912, 3914, 5, 908, 0, 0,
		3913, 3912, 1, 0, 0, 0, 3913, 3914, 1, 0, 0, 0, 3914, 3915, 1, 0, 0, 0,
		3915, 3950, 3, 280, 140, 0, 3916, 3918, 5, 221, 0, 0, 3917, 3919, 5, 908,
		0, 0, 3918, 3917, 1, 0, 0, 0, 3918, 3919, 1, 0, 0, 0, 3919, 3920, 1, 0,
		0, 0, 3920, 3950, 3, 288, 144, 0, 3921, 3923, 5, 689, 0, 0, 3922, 3924,
		5, 908, 0, 0, 3923, 3922, 1, 0, 0, 0, 3923, 3924, 1, 0, 0, 0, 3924, 3925,
		1, 0, 0, 0, 3925, 3950, 3, 350, 175, 0, 3926, 3950, 3, 166, 83, 0, 3927,
		3929, 5, 388, 0, 0, 3928, 3930, 5, 908, 0, 0, 3929, 3928, 1, 0, 0, 0, 3929,
		3930, 1, 0, 0, 0, 3930, 3931, 1, 0, 0, 0, 3931, 3950, 3, 288, 144, 0, 3932,
		3934, 5, 786, 0, 0, 3933, 3935, 5, 908, 0, 0, 3934, 3933, 1, 0, 0, 0, 3934,
		3935, 1, 0, 0, 0, 3935, 3936, 1, 0, 0, 0, 3936, 3950, 5, 271, 0, 0, 3937,
		3939, 5, 700, 0, 0, 3938, 3940, 5, 908, 0, 0, 3939, 3938, 1, 0, 0, 0, 3939,
		3940, 1, 0, 0, 0, 3940, 3941, 1, 0, 0, 0, 3941, 3950, 5, 271, 0, 0, 3942,
		3944, 5, 525, 0, 0, 3943, 3945, 5, 908, 0, 0, 3944, 3943, 1, 0, 0, 0, 3944,
		3945, 1, 0, 0, 0, 3945, 3946, 1, 0, 0, 0, 3946, 3950, 5, 271, 0, 0, 3947,
		3948, 5, 702, 0, 0, 3948, 3950, 3, 282, 141, 0, 3949, 3823, 1, 0, 0, 0,
		3949, 3828, 1, 0, 0, 0, 3949, 3833, 1, 0, 0, 0, 3949, 3841, 1, 0, 0, 0,
		3949, 3849, 1, 0, 0, 0, 3949, 3854, 1, 0, 0, 0, 3949, 3859, 1, 0, 0, 0,
		3949, 3864, 1, 0, 0, 0, 3949, 3869, 1, 0, 0, 0, 3949, 3874, 1, 0, 0, 0,
		3949, 3879, 1, 0, 0, 0, 3949, 3884, 1, 0, 0, 0, 3949, 3890, 1, 0, 0, 0,
		3949, 3899, 1, 0, 0, 0, 3949, 3906, 1, 0, 0, 0, 3949, 3911, 1, 0, 0, 0,
		3949, 3916, 1, 0, 0, 0, 3949, 3921, 1, 0, 0, 0, 3949, 3926, 1, 0, 0, 0,
		3949, 3927, 1, 0, 0, 0, 3949, 3932, 1, 0, 0, 0, 3949, 3937, 1, 0, 0, 0,
		3949, 3942, 1, 0, 0, 0, 3949, 3947, 1, 0, 0, 0, 3950, 287, 1, 0, 0, 0,
		3951, 3955, 3, 934, 467, 0, 3952, 3955, 5, 923, 0, 0, 3953, 3955, 5, 8,
		0, 0, 3954, 3951, 1, 0, 0, 0, 3954, 3952, 1, 0, 0, 0, 3954, 3953, 1, 0,
		0, 0, 3955, 289, 1, 0, 0, 0, 3956, 3958, 5, 908, 0, 0, 3957, 3956, 1, 0,
		0, 0, 3957, 3958, 1, 0, 0, 0, 3958, 291, 1, 0, 0, 0, 3959, 3964, 3, 296,
		148, 0, 3960, 3964, 3, 300, 150, 0, 3961, 3964, 3, 302, 151, 0, 3962, 3964,
		3, 298, 149, 0, 3963, 3959, 1, 0, 0, 0, 3963, 3960, 1, 0, 0, 0, 3963, 3961,
		1, 0, 0, 0, 3963, 3962, 1, 0, 0, 0, 3964, 293, 1, 0, 0, 0, 3965, 3966,
		3, 292, 146, 0, 3966, 3967, 3, 304, 152, 0, 3967, 3970, 1, 0, 0, 0, 3968,
		3970, 3, 304, 152, 0, 3969, 3965, 1, 0, 0, 0, 3969, 3968, 1, 0, 0, 0, 3970,
		295, 1, 0, 0, 0, 3971, 3972, 5, 166, 0, 0, 3972, 3973, 5, 19, 0, 0, 3973,
		3974, 5, 359, 0, 0, 3974, 3975, 5, 896, 0, 0, 3975, 3976, 3, 36, 18, 0,
		3976, 3977, 5, 903, 0, 0, 3977, 3980, 3, 314, 157, 0, 3978, 3979, 5, 408,
		0, 0, 3979, 3981, 5, 271, 0, 0, 3980, 3978, 1, 0, 0, 0, 3980, 3981, 1,
		0, 0, 0, 3981, 297, 1, 0, 0, 0, 3982, 3983, 5, 166, 0, 0, 3983, 3984, 5,
		19, 0, 0, 3984, 3985, 5, 127, 0, 0, 3985, 3986, 5, 896, 0, 0, 3986, 3987,
		3, 36, 18, 0, 3987, 3988, 5, 903, 0, 0, 3988, 3991, 3, 314, 157, 0, 3989,
		3990, 5, 408, 0, 0, 3990, 3992, 5, 271, 0, 0, 3991, 3989, 1, 0, 0, 0, 3991,
		3992, 1, 0, 0, 0, 3992, 3993, 1, 0, 0, 0, 3993, 3994, 3, 316, 158, 0, 3994,
		4010, 1, 0, 0, 0, 3995, 3996, 5, 166, 0, 0, 3996, 3997, 5, 19, 0, 0, 3997,
		3998, 5, 127, 0, 0, 3998, 3999, 5, 33, 0, 0, 3999, 4000, 5, 896, 0, 0,
		4000, 4001, 3, 312, 156, 0, 4001, 4002, 5, 903, 0, 0, 4002, 4005, 3, 314,
		157, 0, 4003, 4004, 5, 408, 0, 0, 4004, 4006, 5, 271, 0, 0, 4005, 4003,
		1, 0, 0, 0, 4005, 4006, 1, 0, 0, 0, 4006, 4007, 1, 0, 0, 0, 4007, 4008,
		3, 316, 158, 0, 4008, 4010, 1, 0, 0, 0, 4009, 3982, 1, 0, 0, 0, 4009, 3995,
		1, 0, 0, 0, 4010, 299, 1, 0, 0, 0, 4011, 4012, 5, 166, 0, 0, 4012, 4013,
		5, 19, 0, 0, 4013, 4014, 5, 116, 0, 0, 4014, 4015, 5, 896, 0, 0, 4015,
		4016, 3, 312, 156, 0, 4016, 4017, 5, 903, 0, 0, 4017, 4020, 3, 314, 157,
		0, 4018, 4019, 5, 408, 0, 0, 4019, 4021, 5, 271, 0, 0, 4020, 4018, 1, 0,
		0, 0, 4020, 4021, 1, 0, 0, 0, 4021, 4033, 1, 0, 0, 0, 4022, 4023, 5, 166,
		0, 0, 4023, 4024, 5, 19, 0, 0, 4024, 4025, 5, 116, 0, 0, 4025, 4026, 5,
		896, 0, 0, 4026, 4027, 5, 903, 0, 0, 4027, 4030, 3, 314, 157, 0, 4028,
		4029, 5, 408, 0, 0, 4029, 4031, 5, 271, 0, 0, 4030, 4028, 1, 0, 0, 0, 4030,
		4031, 1, 0, 0, 0, 4031, 4033, 1, 0, 0, 0, 4032, 4011, 1, 0, 0, 0, 4032,
		4022, 1, 0, 0, 0, 4033, 301, 1, 0, 0, 0, 4034, 4035, 5, 166, 0, 0, 4035,
		4036, 5, 19, 0, 0, 4036, 4037, 5, 170, 0, 0, 4037, 4038, 5, 896, 0, 0,
		4038, 4039, 3, 36, 18, 0, 4039, 4040, 5, 903, 0, 0, 4040, 4043, 3, 314,
		157, 0, 4041, 4042, 5, 408, 0, 0, 4042, 4044, 5, 271, 0, 0, 4043, 4041,
		1, 0, 0, 0, 4043, 4044, 1, 0, 0, 0, 4044, 4045, 1, 0, 0, 0, 4045, 4046,
		3, 320, 160, 0, 4046, 4062, 1, 0, 0, 0, 4047, 4048, 5, 166, 0, 0, 4048,
		4049, 5, 19, 0, 0, 4049, 4050, 5, 170, 0, 0, 4050, 4051, 5, 33, 0, 0, 4051,
		4052, 5, 896, 0, 0, 4052, 4053, 3, 312, 156, 0, 4053, 4054, 5, 903, 0,
		0, 4054, 4057, 3, 314, 157, 0, 4055, 4056, 5, 408, 0, 0, 4056, 4058, 5,
		271, 0, 0, 4057, 4055, 1, 0, 0, 0, 4057, 4058, 1, 0, 0, 0, 4058, 4059,
		1, 0, 0, 0, 4059, 4060, 3, 320, 160, 0, 4060, 4062, 1, 0, 0, 0, 4061, 4034,
		1, 0, 0, 0, 4061, 4047, 1, 0, 0, 0, 4062, 303, 1, 0, 0, 0, 4063, 4065,
		3, 306, 153, 0, 4064, 4063, 1, 0, 0, 0, 4064, 4065, 1, 0, 0, 0, 4065, 305,
		1, 0, 0, 0, 4066, 4067, 5, 166, 0, 0, 4067, 4068, 5, 19, 0, 0, 4068, 4069,
		5, 32, 0, 0, 4069, 4070, 5, 896, 0, 0, 4070, 4071, 3, 310, 155, 0, 4071,
		4072, 5, 903, 0, 0, 4072, 4083, 1, 0, 0, 0, 4073, 4074, 5, 166, 0, 0, 4074,
		4075, 5, 19, 0, 0, 4075, 4076, 5, 32, 0, 0, 4076, 4077, 5, 896, 0, 0, 4077,
		4078, 3, 310, 155, 0, 4078, 4079, 5, 890, 0, 0, 4079, 4080, 3, 308, 154,
		0, 4080, 4081, 5, 903, 0, 0, 4081, 4083, 1, 0, 0, 0, 4082, 4066, 1, 0,
		0, 0, 4082, 4073, 1, 0, 0, 0, 4083, 307, 1, 0, 0, 0, 4084, 4089, 3, 310,
		155, 0, 4085, 4086, 5, 890, 0, 0, 4086, 4088, 3, 310, 155, 0, 4087, 4085,
		1, 0, 0, 0, 4088, 4091, 1, 0, 0, 0, 4089, 4087, 1, 0, 0, 0, 4089, 4090,
		1, 0, 0, 0, 4090, 309, 1, 0, 0, 0, 4091, 4089, 1, 0, 0, 0, 4092, 4098,
		3, 932, 466, 0, 4093, 4094, 5, 896, 0, 0, 4094, 4095, 3, 312, 156, 0, 4095,
		4096, 5, 903, 0, 0, 4096, 4098, 1, 0, 0, 0, 4097, 4092, 1, 0, 0, 0, 4097,
		4093, 1, 0, 0, 0, 4098, 311, 1, 0, 0, 0, 4099, 4104, 3, 932, 466, 0, 4100,
		4101, 5, 890, 0, 0, 4101, 4103, 3, 932, 466, 0, 4102, 4100, 1, 0, 0, 0,
		4103, 4106, 1, 0, 0, 0, 4104, 4102, 1, 0, 0, 0, 4104, 4105, 1, 0, 0, 0,
		4105, 313, 1, 0, 0, 0, 4106, 4104, 1, 0, 0, 0, 4107, 4108, 5, 325, 0, 0,
		4108, 4109, 5, 19, 0, 0, 4109, 4110, 5, 170, 0, 0, 4110, 4111, 5, 896,
		0, 0, 4111, 4112, 3, 36, 18, 0, 4112, 4113, 5, 903, 0, 0, 4113, 4114, 5,
		325, 0, 0, 4114, 4115, 5, 556, 0, 0, 4115, 4116, 3, 322, 161, 0, 4116,
		4171, 1, 0, 0, 0, 4117, 4118, 5, 325, 0, 0, 4118, 4119, 5, 19, 0, 0, 4119,
		4120, 5, 170, 0, 0, 4120, 4121, 5, 33, 0, 0, 4121, 4122, 5, 896, 0, 0,
		4122, 4123, 3, 312, 156, 0, 4123, 4124, 5, 903, 0, 0, 4124, 4125, 5, 325,
		0, 0, 4125, 4126, 5, 556, 0, 0, 4126, 4127, 3, 322, 161, 0, 4127, 4171,
		1, 0, 0, 0, 4128, 4129, 5, 325, 0, 0, 4129, 4130, 5, 19, 0, 0, 4130, 4131,
		5, 359, 0, 0, 4131, 4132, 5, 896, 0, 0, 4132, 4133, 3, 36, 18, 0, 4133,
		4136, 5, 903, 0, 0, 4134, 4135, 5, 596, 0, 0, 4135, 4137, 5, 271, 0, 0,
		4136, 4134, 1, 0, 0, 0, 4136, 4137, 1, 0, 0, 0, 4137, 4171, 1, 0, 0, 0,
		4138, 4139, 5, 325, 0, 0, 4139, 4140, 5, 19, 0, 0, 4140, 4141, 5, 127,
		0, 0, 4141, 4142, 5, 896, 0, 0, 4142, 4143, 3, 36, 18, 0, 4143, 4144, 5,
		903, 0, 0, 4144, 4145, 5, 325, 0, 0, 4145, 4146, 5, 556, 0, 0, 4146, 4147,
		3, 318, 159, 0, 4147, 4171, 1, 0, 0, 0, 4148, 4149, 5, 325, 0, 0, 4149,
		4150, 5, 19, 0, 0, 4150, 4151, 5, 127, 0, 0, 4151, 4152, 5, 33, 0, 0, 4152,
		4153, 5, 896, 0, 0, 4153, 4154, 3, 312, 156, 0, 4154, 4155, 5, 903, 0,
		0, 4155, 4156, 5, 325, 0, 0, 4156, 4157, 5, 556, 0, 0, 4157, 4158, 3, 318,
		159, 0, 4158, 4171, 1, 0, 0, 0, 4159, 4160, 5, 325, 0, 0, 4160, 4161, 5,
		19, 0, 0, 4161, 4162, 5, 116, 0, 0, 4162, 4163, 5, 896, 0, 0, 4163, 4164,
		3, 312, 156, 0, 4164, 4167, 5, 903, 0, 0, 4165, 4166, 5, 596, 0, 0, 4166,
		4168, 5, 271, 0, 0, 4167, 4165, 1, 0, 0, 0, 4167, 4168, 1, 0, 0, 0, 4168,
		4171, 1, 0, 0, 0, 4169, 4171, 3, 948, 474, 0, 4170, 4107, 1, 0, 0, 0, 4170,
		4117, 1, 0, 0, 0, 4170, 4128, 1, 0, 0, 0, 4170, 4138, 1, 0, 0, 0, 4170,
		4148, 1, 0, 0, 0, 4170, 4159, 1, 0, 0, 0, 4170, 4169, 1, 0, 0, 0, 4171,
		315, 1, 0, 0, 0, 4172, 4173, 5, 896, 0, 0, 4173, 4174, 3, 324, 162, 0,
		4174, 4175, 5, 903, 0, 0, 4175, 317, 1, 0, 0, 0, 4176, 4177, 5, 896, 0,
		0, 4177, 4178, 3, 326, 163, 0, 4178, 4179, 5, 903, 0, 0, 4179, 319, 1,
		0, 0, 0, 4180, 4181, 5, 896, 0, 0, 4181, 4182, 3, 336, 168, 0, 4182, 4183,
		5, 903, 0, 0, 4183, 321, 1, 0, 0, 0, 4184, 4185, 5, 896, 0, 0, 4185, 4186,
		3, 342, 171, 0, 4186, 4187, 5, 903, 0, 0, 4187, 323, 1, 0, 0, 0, 4188,
		4193, 3, 330, 165, 0, 4189, 4190, 5, 890, 0, 0, 4190, 4192, 3, 330, 165,
		0, 4191, 4189, 1, 0, 0, 0, 4192, 4195, 1, 0, 0, 0, 4193, 4191, 1, 0, 0,
		0, 4193, 4194, 1, 0, 0, 0, 4194, 325, 1, 0, 0, 0, 4195, 4193, 1, 0, 0,
		0, 4196, 4201, 3, 328, 164, 0, 4197, 4198, 5, 890, 0, 0, 4198, 4200, 3,
		328, 164, 0, 4199, 4197, 1, 0, 0, 0, 4200, 4203, 1, 0, 0, 0, 4201, 4199,
		1, 0, 0, 0, 4201, 4202, 1, 0, 0, 0, 4202, 327, 1, 0, 0, 0, 4203, 4201,
		1, 0, 0, 0, 4204, 4205, 5, 325, 0, 0, 4205, 4206, 3, 584, 292, 0, 4206,
		4207, 5, 238, 0, 0, 4207, 4208, 5, 95, 0, 0, 4208, 4209, 3, 332, 166, 0,
		4209, 329, 1, 0, 0, 0, 4210, 4211, 5, 166, 0, 0, 4211, 4212, 3, 584, 292,
		0, 4212, 4213, 5, 238, 0, 0, 4213, 4214, 5, 95, 0, 0, 4214, 4217, 3, 332,
		166, 0, 4215, 4216, 5, 92, 0, 0, 4216, 4218, 5, 271, 0, 0, 4217, 4215,
		1, 0, 0, 0, 4217, 4218, 1, 0, 0, 0, 4218, 331, 1, 0, 0, 0, 4219, 4220,
		5, 896, 0, 0, 4220, 4221, 3, 334, 167, 0, 4221, 4222, 5, 903, 0, 0, 4222,
		4227, 1, 0, 0, 0, 4223, 4224, 5, 896, 0, 0, 4224, 4225, 5, 52, 0, 0, 4225,
		4227, 5, 903, 0, 0, 4226, 4219, 1, 0, 0, 0, 4226, 4223, 1, 0, 0, 0, 4227,
		333, 1, 0, 0, 0, 4228, 4233, 3, 36, 18, 0, 4229, 4230, 5, 890, 0, 0, 4230,
		4232, 3, 36, 18, 0, 4231, 4229, 1, 0, 0, 0, 4232, 4235, 1, 0, 0, 0, 4233,
		4231, 1, 0, 0, 0, 4233, 4234, 1, 0, 0, 0, 4234, 335, 1, 0, 0, 0, 4235,
		4233, 1, 0, 0, 0, 4236, 4241, 3, 338, 169, 0, 4237, 4238, 5, 890, 0, 0,
		4238, 4240, 3, 338, 169, 0, 4239, 4237, 1, 0, 0, 0, 4240, 4243, 1, 0, 0,
		0, 4241, 4239, 1, 0, 0, 0, 4241, 4242, 1, 0, 0, 0, 4242, 337, 1, 0, 0,
		0, 4243, 4241, 1, 0, 0, 0, 4244, 4245, 5, 166, 0, 0, 4245, 4246, 3, 584,
		292, 0, 4246, 4247, 5, 238, 0, 0, 4247, 4248, 5, 416, 0, 0, 4248, 4249,
		5, 683, 0, 0, 4249, 4252, 3, 344, 172, 0, 4250, 4251, 5, 92, 0, 0, 4251,
		4253, 5, 271, 0, 0, 4252, 4250, 1, 0, 0, 0, 4252, 4253, 1, 0, 0, 0, 4253,
		339, 1, 0, 0, 0, 4254, 4255, 5, 325, 0, 0, 4255, 4256, 3, 584, 292, 0,
		4256, 4257, 5, 238, 0, 0, 4257, 4258, 5, 416, 0, 0, 4258, 4259, 5, 683,
		0, 0, 4259, 4260, 3, 344, 172, 0, 4260, 341, 1, 0, 0, 0, 4261, 4266, 3,
		340, 170, 0, 4262, 4263, 5, 890, 0, 0, 4263, 4265, 3, 340, 170, 0, 4264,
		4262, 1, 0, 0, 0, 4265, 4268, 1, 0, 0, 0, 4266, 4264, 1, 0, 0, 0, 4266,
		4267, 1, 0, 0, 0, 4267, 343, 1, 0, 0, 0, 4268, 4266, 1, 0, 0, 0, 4269,
		4270, 5, 896, 0, 0, 4270, 4271, 3, 346, 173, 0, 4271, 4272, 5, 903, 0,
		0, 4272, 4275, 1, 0, 0, 0, 4273, 4275, 5, 141, 0, 0, 4274, 4269, 1, 0,
		0, 0, 4274, 4273, 1, 0, 0, 0, 4275, 345, 1, 0, 0, 0, 4276, 4281, 3, 348,
		174, 0, 4277, 4278, 5, 890, 0, 0, 4278, 4280, 3, 348, 174, 0, 4279, 4277,
		1, 0, 0, 0, 4280, 4283, 1, 0, 0, 0, 4281, 4279, 1, 0, 0, 0, 4281, 4282,
		1, 0, 0, 0, 4282, 347, 1, 0, 0, 0, 4283, 4281, 1, 0, 0, 0, 4284, 4287,
		3, 36, 18, 0, 4285, 4287, 5, 141, 0, 0, 4286, 4284, 1, 0, 0, 0, 4286, 4285,
		1, 0, 0, 0, 4287, 349, 1, 0, 0, 0, 4288, 4289, 7, 1, 0, 0, 4289, 351, 1,
		0, 0, 0, 4290, 4291, 5, 166, 0, 0, 4291, 4292, 5, 19, 0, 0, 4292, 4293,
		5, 359, 0, 0, 4293, 4296, 3, 360, 180, 0, 4294, 4295, 5, 408, 0, 0, 4295,
		4297, 5, 271, 0, 0, 4296, 4294, 1, 0, 0, 0, 4296, 4297, 1, 0, 0, 0, 4297,
		353, 1, 0, 0, 0, 4298, 4299, 5, 166, 0, 0, 4299, 4300, 5, 19, 0, 0, 4300,
		4301, 5, 116, 0, 0, 4301, 4302, 5, 271, 0, 0, 4302, 4305, 3, 360, 180,
		0, 4303, 4304, 5, 408, 0, 0, 4304, 4306, 5, 271, 0, 0, 4305, 4303, 1, 0,
		0, 0, 4305, 4306, 1, 0, 0, 0, 4306, 355, 1, 0, 0, 0, 4307, 4308, 5, 166,
		0, 0, 4308, 4309, 5, 19, 0, 0, 4309, 4310, 5, 170, 0, 0, 4310, 4313, 3,
		360, 180, 0, 4311, 4312, 5, 408, 0, 0, 4312, 4314, 5, 271, 0, 0, 4313,
		4311, 1, 0, 0, 0, 4313, 4314, 1, 0, 0, 0, 4314, 4315, 1, 0, 0, 0, 4315,
		4316, 3, 320, 160, 0, 4316, 4330, 1, 0, 0, 0, 4317, 4318, 5, 166, 0, 0,
		4318, 4319, 5, 19, 0, 0, 4319, 4320, 5, 170, 0, 0, 4320, 4321, 5, 33, 0,
		0, 4321, 4322, 5, 271, 0, 0, 4322, 4325, 3, 360, 180, 0, 4323, 4324, 5,
		408, 0, 0, 4324, 4326, 5, 271, 0, 0, 4325, 4323, 1, 0, 0, 0, 4325, 4326,
		1, 0, 0, 0, 4326, 4327, 1, 0, 0, 0, 4327, 4328, 3, 320, 160, 0, 4328, 4330,
		1, 0, 0, 0, 4329, 4307, 1, 0, 0, 0, 4329, 4317, 1, 0, 0, 0, 4330, 357,
		1, 0, 0, 0, 4331, 4332, 5, 166, 0, 0, 4332, 4333, 5, 19, 0, 0, 4333, 4334,
		5, 127, 0, 0, 4334, 4337, 3, 360, 180, 0, 4335, 4336, 5, 408, 0, 0, 4336,
		4338, 5, 271, 0, 0, 4337, 4335, 1, 0, 0, 0, 4337, 4338, 1, 0, 0, 0, 4338,
		4339, 1, 0, 0, 0, 4339, 4340, 3, 316, 158, 0, 4340, 4354, 1, 0, 0, 0, 4341,
		4342, 5, 166, 0, 0, 4342, 4343, 5, 19, 0, 0, 4343, 4344, 5, 127, 0, 0,
		4344, 4345, 5, 33, 0, 0, 4345, 4346, 5, 271, 0, 0, 4346, 4349, 3, 360,
		180, 0, 4347, 4348, 5, 408, 0, 0, 4348, 4350, 5, 271, 0, 0, 4349, 4347,
		1, 0, 0, 0, 4349, 4350, 1, 0, 0, 0, 4350, 4351, 1, 0, 0, 0, 4351, 4352,
		3, 316, 158, 0, 4352, 4354, 1, 0, 0, 0, 4353, 4331, 1, 0, 0, 0, 4353, 4341,
		1, 0, 0, 0, 4354, 359, 1, 0, 0, 0, 4355, 4356, 5, 325, 0, 0, 4356, 4357,
		5, 19, 0, 0, 4357, 4358, 5, 170, 0, 0, 4358, 4359, 5, 325, 0, 0, 4359,
		4360, 5, 556, 0, 0, 4360, 4400, 3, 322, 161, 0, 4361, 4362, 5, 325, 0,
		0, 4362, 4363, 5, 19, 0, 0, 4363, 4364, 5, 170, 0, 0, 4364, 4365, 5, 33,
		0, 0, 4365, 4366, 5, 271, 0, 0, 4366, 4367, 5, 325, 0, 0, 4367, 4368, 5,
		556, 0, 0, 4368, 4400, 3, 322, 161, 0, 4369, 4370, 5, 325, 0, 0, 4370,
		4371, 5, 19, 0, 0, 4371, 4374, 5, 359, 0, 0, 4372, 4373, 5, 596, 0, 0,
		4373, 4375, 5, 271, 0, 0, 4374, 4372, 1, 0, 0, 0, 4374, 4375, 1, 0, 0,
		0, 4375, 4400, 1, 0, 0, 0, 4376, 4377, 5, 325, 0, 0, 4377, 4378, 5, 19,
		0, 0, 4378, 4379, 5, 116, 0, 0, 4379, 4382, 5, 271, 0, 0, 4380, 4381, 5,
		596, 0, 0, 4381, 4383, 5, 271, 0, 0, 4382, 4380, 1, 0, 0, 0, 4382, 4383,
		1, 0, 0, 0, 4383, 4400, 1, 0, 0, 0, 4384, 4385, 5, 325, 0, 0, 4385, 4386,
		5, 19, 0, 0, 4386, 4387, 5, 127, 0, 0, 4387, 4388, 5, 325, 0, 0, 4388,
		4389, 5, 556, 0, 0, 4389, 4400, 3, 318, 159, 0, 4390, 4391, 5, 325, 0,
		0, 4391, 4392, 5, 19, 0, 0, 4392, 4393, 5, 127, 0, 0, 4393, 4394, 5, 33,
		0, 0, 4394, 4395, 5, 271, 0, 0, 4395, 4396, 5, 325, 0, 0, 4396, 4397, 5,
		556, 0, 0, 4397, 4400, 3, 318, 159, 0, 4398, 4400, 3, 948, 474, 0, 4399,
		4355, 1, 0, 0, 0, 4399, 4361, 1, 0, 0, 0, 4399, 4369, 1, 0, 0, 0, 4399,
		4376, 1, 0, 0, 0, 4399, 4384, 1, 0, 0, 0, 4399, 4390, 1, 0, 0, 0, 4399,
		4398, 1, 0, 0, 0, 4400, 361, 1, 0, 0, 0, 4401, 4402, 7, 31, 0, 0, 4402,
		363, 1, 0, 0, 0, 4403, 4404, 5, 34, 0, 0, 4404, 4409, 5, 221, 0, 0, 4405,
		4406, 5, 93, 0, 0, 4406, 4407, 3, 38, 19, 0, 4407, 4408, 5, 69, 0, 0, 4408,
		4410, 1, 0, 0, 0, 4409, 4405, 1, 0, 0, 0, 4409, 4410, 1, 0, 0, 0, 4410,
		4411, 1, 0, 0, 0, 4411, 4413, 3, 934, 467, 0, 4412, 4414, 3, 372, 186,
		0, 4413, 4412, 1, 0, 0, 0, 4413, 4414, 1, 0, 0, 0, 4414, 4419, 1, 0, 0,
		0, 4415, 4420, 3, 352, 176, 0, 4416, 4420, 3, 354, 177, 0, 4417, 4420,
		3, 356, 178, 0, 4418, 4420, 3, 358, 179, 0, 4419, 4415, 1, 0, 0, 0, 4419,
		4416, 1, 0, 0, 0, 4419, 4417, 1, 0, 0, 0, 4419, 4418, 1, 0, 0, 0, 4419,
		4420, 1, 0, 0, 0, 4420, 365, 1, 0, 0, 0, 4421, 4422, 5, 62, 0, 0, 4422,
		4425, 5, 221, 0, 0, 4423, 4424, 5, 93, 0, 0, 4424, 4426, 5, 69, 0, 0, 4425,
		4423, 1, 0, 0, 0, 4425, 4426, 1, 0, 0, 0, 4426, 4427, 1, 0, 0, 0, 4427,
		4428, 3, 934, 467, 0, 4428, 367, 1, 0, 0, 0, 4429, 4430, 5, 4, 0, 0, 4430,
		4431, 5, 221, 0, 0, 4431, 4432, 3, 934, 467, 0, 4432, 4434, 5, 2, 0, 0,
		4433, 4435, 5, 220, 0, 0, 4434, 4433, 1, 0, 0, 0, 4434, 4435, 1, 0, 0,
		0, 4435, 4436, 1, 0, 0, 0, 4436, 4437, 3, 412, 206, 0, 4437, 4449, 1, 0,
		0, 0, 4438, 4439, 5, 4, 0, 0, 4439, 4440, 5, 221, 0, 0, 4440, 4441, 3,
		934, 467, 0, 4441, 4442, 3, 376, 188, 0, 4442, 4449, 1, 0, 0, 0, 4443,
		4444, 5, 4, 0, 0, 4444, 4445, 5, 221, 0, 0, 4445, 4446, 3, 934, 467, 0,
		4446, 4447, 3, 796, 398, 0, 4447, 4449, 1, 0, 0, 0, 4448, 4429, 1, 0, 0,
		0, 4448, 4438, 1, 0, 0, 0, 4448, 4443, 1, 0, 0, 0, 4449, 369, 1, 0, 0,
		0, 4450, 4455, 3, 374, 187, 0, 4451, 4452, 3, 374, 187, 0, 4452, 4453,
		3, 370, 185, 0, 4453, 4455, 1, 0, 0, 0, 4454, 4450, 1, 0, 0, 0, 4454, 4451,
		1, 0, 0, 0, 4455, 371, 1, 0, 0, 0, 4456, 4462, 3, 370, 185, 0, 4457, 4458,
		3, 374, 187, 0, 4458, 4459, 5, 890, 0, 0, 4459, 4460, 3, 372, 186, 0, 4460,
		4462, 1, 0, 0, 0, 4461, 4456, 1, 0, 0, 0, 4461, 4457, 1, 0, 0, 0, 4462,
		373, 1, 0, 0, 0, 4463, 4465, 5, 476, 0, 0, 4464, 4466, 5, 908, 0, 0, 4465,
		4464, 1, 0, 0, 0, 4465, 4466, 1, 0, 0, 0, 4466, 4467, 1, 0, 0, 0, 4467,
		4469, 3, 284, 142, 0, 4468, 4470, 5, 79, 0, 0, 4469, 4468, 1, 0, 0, 0,
		4469, 4470, 1, 0, 0, 0, 4470, 4492, 1, 0, 0, 0, 4471, 4473, 5, 773, 0,
		0, 4472, 4474, 5, 908, 0, 0, 4473, 4472, 1, 0, 0, 0, 4473, 4474, 1, 0,
		0, 0, 4474, 4475, 1, 0, 0, 0, 4475, 4492, 3, 280, 140, 0, 4476, 4478, 5,
		849, 0, 0, 4477, 4479, 5, 908, 0, 0, 4478, 4477, 1, 0, 0, 0, 4478, 4479,
		1, 0, 0, 0, 4479, 4480, 1, 0, 0, 0, 4480, 4492, 5, 271, 0, 0, 4481, 4483,
		5, 750, 0, 0, 4482, 4484, 5, 908, 0, 0, 4483, 4482, 1, 0, 0, 0, 4483, 4484,
		1, 0, 0, 0, 4484, 4485, 1, 0, 0, 0, 4485, 4492, 5, 884, 0, 0, 4486, 4488,
		5, 525, 0, 0, 4487, 4489, 5, 908, 0, 0, 4488, 4487, 1, 0, 0, 0, 4488, 4489,
		1, 0, 0, 0, 4489, 4490, 1, 0, 0, 0, 4490, 4492, 5, 271, 0, 0, 4491, 4463,
		1, 0, 0, 0, 4491, 4471, 1, 0, 0, 0, 4491, 4476, 1, 0, 0, 0, 4491, 4481,
		1, 0, 0, 0, 4491, 4486, 1, 0, 0, 0, 4492, 375, 1, 0, 0, 0, 4493, 4498,
		3, 378, 189, 0, 4494, 4495, 5, 890, 0, 0, 4495, 4497, 3, 378, 189, 0, 4496,
		4494, 1, 0, 0, 0, 4497, 4500, 1, 0, 0, 0, 4498, 4496, 1, 0, 0, 0, 4498,
		4499, 1, 0, 0, 0, 4499, 377, 1, 0, 0, 0, 4500, 4498, 1, 0, 0, 0, 4501,
		4503, 5, 193, 0, 0, 4502, 4501, 1, 0, 0, 0, 4502, 4503, 1, 0, 0, 0, 4503,
		4504, 1, 0, 0, 0, 4504, 4505, 3, 370, 185, 0, 4505, 379, 1, 0, 0, 0, 4506,
		4508, 5, 52, 0, 0, 4507, 4506, 1, 0, 0, 0, 4507, 4508, 1, 0, 0, 0, 4508,
		4509, 1, 0, 0, 0, 4509, 4511, 5, 221, 0, 0, 4510, 4512, 5, 908, 0, 0, 4511,
		4510, 1, 0, 0, 0, 4511, 4512, 1, 0, 0, 0, 4512, 4513, 1, 0, 0, 0, 4513,
		4523, 3, 934, 467, 0, 4514, 4516, 5, 52, 0, 0, 4515, 4514, 1, 0, 0, 0,
		4515, 4516, 1, 0, 0, 0, 4516, 4517, 1, 0, 0, 0, 4517, 4519, 5, 221, 0,
		0, 4518, 4520, 5, 908, 0, 0, 4519, 4518, 1, 0, 0, 0, 4519, 4520, 1, 0,
		0, 0, 4520, 4521, 1, 0, 0, 0, 4521, 4523, 5, 270, 0, 0, 4522, 4507, 1,
		0, 0, 0, 4522, 4515, 1, 0, 0, 0, 4523, 381, 1, 0, 0, 0, 4524, 4527, 5,
		34, 0, 0, 4525, 4526, 5, 158, 0, 0, 4526, 4528, 5, 179, 0, 0, 4527, 4525,
		1, 0, 0, 0, 4527, 4528, 1, 0, 0, 0, 4528, 4530, 1, 0, 0, 0, 4529, 4531,
		5, 818, 0, 0, 4530, 4529, 1, 0, 0, 0, 4530, 4531, 1, 0, 0, 0, 4531, 4532,
		1, 0, 0, 0, 4532, 4533, 5, 473, 0, 0, 4533, 4538, 3, 386, 193, 0, 4534,
		4535, 5, 896, 0, 0, 4535, 4536, 3, 428, 214, 0, 4536, 4537, 5, 903, 0,
		0, 4537, 4539, 1, 0, 0, 0, 4538, 4534, 1, 0, 0, 0, 4538, 4539, 1, 0, 0,
		0, 4539, 4543, 1, 0, 0, 0, 4540, 4541, 5, 439, 0, 0, 4541, 4542, 5, 908,
		0, 0, 4542, 4544, 5, 271, 0, 0, 4543, 4540, 1, 0, 0, 0, 4543, 4544, 1,
		0, 0, 0, 4544, 4545, 1, 0, 0, 0, 4545, 4546, 5, 9, 0, 0, 4546, 4547, 3,
		384, 192, 0, 4547, 383, 1, 0, 0, 0, 4548, 4549, 3, 436, 218, 0, 4549, 385,
		1, 0, 0, 0, 4550, 4551, 3, 584, 292, 0, 4551, 387, 1, 0, 0, 0, 4552, 4554,
		5, 34, 0, 0, 4553, 4555, 7, 32, 0, 0, 4554, 4553, 1, 0, 0, 0, 4554, 4555,
		1, 0, 0, 0, 4555, 4556, 1, 0, 0, 0, 4556, 4561, 5, 96, 0, 0, 4557, 4558,
		5, 93, 0, 0, 4558, 4559, 3, 38, 19, 0, 4559, 4560, 5, 69, 0, 0, 4560, 4562,
		1, 0, 0, 0, 4561, 4557, 1, 0, 0, 0, 4561, 4562, 1, 0, 0, 0, 4562, 4563,
		1, 0, 0, 0, 4563, 4565, 3, 590, 295, 0, 4564, 4566, 3, 404, 202, 0, 4565,
		4564, 1, 0, 0, 0, 4565, 4566, 1, 0, 0, 0, 4566, 4567, 1, 0, 0, 0, 4567,
		4568, 5, 154, 0, 0, 4568, 4569, 3, 584, 292, 0, 4569, 4570, 5, 896, 0,
		0, 4570, 4571, 3, 396, 198, 0, 4571, 4573, 5, 903, 0, 0, 4572, 4574, 3,
		400, 200, 0, 4573, 4572, 1, 0, 0, 0, 4573, 4574, 1, 0, 0, 0, 4574, 4575,
		1, 0, 0, 0, 4575, 4576, 3, 294, 147, 0, 4576, 389, 1, 0, 0, 0, 4577, 4578,
		3, 934, 467, 0, 4578, 391, 1, 0, 0, 0, 4579, 4581, 3, 394, 197, 0, 4580,
		4579, 1, 0, 0, 0, 4580, 4581, 1, 0, 0, 0, 4581, 393, 1, 0, 0, 0, 4582,
		4583, 3, 934, 467, 0, 4583, 395, 1, 0, 0, 0, 4584, 4589, 3, 398, 199, 0,
		4585, 4586, 5, 890, 0, 0, 4586, 4588, 3, 398, 199, 0, 4587, 4585, 1, 0,
		0, 0, 4588, 4591, 1, 0, 0, 0, 4589, 4587, 1, 0, 0, 0, 4589, 4590, 1, 0,
		0, 0, 4590, 397, 1, 0, 0, 0, 4591, 4589, 1, 0, 0, 0, 4592, 4596, 3, 932,
		466, 0, 4593, 4594, 5, 896, 0, 0, 4594, 4595, 5, 271, 0, 0, 4595, 4597,
		5, 903, 0, 0, 4596, 4593, 1, 0, 0, 0, 4596, 4597, 1, 0, 0, 0, 4597, 4599,
		1, 0, 0, 0, 4598, 4600, 7, 33, 0, 0, 4599, 4598, 1, 0, 0, 0, 4599, 4600,
		1, 0, 0, 0, 4600, 4603, 1, 0, 0, 0, 4601, 4602, 5, 92, 0, 0, 4602, 4604,
		5, 271, 0, 0, 4603, 4601, 1, 0, 0, 0, 4603, 4604, 1, 0, 0, 0, 4604, 399,
		1, 0, 0, 0, 4605, 4607, 3, 402, 201, 0, 4606, 4605, 1, 0, 0, 0, 4607, 4608,
		1, 0, 0, 0, 4608, 4606, 1, 0, 0, 0, 4608, 4609, 1, 0, 0, 0, 4609, 401,
		1, 0, 0, 0, 4610, 4656, 5, 497, 0, 0, 4611, 4656, 5, 129, 0, 0, 4612, 4614,
		5, 565, 0, 0, 4613, 4615, 5, 908, 0, 0, 4614, 4613, 1, 0, 0, 0, 4614, 4615,
		1, 0, 0, 0, 4615, 4616, 1, 0, 0, 0, 4616, 4656, 5, 271, 0, 0, 4617, 4618,
		5, 369, 0, 0, 4618, 4656, 5, 923, 0, 0, 4619, 4620, 5, 825, 0, 0, 4620,
		4621, 5, 896, 0, 0, 4621, 4622, 3, 312, 156, 0, 4622, 4623, 5, 903, 0,
		0, 4623, 4656, 1, 0, 0, 0, 4624, 4625, 5, 538, 0, 0, 4625, 4626, 5, 896,
		0, 0, 4626, 4627, 3, 312, 156, 0, 4627, 4628, 5, 903, 0, 0, 4628, 4656,
		1, 0, 0, 0, 4629, 4656, 5, 41, 0, 0, 4630, 4631, 5, 247, 0, 0, 4631, 4632,
		5, 163, 0, 0, 4632, 4656, 5, 923, 0, 0, 4633, 4656, 3, 404, 202, 0, 4634,
		4656, 3, 808, 404, 0, 4635, 4637, 5, 509, 0, 0, 4636, 4638, 5, 908, 0,
		0, 4637, 4636, 1, 0, 0, 0, 4637, 4638, 1, 0, 0, 0, 4638, 4639, 1, 0, 0,
		0, 4639, 4656, 5, 271, 0, 0, 4640, 4642, 5, 636, 0, 0, 4641, 4643, 5, 908,
		0, 0, 4642, 4641, 1, 0, 0, 0, 4642, 4643, 1, 0, 0, 0, 4643, 4644, 1, 0,
		0, 0, 4644, 4656, 5, 271, 0, 0, 4645, 4647, 5, 726, 0, 0, 4646, 4648, 5,
		908, 0, 0, 4647, 4646, 1, 0, 0, 0, 4647, 4648, 1, 0, 0, 0, 4648, 4649,
		1, 0, 0, 0, 4649, 4656, 5, 271, 0, 0, 4650, 4652, 5, 525, 0, 0, 4651, 4653,
		5, 908, 0, 0, 4652, 4651, 1, 0, 0, 0, 4652, 4653, 1, 0, 0, 0, 4653, 4654,
		1, 0, 0, 0, 4654, 4656, 5, 271, 0, 0, 4655, 4610, 1, 0, 0, 0, 4655, 4611,
		1, 0, 0, 0, 4655, 4612, 1, 0, 0, 0, 4655, 4617, 1, 0, 0, 0, 4655, 4619,
		1, 0, 0, 0, 4655, 4624, 1, 0, 0, 0, 4655, 4629, 1, 0, 0, 0, 4655, 4630,
		1, 0, 0, 0, 4655, 4633, 1, 0, 0, 0, 4655, 4634, 1, 0, 0, 0, 4655, 4635,
		1, 0, 0, 0, 4655, 4640, 1, 0, 0, 0, 4655, 4645, 1, 0, 0, 0, 4655, 4650,
		1, 0, 0, 0, 4656, 403, 1, 0, 0, 0, 4657, 4658, 5, 234, 0, 0, 4658, 4662,
		5, 356, 0, 0, 4659, 4660, 5, 234, 0, 0, 4660, 4662, 5, 359, 0, 0, 4661,
		4657, 1, 0, 0, 0, 4661, 4659, 1, 0, 0, 0, 4662, 405, 1, 0, 0, 0, 4663,
		4665, 5, 62, 0, 0, 4664, 4666, 7, 34, 0, 0, 4665, 4664, 1, 0, 0, 0, 4665,
		4666, 1, 0, 0, 0, 4666, 4667, 1, 0, 0, 0, 4667, 4670, 3, 408, 204, 0, 4668,
		4669, 5, 93, 0, 0, 4669, 4671, 5, 69, 0, 0, 4670, 4668, 1, 0, 0, 0, 4670,
		4671, 1, 0, 0, 0, 4671, 4672, 1, 0, 0, 0, 4672, 4674, 3, 412, 206, 0, 4673,
		4675, 7, 35, 0, 0, 4674, 4673, 1, 0, 0, 0, 4674, 4675, 1, 0, 0, 0, 4675,
		407, 1, 0, 0, 0, 4676, 4677, 7, 36, 0, 0, 4677, 409, 1, 0, 0, 0, 4678,
		4680, 5, 62, 0, 0, 4679, 4681, 5, 818, 0, 0, 4680, 4679, 1, 0, 0, 0, 4680,
		4681, 1, 0, 0, 0, 4681, 4682, 1, 0, 0, 0, 4682, 4685, 5, 473, 0, 0, 4683,
		4684, 5, 93, 0, 0, 4684, 4686, 5, 69, 0, 0, 4685, 4683, 1, 0, 0, 0, 4685,
		4686, 1, 0, 0, 0, 4686, 4687, 1, 0, 0, 0, 4687, 4689, 3, 412, 206, 0, 4688,
		4690, 7, 35, 0, 0, 4689, 4688, 1, 0, 0, 0, 4689, 4690, 1, 0, 0, 0, 4690,
		411, 1, 0, 0, 0, 4691, 4696, 3, 584, 292, 0, 4692, 4693, 5, 890, 0, 0,
		4693, 4695, 3, 584, 292, 0, 4694, 4692, 1, 0, 0, 0, 4695, 4698, 1, 0, 0,
		0, 4696, 4694, 1, 0, 0, 0, 4696, 4697, 1, 0, 0, 0, 4697, 413, 1, 0, 0,
		0, 4698, 4696, 1, 0, 0, 0, 4699, 4700, 5, 62, 0, 0, 4700, 4701, 5, 96,
		0, 0, 4701, 4702, 3, 934, 467, 0, 4702, 4703, 5, 154, 0, 0, 4703, 4704,
		3, 584, 292, 0, 4704, 415, 1, 0, 0, 0, 4705, 4707, 3, 426, 213, 0, 4706,
		4708, 5, 367, 0, 0, 4707, 4706, 1, 0, 0, 0, 4707, 4708, 1, 0, 0, 0, 4708,
		4710, 1, 0, 0, 0, 4709, 4711, 5, 109, 0, 0, 4710, 4709, 1, 0, 0, 0, 4710,
		4711, 1, 0, 0, 0, 4711, 4712, 1, 0, 0, 0, 4712, 4718, 3, 418, 209, 0, 4713,
		4714, 5, 154, 0, 0, 4714, 4715, 5, 376, 0, 0, 4715, 4716, 5, 116, 0, 0,
		4716, 4717, 5, 231, 0, 0, 4717, 4719, 3, 116, 58, 0, 4718, 4713, 1, 0,
		0, 0, 4718, 4719, 1, 0, 0, 0, 4719, 4730, 1, 0, 0, 0, 4720, 4722, 3, 424,
		212, 0, 4721, 4723, 5, 367, 0, 0, 4722, 4721, 1, 0, 0, 0, 4722, 4723, 1,
		0, 0, 0, 4723, 4725, 1, 0, 0, 0, 4724, 4726, 5, 109, 0, 0, 4725, 4724,
		1, 0, 0, 0, 4725, 4726, 1, 0, 0, 0, 4726, 4727, 1, 0, 0, 0, 4727, 4728,
		3, 418, 209, 0, 4728, 4730, 1, 0, 0, 0, 4729, 4705, 1, 0, 0, 0, 4729, 4720,
		1, 0, 0, 0, 4730, 417, 1, 0, 0, 0, 4731, 4732, 3, 556, 278, 0, 4732, 4733,
		3, 420, 210, 0, 4733, 4750, 1, 0, 0, 0, 4734, 4735, 3, 556, 278, 0, 4735,
		4736, 5, 896, 0, 0, 4736, 4737, 5, 903, 0, 0, 4737, 4738, 3, 420, 210,
		0, 4738, 4750, 1, 0, 0, 0, 4739, 4740, 3, 556, 278, 0, 4740, 4741, 5, 896,
		0, 0, 4741, 4742, 3, 428, 214, 0, 4742, 4743, 5, 903, 0, 0, 4743, 4744,
		3, 420, 210, 0, 4744, 4750, 1, 0, 0, 0, 4745, 4746, 3, 556, 278, 0, 4746,
		4747, 5, 193, 0, 0, 4747, 4748, 3, 116, 58, 0, 4748, 4750, 1, 0, 0, 0,
		4749, 4731, 1, 0, 0, 0, 4749, 4734, 1, 0, 0, 0, 4749, 4739, 1, 0, 0, 0,
		4749, 4745, 1, 0, 0, 0, 4750, 419, 1, 0, 0, 0, 4751, 4752, 3, 422, 211,
		0, 4752, 4753, 3, 430, 215, 0, 4753, 4756, 1, 0, 0, 0, 4754, 4756, 3, 436,
		218, 0, 4755, 4751, 1, 0, 0, 0, 4755, 4754, 1, 0, 0, 0, 4756, 421, 1, 0,
		0, 0, 4757, 4758, 7, 37, 0, 0, 4758, 423, 1, 0, 0, 0, 4759, 4763, 5, 179,
		0, 0, 4760, 4761, 5, 928, 0, 0, 4761, 4763, 3, 502, 251, 0, 4762, 4759,
		1, 0, 0, 0, 4762, 4760, 1, 0, 0, 0, 4763, 425, 1, 0, 0, 0, 4764, 4768,
		5, 108, 0, 0, 4765, 4766, 5, 929, 0, 0, 4766, 4768, 3, 502, 251, 0, 4767,
		4764, 1, 0, 0, 0, 4767, 4765, 1, 0, 0, 0, 4768, 427, 1, 0, 0, 0, 4769,
		4774, 3, 226, 113, 0, 4770, 4771, 5, 890, 0, 0, 4771, 4773, 3, 226, 113,
		0, 4772, 4770, 1, 0, 0, 0, 4773, 4776, 1, 0, 0, 0, 4774, 4772, 1, 0, 0,
		0, 4774, 4775, 1, 0, 0, 0, 4775, 429, 1, 0, 0, 0, 4776, 4774, 1, 0, 0,
		0, 4777, 4778, 6, 215, -1, 0, 4778, 4779, 5, 896, 0, 0, 4779, 4780, 3,
		432, 216, 0, 4780, 4781, 5, 903, 0, 0, 4781, 4790, 1, 0, 0, 0, 4782, 4783,
		10, 1, 0, 0, 4783, 4784, 5, 890, 0, 0, 4784, 4785, 5, 896, 0, 0, 4785,
		4786, 3, 432, 216, 0, 4786, 4787, 5, 903, 0, 0, 4787, 4789, 1, 0, 0, 0,
		4788, 4782, 1, 0, 0, 0, 4789, 4792, 1, 0, 0, 0, 4790, 4788, 1, 0, 0, 0,
		4790, 4791, 1, 0, 0, 0, 4791, 431, 1, 0, 0, 0, 4792, 4790, 1, 0, 0, 0,
		4793, 4794, 6, 216, -1, 0, 4794, 4797, 3, 434, 217, 0, 4795, 4797, 3, 948,
		474, 0, 4796, 4793, 1, 0, 0, 0, 4796, 4795, 1, 0, 0, 0, 4797, 4803, 1,
		0, 0, 0, 4798, 4799, 10, 2, 0, 0, 4799, 4800, 5, 890, 0, 0, 4800, 4802,
		3, 434, 217, 0, 4801, 4798, 1, 0, 0, 0, 4802, 4805, 1, 0, 0, 0, 4803, 4801,
		1, 0, 0, 0, 4803, 4804, 1, 0, 0, 0, 4804, 433, 1, 0, 0, 0, 4805, 4803,
		1, 0, 0, 0, 4806, 4809, 3, 36, 18, 0, 4807, 4809, 5, 52, 0, 0, 4808, 4806,
		1, 0, 0, 0, 4808, 4807, 1, 0, 0, 0, 4809, 435, 1, 0, 0, 0, 4810, 4814,
		3, 442, 221, 0, 4811, 4814, 3, 440, 220, 0, 4812, 4814, 3, 438, 219, 0,
		4813, 4810, 1, 0, 0, 0, 4813, 4811, 1, 0, 0, 0, 4813, 4812, 1, 0, 0, 0,
		4814, 437, 1, 0, 0, 0, 4815, 4816, 3, 442, 221, 0, 4816, 4817, 3, 482,
		241, 0, 4817, 439, 1, 0, 0, 0, 4818, 4819, 5, 896, 0, 0, 4819, 4820, 3,
		442, 221, 0, 4820, 4821, 5, 903, 0, 0, 4821, 4827, 1, 0, 0, 0, 4822, 4823,
		5, 896, 0, 0, 4823, 4824, 3, 440, 220, 0, 4824, 4825, 5, 903, 0, 0, 4825,
		4827, 1, 0, 0, 0, 4826, 4818, 1, 0, 0, 0, 4826, 4822, 1, 0, 0, 0, 4827,
		441, 1, 0, 0, 0, 4828, 4832, 3, 446, 223, 0, 4829, 4830, 5, 78, 0, 0, 4830,
		4831, 5, 231, 0, 0, 4831, 4833, 3, 522, 261, 0, 4832, 4829, 1, 0, 0, 0,
		4832, 4833, 1, 0, 0, 0, 4833, 4847, 1, 0, 0, 0, 4834, 4838, 3, 450, 225,
		0, 4835, 4836, 5, 78, 0, 0, 4836, 4837, 5, 231, 0, 0, 4837, 4839, 3, 522,
		261, 0, 4838, 4835, 1, 0, 0, 0, 4838, 4839, 1, 0, 0, 0, 4839, 4847, 1,
		0, 0, 0, 4840, 4844, 3, 448, 224, 0, 4841, 4842, 5, 78, 0, 0, 4842, 4843,
		5, 231, 0, 0, 4843, 4845, 3, 522, 261, 0, 4844, 4841, 1, 0, 0, 0, 4844,
		4845, 1, 0, 0, 0, 4845, 4847, 1, 0, 0, 0, 4846, 4828, 1, 0, 0, 0, 4846,
		4834, 1, 0, 0, 0, 4846, 4840, 1, 0, 0, 0, 4847, 443, 1, 0, 0, 0, 4848,
		4850, 3, 462, 231, 0, 4849, 4851, 3, 538, 269, 0, 4850, 4849, 1, 0, 0,
		0, 4850, 4851, 1, 0, 0, 0, 4851, 4852, 1, 0, 0, 0, 4852, 4853, 3, 544,
		272, 0, 4853, 4854, 3, 484, 242, 0, 4854, 4874, 1, 0, 0, 0, 4855, 4857,
		3, 462, 231, 0, 4856, 4858, 3, 538, 269, 0, 4857, 4856, 1, 0, 0, 0, 4857,
		4858, 1, 0, 0, 0, 4858, 4859, 1, 0, 0, 0, 4859, 4860, 3, 544, 272, 0, 4860,
		4861, 3, 484, 242, 0, 4861, 4862, 5, 80, 0, 0, 4862, 4867, 5, 63, 0, 0,
		4863, 4864, 5, 243, 0, 0, 4864, 4865, 3, 478, 239, 0, 4865, 4866, 3, 36,
		18, 0, 4866, 4868, 1, 0, 0, 0, 4867, 4863, 1, 0, 0, 0, 4867, 4868, 1, 0,
		0, 0, 4868, 4871, 1, 0, 0, 0, 4869, 4870, 5, 246, 0, 0, 4870, 4872, 3,
		62, 31, 0, 4871, 4869, 1, 0, 0, 0, 4871, 4872, 1, 0, 0, 0, 4872, 4874,
		1, 0, 0, 0, 4873, 4848, 1, 0, 0, 0, 4873, 4855, 1, 0, 0, 0, 4874, 445,
		1, 0, 0, 0, 4875, 4881, 3, 444, 222, 0, 4876, 4881, 3, 456, 228, 0, 4877,
		4881, 3, 468, 234, 0, 4878, 4881, 3, 458, 229, 0, 4879, 4881, 3, 460, 230,
		0, 4880, 4875, 1, 0, 0, 0, 4880, 4876, 1, 0, 0, 0, 4880, 4877, 1, 0, 0,
		0, 4880, 4878, 1, 0, 0, 0, 4880, 4879, 1, 0, 0, 0, 4881, 447, 1, 0, 0,
		0, 4882, 4883, 3, 450, 225, 0, 4883, 4884, 3, 532, 266, 0, 4884, 4892,
		1, 0, 0, 0, 4885, 4887, 3, 450, 225, 0, 4886, 4888, 3, 532, 266, 0, 4887,
		4886, 1, 0, 0, 0, 4887, 4888, 1, 0, 0, 0, 4888, 4889, 1, 0, 0, 0, 4889,
		4890, 3, 480, 240, 0, 4890, 4892, 1, 0, 0, 0, 4891, 4882, 1, 0, 0, 0, 4891,
		4885, 1, 0, 0, 0, 4892, 449, 1, 0, 0, 0, 4893, 4894, 6, 225, -1, 0, 4894,
		4895, 3, 454, 227, 0, 4895, 4896, 3, 474, 237, 0, 4896, 4897, 3, 452, 226,
		0, 4897, 4917, 1, 0, 0, 0, 4898, 4899, 10, 4, 0, 0, 4899, 4900, 3, 474,
		237, 0, 4900, 4901, 3, 452, 226, 0, 4901, 4916, 1, 0, 0, 0, 4902, 4903,
		10, 3, 0, 0, 4903, 4904, 3, 532, 266, 0, 4904, 4905, 3, 474, 237, 0, 4905,
		4906, 3, 452, 226, 0, 4906, 4916, 1, 0, 0, 0, 4907, 4909, 10, 2, 0, 0,
		4908, 4910, 3, 532, 266, 0, 4909, 4908, 1, 0, 0, 0, 4909, 4910, 1, 0, 0,
		0, 4910, 4911, 1, 0, 0, 0, 4911, 4912, 3, 480, 240, 0, 4912, 4913, 3, 474,
		237, 0, 4913, 4914, 3, 452, 226, 0, 4914, 4916, 1, 0, 0, 0, 4915, 4898,
		1, 0, 0, 0, 4915, 4902, 1, 0, 0, 0, 4915, 4907, 1, 0, 0, 0, 4916, 4919,
		1, 0, 0, 0, 4917, 4915, 1, 0, 0, 0, 4917, 4918, 1, 0, 0, 0, 4918, 451,
		1, 0, 0, 0, 4919, 4917, 1, 0, 0, 0, 4920, 4924, 3, 444, 222, 0, 4921, 4924,
		3, 468, 234, 0, 4922, 4924, 3, 440, 220, 0, 4923, 4920, 1, 0, 0, 0, 4923,
		4921, 1, 0, 0, 0, 4923, 4922, 1, 0, 0, 0, 4924, 453, 1, 0, 0, 0, 4925,
		4929, 3, 456, 228, 0, 4926, 4929, 3, 458, 229, 0, 4927, 4929, 3, 452, 226,
		0, 4928, 4925, 1, 0, 0, 0, 4928, 4926, 1, 0, 0, 0, 4928, 4927, 1, 0, 0,
		0, 4929, 455, 1, 0, 0, 0, 4930, 4931, 3, 444, 222, 0, 4931, 4932, 3, 532,
		266, 0, 4932, 4940, 1, 0, 0, 0, 4933, 4935, 3, 444, 222, 0, 4934, 4936,
		3, 532, 266, 0, 4935, 4934, 1, 0, 0, 0, 4935, 4936, 1, 0, 0, 0, 4936, 4937,
		1, 0, 0, 0, 4937, 4938, 3, 480, 240, 0, 4938, 4940, 1, 0, 0, 0, 4939, 4930,
		1, 0, 0, 0, 4939, 4933, 1, 0, 0, 0, 4940, 457, 1, 0, 0, 0, 4941, 4942,
		3, 468, 234, 0, 4942, 4943, 3, 532, 266, 0, 4943, 4951, 1, 0, 0, 0, 4944,
		4946, 3, 468, 234, 0, 4945, 4947, 3, 532, 266, 0, 4946, 4945, 1, 0, 0,
		0, 4946, 4947, 1, 0, 0, 0, 4947, 4948, 1, 0, 0, 0, 4948, 4949, 3, 480,
		240, 0, 4949, 4951, 1, 0, 0, 0, 4950, 4941, 1, 0, 0, 0, 4950, 4944, 1,
		0, 0, 0, 4951, 459, 1, 0, 0, 0, 4952, 4953, 3, 440, 220, 0, 4953, 4954,
		3, 532, 266, 0, 4954, 4962, 1, 0, 0, 0, 4955, 4957, 3, 440, 220, 0, 4956,
		4958, 3, 532, 266, 0, 4957, 4956, 1, 0, 0, 0, 4957, 4958, 1, 0, 0, 0, 4958,
		4959, 1, 0, 0, 0, 4959, 4960, 3, 480, 240, 0, 4960, 4962, 1, 0, 0, 0, 4961,
		4952, 1, 0, 0, 0, 4961, 4955, 1, 0, 0, 0, 4962, 461, 1, 0, 0, 0, 4963,
		4967, 5, 189, 0, 0, 4964, 4965, 5, 930, 0, 0, 4965, 4967, 3, 502, 251,
		0, 4966, 4963, 1, 0, 0, 0, 4966, 4964, 1, 0, 0, 0, 4967, 463, 1, 0, 0,
		0, 4968, 4972, 5, 231, 0, 0, 4969, 4970, 5, 931, 0, 0, 4970, 4972, 3, 502,
		251, 0, 4971, 4968, 1, 0, 0, 0, 4971, 4969, 1, 0, 0, 0, 4972, 465, 1, 0,
		0, 0, 4973, 4977, 5, 54, 0, 0, 4974, 4975, 5, 932, 0, 0, 4975, 4977, 3,
		502, 251, 0, 4976, 4973, 1, 0, 0, 0, 4976, 4974, 1, 0, 0, 0, 4977, 467,
		1, 0, 0, 0, 4978, 4980, 3, 462, 231, 0, 4979, 4981, 3, 538, 269, 0, 4980,
		4979, 1, 0, 0, 0, 4980, 4981, 1, 0, 0, 0, 4981, 4982, 1, 0, 0, 0, 4982,
		4983, 3, 544, 272, 0, 4983, 4984, 3, 484, 242, 0, 4984, 4985, 5, 80, 0,
		0, 4985, 4990, 3, 546, 273, 0, 4986, 4987, 5, 243, 0, 0, 4987, 4988, 3,
		478, 239, 0, 4988, 4989, 3, 36, 18, 0, 4989, 4991, 1, 0, 0, 0, 4990, 4986,
		1, 0, 0, 0, 4990, 4991, 1, 0, 0, 0, 4991, 4995, 1, 0, 0, 0, 4992, 4993,
		5, 86, 0, 0, 4993, 4994, 5, 19, 0, 0, 4994, 4996, 3, 526, 263, 0, 4995,
		4992, 1, 0, 0, 0, 4995, 4996, 1, 0, 0, 0, 4996, 4999, 1, 0, 0, 0, 4997,
		4998, 5, 87, 0, 0, 4998, 5000, 3, 36, 18, 0, 4999, 4997, 1, 0, 0, 0, 4999,
		5000, 1, 0, 0, 0, 5000, 5003, 1, 0, 0, 0, 5001, 5002, 5, 246, 0, 0, 5002,
		5004, 3, 62, 31, 0, 5003, 5001, 1, 0, 0, 0, 5003, 5004, 1, 0, 0, 0, 5004,
		469, 1, 0, 0, 0, 5005, 5006, 5, 227, 0, 0, 5006, 471, 1, 0, 0, 0, 5007,
		5008, 7, 38, 0, 0, 5008, 473, 1, 0, 0, 0, 5009, 5010, 3, 470, 235, 0, 5010,
		5011, 3, 476, 238, 0, 5011, 5014, 1, 0, 0, 0, 5012, 5014, 3, 472, 236,
		0, 5013, 5009, 1, 0, 0, 0, 5013, 5012, 1, 0, 0, 0, 5014, 475, 1, 0, 0,
		0, 5015, 5017, 7, 6, 0, 0, 5016, 5015, 1, 0, 0, 0, 5016, 5017, 1, 0, 0,
		0, 5017, 477, 1, 0, 0, 0, 5018, 5020, 5, 889, 0, 0, 5019, 5018, 1, 0, 0,
		0, 5019, 5020, 1, 0, 0, 0, 5020, 479, 1, 0, 0, 0, 5021, 5022, 5, 123, 0,
		0, 5022, 5023, 3, 520, 260, 0, 5023, 5024, 5, 463, 0, 0, 5024, 5025, 3,
		520, 260, 0, 5025, 5034, 1, 0, 0, 0, 5026, 5027, 5, 123, 0, 0, 5027, 5034,
		3, 520, 260, 0, 5028, 5029, 5, 123, 0, 0, 5029, 5030, 3, 520, 260, 0, 5030,
		5031, 5, 890, 0, 0, 5031, 5032, 3, 520, 260, 0, 5032, 5034, 1, 0, 0, 0,
		5033, 5021, 1, 0, 0, 0, 5033, 5026, 1, 0, 0, 0, 5033, 5028, 1, 0, 0, 0,
		5034, 481, 1, 0, 0, 0, 5035, 5036, 5, 109, 0, 0, 5036, 5037, 5, 162, 0,
		0, 5037, 5041, 5, 923, 0, 0, 5038, 5039, 3, 162, 81, 0, 5039, 5040, 3,
		260, 130, 0, 5040, 5042, 1, 0, 0, 0, 5041, 5038, 1, 0, 0, 0, 5041, 5042,
		1, 0, 0, 0, 5042, 5043, 1, 0, 0, 0, 5043, 5044, 3, 490, 245, 0, 5044, 5045,
		3, 496, 248, 0, 5045, 5052, 1, 0, 0, 0, 5046, 5047, 5, 109, 0, 0, 5047,
		5048, 5, 672, 0, 0, 5048, 5052, 5, 923, 0, 0, 5049, 5050, 5, 109, 0, 0,
		5050, 5052, 3, 486, 243, 0, 5051, 5035, 1, 0, 0, 0, 5051, 5046, 1, 0, 0,
		0, 5051, 5049, 1, 0, 0, 0, 5052, 483, 1, 0, 0, 0, 5053, 5055, 3, 482, 241,
		0, 5054, 5053, 1, 0, 0, 0, 5054, 5055, 1, 0, 0, 0, 5055, 485, 1, 0, 0,
		0, 5056, 5061, 3, 488, 244, 0, 5057, 5058, 5, 890, 0, 0, 5058, 5060, 3,
		488, 244, 0, 5059, 5057, 1, 0, 0, 0, 5060, 5063, 1, 0, 0, 0, 5061, 5059,
		1, 0, 0, 0, 5061, 5062, 1, 0, 0, 0, 5062, 487, 1, 0, 0, 0, 5063, 5061,
		1, 0, 0, 0, 5064, 5067, 5, 920, 0, 0, 5065, 5067, 3, 930, 465, 0, 5066,
		5064, 1, 0, 0, 0, 5066, 5065, 1, 0, 0, 0, 5067, 489, 1, 0, 0, 0, 5068,
		5069, 3, 646, 323, 0, 5069, 5070, 3, 492, 246, 0, 5070, 5073, 1, 0, 0,
		0, 5071, 5073, 3, 948, 474, 0, 5072, 5068, 1, 0, 0, 0, 5072, 5071, 1, 0,
		0, 0, 5073, 491, 1, 0, 0, 0, 5074, 5076, 3, 494, 247, 0, 5075, 5074, 1,
		0, 0, 0, 5076, 5077, 1, 0, 0, 0, 5077, 5075, 1, 0, 0, 0, 5077, 5078, 1,
		0, 0, 0, 5078, 493, 1, 0, 0, 0, 5079, 5080, 5, 215, 0, 0, 5080, 5081, 5,
		19, 0, 0, 5081, 5093, 5, 923, 0, 0, 5082, 5083, 5, 157, 0, 0, 5083, 5084,
		5, 65, 0, 0, 5084, 5085, 5, 19, 0, 0, 5085, 5093, 5, 923, 0, 0, 5086, 5087,
		5, 65, 0, 0, 5087, 5088, 5, 19, 0, 0, 5088, 5093, 5, 923, 0, 0, 5089, 5090,
		5, 68, 0, 0, 5090, 5091, 5, 19, 0, 0, 5091, 5093, 5, 923, 0, 0, 5092, 5079,
		1, 0, 0, 0, 5092, 5082, 1, 0, 0, 0, 5092, 5086, 1, 0, 0, 0, 5092, 5089,
		1, 0, 0, 0, 5093, 495, 1, 0, 0, 0, 5094, 5095, 5, 126, 0, 0, 5095, 5098,
		3, 498, 249, 0, 5096, 5098, 3, 948, 474, 0, 5097, 5094, 1, 0, 0, 0, 5097,
		5096, 1, 0, 0, 0, 5098, 497, 1, 0, 0, 0, 5099, 5101, 3, 500, 250, 0, 5100,
		5099, 1, 0, 0, 0, 5101, 5102, 1, 0, 0, 0, 5102, 5100, 1, 0, 0, 0, 5102,
		5103, 1, 0, 0, 0, 5103, 499, 1, 0, 0, 0, 5104, 5105, 5, 215, 0, 0, 5105,
		5106, 5, 19, 0, 0, 5106, 5111, 5, 923, 0, 0, 5107, 5108, 5, 209, 0, 0,
		5108, 5109, 5, 19, 0, 0, 5109, 5111, 5, 923, 0, 0, 5110, 5104, 1, 0, 0,
		0, 5110, 5107, 1, 0, 0, 0, 5111, 501, 1, 0, 0, 0, 5112, 5118, 3, 506, 253,
		0, 5113, 5114, 3, 504, 252, 0, 5114, 5115, 5, 890, 0, 0, 5115, 5116, 3,
		506, 253, 0, 5116, 5118, 1, 0, 0, 0, 5117, 5112, 1, 0, 0, 0, 5117, 5113,
		1, 0, 0, 0, 5117, 5118, 1, 0, 0, 0, 5118, 5119, 1, 0, 0, 0, 5119, 5120,
		5, 933, 0, 0, 5120, 503, 1, 0, 0, 0, 5121, 5122, 6, 252, -1, 0, 5122, 5125,
		3, 506, 253, 0, 5123, 5125, 3, 948, 474, 0, 5124, 5121, 1, 0, 0, 0, 5124,
		5123, 1, 0, 0, 0, 5125, 5131, 1, 0, 0, 0, 5126, 5127, 10, 2, 0, 0, 5127,
		5128, 5, 890, 0, 0, 5128, 5130, 3, 506, 253, 0, 5129, 5126, 1, 0, 0, 0,
		5130, 5133, 1, 0, 0, 0, 5131, 5129, 1, 0, 0, 0, 5131, 5132, 1, 0, 0, 0,
		5132, 505, 1, 0, 0, 0, 5133, 5131, 1, 0, 0, 0, 5134, 5136, 3, 510, 255,
		0, 5135, 5134, 1, 0, 0, 0, 5136, 5137, 1, 0, 0, 0, 5137, 5135, 1, 0, 0,
		0, 5137, 5138, 1, 0, 0, 0, 5138, 507, 1, 0, 0, 0, 5139, 5140, 6, 254, -1,
		0, 5140, 5141, 5, 921, 0, 0, 5141, 5149, 1, 0, 0, 0, 5142, 5143, 10, 2,
		0, 0, 5143, 5148, 5, 921, 0, 0, 5144, 5145, 10, 1, 0, 0, 5145, 5146, 5,
		890, 0, 0, 5146, 5148, 5, 921, 0, 0, 5147, 5142, 1, 0, 0, 0, 5147, 5144,
		1, 0, 0, 0, 5148, 5151, 1, 0, 0, 0, 5149, 5147, 1, 0, 0, 0, 5149, 5150,
		1, 0, 0, 0, 5150, 509, 1, 0, 0, 0, 5151, 5149, 1, 0, 0, 0, 5152, 5404,
		5, 934, 0, 0, 5153, 5154, 5, 935, 0, 0, 5154, 5155, 5, 896, 0, 0, 5155,
		5156, 3, 512, 256, 0, 5156, 5157, 5, 903, 0, 0, 5157, 5404, 1, 0, 0, 0,
		5158, 5159, 5, 936, 0, 0, 5159, 5160, 5, 896, 0, 0, 5160, 5161, 3, 596,
		298, 0, 5161, 5162, 3, 594, 297, 0, 5162, 5163, 5, 921, 0, 0, 5163, 5164,
		5, 903, 0, 0, 5164, 5404, 1, 0, 0, 0, 5165, 5166, 5, 937, 0, 0, 5166, 5167,
		5, 896, 0, 0, 5167, 5168, 5, 271, 0, 0, 5168, 5404, 5, 903, 0, 0, 5169,
		5170, 5, 938, 0, 0, 5170, 5171, 5, 896, 0, 0, 5171, 5172, 5, 271, 0, 0,
		5172, 5404, 5, 903, 0, 0, 5173, 5174, 5, 939, 0, 0, 5174, 5175, 5, 896,
		0, 0, 5175, 5176, 5, 271, 0, 0, 5176, 5177, 5, 271, 0, 0, 5177, 5404, 5,
		903, 0, 0, 5178, 5404, 5, 940, 0, 0, 5179, 5180, 5, 941, 0, 0, 5180, 5181,
		5, 896, 0, 0, 5181, 5182, 5, 921, 0, 0, 5182, 5404, 5, 903, 0, 0, 5183,
		5184, 5, 941, 0, 0, 5184, 5185, 5, 896, 0, 0, 5185, 5186, 5, 886, 0, 0,
		5186, 5187, 5, 923, 0, 0, 5187, 5188, 5, 886, 0, 0, 5188, 5404, 5, 903,
		0, 0, 5189, 5190, 5, 942, 0, 0, 5190, 5191, 5, 896, 0, 0, 5191, 5192, 3,
		596, 298, 0, 5192, 5193, 3, 608, 304, 0, 5193, 5194, 5, 903, 0, 0, 5194,
		5404, 1, 0, 0, 0, 5195, 5196, 5, 942, 0, 0, 5196, 5197, 5, 896, 0, 0, 5197,
		5198, 3, 596, 298, 0, 5198, 5199, 3, 598, 299, 0, 5199, 5200, 5, 903, 0,
		0, 5200, 5404, 1, 0, 0, 0, 5201, 5404, 5, 943, 0, 0, 5202, 5203, 5, 944,
		0, 0, 5203, 5204, 5, 896, 0, 0, 5204, 5205, 3, 596, 298, 0, 5205, 5206,
		3, 594, 297, 0, 5206, 5207, 5, 903, 0, 0, 5207, 5404, 1, 0, 0, 0, 5208,
		5209, 5, 945, 0, 0, 5209, 5210, 5, 896, 0, 0, 5210, 5211, 3, 514, 257,
		0, 5211, 5212, 5, 903, 0, 0, 5212, 5404, 1, 0, 0, 0, 5213, 5214, 5, 946,
		0, 0, 5214, 5215, 5, 896, 0, 0, 5215, 5216, 3, 596, 298, 0, 5216, 5217,
		3, 610, 305, 0, 5217, 5218, 5, 903, 0, 0, 5218, 5404, 1, 0, 0, 0, 5219,
		5220, 5, 947, 0, 0, 5220, 5221, 5, 896, 0, 0, 5221, 5222, 3, 596, 298,
		0, 5222, 5223, 3, 610, 305, 0, 5223, 5224, 5, 903, 0, 0, 5224, 5404, 1,
		0, 0, 0, 5225, 5226, 5, 948, 0, 0, 5226, 5227, 5, 896, 0, 0, 5227, 5228,
		3, 596, 298, 0, 5228, 5229, 3, 610, 305, 0, 5229, 5230, 5, 903, 0, 0, 5230,
		5404, 1, 0, 0, 0, 5231, 5232, 5, 949, 0, 0, 5232, 5233, 5, 896, 0, 0, 5233,
		5234, 3, 596, 298, 0, 5234, 5235, 3, 610, 305, 0, 5235, 5236, 5, 903, 0,
		0, 5236, 5404, 1, 0, 0, 0, 5237, 5238, 5, 950, 0, 0, 5238, 5239, 5, 896,
		0, 0, 5239, 5240, 3, 596, 298, 0, 5240, 5241, 3, 610, 305, 0, 5241, 5242,
		5, 903, 0, 0, 5242, 5404, 1, 0, 0, 0, 5243, 5244, 5, 951, 0, 0, 5244, 5245,
		5, 896, 0, 0, 5245, 5246, 3, 596, 298, 0, 5246, 5247, 3, 610, 305, 0, 5247,
		5248, 5, 903, 0, 0, 5248, 5404, 1, 0, 0, 0, 5249, 5250, 5, 952, 0, 0, 5250,
		5251, 5, 896, 0, 0, 5251, 5252, 3, 596, 298, 0, 5252, 5253, 3, 610, 305,
		0, 5253, 5254, 5, 903, 0, 0, 5254, 5404, 1, 0, 0, 0, 5255, 5256, 5, 953,
		0, 0, 5256, 5257, 5, 896, 0, 0, 5257, 5258, 3, 596, 298, 0, 5258, 5259,
		3, 610, 305, 0, 5259, 5260, 5, 903, 0, 0, 5260, 5404, 1, 0, 0, 0, 5261,
		5262, 5, 954, 0, 0, 5262, 5263, 5, 896, 0, 0, 5263, 5264, 3, 596, 298,
		0, 5264, 5265, 3, 610, 305, 0, 5265, 5266, 5, 903, 0, 0, 5266, 5404, 1,
		0, 0, 0, 5267, 5268, 5, 955, 0, 0, 5268, 5269, 5, 896, 0, 0, 5269, 5270,
		3, 596, 298, 0, 5270, 5271, 3, 610, 305, 0, 5271, 5272, 5, 903, 0, 0, 5272,
		5404, 1, 0, 0, 0, 5273, 5404, 5, 956, 0, 0, 5274, 5404, 5, 957, 0, 0, 5275,
		5280, 5, 958, 0, 0, 5276, 5277, 5, 896, 0, 0, 5277, 5278, 3, 596, 298,
		0, 5278, 5279, 5, 903, 0, 0, 5279, 5281, 1, 0, 0, 0, 5280, 5276, 1, 0,
		0, 0, 5280, 5281, 1, 0, 0, 0, 5281, 5404, 1, 0, 0, 0, 5282, 5287, 5, 959,
		0, 0, 5283, 5284, 5, 896, 0, 0, 5284, 5285, 3, 596, 298, 0, 5285, 5286,
		5, 903, 0, 0, 5286, 5288, 1, 0, 0, 0, 5287, 5283, 1, 0, 0, 0, 5287, 5288,
		1, 0, 0, 0, 5288, 5404, 1, 0, 0, 0, 5289, 5294, 5, 960, 0, 0, 5290, 5291,
		5, 896, 0, 0, 5291, 5292, 3, 596, 298, 0, 5292, 5293, 5, 903, 0, 0, 5293,
		5295, 1, 0, 0, 0, 5294, 5290, 1, 0, 0, 0, 5294, 5295, 1, 0, 0, 0, 5295,
		5404, 1, 0, 0, 0, 5296, 5301, 5, 961, 0, 0, 5297, 5298, 5, 896, 0, 0, 5298,
		5299, 3, 596, 298, 0, 5299, 5300, 5, 903, 0, 0, 5300, 5302, 1, 0, 0, 0,
		5301, 5297, 1, 0, 0, 0, 5301, 5302, 1, 0, 0, 0, 5302, 5404, 1, 0, 0, 0,
		5303, 5308, 5, 962, 0, 0, 5304, 5305, 5, 896, 0, 0, 5305, 5306, 3, 596,
		298, 0, 5306, 5307, 5, 903, 0, 0, 5307, 5309, 1, 0, 0, 0, 5308, 5304, 1,
		0, 0, 0, 5308, 5309, 1, 0, 0, 0, 5309, 5404, 1, 0, 0, 0, 5310, 5315, 5,
		963, 0, 0, 5311, 5312, 5, 896, 0, 0, 5312, 5313, 3, 596, 298, 0, 5313,
		5314, 5, 903, 0, 0, 5314, 5316, 1, 0, 0, 0, 5315, 5311, 1, 0, 0, 0, 5315,
		5316, 1, 0, 0, 0, 5316, 5404, 1, 0, 0, 0, 5317, 5322, 5, 964, 0, 0, 5318,
		5319, 5, 896, 0, 0, 5319, 5320, 3, 596, 298, 0, 5320, 5321, 5, 903, 0,
		0, 5321, 5323, 1, 0, 0, 0, 5322, 5318, 1, 0, 0, 0, 5322, 5323, 1, 0, 0,
		0, 5323, 5404, 1, 0, 0, 0, 5324, 5329, 5, 965, 0, 0, 5325, 5326, 5, 896,
		0, 0, 5326, 5327, 3, 596, 298, 0, 5327, 5328, 5, 903, 0, 0, 5328, 5330,
		1, 0, 0, 0, 5329, 5325, 1, 0, 0, 0, 5329, 5330, 1, 0, 0, 0, 5330, 5404,
		1, 0, 0, 0, 5331, 5336, 5, 966, 0, 0, 5332, 5333, 5, 896, 0, 0, 5333, 5334,
		3, 596, 298, 0, 5334, 5335, 5, 903, 0, 0, 5335, 5337, 1, 0, 0, 0, 5336,
		5332, 1, 0, 0, 0, 5336, 5337, 1, 0, 0, 0, 5337, 5404, 1, 0, 0, 0, 5338,
		5339, 5, 967, 0, 0, 5339, 5340, 5, 896, 0, 0, 5340, 5341, 3, 516, 258,
		0, 5341, 5342, 5, 903, 0, 0, 5342, 5404, 1, 0, 0, 0, 5343, 5404, 5, 968,
		0, 0, 5344, 5404, 5, 969, 0, 0, 5345, 5404, 5, 970, 0, 0, 5346, 5404, 5,
		971, 0, 0, 5347, 5348, 5, 972, 0, 0, 5348, 5349, 5, 896, 0, 0, 5349, 5350,
		3, 612, 306, 0, 5350, 5351, 5, 903, 0, 0, 5351, 5404, 1, 0, 0, 0, 5352,
		5353, 5, 852, 0, 0, 5353, 5354, 5, 896, 0, 0, 5354, 5355, 3, 612, 306,
		0, 5355, 5356, 5, 903, 0, 0, 5356, 5404, 1, 0, 0, 0, 5357, 5404, 5, 973,
		0, 0, 5358, 5404, 5, 974, 0, 0, 5359, 5360, 5, 975, 0, 0, 5360, 5361, 5,
		896, 0, 0, 5361, 5363, 3, 256, 128, 0, 5362, 5364, 5, 890, 0, 0, 5363,
		5362, 1, 0, 0, 0, 5363, 5364, 1, 0, 0, 0, 5364, 5365, 1, 0, 0, 0, 5365,
		5366, 3, 258, 129, 0, 5366, 5367, 5, 903, 0, 0, 5367, 5404, 1, 0, 0, 0,
		5368, 5404, 5, 976, 0, 0, 5369, 5404, 5, 977, 0, 0, 5370, 5371, 5, 978,
		0, 0, 5371, 5372, 5, 896, 0, 0, 5372, 5373, 5, 921, 0, 0, 5373, 5404, 5,
		903, 0, 0, 5374, 5375, 5, 979, 0, 0, 5375, 5376, 5, 896, 0, 0, 5376, 5377,
		5, 271, 0, 0, 5377, 5404, 5, 903, 0, 0, 5378, 5379, 5, 980, 0, 0, 5379,
		5380, 5, 896, 0, 0, 5380, 5381, 5, 271, 0, 0, 5381, 5404, 5, 903, 0, 0,
		5382, 5383, 5, 981, 0, 0, 5383, 5384, 5, 896, 0, 0, 5384, 5385, 3, 596,
		298, 0, 5385, 5387, 3, 602, 301, 0, 5386, 5388, 5, 890, 0, 0, 5387, 5386,
		1, 0, 0, 0, 5387, 5388, 1, 0, 0, 0, 5388, 5389, 1, 0, 0, 0, 5389, 5393,
		3, 518, 259, 0, 5390, 5391, 3, 274, 137, 0, 5391, 5392, 3, 518, 259, 0,
		5392, 5394, 1, 0, 0, 0, 5393, 5390, 1, 0, 0, 0, 5393, 5394, 1, 0, 0, 0,
		5394, 5395, 1, 0, 0, 0, 5395, 5396, 5, 903, 0, 0, 5396, 5404, 1, 0, 0,
		0, 5397, 5398, 5, 982, 0, 0, 5398, 5399, 5, 896, 0, 0, 5399, 5400, 5, 271,
		0, 0, 5400, 5404, 5, 903, 0, 0, 5401, 5404, 5, 921, 0, 0, 5402, 5404, 5,
		922, 0, 0, 5403, 5152, 1, 0, 0, 0, 5403, 5153, 1, 0, 0, 0, 5403, 5158,
		1, 0, 0, 0, 5403, 5165, 1, 0, 0, 0, 5403, 5169, 1, 0, 0, 0, 5403, 5173,
		1, 0, 0, 0, 5403, 5178, 1, 0, 0, 0, 5403, 5179, 1, 0, 0, 0, 5403, 5183,
		1, 0, 0, 0, 5403, 5189, 1, 0, 0, 0, 5403, 5195, 1, 0, 0, 0, 5403, 5201,
		1, 0, 0, 0, 5403, 5202, 1, 0, 0, 0, 5403, 5208, 1, 0, 0, 0, 5403, 5213,
		1, 0, 0, 0, 5403, 5219, 1, 0, 0, 0, 5403, 5225, 1, 0, 0, 0, 5403, 5231,
		1, 0, 0, 0, 5403, 5237, 1, 0, 0, 0, 5403, 5243, 1, 0, 0, 0, 5403, 5249,
		1, 0, 0, 0, 5403, 5255, 1, 0, 0, 0, 5403, 5261, 1, 0, 0, 0, 5403, 5267,
		1, 0, 0, 0, 5403, 5273, 1, 0, 0, 0, 5403, 5274, 1, 0, 0, 0, 5403, 5275,
		1, 0, 0, 0, 5403, 5282, 1, 0, 0, 0, 5403, 5289, 1, 0, 0, 0, 5403, 5296,
		1, 0, 0, 0, 5403, 5303, 1, 0, 0, 0, 5403, 5310, 1, 0, 0, 0, 5403, 5317,
		1, 0, 0, 0, 5403, 5324, 1, 0, 0, 0, 5403, 5331, 1, 0, 0, 0, 5403, 5338,
		1, 0, 0, 0, 5403, 5343, 1, 0, 0, 0, 5403, 5344, 1, 0, 0, 0, 5403, 5345,
		1, 0, 0, 0, 5403, 5346, 1, 0, 0, 0, 5403, 5347, 1, 0, 0, 0, 5403, 5352,
		1, 0, 0, 0, 5403, 5357, 1, 0, 0, 0, 5403, 5358, 1, 0, 0, 0, 5403, 5359,
		1, 0, 0, 0, 5403, 5368, 1, 0, 0, 0, 5403, 5369, 1, 0, 0, 0, 5403, 5370,
		1, 0, 0, 0, 5403, 5374, 1, 0, 0, 0, 5403, 5378, 1, 0, 0, 0, 5403, 5382,
		1, 0, 0, 0, 5403, 5397, 1, 0, 0, 0, 5403, 5401, 1, 0, 0, 0, 5403, 5402,
		1, 0, 0, 0, 5404, 511, 1, 0, 0, 0, 5405, 5406, 7, 39, 0, 0, 5406, 513,
		1, 0, 0, 0, 5407, 5408, 7, 40, 0, 0, 5408, 515, 1, 0, 0, 0, 5409, 5410,
		7, 41, 0, 0, 5410, 517, 1, 0, 0, 0, 5411, 5412, 7, 42, 0, 0, 5412, 519,
		1, 0, 0, 0, 5413, 5414, 7, 43, 0, 0, 5414, 521, 1, 0, 0, 0, 5415, 5423,
		3, 948, 474, 0, 5416, 5417, 5, 377, 0, 0, 5417, 5423, 5, 883, 0, 0, 5418,
		5419, 5, 377, 0, 0, 5419, 5423, 5, 271, 0, 0, 5420, 5423, 5, 528, 0, 0,
		5421, 5423, 5, 547, 0, 0, 5422, 5415, 1, 0, 0, 0, 5422, 5416, 1, 0, 0,
		0, 5422, 5418, 1, 0, 0, 0, 5422, 5420, 1, 0, 0, 0, 5422, 5421, 1, 0, 0,
		0, 5423, 523, 1, 0, 0, 0, 5424, 5454, 3, 36, 18, 0, 5425, 5426, 3, 36,
		18, 0, 5426, 5427, 5, 80, 0, 0, 5427, 5428, 3, 36, 18, 0, 5428, 5454, 1,
		0, 0, 0, 5429, 5430, 5, 17, 0, 0, 5430, 5431, 3, 36, 18, 0, 5431, 5432,
		5, 80, 0, 0, 5432, 5433, 3, 36, 18, 0, 5433, 5454, 1, 0, 0, 0, 5434, 5435,
		5, 120, 0, 0, 5435, 5436, 3, 36, 18, 0, 5436, 5437, 5, 80, 0, 0, 5437,
		5438, 3, 36, 18, 0, 5438, 5454, 1, 0, 0, 0, 5439, 5440, 5, 224, 0, 0, 5440,
		5441, 3, 36, 18, 0, 5441, 5442, 5, 80, 0, 0, 5442, 5443, 3, 36, 18, 0,
		5443, 5454, 1, 0, 0, 0, 5444, 5445, 5, 17, 0, 0, 5445, 5446, 5, 80, 0,
		0, 5446, 5454, 3, 36, 18, 0, 5447, 5448, 5, 120, 0, 0, 5448, 5449, 5, 80,
		0, 0, 5449, 5454, 3, 36, 18, 0, 5450, 5451, 5, 224, 0, 0, 5451, 5452, 5,
		80, 0, 0, 5452, 5454, 3, 36, 18, 0, 5453, 5424, 1, 0, 0, 0, 5453, 5425,
		1, 0, 0, 0, 5453, 5429, 1, 0, 0, 0, 5453, 5434, 1, 0, 0, 0, 5453, 5439,
		1, 0, 0, 0, 5453, 5444, 1, 0, 0, 0, 5453, 5447, 1, 0, 0, 0, 5453, 5450,
		1, 0, 0, 0, 5454, 525, 1, 0, 0, 0, 5455, 5458, 3, 528, 264, 0, 5456, 5457,
		5, 247, 0, 0, 5457, 5459, 5, 864, 0, 0, 5458, 5456, 1, 0, 0, 0, 5458, 5459,
		1, 0, 0, 0, 5459, 527, 1, 0, 0, 0, 5460, 5465, 3, 530, 265, 0, 5461, 5462,
		5, 890, 0, 0, 5462, 5464, 3, 530, 265, 0, 5463, 5461, 1, 0, 0, 0, 5464,
		5467, 1, 0, 0, 0, 5465, 5463, 1, 0, 0, 0, 5465, 5466, 1, 0, 0, 0, 5466,
		529, 1, 0, 0, 0, 5467, 5465, 1, 0, 0, 0, 5468, 5470, 3, 36, 18, 0, 5469,
		5471, 7, 33, 0, 0, 5470, 5469, 1, 0, 0, 0, 5470, 5471, 1, 0, 0, 0, 5471,
		531, 1, 0, 0, 0, 5472, 5473, 5, 159, 0, 0, 5473, 5474, 5, 19, 0, 0, 5474,
		5475, 3, 534, 267, 0, 5475, 533, 1, 0, 0, 0, 5476, 5481, 3, 536, 268, 0,
		5477, 5478, 5, 890, 0, 0, 5478, 5480, 3, 536, 268, 0, 5479, 5477, 1, 0,
		0, 0, 5480, 5483, 1, 0, 0, 0, 5481, 5479, 1, 0, 0, 0, 5481, 5482, 1, 0,
		0, 0, 5482, 535, 1, 0, 0, 0, 5483, 5481, 1, 0, 0, 0, 5484, 5486, 3, 36,
		18, 0, 5485, 5487, 7, 33, 0, 0, 5486, 5485, 1, 0, 0, 0, 5486, 5487, 1,
		0, 0, 0, 5487, 537, 1, 0, 0, 0, 5488, 5493, 3, 540, 270, 0, 5489, 5490,
		3, 540, 270, 0, 5490, 5491, 3, 540, 270, 0, 5491, 5493, 1, 0, 0, 0, 5492,
		5488, 1, 0, 0, 0, 5492, 5489, 1, 0, 0, 0, 5493, 539, 1, 0, 0, 0, 5494,
		5495, 7, 44, 0, 0, 5495, 541, 1, 0, 0, 0, 5496, 5511, 3, 36, 18, 0, 5497,
		5499, 3, 36, 18, 0, 5498, 5500, 5, 9, 0, 0, 5499, 5498, 1, 0, 0, 0, 5499,
		5500, 1, 0, 0, 0, 5500, 5501, 1, 0, 0, 0, 5501, 5502, 3, 938, 469, 0, 5502,
		5511, 1, 0, 0, 0, 5503, 5505, 3, 36, 18, 0, 5504, 5506, 5, 9, 0, 0, 5505,
		5504, 1, 0, 0, 0, 5505, 5506, 1, 0, 0, 0, 5506, 5507, 1, 0, 0, 0, 5507,
		5508, 5, 923, 0, 0, 5508, 5511, 1, 0, 0, 0, 5509, 5511, 5, 894, 0, 0, 5510,
		5496, 1, 0, 0, 0, 5510, 5497, 1, 0, 0, 0, 5510, 5503, 1, 0, 0, 0, 5510,
		5509, 1, 0, 0, 0, 5511, 543, 1, 0, 0, 0, 5512, 5517, 3, 542, 271, 0, 5513,
		5514, 5, 890, 0, 0, 5514, 5516, 3, 542, 271, 0, 5515, 5513, 1, 0, 0, 0,
		5516, 5519, 1, 0, 0, 0, 5517, 5515, 1, 0, 0, 0, 5517, 5518, 1, 0, 0, 0,
		5518, 545, 1, 0, 0, 0, 5519, 5517, 1, 0, 0, 0, 5520, 5521, 3, 548, 274,
		0, 5521, 547, 1, 0, 0, 0, 5522, 5527, 3, 550, 275, 0, 5523, 5524, 5, 890,
		0, 0, 5524, 5526, 3, 550, 275, 0, 5525, 5523, 1, 0, 0, 0, 5526, 5529, 1,
		0, 0, 0, 5527, 5525, 1, 0, 0, 0, 5527, 5528, 1, 0, 0, 0, 5528, 549, 1,
		0, 0, 0, 5529, 5527, 1, 0, 0, 0, 5530, 5533, 3, 552, 276, 0, 5531, 5533,
		3, 616, 308, 0, 5532, 5530, 1, 0, 0, 0, 5532, 5531, 1, 0, 0, 0, 5533, 551,
		1, 0, 0, 0, 5534, 5542, 3, 554, 277, 0, 5535, 5542, 3, 566, 283, 0, 5536,
		5542, 3, 440, 220, 0, 5537, 5538, 5, 896, 0, 0, 5538, 5539, 3, 548, 274,
		0, 5539, 5540, 5, 903, 0, 0, 5540, 5542, 1, 0, 0, 0, 5541, 5534, 1, 0,
		0, 0, 5541, 5535, 1, 0, 0, 0, 5541, 5536, 1, 0, 0, 0, 5541, 5537, 1, 0,
		0, 0, 5542, 553, 1, 0, 0, 0, 5543, 5545, 3, 584, 292, 0, 5544, 5546, 3,
		568, 284, 0, 5545, 5544, 1, 0, 0, 0, 5545, 5546, 1, 0, 0, 0, 5546, 5550,
		1, 0, 0, 0, 5547, 5548, 3, 564, 282, 0, 5548, 5549, 3, 560, 280, 0, 5549,
		5551, 1, 0, 0, 0, 5550, 5547, 1, 0, 0, 0, 5550, 5551, 1, 0, 0, 0, 5551,
		5553, 1, 0, 0, 0, 5552, 5554, 3, 582, 291, 0, 5553, 5552, 1, 0, 0, 0, 5553,
		5554, 1, 0, 0, 0, 5554, 5597, 1, 0, 0, 0, 5555, 5557, 3, 584, 292, 0, 5556,
		5558, 3, 568, 284, 0, 5557, 5556, 1, 0, 0, 0, 5557, 5558, 1, 0, 0, 0, 5558,
		5562, 1, 0, 0, 0, 5559, 5560, 3, 564, 282, 0, 5560, 5561, 3, 560, 280,
		0, 5561, 5563, 1, 0, 0, 0, 5562, 5559, 1, 0, 0, 0, 5562, 5563, 1, 0, 0,
		0, 5563, 5564, 1, 0, 0, 0, 5564, 5565, 5, 9, 0, 0, 5565, 5567, 3, 934,
		467, 0, 5566, 5568, 3, 582, 291, 0, 5567, 5566, 1, 0, 0, 0, 5567, 5568,
		1, 0, 0, 0, 5568, 5597, 1, 0, 0, 0, 5569, 5571, 3, 584, 292, 0, 5570, 5572,
		3, 568, 284, 0, 5571, 5570, 1, 0, 0, 0, 5571, 5572, 1, 0, 0, 0, 5572, 5573,
		1, 0, 0, 0, 5573, 5575, 3, 934, 467, 0, 5574, 5576, 3, 582, 291, 0, 5575,
		5574, 1, 0, 0, 0, 5575, 5576, 1, 0, 0, 0, 5576, 5597, 1, 0, 0, 0, 5577,
		5579, 3, 584, 292, 0, 5578, 5580, 3, 568, 284, 0, 5579, 5578, 1, 0, 0,
		0, 5579, 5580, 1, 0, 0, 0, 5580, 5581, 1, 0, 0, 0, 5581, 5582, 3, 564,
		282, 0, 5582, 5583, 3, 558, 279, 0, 5583, 5585, 3, 934, 467, 0, 5584, 5586,
		3, 582, 291, 0, 5585, 5584, 1, 0, 0, 0, 5585, 5586, 1, 0, 0, 0, 5586, 5597,
		1, 0, 0, 0, 5587, 5589, 3, 584, 292, 0, 5588, 5590, 3, 568, 284, 0, 5589,
		5588, 1, 0, 0, 0, 5589, 5590, 1, 0, 0, 0, 5590, 5591, 1, 0, 0, 0, 5591,
		5592, 3, 564, 282, 0, 5592, 5594, 3, 934, 467, 0, 5593, 5595, 3, 582, 291,
		0, 5594, 5593, 1, 0, 0, 0, 5594, 5595, 1, 0, 0, 0, 5595, 5597, 1, 0, 0,
		0, 5596, 5543, 1, 0, 0, 0, 5596, 5555, 1, 0, 0, 0, 5596, 5569, 1, 0, 0,
		0, 5596, 5577, 1, 0, 0, 0, 5596, 5587, 1, 0, 0, 0, 5597, 555, 1, 0, 0,
		0, 5598, 5600, 3, 584, 292, 0, 5599, 5601, 3, 568, 284, 0, 5600, 5599,
		1, 0, 0, 0, 5600, 5601, 1, 0, 0, 0, 5601, 557, 1, 0, 0, 0, 5602, 5603,
		5, 759, 0, 0, 5603, 5604, 5, 896, 0, 0, 5604, 5605, 5, 271, 0, 0, 5605,
		5606, 5, 903, 0, 0, 5606, 559, 1, 0, 0, 0, 5607, 5609, 3, 558, 279, 0,
		5608, 5607, 1, 0, 0, 0, 5608, 5609, 1, 0, 0, 0, 5609, 561, 1, 0, 0, 0,
		5610, 5611, 7, 1, 0, 0, 5611, 563, 1, 0, 0, 0, 5612, 5614, 5, 331, 0, 0,
		5613, 5615, 5, 861, 0, 0, 5614, 5613, 1, 0, 0, 0, 5614, 5615, 1, 0, 0,
		0, 5615, 5617, 1, 0, 0, 0, 5616, 5618, 7, 45, 0, 0, 5617, 5616, 1, 0, 0,
		0, 5617, 5618, 1, 0, 0, 0, 5618, 5619, 1, 0, 0, 0, 5619, 5620, 5, 896,
		0, 0, 5620, 5621, 3, 562, 281, 0, 5621, 5622, 5, 903, 0, 0, 5622, 565,
		1, 0, 0, 0, 5623, 5625, 3, 440, 220, 0, 5624, 5626, 5, 9, 0, 0, 5625, 5624,
		1, 0, 0, 0, 5625, 5626, 1, 0, 0, 0, 5626, 5627, 1, 0, 0, 0, 5627, 5628,
		3, 934, 467, 0, 5628, 567, 1, 0, 0, 0, 5629, 5630, 5, 166, 0, 0, 5630,
		5631, 5, 896, 0, 0, 5631, 5632, 3, 508, 254, 0, 5632, 5633, 5, 903, 0,
		0, 5633, 569, 1, 0, 0, 0, 5634, 5635, 7, 46, 0, 0, 5635, 571, 1, 0, 0,
		0, 5636, 5637, 7, 47, 0, 0, 5637, 573, 1, 0, 0, 0, 5638, 5648, 3, 948,
		474, 0, 5639, 5640, 5, 78, 0, 0, 5640, 5648, 5, 115, 0, 0, 5641, 5642,
		5, 78, 0, 0, 5642, 5643, 5, 159, 0, 0, 5643, 5648, 5, 19, 0, 0, 5644, 5645,
		5, 78, 0, 0, 5645, 5646, 5, 86, 0, 0, 5646, 5648, 5, 19, 0, 0, 5647, 5638,
		1, 0, 0, 0, 5647, 5639, 1, 0, 0, 0, 5647, 5641, 1, 0, 0, 0, 5647, 5644,
		1, 0, 0, 0, 5648, 575, 1, 0, 0, 0, 5649, 5650, 7, 48, 0, 0, 5650, 577,
		1, 0, 0, 0, 5651, 5656, 3, 576, 288, 0, 5652, 5653, 5, 890, 0, 0, 5653,
		5655, 3, 576, 288, 0, 5654, 5652, 1, 0, 0, 0, 5655, 5658, 1, 0, 0, 0, 5656,
		5654, 1, 0, 0, 0, 5656, 5657, 1, 0, 0, 0, 5657, 579, 1, 0, 0, 0, 5658,
		5656, 1, 0, 0, 0, 5659, 5660, 5, 233, 0, 0, 5660, 5661, 3, 572, 286, 0,
		5661, 5662, 3, 574, 287, 0, 5662, 5664, 5, 896, 0, 0, 5663, 5665, 3, 578,
		289, 0, 5664, 5663, 1, 0, 0, 0, 5664, 5665, 1, 0, 0, 0, 5665, 5666, 1,
		0, 0, 0, 5666, 5667, 5, 903, 0, 0, 5667, 5676, 1, 0, 0, 0, 5668, 5669,
		3, 570, 285, 0, 5669, 5670, 3, 572, 286, 0, 5670, 5671, 3, 574, 287, 0,
		5671, 5672, 5, 896, 0, 0, 5672, 5673, 3, 578, 289, 0, 5673, 5674, 5, 903,
		0, 0, 5674, 5676, 1, 0, 0, 0, 5675, 5659, 1, 0, 0, 0, 5675, 5668, 1, 0,
		0, 0, 5676, 581, 1, 0, 0, 0, 5677, 5682, 3, 580, 290, 0, 5678, 5679, 3,
		580, 290, 0, 5679, 5680, 3, 582, 291, 0, 5680, 5682, 1, 0, 0, 0, 5681,
		5677, 1, 0, 0, 0, 5681, 5678, 1, 0, 0, 0, 5682, 583, 1, 0, 0, 0, 5683,
		5686, 3, 590, 295, 0, 5684, 5686, 3, 592, 296, 0, 5685, 5683, 1, 0, 0,
		0, 5685, 5684, 1, 0, 0, 0, 5686, 585, 1, 0, 0, 0, 5687, 5692, 3, 588, 294,
		0, 5688, 5689, 5, 890, 0, 0, 5689, 5691, 3, 588, 294, 0, 5690, 5688, 1,
		0, 0, 0, 5691, 5694, 1, 0, 0, 0, 5692, 5690, 1, 0, 0, 0, 5692, 5693, 1,
		0, 0, 0, 5693, 587, 1, 0, 0, 0, 5694, 5692, 1, 0, 0, 0, 5695, 5698, 3,
		934, 467, 0, 5696, 5697, 5, 901, 0, 0, 5697, 5699, 5, 894, 0, 0, 5698,
		5696, 1, 0, 0, 0, 5698, 5699, 1, 0, 0, 0, 5699, 5708, 1, 0, 0, 0, 5700,
		5701, 3, 934, 467, 0, 5701, 5702, 5, 901, 0, 0, 5702, 5705, 3, 934, 467,
		0, 5703, 5704, 5, 901, 0, 0, 5704, 5706, 5, 894, 0, 0, 5705, 5703, 1, 0,
		0, 0, 5705, 5706, 1, 0, 0, 0, 5706, 5708, 1, 0, 0, 0, 5707, 5695, 1, 0,
		0, 0, 5707, 5700, 1, 0, 0, 0, 5708, 589, 1, 0, 0, 0, 5709, 5715, 3, 934,
		467, 0, 5710, 5711, 3, 934, 467, 0, 5711, 5712, 5, 901, 0, 0, 5712, 5713,
		3, 934, 467, 0, 5713, 5715, 1, 0, 0, 0, 5714, 5709, 1, 0, 0, 0, 5714, 5710,
		1, 0, 0, 0, 5715, 591, 1, 0, 0, 0, 5716, 5717, 5, 901, 0, 0, 5717, 5718,
		3, 934, 467, 0, 5718, 593, 1, 0, 0, 0, 5719, 5720, 3, 590, 295, 0, 5720,
		5721, 3, 596, 298, 0, 5721, 595, 1, 0, 0, 0, 5722, 5723, 5, 885, 0, 0,
		5723, 5726, 5, 921, 0, 0, 5724, 5726, 3, 948, 474, 0, 5725, 5722, 1, 0,
		0, 0, 5725, 5724, 1, 0, 0, 0, 5726, 597, 1, 0, 0, 0, 5727, 5733, 3, 594,
		297, 0, 5728, 5729, 3, 600, 300, 0, 5729, 5730, 3, 594, 297, 0, 5730, 5732,
		1, 0, 0, 0, 5731, 5728, 1, 0, 0, 0, 5732, 5735, 1, 0, 0, 0, 5733, 5731,
		1, 0, 0, 0, 5733, 5734, 1, 0, 0, 0, 5734, 599, 1, 0, 0, 0, 5735, 5733,
		1, 0, 0, 0, 5736, 5738, 5, 890, 0, 0, 5737, 5736, 1, 0, 0, 0, 5737, 5738,
		1, 0, 0, 0, 5738, 601, 1, 0, 0, 0, 5739, 5745, 3, 594, 297, 0, 5740, 5741,
		5, 896, 0, 0, 5741, 5742, 3, 598, 299, 0, 5742, 5743, 5, 903, 0, 0, 5743,
		5745, 1, 0, 0, 0, 5744, 5739, 1, 0, 0, 0, 5744, 5740, 1, 0, 0, 0, 5745,
		603, 1, 0, 0, 0, 5746, 5747, 5, 896, 0, 0, 5747, 5748, 3, 598, 299, 0,
		5748, 5749, 5, 903, 0, 0, 5749, 605, 1, 0, 0, 0, 5750, 5751, 6, 303, -1,
		0, 5751, 5763, 3, 604, 302, 0, 5752, 5753, 5, 896, 0, 0, 5753, 5754, 3,
		606, 303, 0, 5754, 5755, 5, 903, 0, 0, 5755, 5763, 1, 0, 0, 0, 5756, 5757,
		5, 896, 0, 0, 5757, 5758, 3, 598, 299, 0, 5758, 5759, 3, 600, 300, 0, 5759,
		5760, 3, 606, 303, 0, 5760, 5761, 5, 903, 0, 0, 5761, 5763, 1, 0, 0, 0,
		5762, 5750, 1, 0, 0, 0, 5762, 5752, 1, 0, 0, 0, 5762, 5756, 1, 0, 0, 0,
		5763, 5782, 1, 0, 0, 0, 5764, 5765, 10, 5, 0, 0, 5765, 5766, 3, 600, 300,
		0, 5766, 5767, 3, 604, 302, 0, 5767, 5781, 1, 0, 0, 0, 5768, 5769, 10,
		4, 0, 0, 5769, 5770, 3, 600, 300, 0, 5770, 5771, 3, 594, 297, 0, 5771,
		5781, 1, 0, 0, 0, 5772, 5773, 10, 1, 0, 0, 5773, 5774, 3, 600, 300, 0,
		5774, 5775, 5, 896, 0, 0, 5775, 5776, 3, 598, 299, 0, 5776, 5777, 3, 600,
		300, 0, 5777, 5778, 3, 606, 303, 0, 5778, 5779, 5, 903, 0, 0, 5779, 5781,
		1, 0, 0, 0, 5780, 5764, 1, 0, 0, 0, 5780, 5768, 1, 0, 0, 0, 5780, 5772,
		1, 0, 0, 0, 5781, 5784, 1, 0, 0, 0, 5782, 5780, 1, 0, 0, 0, 5782, 5783,
		1, 0, 0, 0, 5783, 607, 1, 0, 0, 0, 5784, 5782, 1, 0, 0, 0, 5785, 5791,
		3, 606, 303, 0, 5786, 5787, 3, 598, 299, 0, 5787, 5788, 3, 600, 300, 0,
		5788, 5789, 3, 606, 303, 0, 5789, 5791, 1, 0, 0, 0, 5790, 5785, 1, 0, 0,
		0, 5790, 5786, 1, 0, 0, 0, 5791, 609, 1, 0, 0, 0, 5792, 5793, 6, 305, -1,
		0, 5793, 5799, 3, 594, 297, 0, 5794, 5795, 5, 896, 0, 0, 5795, 5796, 3,
		598, 299, 0, 5796, 5797, 5, 903, 0, 0, 5797, 5799, 1, 0, 0, 0, 5798, 5792,
		1, 0, 0, 0, 5798, 5794, 1, 0, 0, 0, 5799, 5812, 1, 0, 0, 0, 5800, 5801,
		10, 2, 0, 0, 5801, 5802, 3, 600, 300, 0, 5802, 5803, 3, 594, 297, 0, 5803,
		5811, 1, 0, 0, 0, 5804, 5805, 10, 1, 0, 0, 5805, 5806, 3, 600, 300, 0,
		5806, 5807, 5, 896, 0, 0, 5807, 5808, 3, 598, 299, 0, 5808, 5809, 5, 903,
		0, 0, 5809, 5811, 1, 0, 0, 0, 5810, 5800, 1, 0, 0, 0, 5810, 5804, 1, 0,
		0, 0, 5811, 5814, 1, 0, 0, 0, 5812, 5810, 1, 0, 0, 0, 5812, 5813, 1, 0,
		0, 0, 5813, 611, 1, 0, 0, 0, 5814, 5812, 1, 0, 0, 0, 5815, 5816, 5, 271,
		0, 0, 5816, 5817, 3, 600, 300, 0, 5817, 5818, 3, 612, 306, 0, 5818, 5821,
		1, 0, 0, 0, 5819, 5821, 5, 271, 0, 0, 5820, 5815, 1, 0, 0, 0, 5820, 5819,
		1, 0, 0, 0, 5821, 613, 1, 0, 0, 0, 5822, 5823, 5, 154, 0, 0, 5823, 5830,
		3, 36, 18, 0, 5824, 5825, 5, 234, 0, 0, 5825, 5826, 5, 896, 0, 0, 5826,
		5827, 3, 428, 214, 0, 5827, 5828, 5, 903, 0, 0, 5828, 5830, 1, 0, 0, 0,
		5829, 5822, 1, 0, 0, 0, 5829, 5824, 1, 0, 0, 0, 5830, 615, 1, 0, 0, 0,
		5831, 5832, 6, 308, -1, 0, 5832, 5833, 3, 552, 276, 0, 5833, 5834, 3, 620,
		310, 0, 5834, 5835, 3, 552, 276, 0, 5835, 5860, 1, 0, 0, 0, 5836, 5837,
		3, 552, 276, 0, 5837, 5838, 3, 620, 310, 0, 5838, 5839, 3, 552, 276, 0,
		5839, 5840, 5, 154, 0, 0, 5840, 5841, 3, 36, 18, 0, 5841, 5860, 1, 0, 0,
		0, 5842, 5843, 3, 552, 276, 0, 5843, 5844, 3, 620, 310, 0, 5844, 5845,
		3, 552, 276, 0, 5845, 5846, 5, 234, 0, 0, 5846, 5847, 5, 896, 0, 0, 5847,
		5848, 3, 428, 214, 0, 5848, 5849, 5, 903, 0, 0, 5849, 5860, 1, 0, 0, 0,
		5850, 5851, 3, 552, 276, 0, 5851, 5852, 3, 622, 311, 0, 5852, 5853, 3,
		552, 276, 0, 5853, 5854, 3, 614, 307, 0, 5854, 5860, 1, 0, 0, 0, 5855,
		5856, 3, 552, 276, 0, 5856, 5857, 3, 618, 309, 0, 5857, 5858, 3, 552, 276,
		0, 5858, 5860, 1, 0, 0, 0, 5859, 5831, 1, 0, 0, 0, 5859, 5836, 1, 0, 0,
		0, 5859, 5842, 1, 0, 0, 0, 5859, 5850, 1, 0, 0, 0, 5859, 5855, 1, 0, 0,
		0, 5860, 5890, 1, 0, 0, 0, 5861, 5862, 10, 9, 0, 0, 5862, 5863, 3, 620,
		310, 0, 5863, 5864, 3, 552, 276, 0, 5864, 5889, 1, 0, 0, 0, 5865, 5866,
		10, 7, 0, 0, 5866, 5867, 3, 620, 310, 0, 5867, 5868, 3, 552, 276, 0, 5868,
		5869, 5, 154, 0, 0, 5869, 5870, 3, 36, 18, 0, 5870, 5889, 1, 0, 0, 0, 5871,
		5872, 10, 5, 0, 0, 5872, 5873, 3, 620, 310, 0, 5873, 5874, 3, 552, 276,
		0, 5874, 5875, 5, 234, 0, 0, 5875, 5876, 5, 896, 0, 0, 5876, 5877, 3, 428,
		214, 0, 5877, 5878, 5, 903, 0, 0, 5878, 5889, 1, 0, 0, 0, 5879, 5880, 10,
		3, 0, 0, 5880, 5881, 3, 622, 311, 0, 5881, 5882, 3, 552, 276, 0, 5882,
		5883, 3, 614, 307, 0, 5883, 5889, 1, 0, 0, 0, 5884, 5885, 10, 1, 0, 0,
		5885, 5886, 3, 618, 309, 0, 5886, 5887, 3, 552, 276, 0, 5887, 5889, 1,
		0, 0, 0, 5888, 5861, 1, 0, 0, 0, 5888, 5865, 1, 0, 0, 0, 5888, 5871, 1,
		0, 0, 0, 5888, 5879, 1, 0, 0, 0, 5888, 5884, 1, 0, 0, 0, 5889, 5892, 1,
		0, 0, 0, 5890, 5888, 1, 0, 0, 0, 5890, 5891, 1, 0, 0, 0, 5891, 617, 1,
		0, 0, 0, 5892, 5890, 1, 0, 0, 0, 5893, 5894, 5, 152, 0, 0, 5894, 5901,
		3, 622, 311, 0, 5895, 5897, 5, 152, 0, 0, 5896, 5898, 5, 97, 0, 0, 5897,
		5896, 1, 0, 0, 0, 5897, 5898, 1, 0, 0, 0, 5898, 5899, 1, 0, 0, 0, 5899,
		5901, 5, 115, 0, 0, 5900, 5893, 1, 0, 0, 0, 5900, 5895, 1, 0, 0, 0, 5901,
		619, 1, 0, 0, 0, 5902, 5908, 5, 115, 0, 0, 5903, 5904, 5, 97, 0, 0, 5904,
		5908, 5, 115, 0, 0, 5905, 5906, 5, 35, 0, 0, 5906, 5908, 5, 115, 0, 0,
		5907, 5902, 1, 0, 0, 0, 5907, 5903, 1, 0, 0, 0, 5907, 5905, 1, 0, 0, 0,
		5908, 621, 1, 0, 0, 0, 5909, 5911, 5, 81, 0, 0, 5910, 5912, 5, 161, 0,
		0, 5911, 5910, 1, 0, 0, 0, 5911, 5912, 1, 0, 0, 0, 5912, 5913, 1, 0, 0,
		0, 5913, 5925, 5, 115, 0, 0, 5914, 5916, 5, 122, 0, 0, 5915, 5917, 5, 161,
		0, 0, 5916, 5915, 1, 0, 0, 0, 5916, 5917, 1, 0, 0, 0, 5917, 5918, 1, 0,
		0, 0, 5918, 5925, 5, 115, 0, 0, 5919, 5921, 5, 186, 0, 0, 5920, 5922, 5,
		161, 0, 0, 5921, 5920, 1, 0, 0, 0, 5921, 5922, 1, 0, 0, 0, 5922, 5923,
		1, 0, 0, 0, 5923, 5925, 5, 115, 0, 0, 5924, 5909, 1, 0, 0, 0, 5924, 5914,
		1, 0, 0, 0, 5924, 5919, 1, 0, 0, 0, 5925, 623, 1, 0, 0, 0, 5926, 5927,
		5, 7, 0, 0, 5927, 5928, 5, 220, 0, 0, 5928, 5929, 3, 584, 292, 0, 5929,
		5930, 5, 231, 0, 0, 5930, 5931, 5, 699, 0, 0, 5931, 5932, 5, 154, 0, 0,
		5932, 5933, 3, 312, 156, 0, 5933, 5934, 5, 247, 0, 0, 5934, 5935, 5, 271,
		0, 0, 5935, 5936, 5, 854, 0, 0, 5936, 5946, 1, 0, 0, 0, 5937, 5938, 5,
		7, 0, 0, 5938, 5939, 5, 220, 0, 0, 5939, 5940, 3, 584, 292, 0, 5940, 5941,
		5, 62, 0, 0, 5941, 5942, 5, 699, 0, 0, 5942, 5943, 5, 154, 0, 0, 5943,
		5944, 3, 312, 156, 0, 5944, 5946, 1, 0, 0, 0, 5945, 5926, 1, 0, 0, 0, 5945,
		5937, 1, 0, 0, 0, 5946, 625, 1, 0, 0, 0, 5947, 5950, 5, 34, 0, 0, 5948,
		5949, 5, 158, 0, 0, 5949, 5951, 5, 179, 0, 0, 5950, 5948, 1, 0, 0, 0, 5950,
		5951, 1, 0, 0, 0, 5951, 5952, 1, 0, 0, 0, 5952, 5953, 5, 648, 0, 0, 5953,
		5954, 3, 934, 467, 0, 5954, 5955, 5, 154, 0, 0, 5955, 5958, 3, 636, 318,
		0, 5956, 5957, 5, 223, 0, 0, 5957, 5959, 3, 636, 318, 0, 5958, 5956, 1,
		0, 0, 0, 5958, 5959, 1, 0, 0, 0, 5959, 5974, 1, 0, 0, 0, 5960, 5963, 5,
		34, 0, 0, 5961, 5962, 5, 158, 0, 0, 5962, 5964, 5, 179, 0, 0, 5963, 5961,
		1, 0, 0, 0, 5963, 5964, 1, 0, 0, 0, 5964, 5965, 1, 0, 0, 0, 5965, 5966,
		5, 648, 0, 0, 5966, 5967, 3, 934, 467, 0, 5967, 5968, 5, 154, 0, 0, 5968,
		5969, 5, 923, 0, 0, 5969, 5970, 5, 234, 0, 0, 5970, 5971, 5, 985, 0, 0,
		5971, 5972, 3, 502, 251, 0, 5972, 5974, 1, 0, 0, 0, 5973, 5947, 1, 0, 0,
		0, 5973, 5960, 1, 0, 0, 0, 5974, 627, 1, 0, 0, 0, 5975, 5976, 5, 4, 0,
		0, 5976, 5977, 5, 648, 0, 0, 5977, 5978, 3, 934, 467, 0, 5978, 5979, 5,
		2, 0, 0, 5979, 5982, 3, 636, 318, 0, 5980, 5981, 5, 223, 0, 0, 5981, 5983,
		3, 636, 318, 0, 5982, 5980, 1, 0, 0, 0, 5982, 5983, 1, 0, 0, 0, 5983, 629,
		1, 0, 0, 0, 5984, 5985, 5, 62, 0, 0, 5985, 5986, 5, 648, 0, 0, 5986, 5987,
		3, 584, 292, 0, 5987, 631, 1, 0, 0, 0, 5988, 5989, 3, 634, 317, 0, 5989,
		5992, 3, 584, 292, 0, 5990, 5993, 5, 923, 0, 0, 5991, 5993, 3, 932, 466,
		0, 5992, 5990, 1, 0, 0, 0, 5992, 5991, 1, 0, 0, 0, 5992, 5993, 1, 0, 0,
		0, 5993, 6028, 1, 0, 0, 0, 5994, 5995, 3, 634, 317, 0, 5995, 5996, 3, 636,
		318, 0, 5996, 6028, 1, 0, 0, 0, 5997, 5998, 3, 634, 317, 0, 5998, 5999,
		5, 873, 0, 0, 5999, 6000, 3, 636, 318, 0, 6000, 6028, 1, 0, 0, 0, 6001,
		6002, 3, 634, 317, 0, 6002, 6003, 5, 648, 0, 0, 6003, 6004, 3, 636, 318,
		0, 6004, 6028, 1, 0, 0, 0, 6005, 6006, 3, 634, 317, 0, 6006, 6007, 5, 810,
		0, 0, 6007, 6008, 3, 636, 318, 0, 6008, 6028, 1, 0, 0, 0, 6009, 6010, 3,
		634, 317, 0, 6010, 6011, 5, 754, 0, 0, 6011, 6012, 3, 636, 318, 0, 6012,
		6028, 1, 0, 0, 0, 6013, 6014, 3, 634, 317, 0, 6014, 6015, 5, 743, 0, 0,
		6015, 6016, 3, 636, 318, 0, 6016, 6028, 1, 0, 0, 0, 6017, 6018, 3, 634,
		317, 0, 6018, 6019, 5, 408, 0, 0, 6019, 6020, 3, 636, 318, 0, 6020, 6028,
		1, 0, 0, 0, 6021, 6022, 3, 634, 317, 0, 6022, 6023, 5, 274, 0, 0, 6023,
		6024, 5, 908, 0, 0, 6024, 6025, 3, 638, 319, 0, 6025, 6026, 3, 636, 318,
		0, 6026, 6028, 1, 0, 0, 0, 6027, 5988, 1, 0, 0, 0, 6027, 5994, 1, 0, 0,
		0, 6027, 5997, 1, 0, 0, 0, 6027, 6001, 1, 0, 0, 0, 6027, 6005, 1, 0, 0,
		0, 6027, 6009, 1, 0, 0, 0, 6027, 6013, 1, 0, 0, 0, 6027, 6017, 1, 0, 0,
		0, 6027, 6021, 1, 0, 0, 0, 6028, 633, 1, 0, 0, 0, 6029, 6030, 7, 49, 0,
		0, 6030, 635, 1, 0, 0, 0, 6031, 6036, 3, 436, 218, 0, 6032, 6036, 3, 110,
		55, 0, 6033, 6036, 3, 416, 208, 0, 6034, 6036, 3, 114, 57, 0, 6035, 6031,
		1, 0, 0, 0, 6035, 6032, 1, 0, 0, 0, 6035, 6033, 1, 0, 0, 0, 6035, 6034,
		1, 0, 0, 0, 6036, 637, 1, 0, 0, 0, 6037, 6038, 7, 50, 0, 0, 6038, 639,
		1, 0, 0, 0, 6039, 6041, 5, 195, 0, 0, 6040, 6042, 5, 81, 0, 0, 6041, 6040,
		1, 0, 0, 0, 6041, 6042, 1, 0, 0, 0, 6042, 6043, 1, 0, 0, 0, 6043, 6047,
		5, 389, 0, 0, 6044, 6045, 3, 652, 326, 0, 6045, 6046, 3, 158, 79, 0, 6046,
		6048, 1, 0, 0, 0, 6047, 6044, 1, 0, 0, 0, 6047, 6048, 1, 0, 0, 0, 6048,
		6057, 1, 0, 0, 0, 6049, 6050, 5, 124, 0, 0, 6050, 6058, 5, 923, 0, 0, 6051,
		6052, 5, 124, 0, 0, 6052, 6053, 5, 923, 0, 0, 6053, 6054, 5, 793, 0, 0,
		6054, 6058, 5, 923, 0, 0, 6055, 6056, 5, 243, 0, 0, 6056, 6058, 3, 36,
		18, 0, 6057, 6049, 1, 0, 0, 0, 6057, 6051, 1, 0, 0, 0, 6057, 6055, 1, 0,
		0, 0, 6057, 6058, 1, 0, 0, 0, 6058, 6363, 1, 0, 0, 0, 6059, 6060, 5, 195,
		0, 0, 6060, 6062, 3, 642, 321, 0, 6061, 6063, 5, 404, 0, 0, 6062, 6061,
		1, 0, 0, 0, 6062, 6063, 1, 0, 0, 0, 6063, 6072, 1, 0, 0, 0, 6064, 6065,
		5, 124, 0, 0, 6065, 6073, 5, 923, 0, 0, 6066, 6067, 5, 124, 0, 0, 6067,
		6068, 5, 923, 0, 0, 6068, 6069, 5, 793, 0, 0, 6069, 6073, 5, 923, 0, 0,
		6070, 6071, 5, 243, 0, 0, 6071, 6073, 3, 36, 18, 0, 6072, 6064, 1, 0, 0,
		0, 6072, 6066, 1, 0, 0, 0, 6072, 6070, 1, 0, 0, 0, 6072, 6073, 1, 0, 0,
		0, 6073, 6363, 1, 0, 0, 0, 6074, 6076, 5, 195, 0, 0, 6075, 6077, 5, 81,
		0, 0, 6076, 6075, 1, 0, 0, 0, 6076, 6077, 1, 0, 0, 0, 6077, 6078, 1, 0,
		0, 0, 6078, 6079, 3, 646, 323, 0, 6079, 6080, 3, 652, 326, 0, 6080, 6084,
		3, 584, 292, 0, 6081, 6082, 3, 652, 326, 0, 6082, 6083, 3, 158, 79, 0,
		6083, 6085, 1, 0, 0, 0, 6084, 6081, 1, 0, 0, 0, 6084, 6085, 1, 0, 0, 0,
		6085, 6094, 1, 0, 0, 0, 6086, 6087, 5, 124, 0, 0, 6087, 6095, 5, 923, 0,
		0, 6088, 6089, 5, 124, 0, 0, 6089, 6090, 5, 923, 0, 0, 6090, 6091, 5, 793,
		0, 0, 6091, 6095, 5, 923, 0, 0, 6092, 6093, 5, 243, 0, 0, 6093, 6095, 3,
		36, 18, 0, 6094, 6086, 1, 0, 0, 0, 6094, 6088, 1, 0, 0, 0, 6094, 6092,
		1, 0, 0, 0, 6094, 6095, 1, 0, 0, 0, 6095, 6363, 1, 0, 0, 0, 6096, 6097,
		5, 195, 0, 0, 6097, 6098, 5, 220, 0, 0, 6098, 6102, 5, 404, 0, 0, 6099,
		6100, 3, 652, 326, 0, 6100, 6101, 3, 158, 79, 0, 6101, 6103, 1, 0, 0, 0,
		6102, 6099, 1, 0, 0, 0, 6102, 6103, 1, 0, 0, 0, 6103, 6112, 1, 0, 0, 0,
		6104, 6105, 5, 124, 0, 0, 6105, 6113, 5, 923, 0, 0, 6106, 6107, 5, 124,
		0, 0, 6107, 6108, 5, 923, 0, 0, 6108, 6109, 5, 793, 0, 0, 6109, 6113, 5,
		923, 0, 0, 6110, 6111, 5, 243, 0, 0, 6111, 6113, 3, 36, 18, 0, 6112, 6104,
		1, 0, 0, 0, 6112, 6106, 1, 0, 0, 0, 6112, 6110, 1, 0, 0, 0, 6112, 6113,
		1, 0, 0, 0, 6113, 6363, 1, 0, 0, 0, 6114, 6115, 5, 195, 0, 0, 6115, 6116,
		5, 164, 0, 0, 6116, 6120, 5, 404, 0, 0, 6117, 6118, 3, 652, 326, 0, 6118,
		6119, 3, 158, 79, 0, 6119, 6121, 1, 0, 0, 0, 6120, 6117, 1, 0, 0, 0, 6120,
		6121, 1, 0, 0, 0, 6121, 6130, 1, 0, 0, 0, 6122, 6123, 5, 124, 0, 0, 6123,
		6131, 5, 923, 0, 0, 6124, 6125, 5, 124, 0, 0, 6125, 6126, 5, 923, 0, 0,
		6126, 6127, 5, 793, 0, 0, 6127, 6131, 5, 923, 0, 0, 6128, 6129, 5, 243,
		0, 0, 6129, 6131, 3, 36, 18, 0, 6130, 6122, 1, 0, 0, 0, 6130, 6124, 1,
		0, 0, 0, 6130, 6128, 1, 0, 0, 0, 6130, 6131, 1, 0, 0, 0, 6131, 6363, 1,
		0, 0, 0, 6132, 6133, 5, 195, 0, 0, 6133, 6134, 5, 527, 0, 0, 6134, 6138,
		5, 404, 0, 0, 6135, 6136, 3, 652, 326, 0, 6136, 6137, 3, 158, 79, 0, 6137,
		6139, 1, 0, 0, 0, 6138, 6135, 1, 0, 0, 0, 6138, 6139, 1, 0, 0, 0, 6139,
		6148, 1, 0, 0, 0, 6140, 6141, 5, 124, 0, 0, 6141, 6149, 5, 923, 0, 0, 6142,
		6143, 5, 124, 0, 0, 6143, 6144, 5, 923, 0, 0, 6144, 6145, 5, 793, 0, 0,
		6145, 6149, 5, 923, 0, 0, 6146, 6147, 5, 243, 0, 0, 6147, 6149, 3, 36,
		18, 0, 6148, 6140, 1, 0, 0, 0, 6148, 6142, 1, 0, 0, 0, 6148, 6146, 1, 0,
		0, 0, 6148, 6149, 1, 0, 0, 0, 6149, 6363, 1, 0, 0, 0, 6150, 6151, 5, 195,
		0, 0, 6151, 6152, 5, 494, 0, 0, 6152, 6161, 5, 404, 0, 0, 6153, 6154, 5,
		124, 0, 0, 6154, 6162, 5, 923, 0, 0, 6155, 6156, 5, 124, 0, 0, 6156, 6157,
		5, 923, 0, 0, 6157, 6158, 5, 793, 0, 0, 6158, 6162, 5, 923, 0, 0, 6159,
		6160, 5, 243, 0, 0, 6160, 6162, 3, 36, 18, 0, 6161, 6153, 1, 0, 0, 0, 6161,
		6155, 1, 0, 0, 0, 6161, 6159, 1, 0, 0, 0, 6161, 6162, 1, 0, 0, 0, 6162,
		6363, 1, 0, 0, 0, 6163, 6165, 5, 195, 0, 0, 6164, 6166, 7, 51, 0, 0, 6165,
		6164, 1, 0, 0, 0, 6165, 6166, 1, 0, 0, 0, 6166, 6167, 1, 0, 0, 0, 6167,
		6176, 5, 613, 0, 0, 6168, 6169, 5, 124, 0, 0, 6169, 6177, 5, 923, 0, 0,
		6170, 6171, 5, 124, 0, 0, 6171, 6172, 5, 923, 0, 0, 6172, 6173, 5, 793,
		0, 0, 6173, 6177, 5, 923, 0, 0, 6174, 6175, 5, 243, 0, 0, 6175, 6177, 3,
		36, 18, 0, 6176, 6168, 1, 0, 0, 0, 6176, 6170, 1, 0, 0, 0, 6176, 6174,
		1, 0, 0, 0, 6176, 6177, 1, 0, 0, 0, 6177, 6363, 1, 0, 0, 0, 6178, 6179,
		5, 195, 0, 0, 6179, 6363, 5, 190, 0, 0, 6180, 6181, 5, 195, 0, 0, 6181,
		6182, 5, 34, 0, 0, 6182, 6187, 3, 648, 324, 0, 6183, 6184, 5, 93, 0, 0,
		6184, 6185, 3, 38, 19, 0, 6185, 6186, 5, 69, 0, 0, 6186, 6188, 1, 0, 0,
		0, 6187, 6183, 1, 0, 0, 0, 6187, 6188, 1, 0, 0, 0, 6188, 6189, 1, 0, 0,
		0, 6189, 6190, 3, 158, 79, 0, 6190, 6363, 1, 0, 0, 0, 6191, 6192, 5, 195,
		0, 0, 6192, 6193, 5, 34, 0, 0, 6193, 6194, 5, 220, 0, 0, 6194, 6363, 3,
		584, 292, 0, 6195, 6196, 5, 195, 0, 0, 6196, 6197, 5, 34, 0, 0, 6197, 6198,
		5, 473, 0, 0, 6198, 6363, 3, 584, 292, 0, 6199, 6200, 5, 195, 0, 0, 6200,
		6201, 5, 34, 0, 0, 6201, 6202, 5, 164, 0, 0, 6202, 6363, 3, 584, 292, 0,
		6203, 6204, 5, 195, 0, 0, 6204, 6205, 5, 34, 0, 0, 6205, 6206, 5, 527,
		0, 0, 6206, 6363, 3, 584, 292, 0, 6207, 6208, 5, 195, 0, 0, 6208, 6215,
		5, 273, 0, 0, 6209, 6210, 5, 123, 0, 0, 6210, 6211, 5, 271, 0, 0, 6211,
		6212, 5, 890, 0, 0, 6212, 6216, 5, 271, 0, 0, 6213, 6214, 5, 123, 0, 0,
		6214, 6216, 5, 271, 0, 0, 6215, 6209, 1, 0, 0, 0, 6215, 6213, 1, 0, 0,
		0, 6215, 6216, 1, 0, 0, 0, 6216, 6363, 1, 0, 0, 0, 6217, 6218, 5, 195,
		0, 0, 6218, 6225, 5, 344, 0, 0, 6219, 6220, 5, 123, 0, 0, 6220, 6221, 5,
		271, 0, 0, 6221, 6222, 5, 890, 0, 0, 6222, 6226, 5, 271, 0, 0, 6223, 6224,
		5, 123, 0, 0, 6224, 6226, 5, 271, 0, 0, 6225, 6219, 1, 0, 0, 0, 6225, 6223,
		1, 0, 0, 0, 6225, 6226, 1, 0, 0, 0, 6226, 6363, 1, 0, 0, 0, 6227, 6228,
		5, 195, 0, 0, 6228, 6229, 5, 531, 0, 0, 6229, 6230, 5, 896, 0, 0, 6230,
		6231, 5, 894, 0, 0, 6231, 6232, 5, 903, 0, 0, 6232, 6363, 5, 273, 0, 0,
		6233, 6234, 5, 195, 0, 0, 6234, 6235, 5, 531, 0, 0, 6235, 6236, 5, 896,
		0, 0, 6236, 6237, 5, 894, 0, 0, 6237, 6238, 5, 903, 0, 0, 6238, 6363, 5,
		344, 0, 0, 6239, 6240, 5, 195, 0, 0, 6240, 6241, 5, 521, 0, 0, 6241, 6363,
		3, 644, 322, 0, 6242, 6243, 5, 195, 0, 0, 6243, 6252, 3, 162, 81, 0, 6244,
		6245, 5, 124, 0, 0, 6245, 6253, 5, 923, 0, 0, 6246, 6247, 5, 124, 0, 0,
		6247, 6248, 5, 923, 0, 0, 6248, 6249, 5, 793, 0, 0, 6249, 6253, 5, 923,
		0, 0, 6250, 6251, 5, 243, 0, 0, 6251, 6253, 3, 36, 18, 0, 6252, 6244, 1,
		0, 0, 0, 6252, 6246, 1, 0, 0, 0, 6252, 6250, 1, 0, 0, 0, 6252, 6253, 1,
		0, 0, 0, 6253, 6363, 1, 0, 0, 0, 6254, 6255, 5, 195, 0, 0, 6255, 6264,
		5, 719, 0, 0, 6256, 6257, 5, 124, 0, 0, 6257, 6265, 5, 923, 0, 0, 6258,
		6259, 5, 124, 0, 0, 6259, 6260, 5, 923, 0, 0, 6260, 6261, 5, 793, 0, 0,
		6261, 6265, 5, 923, 0, 0, 6262, 6263, 5, 243, 0, 0, 6263, 6265, 3, 36,
		18, 0, 6264, 6256, 1, 0, 0, 0, 6264, 6258, 1, 0, 0, 0, 6264, 6262, 1, 0,
		0, 0, 6264, 6265, 1, 0, 0, 0, 6265, 6363, 1, 0, 0, 0, 6266, 6267, 5, 195,
		0, 0, 6267, 6276, 5, 361, 0, 0, 6268, 6269, 5, 124, 0, 0, 6269, 6277, 5,
		923, 0, 0, 6270, 6271, 5, 124, 0, 0, 6271, 6272, 5, 923, 0, 0, 6272, 6273,
		5, 793, 0, 0, 6273, 6277, 5, 923, 0, 0, 6274, 6275, 5, 243, 0, 0, 6275,
		6277, 3, 36, 18, 0, 6276, 6268, 1, 0, 0, 0, 6276, 6270, 1, 0, 0, 0, 6276,
		6274, 1, 0, 0, 0, 6276, 6277, 1, 0, 0, 0, 6277, 6363, 1, 0, 0, 0, 6278,
		6279, 5, 195, 0, 0, 6279, 6288, 5, 701, 0, 0, 6280, 6281, 5, 124, 0, 0,
		6281, 6289, 5, 923, 0, 0, 6282, 6283, 5, 124, 0, 0, 6283, 6284, 5, 923,
		0, 0, 6284, 6285, 5, 793, 0, 0, 6285, 6289, 5, 923, 0, 0, 6286, 6287, 5,
		243, 0, 0, 6287, 6289, 3, 36, 18, 0, 6288, 6280, 1, 0, 0, 0, 6288, 6282,
		1, 0, 0, 0, 6288, 6286, 1, 0, 0, 0, 6288, 6289, 1, 0, 0, 0, 6289, 6291,
		1, 0, 0, 0, 6290, 6292, 3, 880, 440, 0, 6291, 6290, 1, 0, 0, 0, 6291, 6292,
		1, 0, 0, 0, 6292, 6363, 1, 0, 0, 0, 6293, 6294, 5, 195, 0, 0, 6294, 6295,
		3, 650, 325, 0, 6295, 6296, 3, 652, 326, 0, 6296, 6300, 3, 584, 292, 0,
		6297, 6298, 3, 652, 326, 0, 6298, 6299, 3, 158, 79, 0, 6299, 6301, 1, 0,
		0, 0, 6300, 6297, 1, 0, 0, 0, 6300, 6301, 1, 0, 0, 0, 6301, 6306, 1, 0,
		0, 0, 6302, 6303, 5, 243, 0, 0, 6303, 6304, 3, 478, 239, 0, 6304, 6305,
		3, 36, 18, 0, 6305, 6307, 1, 0, 0, 0, 6306, 6302, 1, 0, 0, 0, 6306, 6307,
		1, 0, 0, 0, 6307, 6363, 1, 0, 0, 0, 6308, 6310, 5, 195, 0, 0, 6309, 6311,
		5, 81, 0, 0, 6310, 6309, 1, 0, 0, 0, 6310, 6311, 1, 0, 0, 0, 6311, 6312,
		1, 0, 0, 0, 6312, 6363, 5, 807, 0, 0, 6313, 6314, 5, 195, 0, 0, 6314, 6323,
		5, 656, 0, 0, 6315, 6316, 5, 124, 0, 0, 6316, 6324, 5, 923, 0, 0, 6317,
		6318, 5, 124, 0, 0, 6318, 6319, 5, 923, 0, 0, 6319, 6320, 5, 793, 0, 0,
		6320, 6324, 5, 923, 0, 0, 6321, 6322, 5, 243, 0, 0, 6322, 6324, 3, 36,
		18, 0, 6323, 6315, 1, 0, 0, 0, 6323, 6317, 1, 0, 0, 0, 6323, 6321, 1, 0,
		0, 0, 6323, 6324, 1, 0, 0, 0, 6324, 6363, 1, 0, 0, 0, 6325, 6327, 5, 195,
		0, 0, 6326, 6328, 7, 51, 0, 0, 6327, 6326, 1, 0, 0, 0, 6327, 6328, 1, 0,
		0, 0, 6328, 6329, 1, 0, 0, 0, 6329, 6338, 5, 404, 0, 0, 6330, 6331, 5,
		124, 0, 0, 6331, 6339, 5, 923, 0, 0, 6332, 6333, 5, 124, 0, 0, 6333, 6334,
		5, 923, 0, 0, 6334, 6335, 5, 793, 0, 0, 6335, 6339, 5, 923, 0, 0, 6336,
		6337, 5, 243, 0, 0, 6337, 6339, 3, 36, 18, 0, 6338, 6330, 1, 0, 0, 0, 6338,
		6332, 1, 0, 0, 0, 6338, 6336, 1, 0, 0, 0, 6338, 6339, 1, 0, 0, 0, 6339,
		6363, 1, 0, 0, 0, 6340, 6341, 5, 195, 0, 0, 6341, 6343, 5, 882, 0, 0, 6342,
		6344, 5, 404, 0, 0, 6343, 6342, 1, 0, 0, 0, 6343, 6344, 1, 0, 0, 0, 6344,
		6363, 1, 0, 0, 0, 6345, 6346, 5, 195, 0, 0, 6346, 6347, 5, 34, 0, 0, 6347,
		6348, 5, 882, 0, 0, 6348, 6363, 3, 934, 467, 0, 6349, 6351, 5, 195, 0,
		0, 6350, 6352, 5, 591, 0, 0, 6351, 6350, 1, 0, 0, 0, 6351, 6352, 1, 0,
		0, 0, 6352, 6353, 1, 0, 0, 0, 6353, 6363, 5, 379, 0, 0, 6354, 6355, 5,
		195, 0, 0, 6355, 6363, 5, 414, 0, 0, 6356, 6357, 5, 195, 0, 0, 6357, 6363,
		5, 341, 0, 0, 6358, 6359, 5, 195, 0, 0, 6359, 6360, 5, 34, 0, 0, 6360,
		6361, 5, 221, 0, 0, 6361, 6363, 3, 934, 467, 0, 6362, 6039, 1, 0, 0, 0,
		6362, 6059, 1, 0, 0, 0, 6362, 6074, 1, 0, 0, 0, 6362, 6096, 1, 0, 0, 0,
		6362, 6114, 1, 0, 0, 0, 6362, 6132, 1, 0, 0, 0, 6362, 6150, 1, 0, 0, 0,
		6362, 6163, 1, 0, 0, 0, 6362, 6178, 1, 0, 0, 0, 6362, 6180, 1, 0, 0, 0,
		6362, 6191, 1, 0, 0, 0, 6362, 6195, 1, 0, 0, 0, 6362, 6199, 1, 0, 0, 0,
		6362, 6203, 1, 0, 0, 0, 6362, 6207, 1, 0, 0, 0, 6362, 6217, 1, 0, 0, 0,
		6362, 6227, 1, 0, 0, 0, 6362, 6233, 1, 0, 0, 0, 6362, 6239, 1, 0, 0, 0,
		6362, 6242, 1, 0, 0, 0, 6362, 6254, 1, 0, 0, 0, 6362, 6266, 1, 0, 0, 0,
		6362, 6278, 1, 0, 0, 0, 6362, 6293, 1, 0, 0, 0, 6362, 6308, 1, 0, 0, 0,
		6362, 6313, 1, 0, 0, 0, 6362, 6325, 1, 0, 0, 0, 6362, 6340, 1, 0, 0, 0,
		6362, 6345, 1, 0, 0, 0, 6362, 6349, 1, 0, 0, 0, 6362, 6354, 1, 0, 0, 0,
		6362, 6356, 1, 0, 0, 0, 6362, 6358, 1, 0, 0, 0, 6363, 641, 1, 0, 0, 0,
		6364, 6365, 7, 52, 0, 0, 6365, 643, 1, 0, 0, 0, 6366, 6374, 3, 700, 350,
		0, 6367, 6368, 5, 78, 0, 0, 6368, 6374, 5, 40, 0, 0, 6369, 6370, 5, 78,
		0, 0, 6370, 6371, 5, 40, 0, 0, 6371, 6372, 5, 896, 0, 0, 6372, 6374, 5,
		903, 0, 0, 6373, 6366, 1, 0, 0, 0, 6373, 6367, 1, 0, 0, 0, 6373, 6369,
		1, 0, 0, 0, 6374, 645, 1, 0, 0, 0, 6375, 6376, 7, 53, 0, 0, 6376, 647,
		1, 0, 0, 0, 6377, 6378, 7, 14, 0, 0, 6378, 649, 1, 0, 0, 0, 6379, 6380,
		7, 54, 0, 0, 6380, 651, 1, 0, 0, 0, 6381, 6382, 7, 55, 0, 0, 6382, 653,
		1, 0, 0, 0, 6383, 6384, 5, 828, 0, 0, 6384, 6388, 5, 923, 0, 0, 6385, 6386,
		5, 828, 0, 0, 6386, 6388, 5, 921, 0, 0, 6387, 6383, 1, 0, 0, 0, 6387, 6385,
		1, 0, 0, 0, 6388, 655, 1, 0, 0, 0, 6389, 6390, 5, 34, 0, 0, 6390, 6391,
		5, 702, 0, 0, 6391, 6392, 3, 282, 141, 0, 6392, 6393, 3, 658, 329, 0, 6393,
		657, 1, 0, 0, 0, 6394, 6396, 3, 672, 336, 0, 6395, 6394, 1, 0, 0, 0, 6395,
		6396, 1, 0, 0, 0, 6396, 659, 1, 0, 0, 0, 6397, 6399, 5, 363, 0, 0, 6398,
		6400, 5, 908, 0, 0, 6399, 6398, 1, 0, 0, 0, 6399, 6400, 1, 0, 0, 0, 6400,
		6401, 1, 0, 0, 0, 6401, 6402, 5, 923, 0, 0, 6402, 661, 1, 0, 0, 0, 6403,
		6404, 5, 62, 0, 0, 6404, 6405, 5, 702, 0, 0, 6405, 6406, 3, 282, 141, 0,
		6406, 663, 1, 0, 0, 0, 6407, 6413, 3, 666, 333, 0, 6408, 6409, 3, 666,
		333, 0, 6409, 6410, 5, 890, 0, 0, 6410, 6411, 3, 666, 333, 0, 6411, 6413,
		1, 0, 0, 0, 6412, 6407, 1, 0, 0, 0, 6412, 6408, 1, 0, 0, 0, 6413, 665,
		1, 0, 0, 0, 6414, 6416, 5, 193, 0, 0, 6415, 6414, 1, 0, 0, 0, 6415, 6416,
		1, 0, 0, 0, 6416, 6417, 1, 0, 0, 0, 6417, 6418, 3, 660, 330, 0, 6418, 667,
		1, 0, 0, 0, 6419, 6420, 5, 4, 0, 0, 6420, 6421, 5, 702, 0, 0, 6421, 6422,
		3, 282, 141, 0, 6422, 6423, 3, 664, 332, 0, 6423, 669, 1, 0, 0, 0, 6424,
		6425, 5, 4, 0, 0, 6425, 6426, 5, 526, 0, 0, 6426, 6427, 5, 360, 0, 0, 6427,
		6428, 5, 697, 0, 0, 6428, 6429, 5, 362, 0, 0, 6429, 6430, 5, 116, 0, 0,
		6430, 671, 1, 0, 0, 0, 6431, 6436, 3, 660, 330, 0, 6432, 6433, 5, 890,
		0, 0, 6433, 6435, 3, 660, 330, 0, 6434, 6432, 1, 0, 0, 0, 6435, 6438, 1,
		0, 0, 0, 6436, 6434, 1, 0, 0, 0, 6436, 6437, 1, 0, 0, 0, 6437, 673, 1,
		0, 0, 0, 6438, 6436, 1, 0, 0, 0, 6439, 6440, 5, 34, 0, 0, 6440, 6445, 5,
		577, 0, 0, 6441, 6442, 5, 93, 0, 0, 6442, 6443, 3, 38, 19, 0, 6443, 6444,
		5, 69, 0, 0, 6444, 6446, 1, 0, 0, 0, 6445, 6441, 1, 0, 0, 0, 6445, 6446,
		1, 0, 0, 0, 6446, 6447, 1, 0, 0, 0, 6447, 6460, 3, 676, 338, 0, 6448, 6449,
		5, 34, 0, 0, 6449, 6454, 5, 577, 0, 0, 6450, 6451, 5, 93, 0, 0, 6451, 6452,
		3, 38, 19, 0, 6452, 6453, 5, 69, 0, 0, 6453, 6455, 1, 0, 0, 0, 6454, 6450,
		1, 0, 0, 0, 6454, 6455, 1, 0, 0, 0, 6455, 6456, 1, 0, 0, 0, 6456, 6457,
		3, 676, 338, 0, 6457, 6458, 3, 680, 340, 0, 6458, 6460, 1, 0, 0, 0, 6459,
		6439, 1, 0, 0, 0, 6459, 6448, 1, 0, 0, 0, 6460, 675, 1, 0, 0, 0, 6461,
		6466, 3, 678, 339, 0, 6462, 6463, 5, 890, 0, 0, 6463, 6465, 3, 678, 339,
		0, 6464, 6462, 1, 0, 0, 0, 6465, 6468, 1, 0, 0, 0, 6466, 6464, 1, 0, 0,
		0, 6466, 6467, 1, 0, 0, 0, 6467, 677, 1, 0, 0, 0, 6468, 6466, 1, 0, 0,
		0, 6469, 6471, 3, 686, 343, 0, 6470, 6472, 5, 920, 0, 0, 6471, 6470, 1,
		0, 0, 0, 6471, 6472, 1, 0, 0, 0, 6472, 6491, 1, 0, 0, 0, 6473, 6475, 3,
		686, 343, 0, 6474, 6476, 5, 920, 0, 0, 6475, 6474, 1, 0, 0, 0, 6475, 6476,
		1, 0, 0, 0, 6476, 6477, 1, 0, 0, 0, 6477, 6478, 5, 641, 0, 0, 6478, 6479,
		5, 19, 0, 0, 6479, 6480, 3, 692, 346, 0, 6480, 6491, 1, 0, 0, 0, 6481,
		6483, 3, 686, 343, 0, 6482, 6484, 5, 920, 0, 0, 6483, 6482, 1, 0, 0, 0,
		6483, 6484, 1, 0, 0, 0, 6484, 6485, 1, 0, 0, 0, 6485, 6486, 5, 641, 0,
		0, 6486, 6487, 5, 19, 0, 0, 6487, 6488, 5, 704, 0, 0, 6488, 6489, 3, 692,
		346, 0, 6489, 6491, 1, 0, 0, 0, 6490, 6469, 1, 0, 0, 0, 6490, 6473, 1,
		0, 0, 0, 6490, 6481, 1, 0, 0, 0, 6491, 679, 1, 0, 0, 0, 6492, 6493, 5,
		181, 0, 0, 6493, 6501, 5, 806, 0, 0, 6494, 6495, 5, 181, 0, 0, 6495, 6501,
		5, 208, 0, 0, 6496, 6497, 5, 181, 0, 0, 6497, 6501, 5, 250, 0, 0, 6498,
		6499, 5, 181, 0, 0, 6499, 6501, 3, 682, 341, 0, 6500, 6492, 1, 0, 0, 0,
		6500, 6494, 1, 0, 0, 0, 6500, 6496, 1, 0, 0, 0, 6500, 6498, 1, 0, 0, 0,
		6501, 681, 1, 0, 0, 0, 6502, 6503, 6, 341, -1, 0, 6503, 6504, 3, 684, 342,
		0, 6504, 6512, 1, 0, 0, 0, 6505, 6506, 10, 2, 0, 0, 6506, 6511, 3, 684,
		342, 0, 6507, 6508, 10, 1, 0, 0, 6508, 6509, 5, 6, 0, 0, 6509, 6511, 3,
		684, 342, 0, 6510, 6505, 1, 0, 0, 0, 6510, 6507, 1, 0, 0, 0, 6511, 6514,
		1, 0, 0, 0, 6512, 6510, 1, 0, 0, 0, 6512, 6513, 1, 0, 0, 0, 6513, 683,
		1, 0, 0, 0, 6514, 6512, 1, 0, 0, 0, 6515, 6516, 5, 26, 0, 0, 6516, 6522,
		5, 923, 0, 0, 6517, 6518, 5, 113, 0, 0, 6518, 6522, 5, 923, 0, 0, 6519,
		6520, 5, 212, 0, 0, 6520, 6522, 5, 923, 0, 0, 6521, 6515, 1, 0, 0, 0, 6521,
		6517, 1, 0, 0, 0, 6521, 6519, 1, 0, 0, 0, 6522, 685, 1, 0, 0, 0, 6523,
		6527, 5, 923, 0, 0, 6524, 6527, 5, 921, 0, 0, 6525, 6527, 3, 942, 471,
		0, 6526, 6523, 1, 0, 0, 0, 6526, 6524, 1, 0, 0, 0, 6526, 6525, 1, 0, 0,
		0, 6527, 687, 1, 0, 0, 0, 6528, 6530, 5, 920, 0, 0, 6529, 6528, 1, 0, 0,
		0, 6529, 6530, 1, 0, 0, 0, 6530, 689, 1, 0, 0, 0, 6531, 6533, 3, 686, 343,
		0, 6532, 6534, 5, 920, 0, 0, 6533, 6532, 1, 0, 0, 0, 6533, 6534, 1, 0,
		0, 0, 6534, 691, 1, 0, 0, 0, 6535, 6536, 5, 923, 0, 0, 6536, 693, 1, 0,
		0, 0, 6537, 6538, 5, 62, 0, 0, 6538, 6539, 5, 577, 0, 0, 6539, 6540, 3,
		696, 348, 0, 6540, 695, 1, 0, 0, 0, 6541, 6546, 3, 690, 345, 0, 6542, 6543,
		5, 890, 0, 0, 6543, 6545, 3, 690, 345, 0, 6544, 6542, 1, 0, 0, 0, 6545,
		6548, 1, 0, 0, 0, 6546, 6544, 1, 0, 0, 0, 6546, 6547, 1, 0, 0, 0, 6547,
		697, 1, 0, 0, 0, 6548, 6546, 1, 0, 0, 0, 6549, 6550, 5, 193, 0, 0, 6550,
		6555, 5, 704, 0, 0, 6551, 6552, 5, 78, 0, 0, 6552, 6553, 3, 686, 343, 0,
		6553, 6554, 3, 688, 344, 0, 6554, 6556, 1, 0, 0, 0, 6555, 6551, 1, 0, 0,
		0, 6555, 6556, 1, 0, 0, 0, 6556, 6557, 1, 0, 0, 0, 6557, 6558, 5, 908,
		0, 0, 6558, 6586, 5, 923, 0, 0, 6559, 6560, 5, 193, 0, 0, 6560, 6565, 5,
		704, 0, 0, 6561, 6562, 5, 78, 0, 0, 6562, 6563, 3, 686, 343, 0, 6563, 6564,
		3, 688, 344, 0, 6564, 6566, 1, 0, 0, 0, 6565, 6561, 1, 0, 0, 0, 6565, 6566,
		1, 0, 0, 0, 6566, 6567, 1, 0, 0, 0, 6567, 6568, 5, 908, 0, 0, 6568, 6569,
		5, 704, 0, 0, 6569, 6570, 5, 896, 0, 0, 6570, 6571, 3, 692, 346, 0, 6571,
		6572, 5, 903, 0, 0, 6572, 6586, 1, 0, 0, 0, 6573, 6574, 5, 4, 0, 0, 6574,
		6575, 5, 577, 0, 0, 6575, 6576, 3, 690, 345, 0, 6576, 6577, 5, 641, 0,
		0, 6577, 6578, 5, 19, 0, 0, 6578, 6579, 3, 692, 346, 0, 6579, 6586, 1,
		0, 0, 0, 6580, 6581, 5, 4, 0, 0, 6581, 6582, 5, 577, 0, 0, 6582, 6583,
		3, 690, 345, 0, 6583, 6584, 3, 680, 340, 0, 6584, 6586, 1, 0, 0, 0, 6585,
		6549, 1, 0, 0, 0, 6585, 6559, 1, 0, 0, 0, 6585, 6573, 1, 0, 0, 0, 6585,
		6580, 1, 0, 0, 0, 6586, 699, 1, 0, 0, 0, 6587, 6588, 5, 78, 0, 0, 6588,
		6589, 3, 686, 343, 0, 6589, 6590, 3, 688, 344, 0, 6590, 6593, 1, 0, 0,
		0, 6591, 6593, 3, 948, 474, 0, 6592, 6587, 1, 0, 0, 0, 6592, 6591, 1, 0,
		0, 0, 6593, 701, 1, 0, 0, 0, 6594, 6595, 5, 178, 0, 0, 6595, 6596, 5, 577,
		0, 0, 6596, 6597, 3, 706, 353, 0, 6597, 703, 1, 0, 0, 0, 6598, 6600, 3,
		686, 343, 0, 6599, 6601, 5, 920, 0, 0, 6600, 6599, 1, 0, 0, 0, 6600, 6601,
		1, 0, 0, 0, 6601, 6602, 1, 0, 0, 0, 6602, 6603, 5, 223, 0, 0, 6603, 6605,
		3, 686, 343, 0, 6604, 6606, 5, 920, 0, 0, 6605, 6604, 1, 0, 0, 0, 6605,
		6606, 1, 0, 0, 0, 6606, 705, 1, 0, 0, 0, 6607, 6612, 3, 704, 352, 0, 6608,
		6609, 5, 890, 0, 0, 6609, 6611, 3, 704, 352, 0, 6610, 6608, 1, 0, 0, 0,
		6611, 6614, 1, 0, 0, 0, 6612, 6610, 1, 0, 0, 0, 6612, 6613, 1, 0, 0, 0,
		6613, 707, 1, 0, 0, 0, 6614, 6612, 1, 0, 0, 0, 6615, 6616, 5, 4, 0, 0,
		6616, 6617, 5, 577, 0, 0, 6617, 6618, 3, 696, 348, 0, 6618, 6619, 5, 475,
		0, 0, 6619, 6620, 3, 710, 355, 0, 6620, 709, 1, 0, 0, 0, 6621, 6622, 7,
		56, 0, 0, 6622, 711, 1, 0, 0, 0, 6623, 6624, 5, 132, 0, 0, 6624, 6625,
		3, 408, 204, 0, 6625, 6626, 3, 716, 358, 0, 6626, 713, 1, 0, 0, 0, 6627,
		6628, 5, 229, 0, 0, 6628, 6629, 5, 389, 0, 0, 6629, 715, 1, 0, 0, 0, 6630,
		6635, 3, 718, 359, 0, 6631, 6632, 5, 890, 0, 0, 6632, 6634, 3, 718, 359,
		0, 6633, 6631, 1, 0, 0, 0, 6634, 6637, 1, 0, 0, 0, 6635, 6633, 1, 0, 0,
		0, 6635, 6636, 1, 0, 0, 0, 6636, 717, 1, 0, 0, 0, 6637, 6635, 1, 0, 0,
		0, 6638, 6639, 3, 584, 292, 0, 6639, 6640, 3, 720, 360, 0, 6640, 6649,
		1, 0, 0, 0, 6641, 6643, 3, 584, 292, 0, 6642, 6644, 5, 9, 0, 0, 6643, 6642,
		1, 0, 0, 0, 6643, 6644, 1, 0, 0, 0, 6644, 6645, 1, 0, 0, 0, 6645, 6646,
		3, 934, 467, 0, 6646, 6647, 3, 720, 360, 0, 6647, 6649, 1, 0, 0, 0, 6648,
		6638, 1, 0, 0, 0, 6648, 6641, 1, 0, 0, 0, 6649, 719, 1, 0, 0, 0, 6650,
		6652, 5, 171, 0, 0, 6651, 6653, 5, 129, 0, 0, 6652, 6651, 1, 0, 0, 0, 6652,
		6653, 1, 0, 0, 0, 6653, 6658, 1, 0, 0, 0, 6654, 6658, 5, 248, 0, 0, 6655,
		6656, 5, 137, 0, 0, 6656, 6658, 5, 248, 0, 0, 6657, 6650, 1, 0, 0, 0, 6657,
		6654, 1, 0, 0, 0, 6657, 6655, 1, 0, 0, 0, 6658, 721, 1, 0, 0, 0, 6659,
		6661, 5, 612, 0, 0, 6660, 6662, 5, 819, 0, 0, 6661, 6660, 1, 0, 0, 0, 6661,
		6662, 1, 0, 0, 0, 6662, 6683, 1, 0, 0, 0, 6663, 6664, 5, 339, 0, 0, 6664,
		6680, 5, 365, 0, 0, 6665, 6666, 5, 247, 0, 0, 6666, 6667, 5, 298, 0, 0,
		6667, 6681, 5, 466, 0, 0, 6668, 6681, 3, 910, 455, 0, 6669, 6670, 5, 247,
		0, 0, 6670, 6671, 5, 298, 0, 0, 6671, 6672, 5, 466, 0, 0, 6672, 6673, 5,
		890, 0, 0, 6673, 6681, 3, 910, 455, 0, 6674, 6675, 3, 910, 455, 0, 6675,
		6676, 5, 890, 0, 0, 6676, 6677, 5, 247, 0, 0, 6677, 6678, 5, 298, 0, 0,
		6678, 6679, 5, 466, 0, 0, 6679, 6681, 1, 0, 0, 0, 6680, 6665, 1, 0, 0,
		0, 6680, 6668, 1, 0, 0, 0, 6680, 6669, 1, 0, 0, 0, 6680, 6674, 1, 0, 0,
		0, 6680, 6681, 1, 0, 0, 0, 6681, 6683, 1, 0, 0, 0, 6682, 6659, 1, 0, 0,
		0, 6682, 6663, 1, 0, 0, 0, 6683, 723, 1, 0, 0, 0, 6684, 6686, 5, 574, 0,
		0, 6685, 6687, 5, 819, 0, 0, 6686, 6685, 1, 0, 0, 0, 6686, 6687, 1, 0,
		0, 0, 6687, 725, 1, 0, 0, 0, 6688, 6690, 5, 426, 0, 0, 6689, 6691, 5, 819,
		0, 0, 6690, 6689, 1, 0, 0, 0, 6690, 6691, 1, 0, 0, 0, 6691, 727, 1, 0,
		0, 0, 6692, 6693, 5, 118, 0, 0, 6693, 6701, 3, 36, 18, 0, 6694, 6695, 5,
		118, 0, 0, 6695, 6696, 5, 606, 0, 0, 6696, 6701, 3, 36, 18, 0, 6697, 6698,
		5, 118, 0, 0, 6698, 6699, 5, 599, 0, 0, 6699, 6701, 3, 36, 18, 0, 6700,
		6692, 1, 0, 0, 0, 6700, 6694, 1, 0, 0, 0, 6700, 6697, 1, 0, 0, 0, 6701,
		729, 1, 0, 0, 0, 6702, 6703, 5, 85, 0, 0, 6703, 6704, 3, 732, 366, 0, 6704,
		6705, 5, 154, 0, 0, 6705, 6706, 3, 738, 369, 0, 6706, 6707, 5, 223, 0,
		0, 6707, 6708, 3, 676, 338, 0, 6708, 6709, 3, 740, 370, 0, 6709, 731, 1,
		0, 0, 0, 6710, 6716, 3, 734, 367, 0, 6711, 6713, 5, 8, 0, 0, 6712, 6714,
		5, 414, 0, 0, 6713, 6712, 1, 0, 0, 0, 6713, 6714, 1, 0, 0, 0, 6714, 6716,
		1, 0, 0, 0, 6715, 6710, 1, 0, 0, 0, 6715, 6711, 1, 0, 0, 0, 6716, 733,
		1, 0, 0, 0, 6717, 6722, 3, 736, 368, 0, 6718, 6719, 5, 890, 0, 0, 6719,
		6721, 3, 736, 368, 0, 6720, 6718, 1, 0, 0, 0, 6721, 6724, 1, 0, 0, 0, 6722,
		6720, 1, 0, 0, 0, 6722, 6723, 1, 0, 0, 0, 6723, 735, 1, 0, 0, 0, 6724,
		6722, 1, 0, 0, 0, 6725, 6749, 5, 4, 0, 0, 6726, 6749, 5, 34, 0, 0, 6727,
		6728, 5, 34, 0, 0, 6728, 6749, 5, 577, 0, 0, 6729, 6749, 5, 54, 0, 0, 6730,
		6749, 5, 62, 0, 0, 6731, 6732, 5, 85, 0, 0, 6732, 6749, 5, 155, 0, 0, 6733,
		6749, 5, 108, 0, 0, 6734, 6749, 5, 231, 0, 0, 6735, 6749, 5, 189, 0, 0,
		6736, 6749, 5, 96, 0, 0, 6737, 6738, 5, 34, 0, 0, 6738, 6749, 5, 473, 0,
		0, 6739, 6740, 5, 195, 0, 0, 6740, 6749, 5, 473, 0, 0, 6741, 6742, 5, 195,
		0, 0, 6742, 6749, 5, 48, 0, 0, 6743, 6749, 5, 573, 0, 0, 6744, 6749, 5,
		447, 0, 0, 6745, 6749, 5, 232, 0, 0, 6746, 6747, 5, 34, 0, 0, 6747, 6749,
		5, 213, 0, 0, 6748, 6725, 1, 0, 0, 0, 6748, 6726, 1, 0, 0, 0, 6748, 6727,
		1, 0, 0, 0, 6748, 6729, 1, 0, 0, 0, 6748, 6730, 1, 0, 0, 0, 6748, 6731,
		1, 0, 0, 0, 6748, 6733, 1, 0, 0, 0, 6748, 6734, 1, 0, 0, 0, 6748, 6735,
		1, 0, 0, 0, 6748, 6736, 1, 0, 0, 0, 6748, 6737, 1, 0, 0, 0, 6748, 6739,
		1, 0, 0, 0, 6748, 6741, 1, 0, 0, 0, 6748, 6743, 1, 0, 0, 0, 6748, 6744,
		1, 0, 0, 0, 6748, 6745, 1, 0, 0, 0, 6748, 6746, 1, 0, 0, 0, 6749, 737,
		1, 0, 0, 0, 6750, 6764, 5, 894, 0, 0, 6751, 6752, 5, 894, 0, 0, 6752, 6753,
		5, 901, 0, 0, 6753, 6764, 5, 894, 0, 0, 6754, 6755, 3, 934, 467, 0, 6755,
		6756, 5, 901, 0, 0, 6756, 6757, 5, 894, 0, 0, 6757, 6764, 1, 0, 0, 0, 6758,
		6764, 3, 934, 467, 0, 6759, 6760, 3, 934, 467, 0, 6760, 6761, 5, 901, 0,
		0, 6761, 6762, 3, 934, 467, 0, 6762, 6764, 1, 0, 0, 0, 6763, 6750, 1, 0,
		0, 0, 6763, 6751, 1, 0, 0, 0, 6763, 6754, 1, 0, 0, 0, 6763, 6758, 1, 0,
		0, 0, 6763, 6759, 1, 0, 0, 0, 6764, 739, 1, 0, 0, 0, 6765, 6766, 5, 247,
		0, 0, 6766, 6767, 5, 85, 0, 0, 6767, 6770, 5, 155, 0, 0, 6768, 6770, 3,
		948, 474, 0, 6769, 6765, 1, 0, 0, 0, 6769, 6768, 1, 0, 0, 0, 6770, 741,
		1, 0, 0, 0, 6771, 6772, 5, 185, 0, 0, 6772, 6773, 3, 732, 366, 0, 6773,
		6774, 5, 154, 0, 0, 6774, 6775, 3, 738, 369, 0, 6775, 6776, 5, 80, 0, 0,
		6776, 6777, 3, 696, 348, 0, 6777, 6789, 1, 0, 0, 0, 6778, 6779, 5, 185,
		0, 0, 6779, 6781, 5, 8, 0, 0, 6780, 6782, 5, 414, 0, 0, 6781, 6780, 1,
		0, 0, 0, 6781, 6782, 1, 0, 0, 0, 6782, 6783, 1, 0, 0, 0, 6783, 6784, 5,
		890, 0, 0, 6784, 6785, 5, 85, 0, 0, 6785, 6786, 5, 155, 0, 0, 6786, 6787,
		5, 80, 0, 0, 6787, 6789, 3, 696, 348, 0, 6788, 6771, 1, 0, 0, 0, 6788,
		6778, 1, 0, 0, 0, 6789, 743, 1, 0, 0, 0, 6790, 6791, 5, 816, 0, 0, 6791,
		6792, 3, 746, 373, 0, 6792, 6793, 5, 80, 0, 0, 6793, 6794, 3, 748, 374,
		0, 6794, 745, 1, 0, 0, 0, 6795, 6796, 3, 938, 469, 0, 6796, 747, 1, 0,
		0, 0, 6797, 6800, 3, 238, 119, 0, 6798, 6800, 5, 920, 0, 0, 6799, 6797,
		1, 0, 0, 0, 6799, 6798, 1, 0, 0, 0, 6800, 749, 1, 0, 0, 0, 6801, 6802,
		5, 193, 0, 0, 6802, 6803, 3, 754, 377, 0, 6803, 751, 1, 0, 0, 0, 6804,
		6809, 3, 760, 380, 0, 6805, 6806, 5, 890, 0, 0, 6806, 6808, 3, 760, 380,
		0, 6807, 6805, 1, 0, 0, 0, 6808, 6811, 1, 0, 0, 0, 6809, 6807, 1, 0, 0,
		0, 6809, 6810, 1, 0, 0, 0, 6810, 753, 1, 0, 0, 0, 6811, 6809, 1, 0, 0,
		0, 6812, 6817, 3, 758, 379, 0, 6813, 6814, 5, 890, 0, 0, 6814, 6816, 3,
		758, 379, 0, 6815, 6813, 1, 0, 0, 0, 6816, 6819, 1, 0, 0, 0, 6817, 6815,
		1, 0, 0, 0, 6817, 6818, 1, 0, 0, 0, 6818, 755, 1, 0, 0, 0, 6819, 6817,
		1, 0, 0, 0, 6820, 6826, 3, 36, 18, 0, 6821, 6826, 5, 154, 0, 0, 6822, 6826,
		5, 373, 0, 0, 6823, 6826, 5, 15, 0, 0, 6824, 6826, 5, 52, 0, 0, 6825, 6820,
		1, 0, 0, 0, 6825, 6821, 1, 0, 0, 0, 6825, 6822, 1, 0, 0, 0, 6825, 6823,
		1, 0, 0, 0, 6825, 6824, 1, 0, 0, 0, 6826, 757, 1, 0, 0, 0, 6827, 6828,
		5, 920, 0, 0, 6828, 6829, 3, 764, 382, 0, 6829, 6830, 3, 36, 18, 0, 6830,
		6845, 1, 0, 0, 0, 6831, 6832, 5, 920, 0, 0, 6832, 6833, 5, 909, 0, 0, 6833,
		6845, 3, 36, 18, 0, 6834, 6845, 3, 760, 380, 0, 6835, 6836, 3, 762, 381,
		0, 6836, 6837, 3, 932, 466, 0, 6837, 6838, 3, 764, 382, 0, 6838, 6839,
		3, 756, 378, 0, 6839, 6845, 1, 0, 0, 0, 6840, 6841, 5, 919, 0, 0, 6841,
		6842, 3, 764, 382, 0, 6842, 6843, 3, 756, 378, 0, 6843, 6845, 1, 0, 0,
		0, 6844, 6827, 1, 0, 0, 0, 6844, 6831, 1, 0, 0, 0, 6844, 6834, 1, 0, 0,
		0, 6844, 6835, 1, 0, 0, 0, 6844, 6840, 1, 0, 0, 0, 6845, 759, 1, 0, 0,
		0, 6846, 6847, 3, 930, 465, 0, 6847, 6848, 3, 764, 382, 0, 6848, 6849,
		3, 756, 378, 0, 6849, 6855, 1, 0, 0, 0, 6850, 6851, 3, 930, 465, 0, 6851,
		6852, 5, 909, 0, 0, 6852, 6853, 3, 756, 378, 0, 6853, 6855, 1, 0, 0, 0,
		6854, 6846, 1, 0, 0, 0, 6854, 6850, 1, 0, 0, 0, 6855, 761, 1, 0, 0, 0,
		6856, 6863, 5, 497, 0, 0, 6857, 6863, 5, 834, 0, 0, 6858, 6859, 5, 253,
		0, 0, 6859, 6863, 5, 901, 0, 0, 6860, 6861, 5, 254, 0, 0, 6861, 6863, 5,
		901, 0, 0, 6862, 6856, 1, 0, 0, 0, 6862, 6857, 1, 0, 0, 0, 6862, 6858,
		1, 0, 0, 0, 6862, 6860, 1, 0, 0, 0, 6863, 763, 1, 0, 0, 0, 6864, 6865,
		7, 57, 0, 0, 6865, 765, 1, 0, 0, 0, 6866, 6867, 5, 836, 0, 0, 6867, 6870,
		3, 746, 373, 0, 6868, 6869, 5, 234, 0, 0, 6869, 6871, 3, 768, 384, 0, 6870,
		6868, 1, 0, 0, 0, 6870, 6871, 1, 0, 0, 0, 6871, 767, 1, 0, 0, 0, 6872,
		6877, 3, 770, 385, 0, 6873, 6874, 5, 890, 0, 0, 6874, 6876, 3, 770, 385,
		0, 6875, 6873, 1, 0, 0, 0, 6876, 6879, 1, 0, 0, 0, 6877, 6875, 1, 0, 0,
		0, 6877, 6878, 1, 0, 0, 0, 6878, 769, 1, 0, 0, 0, 6879, 6877, 1, 0, 0,
		0, 6880, 6881, 5, 920, 0, 0, 6881, 771, 1, 0, 0, 0, 6882, 6883, 3, 774,
		387, 0, 6883, 6884, 5, 816, 0, 0, 6884, 6885, 3, 746, 373, 0, 6885, 773,
		1, 0, 0, 0, 6886, 6887, 7, 58, 0, 0, 6887, 775, 1, 0, 0, 0, 6888, 6890,
		5, 305, 0, 0, 6889, 6891, 5, 220, 0, 0, 6890, 6889, 1, 0, 0, 0, 6890, 6891,
		1, 0, 0, 0, 6891, 6892, 1, 0, 0, 0, 6892, 6893, 3, 584, 292, 0, 6893, 777,
		1, 0, 0, 0, 6894, 6895, 5, 178, 0, 0, 6895, 6896, 5, 220, 0, 0, 6896, 6897,
		3, 780, 390, 0, 6897, 779, 1, 0, 0, 0, 6898, 6903, 3, 782, 391, 0, 6899,
		6900, 5, 890, 0, 0, 6900, 6902, 3, 782, 391, 0, 6901, 6899, 1, 0, 0, 0,
		6902, 6905, 1, 0, 0, 0, 6903, 6901, 1, 0, 0, 0, 6903, 6904, 1, 0, 0, 0,
		6904, 781, 1, 0, 0, 0, 6905, 6903, 1, 0, 0, 0, 6906, 6907, 3, 584, 292,
		0, 6907, 6908, 5, 223, 0, 0, 6908, 6909, 3, 584, 292, 0, 6909, 783, 1,
		0, 0, 0, 6910, 6911, 5, 4, 0, 0, 6911, 6912, 5, 220, 0, 0, 6912, 6913,
		3, 584, 292, 0, 6913, 6914, 3, 786, 393, 0, 6914, 785, 1, 0, 0, 0, 6915,
		6916, 6, 393, -1, 0, 6916, 6919, 3, 788, 394, 0, 6917, 6919, 3, 948, 474,
		0, 6918, 6915, 1, 0, 0, 0, 6918, 6917, 1, 0, 0, 0, 6919, 6925, 1, 0, 0,
		0, 6920, 6921, 10, 2, 0, 0, 6921, 6922, 5, 890, 0, 0, 6922, 6924, 3, 788,
		394, 0, 6923, 6920, 1, 0, 0, 0, 6924, 6927, 1, 0, 0, 0, 6925, 6923, 1,
		0, 0, 0, 6925, 6926, 1, 0, 0, 0, 6926, 787, 1, 0, 0, 0, 6927, 6925, 1,
		0, 0, 0, 6928, 6930, 5, 193, 0, 0, 6929, 6928, 1, 0, 0, 0, 6929, 6930,
		1, 0, 0, 0, 6930, 6931, 1, 0, 0, 0, 6931, 6944, 3, 276, 138, 0, 6932, 6944,
		3, 810, 405, 0, 6933, 6944, 3, 812, 406, 0, 6934, 6936, 5, 178, 0, 0, 6935,
		6937, 5, 223, 0, 0, 6936, 6935, 1, 0, 0, 0, 6936, 6937, 1, 0, 0, 0, 6937,
		6938, 1, 0, 0, 0, 6938, 6944, 3, 584, 292, 0, 6939, 6944, 3, 804, 402,
		0, 6940, 6944, 3, 792, 396, 0, 6941, 6944, 3, 790, 395, 0, 6942, 6944,
		3, 806, 403, 0, 6943, 6929, 1, 0, 0, 0, 6943, 6932, 1, 0, 0, 0, 6943, 6933,
		1, 0, 0, 0, 6943, 6934, 1, 0, 0, 0, 6943, 6939, 1, 0, 0, 0, 6943, 6940,
		1, 0, 0, 0, 6943, 6941, 1, 0, 0, 0, 6943, 6942, 1, 0, 0, 0, 6944, 789,
		1, 0, 0, 0, 6945, 6946, 5, 62, 0, 0, 6946, 6947, 5, 28, 0, 0, 6947, 6948,
		5, 896, 0, 0, 6948, 6949, 3, 508, 254, 0, 6949, 6950, 5, 903, 0, 0, 6950,
		6960, 1, 0, 0, 0, 6951, 6952, 5, 2, 0, 0, 6952, 6953, 5, 28, 0, 0, 6953,
		6954, 3, 394, 197, 0, 6954, 6955, 5, 25, 0, 0, 6955, 6956, 5, 896, 0, 0,
		6956, 6957, 3, 36, 18, 0, 6957, 6958, 5, 903, 0, 0, 6958, 6960, 1, 0, 0,
		0, 6959, 6945, 1, 0, 0, 0, 6959, 6951, 1, 0, 0, 0, 6960, 791, 1, 0, 0,
		0, 6961, 6962, 5, 62, 0, 0, 6962, 6963, 5, 166, 0, 0, 6963, 6978, 3, 798,
		399, 0, 6964, 6965, 5, 2, 0, 0, 6965, 6966, 5, 166, 0, 0, 6966, 6978, 3,
		794, 397, 0, 6967, 6978, 3, 800, 400, 0, 6968, 6969, 5, 564, 0, 0, 6969,
		6970, 5, 166, 0, 0, 6970, 6971, 3, 508, 254, 0, 6971, 6972, 5, 109, 0,
		0, 6972, 6973, 3, 794, 397, 0, 6973, 6978, 1, 0, 0, 0, 6974, 6975, 5, 305,
		0, 0, 6975, 6976, 5, 166, 0, 0, 6976, 6978, 3, 508, 254, 0, 6977, 6961,
		1, 0, 0, 0, 6977, 6964, 1, 0, 0, 0, 6977, 6967, 1, 0, 0, 0, 6977, 6968,
		1, 0, 0, 0, 6977, 6974, 1, 0, 0, 0, 6978, 793, 1, 0, 0, 0, 6979, 6982,
		3, 320, 160, 0, 6980, 6982, 3, 316, 158, 0, 6981, 6979, 1, 0, 0, 0, 6981,
		6980, 1, 0, 0, 0, 6982, 795, 1, 0, 0, 0, 6983, 6984, 5, 62, 0, 0, 6984,
		6985, 5, 166, 0, 0, 6985, 7000, 3, 798, 399, 0, 6986, 6987, 5, 2, 0, 0,
		6987, 6988, 5, 166, 0, 0, 6988, 7000, 3, 794, 397, 0, 6989, 7000, 3, 802,
		401, 0, 6990, 6991, 5, 564, 0, 0, 6991, 6992, 5, 166, 0, 0, 6992, 6993,
		3, 508, 254, 0, 6993, 6994, 5, 109, 0, 0, 6994, 6995, 3, 794, 397, 0, 6995,
		7000, 1, 0, 0, 0, 6996, 6997, 5, 305, 0, 0, 6997, 6998, 5, 166, 0, 0, 6998,
		7000, 3, 508, 254, 0, 6999, 6983, 1, 0, 0, 0, 6999, 6986, 1, 0, 0, 0, 6999,
		6989, 1, 0, 0, 0, 6999, 6990, 1, 0, 0, 0, 6999, 6996, 1, 0, 0, 0, 7000,
		797, 1, 0, 0, 0, 7001, 7007, 3, 508, 254, 0, 7002, 7003, 5, 896, 0, 0,
		7003, 7004, 3, 508, 254, 0, 7004, 7005, 5, 903, 0, 0, 7005, 7007, 1, 0,
		0, 0, 7006, 7001, 1, 0, 0, 0, 7006, 7002, 1, 0, 0, 0, 7007, 799, 1, 0,
		0, 0, 7008, 7013, 3, 296, 148, 0, 7009, 7013, 3, 300, 150, 0, 7010, 7013,
		3, 302, 151, 0, 7011, 7013, 3, 298, 149, 0, 7012, 7008, 1, 0, 0, 0, 7012,
		7009, 1, 0, 0, 0, 7012, 7010, 1, 0, 0, 0, 7012, 7011, 1, 0, 0, 0, 7013,
		801, 1, 0, 0, 0, 7014, 7019, 3, 352, 176, 0, 7015, 7019, 3, 354, 177, 0,
		7016, 7019, 3, 356, 178, 0, 7017, 7019, 3, 358, 179, 0, 7018, 7014, 1,
		0, 0, 0, 7018, 7015, 1, 0, 0, 0, 7018, 7016, 1, 0, 0, 0, 7018, 7017, 1,
		0, 0, 0, 7019, 803, 1, 0, 0, 0, 7020, 7021, 5, 2, 0, 0, 7021, 7023, 3,
		572, 286, 0, 7022, 7024, 3, 390, 195, 0, 7023, 7022, 1, 0, 0, 0, 7023,
		7024, 1, 0, 0, 0, 7024, 7026, 1, 0, 0, 0, 7025, 7027, 3, 404, 202, 0, 7026,
		7025, 1, 0, 0, 0, 7026, 7027, 1, 0, 0, 0, 7027, 7028, 1, 0, 0, 0, 7028,
		7029, 5, 896, 0, 0, 7029, 7030, 3, 396, 198, 0, 7030, 7032, 5, 903, 0,
		0, 7031, 7033, 3, 400, 200, 0, 7032, 7031, 1, 0, 0, 0, 7032, 7033, 1, 0,
		0, 0, 7033, 7118, 1, 0, 0, 0, 7034, 7035, 5, 2, 0, 0, 7035, 7037, 5, 228,
		0, 0, 7036, 7038, 3, 572, 286, 0, 7037, 7036, 1, 0, 0, 0, 7037, 7038, 1,
		0, 0, 0, 7038, 7040, 1, 0, 0, 0, 7039, 7041, 3, 390, 195, 0, 7040, 7039,
		1, 0, 0, 0, 7040, 7041, 1, 0, 0, 0, 7041, 7043, 1, 0, 0, 0, 7042, 7044,
		3, 404, 202, 0, 7043, 7042, 1, 0, 0, 0, 7043, 7044, 1, 0, 0, 0, 7044, 7045,
		1, 0, 0, 0, 7045, 7046, 5, 896, 0, 0, 7046, 7047, 3, 396, 198, 0, 7047,
		7049, 5, 903, 0, 0, 7048, 7050, 3, 400, 200, 0, 7049, 7048, 1, 0, 0, 0,
		7049, 7050, 1, 0, 0, 0, 7050, 7118, 1, 0, 0, 0, 7051, 7052, 5, 2, 0, 0,
		7052, 7054, 5, 28, 0, 0, 7053, 7055, 3, 394, 197, 0, 7054, 7053, 1, 0,
		0, 0, 7054, 7055, 1, 0, 0, 0, 7055, 7056, 1, 0, 0, 0, 7056, 7058, 5, 228,
		0, 0, 7057, 7059, 3, 572, 286, 0, 7058, 7057, 1, 0, 0, 0, 7058, 7059, 1,
		0, 0, 0, 7059, 7061, 1, 0, 0, 0, 7060, 7062, 3, 390, 195, 0, 7061, 7060,
		1, 0, 0, 0, 7061, 7062, 1, 0, 0, 0, 7062, 7064, 1, 0, 0, 0, 7063, 7065,
		3, 404, 202, 0, 7064, 7063, 1, 0, 0, 0, 7064, 7065, 1, 0, 0, 0, 7065, 7066,
		1, 0, 0, 0, 7066, 7067, 5, 896, 0, 0, 7067, 7068, 3, 396, 198, 0, 7068,
		7070, 5, 903, 0, 0, 7069, 7071, 3, 400, 200, 0, 7070, 7069, 1, 0, 0, 0,
		7070, 7071, 1, 0, 0, 0, 7071, 7118, 1, 0, 0, 0, 7072, 7073, 5, 2, 0, 0,
		7073, 7075, 5, 82, 0, 0, 7074, 7076, 3, 572, 286, 0, 7075, 7074, 1, 0,
		0, 0, 7075, 7076, 1, 0, 0, 0, 7076, 7078, 1, 0, 0, 0, 7077, 7079, 3, 390,
		195, 0, 7078, 7077, 1, 0, 0, 0, 7078, 7079, 1, 0, 0, 0, 7079, 7081, 1,
		0, 0, 0, 7080, 7082, 3, 404, 202, 0, 7081, 7080, 1, 0, 0, 0, 7081, 7082,
		1, 0, 0, 0, 7082, 7083, 1, 0, 0, 0, 7083, 7084, 5, 896, 0, 0, 7084, 7085,
		3, 396, 198, 0, 7085, 7087, 5, 903, 0, 0, 7086, 7088, 3, 400, 200, 0, 7087,
		7086, 1, 0, 0, 0, 7087, 7088, 1, 0, 0, 0, 7088, 7118, 1, 0, 0, 0, 7089,
		7090, 5, 62, 0, 0, 7090, 7091, 3, 572, 286, 0, 7091, 7092, 3, 390, 195,
		0, 7092, 7118, 1, 0, 0, 0, 7093, 7096, 5, 2, 0, 0, 7094, 7095, 5, 28, 0,
		0, 7095, 7097, 3, 392, 196, 0, 7096, 7094, 1, 0, 0, 0, 7096, 7097, 1, 0,
		0, 0, 7097, 7098, 1, 0, 0, 0, 7098, 7099, 5, 168, 0, 0, 7099, 7100, 5,
		116, 0, 0, 7100, 7101, 5, 896, 0, 0, 7101, 7102, 3, 312, 156, 0, 7102,
		7104, 5, 903, 0, 0, 7103, 7105, 3, 400, 200, 0, 7104, 7103, 1, 0, 0, 0,
		7104, 7105, 1, 0, 0, 0, 7105, 7118, 1, 0, 0, 0, 7106, 7107, 5, 4, 0, 0,
		7107, 7108, 5, 96, 0, 0, 7108, 7109, 3, 390, 195, 0, 7109, 7110, 3, 808,
		404, 0, 7110, 7118, 1, 0, 0, 0, 7111, 7112, 5, 178, 0, 0, 7112, 7113, 3,
		572, 286, 0, 7113, 7114, 3, 390, 195, 0, 7114, 7115, 5, 223, 0, 0, 7115,
		7116, 3, 390, 195, 0, 7116, 7118, 1, 0, 0, 0, 7117, 7020, 1, 0, 0, 0, 7117,
		7034, 1, 0, 0, 0, 7117, 7051, 1, 0, 0, 0, 7117, 7072, 1, 0, 0, 0, 7117,
		7089, 1, 0, 0, 0, 7117, 7093, 1, 0, 0, 0, 7117, 7106, 1, 0, 0, 0, 7117,
		7111, 1, 0, 0, 0, 7118, 805, 1, 0, 0, 0, 7119, 7120, 5, 62, 0, 0, 7120,
		7121, 5, 74, 0, 0, 7121, 7122, 5, 116, 0, 0, 7122, 7151, 3, 390, 195, 0,
		7123, 7126, 5, 2, 0, 0, 7124, 7125, 5, 28, 0, 0, 7125, 7127, 3, 392, 196,
		0, 7126, 7124, 1, 0, 0, 0, 7126, 7127, 1, 0, 0, 0, 7127, 7128, 1, 0, 0,
		0, 7128, 7129, 5, 74, 0, 0, 7129, 7131, 5, 116, 0, 0, 7130, 7132, 3, 390,
		195, 0, 7131, 7130, 1, 0, 0, 0, 7131, 7132, 1, 0, 0, 0, 7132, 7133, 1,
		0, 0, 0, 7133, 7134, 5, 896, 0, 0, 7134, 7135, 3, 312, 156, 0, 7135, 7136,
		5, 903, 0, 0, 7136, 7137, 5, 176, 0, 0, 7137, 7138, 3, 584, 292, 0, 7138,
		7139, 5, 896, 0, 0, 7139, 7140, 3, 312, 156, 0, 7140, 7143, 5, 903, 0,
		0, 7141, 7142, 5, 140, 0, 0, 7142, 7144, 3, 218, 109, 0, 7143, 7141, 1,
		0, 0, 0, 7143, 7144, 1, 0, 0, 0, 7144, 7148, 1, 0, 0, 0, 7145, 7146, 3,
		212, 106, 0, 7146, 7147, 3, 214, 107, 0, 7147, 7149, 1, 0, 0, 0, 7148,
		7145, 1, 0, 0, 0, 7148, 7149, 1, 0, 0, 0, 7149, 7151, 1, 0, 0, 0, 7150,
		7119, 1, 0, 0, 0, 7150, 7123, 1, 0, 0, 0, 7151, 807, 1, 0, 0, 0, 7152,
		7153, 7, 59, 0, 0, 7153, 809, 1, 0, 0, 0, 7154, 7156, 5, 2, 0, 0, 7155,
		7157, 5, 32, 0, 0, 7156, 7155, 1, 0, 0, 0, 7156, 7157, 1, 0, 0, 0, 7157,
		7158, 1, 0, 0, 0, 7158, 7195, 3, 220, 110, 0, 7159, 7161, 5, 2, 0, 0, 7160,
		7162, 5, 32, 0, 0, 7161, 7160, 1, 0, 0, 0, 7161, 7162, 1, 0, 0, 0, 7162,
		7163, 1, 0, 0, 0, 7163, 7164, 5, 896, 0, 0, 7164, 7165, 3, 228, 114, 0,
		7165, 7166, 5, 903, 0, 0, 7166, 7195, 1, 0, 0, 0, 7167, 7169, 5, 62, 0,
		0, 7168, 7170, 5, 32, 0, 0, 7169, 7168, 1, 0, 0, 0, 7169, 7170, 1, 0, 0,
		0, 7170, 7171, 1, 0, 0, 0, 7171, 7173, 3, 932, 466, 0, 7172, 7174, 7, 35,
		0, 0, 7173, 7172, 1, 0, 0, 0, 7173, 7174, 1, 0, 0, 0, 7174, 7195, 1, 0,
		0, 0, 7175, 7177, 5, 4, 0, 0, 7176, 7178, 5, 32, 0, 0, 7177, 7176, 1, 0,
		0, 0, 7177, 7178, 1, 0, 0, 0, 7178, 7179, 1, 0, 0, 0, 7179, 7180, 3, 932,
		466, 0, 7180, 7181, 3, 814, 407, 0, 7181, 7195, 1, 0, 0, 0, 7182, 7184,
		5, 23, 0, 0, 7183, 7185, 5, 32, 0, 0, 7184, 7183, 1, 0, 0, 0, 7184, 7185,
		1, 0, 0, 0, 7185, 7186, 1, 0, 0, 0, 7186, 7187, 3, 932, 466, 0, 7187, 7188,
		3, 220, 110, 0, 7188, 7195, 1, 0, 0, 0, 7189, 7191, 5, 544, 0, 0, 7190,
		7192, 5, 32, 0, 0, 7191, 7190, 1, 0, 0, 0, 7191, 7192, 1, 0, 0, 0, 7192,
		7193, 1, 0, 0, 0, 7193, 7195, 3, 220, 110, 0, 7194, 7154, 1, 0, 0, 0, 7194,
		7159, 1, 0, 0, 0, 7194, 7167, 1, 0, 0, 0, 7194, 7175, 1, 0, 0, 0, 7194,
		7182, 1, 0, 0, 0, 7194, 7189, 1, 0, 0, 0, 7195, 811, 1, 0, 0, 0, 7196,
		7197, 5, 62, 0, 0, 7197, 7198, 5, 221, 0, 0, 7198, 813, 1, 0, 0, 0, 7199,
		7200, 5, 193, 0, 0, 7200, 7201, 5, 52, 0, 0, 7201, 7205, 3, 272, 136, 0,
		7202, 7203, 5, 62, 0, 0, 7203, 7205, 5, 52, 0, 0, 7204, 7199, 1, 0, 0,
		0, 7204, 7202, 1, 0, 0, 0, 7205, 815, 1, 0, 0, 0, 7206, 7207, 5, 654, 0,
		0, 7207, 7208, 5, 220, 0, 0, 7208, 7209, 3, 584, 292, 0, 7209, 7210, 5,
		223, 0, 0, 7210, 7211, 5, 13, 0, 0, 7211, 7215, 5, 62, 0, 0, 7212, 7213,
		5, 178, 0, 0, 7213, 7214, 5, 223, 0, 0, 7214, 7216, 3, 584, 292, 0, 7215,
		7212, 1, 0, 0, 0, 7215, 7216, 1, 0, 0, 0, 7216, 7240, 1, 0, 0, 0, 7217,
		7218, 5, 654, 0, 0, 7218, 7219, 3, 156, 78, 0, 7219, 7220, 3, 158, 79,
		0, 7220, 7221, 5, 223, 0, 0, 7221, 7222, 5, 13, 0, 0, 7222, 7226, 5, 62,
		0, 0, 7223, 7224, 5, 178, 0, 0, 7224, 7225, 5, 223, 0, 0, 7225, 7227, 3,
		158, 79, 0, 7226, 7223, 1, 0, 0, 0, 7226, 7227, 1, 0, 0, 0, 7227, 7240,
		1, 0, 0, 0, 7228, 7229, 5, 654, 0, 0, 7229, 7230, 5, 882, 0, 0, 7230, 7231,
		3, 934, 467, 0, 7231, 7232, 5, 223, 0, 0, 7232, 7233, 5, 13, 0, 0, 7233,
		7237, 5, 62, 0, 0, 7234, 7235, 5, 178, 0, 0, 7235, 7236, 5, 223, 0, 0,
		7236, 7238, 3, 934, 467, 0, 7237, 7234, 1, 0, 0, 0, 7237, 7238, 1, 0, 0,
		0, 7238, 7240, 1, 0, 0, 0, 7239, 7206, 1, 0, 0, 0, 7239, 7217, 1, 0, 0,
		0, 7239, 7228, 1, 0, 0, 0, 7240, 817, 1, 0, 0, 0, 7241, 7242, 5, 165, 0,
		0, 7242, 7243, 5, 220, 0, 0, 7243, 7257, 3, 584, 292, 0, 7244, 7245, 5,
		165, 0, 0, 7245, 7246, 5, 96, 0, 0, 7246, 7257, 3, 584, 292, 0, 7247, 7248,
		5, 165, 0, 0, 7248, 7249, 3, 156, 78, 0, 7249, 7250, 3, 158, 79, 0, 7250,
		7257, 1, 0, 0, 0, 7251, 7252, 5, 165, 0, 0, 7252, 7253, 5, 882, 0, 0, 7253,
		7257, 3, 934, 467, 0, 7254, 7255, 5, 165, 0, 0, 7255, 7257, 5, 341, 0,
		0, 7256, 7241, 1, 0, 0, 0, 7256, 7244, 1, 0, 0, 0, 7256, 7247, 1, 0, 0,
		0, 7256, 7251, 1, 0, 0, 0, 7256, 7254, 1, 0, 0, 0, 7257, 819, 1, 0, 0,
		0, 7258, 7259, 5, 156, 0, 0, 7259, 7260, 5, 220, 0, 0, 7260, 7268, 3, 412,
		206, 0, 7261, 7262, 5, 156, 0, 0, 7262, 7263, 5, 882, 0, 0, 7263, 7268,
		3, 934, 467, 0, 7264, 7265, 5, 156, 0, 0, 7265, 7266, 5, 882, 0, 0, 7266,
		7268, 5, 8, 0, 0, 7267, 7258, 1, 0, 0, 0, 7267, 7261, 1, 0, 0, 0, 7267,
		7264, 1, 0, 0, 0, 7268, 821, 1, 0, 0, 0, 7269, 7270, 5, 428, 0, 0, 7270,
		7271, 5, 715, 0, 0, 7271, 7306, 5, 8, 0, 0, 7272, 7273, 5, 428, 0, 0, 7273,
		7274, 5, 715, 0, 0, 7274, 7275, 5, 535, 0, 0, 7275, 7276, 5, 908, 0, 0,
		7276, 7277, 5, 923, 0, 0, 7277, 7278, 5, 890, 0, 0, 7278, 7279, 5, 357,
		0, 0, 7279, 7280, 5, 908, 0, 0, 7280, 7306, 5, 271, 0, 0, 7281, 7282, 5,
		428, 0, 0, 7282, 7283, 5, 410, 0, 0, 7283, 7306, 5, 8, 0, 0, 7284, 7285,
		5, 428, 0, 0, 7285, 7286, 5, 410, 0, 0, 7286, 7287, 5, 841, 0, 0, 7287,
		7288, 5, 908, 0, 0, 7288, 7289, 5, 271, 0, 0, 7289, 7290, 5, 890, 0, 0,
		7290, 7291, 5, 370, 0, 0, 7291, 7292, 5, 908, 0, 0, 7292, 7306, 5, 271,
		0, 0, 7293, 7294, 5, 428, 0, 0, 7294, 7295, 5, 410, 0, 0, 7295, 7296, 5,
		615, 0, 0, 7296, 7297, 5, 908, 0, 0, 7297, 7306, 5, 923, 0, 0, 7298, 7299,
		5, 193, 0, 0, 7299, 7300, 5, 588, 0, 0, 7300, 7301, 5, 908, 0, 0, 7301,
		7306, 5, 923, 0, 0, 7302, 7303, 5, 428, 0, 0, 7303, 7304, 5, 758, 0, 0,
		7304, 7306, 5, 822, 0, 0, 7305, 7269, 1, 0, 0, 0, 7305, 7272, 1, 0, 0,
		0, 7305, 7281, 1, 0, 0, 0, 7305, 7284, 1, 0, 0, 0, 7305, 7293, 1, 0, 0,
		0, 7305, 7298, 1, 0, 0, 0, 7305, 7302, 1, 0, 0, 0, 7306, 823, 1, 0, 0,
		0, 7307, 7308, 5, 4, 0, 0, 7308, 7309, 5, 616, 0, 0, 7309, 7312, 5, 391,
		0, 0, 7310, 7311, 5, 519, 0, 0, 7311, 7313, 3, 896, 448, 0, 7312, 7310,
		1, 0, 0, 0, 7312, 7313, 1, 0, 0, 0, 7313, 7314, 1, 0, 0, 0, 7314, 7790,
		3, 838, 419, 0, 7315, 7316, 5, 4, 0, 0, 7316, 7317, 5, 616, 0, 0, 7317,
		7318, 5, 349, 0, 0, 7318, 7319, 3, 828, 414, 0, 7319, 7323, 5, 628, 0,
		0, 7320, 7321, 5, 882, 0, 0, 7321, 7322, 5, 908, 0, 0, 7322, 7324, 3, 834,
		417, 0, 7323, 7320, 1, 0, 0, 0, 7323, 7324, 1, 0, 0, 0, 7324, 7325, 1,
		0, 0, 0, 7325, 7326, 3, 836, 418, 0, 7326, 7790, 1, 0, 0, 0, 7327, 7328,
		5, 4, 0, 0, 7328, 7329, 5, 616, 0, 0, 7329, 7330, 5, 349, 0, 0, 7330, 7331,
		5, 200, 0, 0, 7331, 7335, 3, 828, 414, 0, 7332, 7333, 5, 882, 0, 0, 7333,
		7334, 5, 908, 0, 0, 7334, 7336, 3, 834, 417, 0, 7335, 7332, 1, 0, 0, 0,
		7335, 7336, 1, 0, 0, 0, 7336, 7337, 1, 0, 0, 0, 7337, 7338, 3, 836, 418,
		0, 7338, 7790, 1, 0, 0, 0, 7339, 7340, 5, 4, 0, 0, 7340, 7341, 5, 616,
		0, 0, 7341, 7342, 5, 349, 0, 0, 7342, 7344, 5, 788, 0, 0, 7343, 7345, 3,
		880, 440, 0, 7344, 7343, 1, 0, 0, 0, 7344, 7345, 1, 0, 0, 0, 7345, 7347,
		1, 0, 0, 0, 7346, 7348, 3, 882, 441, 0, 7347, 7346, 1, 0, 0, 0, 7347, 7348,
		1, 0, 0, 0, 7348, 7790, 1, 0, 0, 0, 7349, 7350, 5, 4, 0, 0, 7350, 7351,
		5, 616, 0, 0, 7351, 7352, 5, 349, 0, 0, 7352, 7354, 5, 295, 0, 0, 7353,
		7355, 3, 884, 442, 0, 7354, 7353, 1, 0, 0, 0, 7354, 7355, 1, 0, 0, 0, 7355,
		7790, 1, 0, 0, 0, 7356, 7357, 5, 4, 0, 0, 7357, 7358, 5, 616, 0, 0, 7358,
		7359, 5, 4, 0, 0, 7359, 7360, 5, 513, 0, 0, 7360, 7362, 5, 757, 0, 0, 7361,
		7363, 3, 880, 440, 0, 7362, 7361, 1, 0, 0, 0, 7362, 7363, 1, 0, 0, 0, 7363,
		7365, 1, 0, 0, 0, 7364, 7366, 3, 876, 438, 0, 7365, 7364, 1, 0, 0, 0, 7365,
		7366, 1, 0, 0, 0, 7366, 7368, 1, 0, 0, 0, 7367, 7369, 3, 874, 437, 0, 7368,
		7367, 1, 0, 0, 0, 7368, 7369, 1, 0, 0, 0, 7369, 7370, 1, 0, 0, 0, 7370,
		7371, 5, 193, 0, 0, 7371, 7790, 3, 878, 439, 0, 7372, 7373, 5, 4, 0, 0,
		7373, 7374, 5, 616, 0, 0, 7374, 7375, 5, 128, 0, 0, 7375, 7376, 5, 513,
		0, 0, 7376, 7377, 5, 757, 0, 0, 7377, 7378, 5, 80, 0, 0, 7378, 7379, 5,
		513, 0, 0, 7379, 7383, 5, 628, 0, 0, 7380, 7381, 5, 882, 0, 0, 7381, 7382,
		5, 908, 0, 0, 7382, 7384, 3, 834, 417, 0, 7383, 7380, 1, 0, 0, 0, 7383,
		7384, 1, 0, 0, 0, 7384, 7386, 1, 0, 0, 0, 7385, 7387, 3, 876, 438, 0, 7386,
		7385, 1, 0, 0, 0, 7386, 7387, 1, 0, 0, 0, 7387, 7790, 1, 0, 0, 0, 7388,
		7389, 5, 4, 0, 0, 7389, 7390, 5, 616, 0, 0, 7390, 7391, 5, 417, 0, 0, 7391,
		7392, 5, 311, 0, 0, 7392, 7393, 3, 898, 449, 0, 7393, 7394, 3, 862, 431,
		0, 7394, 7790, 1, 0, 0, 0, 7395, 7396, 5, 4, 0, 0, 7396, 7397, 5, 616,
		0, 0, 7397, 7398, 5, 417, 0, 0, 7398, 7399, 5, 617, 0, 0, 7399, 7400, 3,
		898, 449, 0, 7400, 7401, 3, 852, 426, 0, 7401, 7790, 1, 0, 0, 0, 7402,
		7403, 5, 4, 0, 0, 7403, 7404, 5, 616, 0, 0, 7404, 7405, 3, 858, 429, 0,
		7405, 7406, 5, 311, 0, 0, 7406, 7407, 3, 860, 430, 0, 7407, 7408, 3, 848,
		424, 0, 7408, 7409, 3, 858, 429, 0, 7409, 7411, 3, 866, 433, 0, 7410, 7412,
		5, 79, 0, 0, 7411, 7410, 1, 0, 0, 0, 7411, 7412, 1, 0, 0, 0, 7412, 7790,
		1, 0, 0, 0, 7413, 7414, 5, 4, 0, 0, 7414, 7415, 5, 616, 0, 0, 7415, 7416,
		5, 62, 0, 0, 7416, 7417, 5, 311, 0, 0, 7417, 7418, 3, 860, 430, 0, 7418,
		7423, 3, 848, 424, 0, 7419, 7420, 5, 829, 0, 0, 7420, 7421, 3, 290, 145,
		0, 7421, 7422, 5, 271, 0, 0, 7422, 7424, 1, 0, 0, 0, 7423, 7419, 1, 0,
		0, 0, 7423, 7424, 1, 0, 0, 0, 7424, 7426, 1, 0, 0, 0, 7425, 7427, 3, 850,
		425, 0, 7426, 7425, 1, 0, 0, 0, 7426, 7427, 1, 0, 0, 0, 7427, 7429, 1,
		0, 0, 0, 7428, 7430, 5, 79, 0, 0, 7429, 7428, 1, 0, 0, 0, 7429, 7430, 1,
		0, 0, 0, 7430, 7790, 1, 0, 0, 0, 7431, 7432, 5, 4, 0, 0, 7432, 7433, 5,
		616, 0, 0, 7433, 7434, 3, 864, 432, 0, 7434, 7435, 5, 311, 0, 0, 7435,
		7436, 3, 860, 430, 0, 7436, 7438, 5, 745, 0, 0, 7437, 7439, 5, 908, 0,
		0, 7438, 7437, 1, 0, 0, 0, 7438, 7439, 1, 0, 0, 0, 7439, 7440, 1, 0, 0,
		0, 7440, 7441, 5, 923, 0, 0, 7441, 7443, 5, 646, 0, 0, 7442, 7444, 5, 908,
		0, 0, 7443, 7442, 1, 0, 0, 0, 7443, 7444, 1, 0, 0, 0, 7444, 7445, 1, 0,
		0, 0, 7445, 7447, 5, 923, 0, 0, 7446, 7448, 5, 79, 0, 0, 7447, 7446, 1,
		0, 0, 0, 7447, 7448, 1, 0, 0, 0, 7448, 7790, 1, 0, 0, 0, 7449, 7450, 5,
		4, 0, 0, 7450, 7451, 5, 616, 0, 0, 7451, 7452, 5, 792, 0, 0, 7452, 7454,
		5, 311, 0, 0, 7453, 7455, 3, 852, 426, 0, 7454, 7453, 1, 0, 0, 0, 7454,
		7455, 1, 0, 0, 0, 7455, 7790, 1, 0, 0, 0, 7456, 7457, 5, 4, 0, 0, 7457,
		7458, 5, 616, 0, 0, 7458, 7459, 5, 663, 0, 0, 7459, 7461, 5, 311, 0, 0,
		7460, 7462, 3, 852, 426, 0, 7461, 7460, 1, 0, 0, 0, 7461, 7462, 1, 0, 0,
		0, 7462, 7790, 1, 0, 0, 0, 7463, 7464, 5, 4, 0, 0, 7464, 7465, 5, 616,
		0, 0, 7465, 7466, 5, 339, 0, 0, 7466, 7467, 5, 144, 0, 0, 7467, 7790, 3,
		850, 425, 0, 7468, 7469, 5, 4, 0, 0, 7469, 7470, 5, 616, 0, 0, 7470, 7471,
		3, 872, 436, 0, 7471, 7473, 5, 144, 0, 0, 7472, 7474, 3, 850, 425, 0, 7473,
		7472, 1, 0, 0, 0, 7473, 7474, 1, 0, 0, 0, 7474, 7790, 1, 0, 0, 0, 7475,
		7476, 5, 4, 0, 0, 7476, 7477, 5, 616, 0, 0, 7477, 7478, 5, 731, 0, 0, 7478,
		7479, 5, 144, 0, 0, 7479, 7790, 5, 351, 0, 0, 7480, 7481, 5, 4, 0, 0, 7481,
		7482, 5, 616, 0, 0, 7482, 7483, 5, 610, 0, 0, 7483, 7484, 3, 886, 443,
		0, 7484, 7485, 5, 696, 0, 0, 7485, 7486, 5, 923, 0, 0, 7486, 7790, 1, 0,
		0, 0, 7487, 7488, 5, 4, 0, 0, 7488, 7489, 5, 616, 0, 0, 7489, 7490, 5,
		421, 0, 0, 7490, 7493, 5, 470, 0, 0, 7491, 7492, 5, 367, 0, 0, 7492, 7494,
		3, 844, 422, 0, 7493, 7491, 1, 0, 0, 0, 7493, 7494, 1, 0, 0, 0, 7494, 7790,
		1, 0, 0, 0, 7495, 7496, 5, 4, 0, 0, 7496, 7497, 5, 616, 0, 0, 7497, 7790,
		5, 842, 0, 0, 7498, 7499, 5, 4, 0, 0, 7499, 7500, 5, 616, 0, 0, 7500, 7501,
		5, 567, 0, 0, 7501, 7504, 5, 470, 0, 0, 7502, 7505, 3, 832, 416, 0, 7503,
		7505, 3, 860, 430, 0, 7504, 7502, 1, 0, 0, 0, 7504, 7503, 1, 0, 0, 0, 7504,
		7505, 1, 0, 0, 0, 7505, 7512, 1, 0, 0, 0, 7506, 7507, 5, 494, 0, 0, 7507,
		7508, 3, 290, 145, 0, 7508, 7509, 5, 896, 0, 0, 7509, 7510, 3, 844, 422,
		0, 7510, 7511, 5, 903, 0, 0, 7511, 7513, 1, 0, 0, 0, 7512, 7506, 1, 0,
		0, 0, 7512, 7513, 1, 0, 0, 0, 7513, 7515, 1, 0, 0, 0, 7514, 7516, 3, 850,
		425, 0, 7515, 7514, 1, 0, 0, 0, 7515, 7516, 1, 0, 0, 0, 7516, 7790, 1,
		0, 0, 0, 7517, 7518, 5, 4, 0, 0, 7518, 7519, 5, 616, 0, 0, 7519, 7520,
		5, 731, 0, 0, 7520, 7522, 5, 553, 0, 0, 7521, 7523, 3, 880, 440, 0, 7522,
		7521, 1, 0, 0, 0, 7522, 7523, 1, 0, 0, 0, 7523, 7790, 1, 0, 0, 0, 7524,
		7525, 5, 4, 0, 0, 7525, 7526, 5, 616, 0, 0, 7526, 7527, 3, 842, 421, 0,
		7527, 7528, 5, 494, 0, 0, 7528, 7530, 3, 844, 422, 0, 7529, 7531, 3, 850,
		425, 0, 7530, 7529, 1, 0, 0, 0, 7530, 7531, 1, 0, 0, 0, 7531, 7790, 1,
		0, 0, 0, 7532, 7533, 5, 4, 0, 0, 7533, 7534, 5, 616, 0, 0, 7534, 7535,
		5, 2, 0, 0, 7535, 7536, 5, 555, 0, 0, 7536, 7537, 3, 288, 144, 0, 7537,
		7538, 3, 856, 428, 0, 7538, 7790, 1, 0, 0, 0, 7539, 7540, 5, 4, 0, 0, 7540,
		7541, 5, 616, 0, 0, 7541, 7542, 3, 846, 423, 0, 7542, 7543, 5, 555, 0,
		0, 7543, 7544, 3, 288, 144, 0, 7544, 7790, 1, 0, 0, 0, 7545, 7546, 5, 4,
		0, 0, 7546, 7547, 5, 616, 0, 0, 7547, 7548, 3, 858, 429, 0, 7548, 7549,
		5, 555, 0, 0, 7549, 7551, 3, 288, 144, 0, 7550, 7552, 5, 193, 0, 0, 7551,
		7550, 1, 0, 0, 0, 7551, 7552, 1, 0, 0, 0, 7552, 7553, 1, 0, 0, 0, 7553,
		7554, 3, 856, 428, 0, 7554, 7790, 1, 0, 0, 0, 7555, 7556, 5, 4, 0, 0, 7556,
		7557, 5, 616, 0, 0, 7557, 7558, 5, 710, 0, 0, 7558, 7560, 5, 190, 0, 0,
		7559, 7561, 3, 852, 426, 0, 7560, 7559, 1, 0, 0, 0, 7560, 7561, 1, 0, 0,
		0, 7561, 7790, 1, 0, 0, 0, 7562, 7563, 5, 4, 0, 0, 7563, 7564, 5, 616,
		0, 0, 7564, 7565, 5, 710, 0, 0, 7565, 7566, 5, 758, 0, 0, 7566, 7568, 5,
		972, 0, 0, 7567, 7569, 3, 852, 426, 0, 7568, 7567, 1, 0, 0, 0, 7568, 7569,
		1, 0, 0, 0, 7569, 7790, 1, 0, 0, 0, 7570, 7571, 5, 4, 0, 0, 7571, 7573,
		5, 616, 0, 0, 7572, 7574, 5, 193, 0, 0, 7573, 7572, 1, 0, 0, 0, 7573, 7574,
		1, 0, 0, 0, 7574, 7575, 1, 0, 0, 0, 7575, 7790, 3, 888, 444, 0, 7576, 7577,
		5, 4, 0, 0, 7577, 7578, 5, 616, 0, 0, 7578, 7579, 5, 737, 0, 0, 7579, 7790,
		3, 892, 446, 0, 7580, 7581, 5, 4, 0, 0, 7581, 7582, 5, 616, 0, 0, 7582,
		7583, 5, 731, 0, 0, 7583, 7584, 5, 286, 0, 0, 7584, 7586, 5, 628, 0, 0,
		7585, 7587, 3, 852, 426, 0, 7586, 7585, 1, 0, 0, 0, 7586, 7587, 1, 0, 0,
		0, 7587, 7790, 1, 0, 0, 0, 7588, 7589, 5, 4, 0, 0, 7589, 7590, 5, 616,
		0, 0, 7590, 7591, 5, 541, 0, 0, 7591, 7592, 5, 598, 0, 0, 7592, 7596, 5,
		696, 0, 0, 7593, 7594, 5, 882, 0, 0, 7594, 7595, 5, 908, 0, 0, 7595, 7597,
		3, 834, 417, 0, 7596, 7593, 1, 0, 0, 0, 7596, 7597, 1, 0, 0, 0, 7597, 7601,
		1, 0, 0, 0, 7598, 7599, 5, 555, 0, 0, 7599, 7600, 5, 908, 0, 0, 7600, 7602,
		3, 146, 73, 0, 7601, 7598, 1, 0, 0, 0, 7601, 7602, 1, 0, 0, 0, 7602, 7607,
		1, 0, 0, 0, 7603, 7604, 5, 808, 0, 0, 7604, 7605, 3, 290, 145, 0, 7605,
		7606, 3, 830, 415, 0, 7606, 7608, 1, 0, 0, 0, 7607, 7603, 1, 0, 0, 0, 7607,
		7608, 1, 0, 0, 0, 7608, 7790, 1, 0, 0, 0, 7609, 7610, 5, 4, 0, 0, 7610,
		7611, 5, 616, 0, 0, 7611, 7612, 5, 455, 0, 0, 7612, 7790, 5, 651, 0, 0,
		7613, 7614, 5, 4, 0, 0, 7614, 7615, 5, 616, 0, 0, 7615, 7616, 5, 455, 0,
		0, 7616, 7790, 5, 413, 0, 0, 7617, 7618, 5, 4, 0, 0, 7618, 7619, 5, 616,
		0, 0, 7619, 7620, 5, 455, 0, 0, 7620, 7790, 5, 494, 0, 0, 7621, 7622, 5,
		4, 0, 0, 7622, 7623, 5, 616, 0, 0, 7623, 7624, 5, 455, 0, 0, 7624, 7790,
		5, 555, 0, 0, 7625, 7626, 5, 4, 0, 0, 7626, 7627, 5, 616, 0, 0, 7627, 7628,
		5, 297, 0, 0, 7628, 7630, 5, 413, 0, 0, 7629, 7631, 5, 908, 0, 0, 7630,
		7629, 1, 0, 0, 0, 7630, 7631, 1, 0, 0, 0, 7631, 7632, 1, 0, 0, 0, 7632,
		7633, 5, 271, 0, 0, 7633, 7635, 5, 646, 0, 0, 7634, 7636, 5, 908, 0, 0,
		7635, 7634, 1, 0, 0, 0, 7635, 7636, 1, 0, 0, 0, 7636, 7637, 1, 0, 0, 0,
		7637, 7790, 5, 923, 0, 0, 7638, 7639, 5, 4, 0, 0, 7639, 7640, 5, 616, 0,
		0, 7640, 7641, 5, 610, 0, 0, 7641, 7642, 5, 297, 0, 0, 7642, 7643, 5, 413,
		0, 0, 7643, 7790, 5, 271, 0, 0, 7644, 7645, 5, 4, 0, 0, 7645, 7646, 5,
		616, 0, 0, 7646, 7647, 5, 337, 0, 0, 7647, 7648, 5, 242, 0, 0, 7648, 7790,
		5, 190, 0, 0, 7649, 7650, 5, 4, 0, 0, 7650, 7651, 5, 616, 0, 0, 7651, 7652,
		5, 763, 0, 0, 7652, 7653, 5, 857, 0, 0, 7653, 7655, 5, 923, 0, 0, 7654,
		7656, 3, 852, 426, 0, 7655, 7654, 1, 0, 0, 0, 7655, 7656, 1, 0, 0, 0, 7656,
		7790, 1, 0, 0, 0, 7657, 7658, 5, 4, 0, 0, 7658, 7659, 5, 616, 0, 0, 7659,
		7660, 3, 900, 450, 0, 7660, 7661, 5, 337, 0, 0, 7661, 7790, 1, 0, 0, 0,
		7662, 7663, 5, 4, 0, 0, 7663, 7664, 5, 616, 0, 0, 7664, 7665, 3, 900, 450,
		0, 7665, 7666, 5, 489, 0, 0, 7666, 7667, 5, 337, 0, 0, 7667, 7790, 1, 0,
		0, 0, 7668, 7669, 5, 4, 0, 0, 7669, 7670, 5, 616, 0, 0, 7670, 7671, 5,
		710, 0, 0, 7671, 7790, 5, 812, 0, 0, 7672, 7673, 5, 4, 0, 0, 7673, 7674,
		5, 616, 0, 0, 7674, 7675, 5, 193, 0, 0, 7675, 7676, 5, 707, 0, 0, 7676,
		7677, 5, 510, 0, 0, 7677, 7790, 3, 848, 424, 0, 7678, 7679, 5, 4, 0, 0,
		7679, 7680, 5, 616, 0, 0, 7680, 7681, 5, 462, 0, 0, 7681, 7682, 3, 880,
		440, 0, 7682, 7683, 5, 80, 0, 0, 7683, 7684, 5, 923, 0, 0, 7684, 7790,
		1, 0, 0, 0, 7685, 7686, 5, 4, 0, 0, 7686, 7687, 5, 616, 0, 0, 7687, 7688,
		5, 462, 0, 0, 7688, 7689, 3, 934, 467, 0, 7689, 7690, 5, 80, 0, 0, 7690,
		7691, 3, 934, 467, 0, 7691, 7692, 5, 281, 0, 0, 7692, 7693, 5, 923, 0,
		0, 7693, 7694, 5, 576, 0, 0, 7694, 7695, 5, 923, 0, 0, 7695, 7696, 5, 247,
		0, 0, 7696, 7697, 5, 923, 0, 0, 7697, 7790, 1, 0, 0, 0, 7698, 7699, 5,
		4, 0, 0, 7699, 7700, 5, 616, 0, 0, 7700, 7701, 5, 23, 0, 0, 7701, 7702,
		5, 882, 0, 0, 7702, 7790, 3, 826, 413, 0, 7703, 7704, 5, 4, 0, 0, 7704,
		7705, 5, 616, 0, 0, 7705, 7706, 5, 62, 0, 0, 7706, 7707, 5, 389, 0, 0,
		7707, 7708, 5, 95, 0, 0, 7708, 7709, 5, 834, 0, 0, 7709, 7790, 5, 271,
		0, 0, 7710, 7711, 5, 4, 0, 0, 7711, 7712, 5, 616, 0, 0, 7712, 7713, 5,
		710, 0, 0, 7713, 7714, 5, 389, 0, 0, 7714, 7715, 5, 95, 0, 0, 7715, 7716,
		5, 834, 0, 0, 7716, 7790, 5, 271, 0, 0, 7717, 7718, 5, 4, 0, 0, 7718, 7719,
		5, 795, 0, 0, 7719, 7720, 3, 934, 467, 0, 7720, 7721, 5, 2, 0, 0, 7721,
		7722, 5, 707, 0, 0, 7722, 7727, 5, 923, 0, 0, 7723, 7724, 5, 482, 0, 0,
		7724, 7725, 3, 290, 145, 0, 7725, 7726, 3, 288, 144, 0, 7726, 7728, 1,
		0, 0, 0, 7727, 7723, 1, 0, 0, 0, 7727, 7728, 1, 0, 0, 0, 7728, 7729, 1,
		0, 0, 0, 7729, 7731, 3, 848, 424, 0, 7730, 7732, 3, 850, 425, 0, 7731,
		7730, 1, 0, 0, 0, 7731, 7732, 1, 0, 0, 0, 7732, 7790, 1, 0, 0, 0, 7733,
		7734, 5, 4, 0, 0, 7734, 7735, 5, 795, 0, 0, 7735, 7736, 3, 934, 467, 0,
		7736, 7737, 5, 62, 0, 0, 7737, 7738, 5, 707, 0, 0, 7738, 7739, 5, 923,
		0, 0, 7739, 7741, 3, 848, 424, 0, 7740, 7742, 3, 850, 425, 0, 7741, 7740,
		1, 0, 0, 0, 7741, 7742, 1, 0, 0, 0, 7742, 7790, 1, 0, 0, 0, 7743, 7744,
		5, 4, 0, 0, 7744, 7745, 5, 616, 0, 0, 7745, 7790, 5, 431, 0, 0, 7746, 7747,
		5, 4, 0, 0, 7747, 7748, 5, 616, 0, 0, 7748, 7790, 5, 479, 0, 0, 7749, 7750,
		5, 4, 0, 0, 7750, 7751, 5, 616, 0, 0, 7751, 7752, 5, 690, 0, 0, 7752, 7790,
		5, 47, 0, 0, 7753, 7754, 5, 4, 0, 0, 7754, 7755, 5, 616, 0, 0, 7755, 7756,
		5, 690, 0, 0, 7756, 7757, 5, 488, 0, 0, 7757, 7790, 5, 47, 0, 0, 7758,
		7759, 5, 4, 0, 0, 7759, 7760, 5, 616, 0, 0, 7760, 7761, 5, 610, 0, 0, 7761,
		7790, 5, 690, 0, 0, 7762, 7763, 5, 4, 0, 0, 7763, 7764, 5, 616, 0, 0, 7764,
		7765, 5, 299, 0, 0, 7765, 7790, 5, 690, 0, 0, 7766, 7767, 5, 4, 0, 0, 7767,
		7768, 5, 616, 0, 0, 7768, 7769, 5, 568, 0, 0, 7769, 7790, 5, 690, 0, 0,
		7770, 7771, 5, 4, 0, 0, 7771, 7772, 5, 616, 0, 0, 7772, 7773, 5, 54, 0,
		0, 7773, 7774, 5, 870, 0, 0, 7774, 7790, 5, 690, 0, 0, 7775, 7776, 5, 4,
		0, 0, 7776, 7777, 5, 616, 0, 0, 7777, 7778, 5, 54, 0, 0, 7778, 7779, 5,
		690, 0, 0, 7779, 7790, 5, 271, 0, 0, 7780, 7781, 5, 4, 0, 0, 7781, 7782,
		5, 616, 0, 0, 7782, 7783, 5, 338, 0, 0, 7783, 7790, 5, 47, 0, 0, 7784,
		7785, 5, 4, 0, 0, 7785, 7786, 5, 616, 0, 0, 7786, 7787, 5, 338, 0, 0, 7787,
		7788, 5, 412, 0, 0, 7788, 7790, 5, 271, 0, 0, 7789, 7307, 1, 0, 0, 0, 7789,
		7315, 1, 0, 0, 0, 7789, 7327, 1, 0, 0, 0, 7789, 7339, 1, 0, 0, 0, 7789,
		7349, 1, 0, 0, 0, 7789, 7356, 1, 0, 0, 0, 7789, 7372, 1, 0, 0, 0, 7789,
		7388, 1, 0, 0, 0, 7789, 7395, 1, 0, 0, 0, 7789, 7402, 1, 0, 0, 0, 7789,
		7413, 1, 0, 0, 0, 7789, 7431, 1, 0, 0, 0, 7789, 7449, 1, 0, 0, 0, 7789,
		7456, 1, 0, 0, 0, 7789, 7463, 1, 0, 0, 0, 7789, 7468, 1, 0, 0, 0, 7789,
		7475, 1, 0, 0, 0, 7789, 7480, 1, 0, 0, 0, 7789, 7487, 1, 0, 0, 0, 7789,
		7495, 1, 0, 0, 0, 7789, 7498, 1, 0, 0, 0, 7789, 7517, 1, 0, 0, 0, 7789,
		7524, 1, 0, 0, 0, 7789, 7532, 1, 0, 0, 0, 7789, 7539, 1, 0, 0, 0, 7789,
		7545, 1, 0, 0, 0, 7789, 7555, 1, 0, 0, 0, 7789, 7562, 1, 0, 0, 0, 7789,
		7570, 1, 0, 0, 0, 7789, 7576, 1, 0, 0, 0, 7789, 7580, 1, 0, 0, 0, 7789,
		7588, 1, 0, 0, 0, 7789, 7609, 1, 0, 0, 0, 7789, 7613, 1, 0, 0, 0, 7789,
		7617, 1, 0, 0, 0, 7789, 7621, 1, 0, 0, 0, 7789, 7625, 1, 0, 0, 0, 7789,
		7638, 1, 0, 0, 0, 7789, 7644, 1, 0, 0, 0, 7789, 7649, 1, 0, 0, 0, 7789,
		7657, 1, 0, 0, 0, 7789, 7662, 1, 0, 0, 0, 7789, 7668, 1, 0, 0, 0, 7789,
		7672, 1, 0, 0, 0, 7789, 7678, 1, 0, 0, 0, 7789, 7685, 1, 0, 0, 0, 7789,
		7698, 1, 0, 0, 0, 7789, 7703, 1, 0, 0, 0, 7789, 7710, 1, 0, 0, 0, 7789,
		7717, 1, 0, 0, 0, 7789, 7733, 1, 0, 0, 0, 7789, 7743, 1, 0, 0, 0, 7789,
		7746, 1, 0, 0, 0, 7789, 7749, 1, 0, 0, 0, 7789, 7753, 1, 0, 0, 0, 7789,
		7758, 1, 0, 0, 0, 7789, 7762, 1, 0, 0, 0, 7789, 7766, 1, 0, 0, 0, 7789,
		7770, 1, 0, 0, 0, 7789, 7775, 1, 0, 0, 0, 7789, 7780, 1, 0, 0, 0, 7789,
		7784, 1, 0, 0, 0, 7790, 825, 1, 0, 0, 0, 7791, 7798, 3, 288, 144, 0, 7792,
		7794, 5, 841, 0, 0, 7793, 7795, 5, 908, 0, 0, 7794, 7793, 1, 0, 0, 0, 7794,
		7795, 1, 0, 0, 0, 7795, 7796, 1, 0, 0, 0, 7796, 7798, 5, 271, 0, 0, 7797,
		7791, 1, 0, 0, 0, 7797, 7792, 1, 0, 0, 0, 7798, 827, 1, 0, 0, 0, 7799,
		7800, 7, 60, 0, 0, 7800, 829, 1, 0, 0, 0, 7801, 7802, 7, 61, 0, 0, 7802,
		831, 1, 0, 0, 0, 7803, 7805, 5, 882, 0, 0, 7804, 7806, 5, 908, 0, 0, 7805,
		7804, 1, 0, 0, 0, 7805, 7806, 1, 0, 0, 0, 7806, 7807, 1, 0, 0, 0, 7807,
		7808, 5, 896, 0, 0, 7808, 7809, 3, 834, 417, 0, 7809, 7810, 5, 903, 0,
		0, 7810, 833, 1, 0, 0, 0, 7811, 7816, 3, 288, 144, 0, 7812, 7813, 5, 890,
		0, 0, 7813, 7815, 3, 288, 144, 0, 7814, 7812, 1, 0, 0, 0, 7815, 7818, 1,
		0, 0, 0, 7816, 7814, 1, 0, 0, 0, 7816, 7817, 1, 0, 0, 0, 7817, 835, 1,
		0, 0, 0, 7818, 7816, 1, 0, 0, 0, 7819, 7821, 5, 497, 0, 0, 7820, 7819,
		1, 0, 0, 0, 7820, 7821, 1, 0, 0, 0, 7821, 837, 1, 0, 0, 0, 7822, 7827,
		3, 840, 420, 0, 7823, 7824, 5, 890, 0, 0, 7824, 7826, 3, 840, 420, 0, 7825,
		7823, 1, 0, 0, 0, 7826, 7829, 1, 0, 0, 0, 7827, 7825, 1, 0, 0, 0, 7827,
		7828, 1, 0, 0, 0, 7828, 839, 1, 0, 0, 0, 7829, 7827, 1, 0, 0, 0, 7830,
		7832, 5, 664, 0, 0, 7831, 7833, 5, 908, 0, 0, 7832, 7831, 1, 0, 0, 0, 7832,
		7833, 1, 0, 0, 0, 7833, 7834, 1, 0, 0, 0, 7834, 7835, 3, 288, 144, 0, 7835,
		7837, 5, 555, 0, 0, 7836, 7838, 5, 908, 0, 0, 7837, 7836, 1, 0, 0, 0, 7837,
		7838, 1, 0, 0, 0, 7838, 7839, 1, 0, 0, 0, 7839, 7840, 3, 288, 144, 0, 7840,
		7842, 5, 494, 0, 0, 7841, 7843, 5, 908, 0, 0, 7842, 7841, 1, 0, 0, 0, 7842,
		7843, 1, 0, 0, 0, 7843, 7844, 1, 0, 0, 0, 7844, 7845, 5, 923, 0, 0, 7845,
		7858, 1, 0, 0, 0, 7846, 7848, 5, 555, 0, 0, 7847, 7849, 5, 908, 0, 0, 7848,
		7847, 1, 0, 0, 0, 7848, 7849, 1, 0, 0, 0, 7849, 7850, 1, 0, 0, 0, 7850,
		7851, 3, 288, 144, 0, 7851, 7853, 5, 494, 0, 0, 7852, 7854, 5, 908, 0,
		0, 7853, 7852, 1, 0, 0, 0, 7853, 7854, 1, 0, 0, 0, 7854, 7855, 1, 0, 0,
		0, 7855, 7856, 5, 923, 0, 0, 7856, 7858, 1, 0, 0, 0, 7857, 7830, 1, 0,
		0, 0, 7857, 7846, 1, 0, 0, 0, 7858, 841, 1, 0, 0, 0, 7859, 7869, 5, 2,
		0, 0, 7860, 7869, 5, 54, 0, 0, 7861, 7862, 5, 610, 0, 0, 7862, 7869, 5,
		54, 0, 0, 7863, 7869, 5, 339, 0, 0, 7864, 7869, 5, 279, 0, 0, 7865, 7866,
		5, 79, 0, 0, 7866, 7869, 5, 279, 0, 0, 7867, 7869, 5, 536, 0, 0, 7868,
		7859, 1, 0, 0, 0, 7868, 7860, 1, 0, 0, 0, 7868, 7861, 1, 0, 0, 0, 7868,
		7863, 1, 0, 0, 0, 7868, 7864, 1, 0, 0, 0, 7868, 7865, 1, 0, 0, 0, 7868,
		7867, 1, 0, 0, 0, 7869, 843, 1, 0, 0, 0, 7870, 7875, 5, 923, 0, 0, 7871,
		7872, 5, 890, 0, 0, 7872, 7874, 5, 923, 0, 0, 7873, 7871, 1, 0, 0, 0, 7874,
		7877, 1, 0, 0, 0, 7875, 7873, 1, 0, 0, 0, 7875, 7876, 1, 0, 0, 0, 7876,
		845, 1, 0, 0, 0, 7877, 7875, 1, 0, 0, 0, 7878, 7884, 5, 54, 0, 0, 7879,
		7884, 5, 339, 0, 0, 7880, 7884, 5, 279, 0, 0, 7881, 7882, 5, 79, 0, 0,
		7882, 7884, 5, 279, 0, 0, 7883, 7878, 1, 0, 0, 0, 7883, 7879, 1, 0, 0,
		0, 7883, 7880, 1, 0, 0, 0, 7883, 7881, 1, 0, 0, 0, 7884, 847, 1, 0, 0,
		0, 7885, 7887, 5, 494, 0, 0, 7886, 7888, 5, 908, 0, 0, 7887, 7886, 1, 0,
		0, 0, 7887, 7888, 1, 0, 0, 0, 7888, 7889, 1, 0, 0, 0, 7889, 7890, 5, 923,
		0, 0, 7890, 849, 1, 0, 0, 0, 7891, 7893, 5, 555, 0, 0, 7892, 7894, 5, 908,
		0, 0, 7893, 7892, 1, 0, 0, 0, 7893, 7894, 1, 0, 0, 0, 7894, 7895, 1, 0,
		0, 0, 7895, 7896, 3, 288, 144, 0, 7896, 851, 1, 0, 0, 0, 7897, 7900, 3,
		848, 424, 0, 7898, 7900, 3, 850, 425, 0, 7899, 7897, 1, 0, 0, 0, 7899,
		7898, 1, 0, 0, 0, 7900, 853, 1, 0, 0, 0, 7901, 7903, 5, 664, 0, 0, 7902,
		7904, 5, 908, 0, 0, 7903, 7902, 1, 0, 0, 0, 7903, 7904, 1, 0, 0, 0, 7904,
		7905, 1, 0, 0, 0, 7905, 7917, 3, 288, 144, 0, 7906, 7908, 5, 472, 0, 0,
		7907, 7909, 5, 908, 0, 0, 7908, 7907, 1, 0, 0, 0, 7908, 7909, 1, 0, 0,
		0, 7909, 7910, 1, 0, 0, 0, 7910, 7917, 3, 288, 144, 0, 7911, 7913, 5, 285,
		0, 0, 7912, 7914, 5, 908, 0, 0, 7913, 7912, 1, 0, 0, 0, 7913, 7914, 1,
		0, 0, 0, 7914, 7915, 1, 0, 0, 0, 7915, 7917, 3, 288, 144, 0, 7916, 7901,
		1, 0, 0, 0, 7916, 7906, 1, 0, 0, 0, 7916, 7911, 1, 0, 0, 0, 7917, 855,
		1, 0, 0, 0, 7918, 7919, 6, 428, -1, 0, 7919, 7922, 3, 854, 427, 0, 7920,
		7922, 3, 948, 474, 0, 7921, 7918, 1, 0, 0, 0, 7921, 7920, 1, 0, 0, 0, 7922,
		7928, 1, 0, 0, 0, 7923, 7924, 10, 2, 0, 0, 7924, 7925, 5, 890, 0, 0, 7925,
		7927, 3, 854, 427, 0, 7926, 7923, 1, 0, 0, 0, 7927, 7930, 1, 0, 0, 0, 7928,
		7926, 1, 0, 0, 0, 7928, 7929, 1, 0, 0, 0, 7929, 857, 1, 0, 0, 0, 7930,
		7928, 1, 0, 0, 0, 7931, 7932, 7, 62, 0, 0, 7932, 859, 1, 0, 0, 0, 7933,
		7935, 5, 427, 0, 0, 7934, 7936, 5, 908, 0, 0, 7935, 7934, 1, 0, 0, 0, 7935,
		7936, 1, 0, 0, 0, 7936, 7937, 1, 0, 0, 0, 7937, 7938, 5, 923, 0, 0, 7938,
		861, 1, 0, 0, 0, 7939, 7940, 3, 860, 430, 0, 7940, 7941, 3, 848, 424, 0,
		7941, 7951, 1, 0, 0, 0, 7942, 7944, 3, 848, 424, 0, 7943, 7945, 3, 880,
		440, 0, 7944, 7943, 1, 0, 0, 0, 7944, 7945, 1, 0, 0, 0, 7945, 7951, 1,
		0, 0, 0, 7946, 7948, 3, 850, 425, 0, 7947, 7949, 3, 880, 440, 0, 7948,
		7947, 1, 0, 0, 0, 7948, 7949, 1, 0, 0, 0, 7949, 7951, 1, 0, 0, 0, 7950,
		7939, 1, 0, 0, 0, 7950, 7942, 1, 0, 0, 0, 7950, 7946, 1, 0, 0, 0, 7951,
		863, 1, 0, 0, 0, 7952, 7953, 7, 63, 0, 0, 7953, 865, 1, 0, 0, 0, 7954,
		7959, 3, 868, 434, 0, 7955, 7956, 3, 868, 434, 0, 7956, 7957, 3, 866, 433,
		0, 7957, 7959, 1, 0, 0, 0, 7958, 7954, 1, 0, 0, 0, 7958, 7955, 1, 0, 0,
		0, 7959, 867, 1, 0, 0, 0, 7960, 7961, 3, 870, 435, 0, 7961, 869, 1, 0,
		0, 0, 7962, 7964, 5, 658, 0, 0, 7963, 7965, 5, 908, 0, 0, 7964, 7963, 1,
		0, 0, 0, 7964, 7965, 1, 0, 0, 0, 7965, 7966, 1, 0, 0, 0, 7966, 7967, 5,
		923, 0, 0, 7967, 871, 1, 0, 0, 0, 7968, 7969, 7, 64, 0, 0, 7969, 873, 1,
		0, 0, 0, 7970, 7972, 5, 680, 0, 0, 7971, 7973, 5, 908, 0, 0, 7972, 7971,
		1, 0, 0, 0, 7972, 7973, 1, 0, 0, 0, 7973, 7974, 1, 0, 0, 0, 7974, 7975,
		5, 271, 0, 0, 7975, 875, 1, 0, 0, 0, 7976, 7978, 5, 840, 0, 0, 7977, 7979,
		5, 908, 0, 0, 7978, 7977, 1, 0, 0, 0, 7978, 7979, 1, 0, 0, 0, 7979, 7980,
		1, 0, 0, 0, 7980, 7981, 5, 923, 0, 0, 7981, 877, 1, 0, 0, 0, 7982, 7983,
		3, 932, 466, 0, 7983, 7984, 5, 908, 0, 0, 7984, 7985, 3, 18, 9, 0, 7985,
		879, 1, 0, 0, 0, 7986, 7988, 5, 882, 0, 0, 7987, 7989, 5, 908, 0, 0, 7988,
		7987, 1, 0, 0, 0, 7988, 7989, 1, 0, 0, 0, 7989, 7990, 1, 0, 0, 0, 7990,
		7991, 3, 288, 144, 0, 7991, 881, 1, 0, 0, 0, 7992, 7994, 5, 628, 0, 0,
		7993, 7995, 5, 908, 0, 0, 7994, 7993, 1, 0, 0, 0, 7994, 7995, 1, 0, 0,
		0, 7995, 7996, 1, 0, 0, 0, 7996, 7997, 3, 288, 144, 0, 7997, 883, 1, 0,
		0, 0, 7998, 8000, 5, 384, 0, 0, 7999, 8001, 5, 908, 0, 0, 8000, 7999, 1,
		0, 0, 0, 8000, 8001, 1, 0, 0, 0, 8001, 8002, 1, 0, 0, 0, 8002, 8003, 5,
		271, 0, 0, 8003, 885, 1, 0, 0, 0, 8004, 8005, 5, 166, 0, 0, 8005, 8008,
		5, 324, 0, 0, 8006, 8008, 3, 948, 474, 0, 8007, 8004, 1, 0, 0, 0, 8007,
		8006, 1, 0, 0, 0, 8008, 887, 1, 0, 0, 0, 8009, 8014, 3, 890, 445, 0, 8010,
		8011, 5, 890, 0, 0, 8011, 8013, 3, 890, 445, 0, 8012, 8010, 1, 0, 0, 0,
		8013, 8016, 1, 0, 0, 0, 8014, 8012, 1, 0, 0, 0, 8014, 8015, 1, 0, 0, 0,
		8015, 889, 1, 0, 0, 0, 8016, 8014, 1, 0, 0, 0, 8017, 8018, 5, 921, 0, 0,
		8018, 8019, 5, 908, 0, 0, 8019, 8022, 3, 24, 12, 0, 8020, 8021, 5, 369,
		0, 0, 8021, 8023, 5, 923, 0, 0, 8022, 8020, 1, 0, 0, 0, 8022, 8023, 1,
		0, 0, 0, 8023, 8033, 1, 0, 0, 0, 8024, 8025, 5, 471, 0, 0, 8025, 8026,
		5, 908, 0, 0, 8026, 8034, 5, 758, 0, 0, 8027, 8028, 5, 471, 0, 0, 8028,
		8029, 5, 908, 0, 0, 8029, 8034, 5, 550, 0, 0, 8030, 8031, 5, 471, 0, 0,
		8031, 8032, 5, 908, 0, 0, 8032, 8034, 5, 17, 0, 0, 8033, 8024, 1, 0, 0,
		0, 8033, 8027, 1, 0, 0, 0, 8033, 8030, 1, 0, 0, 0, 8033, 8034, 1, 0, 0,
		0, 8034, 8036, 1, 0, 0, 0, 8035, 8037, 3, 852, 426, 0, 8036, 8035, 1, 0,
		0, 0, 8036, 8037, 1, 0, 0, 0, 8037, 8039, 1, 0, 0, 0, 8038, 8040, 3, 880,
		440, 0, 8039, 8038, 1, 0, 0, 0, 8039, 8040, 1, 0, 0, 0, 8040, 8090, 1,
		0, 0, 0, 8041, 8042, 5, 786, 0, 0, 8042, 8043, 5, 908, 0, 0, 8043, 8046,
		3, 24, 12, 0, 8044, 8045, 5, 369, 0, 0, 8045, 8047, 5, 923, 0, 0, 8046,
		8044, 1, 0, 0, 0, 8046, 8047, 1, 0, 0, 0, 8047, 8057, 1, 0, 0, 0, 8048,
		8049, 5, 471, 0, 0, 8049, 8050, 5, 908, 0, 0, 8050, 8058, 5, 758, 0, 0,
		8051, 8052, 5, 471, 0, 0, 8052, 8053, 5, 908, 0, 0, 8053, 8058, 5, 550,
		0, 0, 8054, 8055, 5, 471, 0, 0, 8055, 8056, 5, 908, 0, 0, 8056, 8058, 5,
		17, 0, 0, 8057, 8048, 1, 0, 0, 0, 8057, 8051, 1, 0, 0, 0, 8057, 8054, 1,
		0, 0, 0, 8057, 8058, 1, 0, 0, 0, 8058, 8060, 1, 0, 0, 0, 8059, 8061, 3,
		852, 426, 0, 8060, 8059, 1, 0, 0, 0, 8060, 8061, 1, 0, 0, 0, 8061, 8063,
		1, 0, 0, 0, 8062, 8064, 3, 880, 440, 0, 8063, 8062, 1, 0, 0, 0, 8063, 8064,
		1, 0, 0, 0, 8064, 8090, 1, 0, 0, 0, 8065, 8066, 5, 478, 0, 0, 8066, 8067,
		5, 908, 0, 0, 8067, 8070, 3, 24, 12, 0, 8068, 8069, 5, 369, 0, 0, 8069,
		8071, 5, 923, 0, 0, 8070, 8068, 1, 0, 0, 0, 8070, 8071, 1, 0, 0, 0, 8071,
		8081, 1, 0, 0, 0, 8072, 8073, 5, 471, 0, 0, 8073, 8074, 5, 908, 0, 0, 8074,
		8082, 5, 758, 0, 0, 8075, 8076, 5, 471, 0, 0, 8076, 8077, 5, 908, 0, 0,
		8077, 8082, 5, 550, 0, 0, 8078, 8079, 5, 471, 0, 0, 8079, 8080, 5, 908,
		0, 0, 8080, 8082, 5, 17, 0, 0, 8081, 8072, 1, 0, 0, 0, 8081, 8075, 1, 0,
		0, 0, 8081, 8078, 1, 0, 0, 0, 8081, 8082, 1, 0, 0, 0, 8082, 8084, 1, 0,
		0, 0, 8083, 8085, 3, 852, 426, 0, 8084, 8083, 1, 0, 0, 0, 8084, 8085, 1,
		0, 0, 0, 8085, 8087, 1, 0, 0, 0, 8086, 8088, 3, 880, 440, 0, 8087, 8086,
		1, 0, 0, 0, 8087, 8088, 1, 0, 0, 0, 8088, 8090, 1, 0, 0, 0, 8089, 8017,
		1, 0, 0, 0, 8089, 8041, 1, 0, 0, 0, 8089, 8065, 1, 0, 0, 0, 8090, 891,
		1, 0, 0, 0, 8091, 8092, 6, 446, -1, 0, 8092, 8095, 3, 894, 447, 0, 8093,
		8095, 3, 948, 474, 0, 8094, 8091, 1, 0, 0, 0, 8094, 8093, 1, 0, 0, 0, 8095,
		8101, 1, 0, 0, 0, 8096, 8097, 10, 2, 0, 0, 8097, 8098, 5, 890, 0, 0, 8098,
		8100, 3, 894, 447, 0, 8099, 8096, 1, 0, 0, 0, 8100, 8103, 1, 0, 0, 0, 8101,
		8099, 1, 0, 0, 0, 8101, 8102, 1, 0, 0, 0, 8102, 893, 1, 0, 0, 0, 8103,
		8101, 1, 0, 0, 0, 8104, 8106, 5, 777, 0, 0, 8105, 8107, 5, 908, 0, 0, 8106,
		8105, 1, 0, 0, 0, 8106, 8107, 1, 0, 0, 0, 8107, 8108, 1, 0, 0, 0, 8108,
		8130, 5, 271, 0, 0, 8109, 8111, 5, 796, 0, 0, 8110, 8112, 5, 908, 0, 0,
		8111, 8110, 1, 0, 0, 0, 8111, 8112, 1, 0, 0, 0, 8112, 8113, 1, 0, 0, 0,
		8113, 8130, 3, 288, 144, 0, 8114, 8116, 5, 866, 0, 0, 8115, 8117, 5, 908,
		0, 0, 8116, 8115, 1, 0, 0, 0, 8116, 8117, 1, 0, 0, 0, 8117, 8118, 1, 0,
		0, 0, 8118, 8130, 5, 271, 0, 0, 8119, 8121, 5, 637, 0, 0, 8120, 8122, 5,
		908, 0, 0, 8121, 8120, 1, 0, 0, 0, 8121, 8122, 1, 0, 0, 0, 8122, 8123,
		1, 0, 0, 0, 8123, 8130, 5, 271, 0, 0, 8124, 8126, 5, 713, 0, 0, 8125, 8127,
		5, 908, 0, 0, 8126, 8125, 1, 0, 0, 0, 8126, 8127, 1, 0, 0, 0, 8127, 8128,
		1, 0, 0, 0, 8128, 8130, 5, 271, 0, 0, 8129, 8104, 1, 0, 0, 0, 8129, 8109,
		1, 0, 0, 0, 8129, 8114, 1, 0, 0, 0, 8129, 8119, 1, 0, 0, 0, 8129, 8124,
		1, 0, 0, 0, 8130, 895, 1, 0, 0, 0, 8131, 8132, 7, 65, 0, 0, 8132, 897,
		1, 0, 0, 0, 8133, 8134, 7, 66, 0, 0, 8134, 899, 1, 0, 0, 0, 8135, 8136,
		7, 67, 0, 0, 8136, 901, 1, 0, 0, 0, 8137, 8138, 5, 193, 0, 0, 8138, 8139,
		5, 532, 0, 0, 8139, 8141, 3, 262, 131, 0, 8140, 8142, 3, 264, 132, 0, 8141,
		8140, 1, 0, 0, 0, 8141, 8142, 1, 0, 0, 0, 8142, 903, 1, 0, 0, 0, 8143,
		8144, 5, 193, 0, 0, 8144, 8145, 3, 162, 81, 0, 8145, 8146, 3, 262, 131,
		0, 8146, 905, 1, 0, 0, 0, 8147, 8149, 5, 193, 0, 0, 8148, 8150, 7, 51,
		0, 0, 8149, 8148, 1, 0, 0, 0, 8149, 8150, 1, 0, 0, 0, 8150, 8151, 1, 0,
		0, 0, 8151, 8152, 5, 365, 0, 0, 8152, 8153, 3, 908, 454, 0, 8153, 907,
		1, 0, 0, 0, 8154, 8171, 3, 910, 455, 0, 8155, 8156, 5, 539, 0, 0, 8156,
		8157, 5, 811, 0, 0, 8157, 8171, 3, 912, 456, 0, 8158, 8159, 3, 910, 455,
		0, 8159, 8160, 5, 890, 0, 0, 8160, 8161, 5, 539, 0, 0, 8161, 8162, 5, 811,
		0, 0, 8162, 8163, 3, 912, 456, 0, 8163, 8171, 1, 0, 0, 0, 8164, 8165, 5,
		539, 0, 0, 8165, 8166, 5, 811, 0, 0, 8166, 8167, 3, 912, 456, 0, 8167,
		8168, 5, 890, 0, 0, 8168, 8169, 3, 910, 455, 0, 8169, 8171, 1, 0, 0, 0,
		8170, 8154, 1, 0, 0, 0, 8170, 8155, 1, 0, 0, 0, 8170, 8158, 1, 0, 0, 0,
		8170, 8164, 1, 0, 0, 0, 8171, 909, 1, 0, 0, 0, 8172, 8173, 5, 171, 0, 0,
		8173, 8177, 5, 848, 0, 0, 8174, 8175, 5, 171, 0, 0, 8175, 8177, 5, 248,
		0, 0, 8176, 8172, 1, 0, 0, 0, 8176, 8174, 1, 0, 0, 0, 8177, 911, 1, 0,
		0, 0, 8178, 8179, 5, 171, 0, 0, 8179, 8186, 5, 545, 0, 0, 8180, 8181, 5,
		171, 0, 0, 8181, 8186, 5, 468, 0, 0, 8182, 8183, 5, 551, 0, 0, 8183, 8186,
		5, 171, 0, 0, 8184, 8186, 5, 688, 0, 0, 8185, 8178, 1, 0, 0, 0, 8185, 8180,
		1, 0, 0, 0, 8185, 8182, 1, 0, 0, 0, 8185, 8184, 1, 0, 0, 0, 8186, 913,
		1, 0, 0, 0, 8187, 8188, 5, 575, 0, 0, 8188, 8189, 3, 930, 465, 0, 8189,
		915, 1, 0, 0, 0, 8190, 8191, 5, 426, 0, 0, 8191, 8192, 5, 223, 0, 0, 8192,
		8202, 3, 930, 465, 0, 8193, 8194, 5, 426, 0, 0, 8194, 8195, 5, 819, 0,
		0, 8195, 8196, 5, 223, 0, 0, 8196, 8202, 3, 930, 465, 0, 8197, 8198, 5,
		426, 0, 0, 8198, 8199, 5, 223, 0, 0, 8199, 8200, 5, 575, 0, 0, 8200, 8202,
		3, 930, 465, 0, 8201, 8190, 1, 0, 0, 0, 8201, 8193, 1, 0, 0, 0, 8201, 8197,
		1, 0, 0, 0, 8202, 917, 1, 0, 0, 0, 8203, 8204, 5, 175, 0, 0, 8204, 8205,
		5, 575, 0, 0, 8205, 8206, 3, 930, 465, 0, 8206, 919, 1, 0, 0, 0, 8207,
		8208, 5, 4, 0, 0, 8208, 8209, 5, 616, 0, 0, 8209, 8210, 3, 922, 461, 0,
		8210, 8211, 3, 928, 464, 0, 8211, 8213, 5, 478, 0, 0, 8212, 8214, 5, 908,
		0, 0, 8213, 8212, 1, 0, 0, 0, 8213, 8214, 1, 0, 0, 0, 8214, 8215, 1, 0,
		0, 0, 8215, 8217, 3, 24, 12, 0, 8216, 8218, 5, 79, 0, 0, 8217, 8216, 1,
		0, 0, 0, 8217, 8218, 1, 0, 0, 0, 8218, 921, 1, 0, 0, 0, 8219, 8220, 5,
		2, 0, 0, 8220, 8230, 5, 519, 0, 0, 8221, 8222, 5, 541, 0, 0, 8222, 8230,
		5, 519, 0, 0, 8223, 8224, 5, 560, 0, 0, 8224, 8225, 5, 519, 0, 0, 8225,
		8230, 5, 608, 0, 0, 8226, 8227, 5, 314, 0, 0, 8227, 8228, 5, 519, 0, 0,
		8228, 8230, 5, 608, 0, 0, 8229, 8219, 1, 0, 0, 0, 8229, 8221, 1, 0, 0,
		0, 8229, 8223, 1, 0, 0, 0, 8229, 8226, 1, 0, 0, 0, 8230, 923, 1, 0, 0,
		0, 8231, 8232, 5, 4, 0, 0, 8232, 8233, 5, 616, 0, 0, 8233, 8234, 3, 926,
		463, 0, 8234, 925, 1, 0, 0, 0, 8235, 8236, 5, 574, 0, 0, 8236, 8237, 5,
		223, 0, 0, 8237, 8238, 5, 753, 0, 0, 8238, 8239, 5, 223, 0, 0, 8239, 8243,
		5, 168, 0, 0, 8240, 8241, 5, 247, 0, 0, 8241, 8242, 5, 834, 0, 0, 8242,
		8244, 5, 498, 0, 0, 8243, 8240, 1, 0, 0, 0, 8243, 8244, 1, 0, 0, 0, 8244,
		8265, 1, 0, 0, 0, 8245, 8246, 5, 574, 0, 0, 8246, 8247, 5, 223, 0, 0, 8247,
		8248, 5, 753, 0, 0, 8248, 8249, 5, 223, 0, 0, 8249, 8250, 5, 546, 0, 0,
		8250, 8254, 5, 817, 0, 0, 8251, 8252, 5, 247, 0, 0, 8252, 8253, 5, 834,
		0, 0, 8253, 8255, 5, 498, 0, 0, 8254, 8251, 1, 0, 0, 0, 8254, 8255, 1,
		0, 0, 0, 8255, 8265, 1, 0, 0, 0, 8256, 8257, 5, 797, 0, 0, 8257, 8258,
		5, 546, 0, 0, 8258, 8259, 5, 817, 0, 0, 8259, 8265, 5, 519, 0, 0, 8260,
		8261, 5, 30, 0, 0, 8261, 8262, 5, 223, 0, 0, 8262, 8263, 5, 546, 0, 0,
		8263, 8265, 5, 817, 0, 0, 8264, 8235, 1, 0, 0, 0, 8264, 8245, 1, 0, 0,
		0, 8264, 8256, 1, 0, 0, 0, 8264, 8260, 1, 0, 0, 0, 8265, 927, 1, 0, 0,
		0, 8266, 8269, 3, 934, 467, 0, 8267, 8269, 5, 923, 0, 0, 8268, 8266, 1,
		0, 0, 0, 8268, 8267, 1, 0, 0, 0, 8269, 929, 1, 0, 0, 0, 8270, 8273, 5,
		921, 0, 0, 8271, 8273, 3, 944, 472, 0, 8272, 8270, 1, 0, 0, 0, 8272, 8271,
		1, 0, 0, 0, 8273, 931, 1, 0, 0, 0, 8274, 8277, 5, 921, 0, 0, 8275, 8277,
		3, 942, 471, 0, 8276, 8274, 1, 0, 0, 0, 8276, 8275, 1, 0, 0, 0, 8277, 933,
		1, 0, 0, 0, 8278, 8281, 5, 921, 0, 0, 8279, 8281, 3, 942, 471, 0, 8280,
		8278, 1, 0, 0, 0, 8280, 8279, 1, 0, 0, 0, 8281, 935, 1, 0, 0, 0, 8282,
		8283, 7, 68, 0, 0, 8283, 937, 1, 0, 0, 0, 8284, 8287, 5, 921, 0, 0, 8285,
		8287, 3, 942, 471, 0, 8286, 8284, 1, 0, 0, 0, 8286, 8285, 1, 0, 0, 0, 8287,
		939, 1, 0, 0, 0, 8288, 8289, 7, 69, 0, 0, 8289, 941, 1, 0, 0, 0, 8290,
		8293, 3, 944, 472, 0, 8291, 8293, 3, 946, 473, 0, 8292, 8290, 1, 0, 0,
		0, 8292, 8291, 1, 0, 0, 0, 8293, 943, 1, 0, 0, 0, 8294, 8295, 7, 70, 0,
		0, 8295, 945, 1, 0, 0, 0, 8296, 8297, 5, 704, 0, 0, 8297, 947, 1, 0, 0,
		0, 8298, 8299, 1, 0, 0, 0, 8299, 949, 1, 0, 0, 0, 8300, 8301, 3, 36, 18,
		0, 8301, 8302, 5, 0, 0, 1, 8302, 951, 1, 0, 0, 0, 8303, 8304, 3, 4, 2,
		0, 8304, 8305, 5, 0, 0, 1, 8305, 953, 1, 0, 0, 0, 871, 964, 966, 1041,
		1048, 1056, 1062, 1068, 1072, 1100, 1103, 1109, 1122, 1133, 1152, 1230,
		1232, 1289, 1342, 1344, 1395, 1403, 1410, 1412, 1440, 1457, 1459, 1473,
		1484, 1493, 1532, 1542, 1552, 1562, 1572, 1582, 1592, 1602, 1612, 1616,
		1620, 1629, 1633, 1637, 1703, 1708, 1713, 1731, 1733, 1755, 1757, 1761,
		1772, 1779, 1789, 1792, 1795, 1806, 1813, 1824, 1827, 1832, 1842, 1854,
		1861, 1896, 1904, 1912, 1920, 1928, 1936, 1944, 1952, 1965, 1969, 1973,
		2185, 2194, 2199, 2217, 2226, 2235, 2250, 2252, 2269, 2271, 2280, 2304,
		2325, 2328, 2331, 2339, 2341, 2352, 2356, 2365, 2368, 2371, 2378, 2392,
		2400, 2409, 2417, 2419, 2424, 2431, 2436, 2441, 2446, 2451, 2456, 2461,
		2466, 2471, 2474, 2479, 2486, 2491, 2496, 2501, 2509, 2514, 2517, 2524,
		2532, 2537, 2542, 2552, 2556, 2562, 2573, 2595, 2602, 2610, 2613, 2621,
		2629, 2638, 2643, 2650, 2655, 2660, 2664, 2668, 2673, 2678, 2683, 2688,
		2693, 2701, 2709, 2715, 2721, 2727, 2730, 2738, 2746, 2753, 2760, 2764,
		2770, 2777, 2781, 2796, 2802, 2806, 2814, 2818, 2827, 2832, 2835, 2839,
		2844, 2848, 2853, 2858, 2865, 2868, 2874, 2880, 2887, 2890, 2896, 2901,
		2907, 2912, 2922, 2930, 2934, 2940, 2949, 2954, 2961, 2974, 2977, 2985,
		2990, 2993, 3003, 3008, 3011, 3021, 3026, 3029, 3041, 3043, 3047, 3051,
		3055, 3060, 3064, 3071, 3073, 3076, 3085, 3098, 3106, 3115, 3122, 3133,
		3140, 3144, 3155, 3161, 3172, 3177, 3188, 3200, 3206, 3212, 3225, 3234,
		3240, 3245, 3251, 3255, 3259, 3262, 3268, 3272, 3275, 3278, 3284, 3288,
		3292, 3295, 3298, 3304, 3308, 3311, 3314, 3320, 3331, 3336, 3348, 3353,
		3355, 3364, 3373, 3383, 3392, 3399, 3405, 3412, 3417, 3424, 3426, 3435,
		3444, 3452, 3465, 3472, 3477, 3481, 3484, 3490, 3501, 3512, 3516, 3520,
		3523, 3531, 3534, 3537, 3548, 3551, 3554, 3565, 3568, 3571, 3582, 3585,
		3588, 3596, 3601, 3604, 3609, 3612, 3617, 3622, 3625, 3629, 3633, 3636,
		3641, 3644, 3648, 3657, 3664, 3669, 3672, 3679, 3684, 3687, 3689, 3696,
		3710, 3719, 3721, 3741, 3747, 3759, 3774, 3785, 3789, 3796, 3799, 3805,
		3812, 3817, 3825, 3830, 3835, 3839, 3843, 3851, 3856, 3861, 3866, 3871,
		3876, 3881, 3886, 3890, 3894, 3899, 3903, 3908, 3913, 3918, 3923, 3929,
		3934, 3939, 3944, 3949, 3954, 3957, 3963, 3969, 3980, 3991, 4005, 4009,
		4020, 4030, 4032, 4043, 4057, 4061, 4064, 4082, 4089, 4097, 4104, 4136,
		4167, 4170, 4193, 4201, 4217, 4226, 4233, 4241, 4252, 4266, 4274, 4281,
		4286, 4296, 4305, 4313, 4325, 4329, 4337, 4349, 4353, 4374, 4382, 4399,
		4409, 4413, 4419, 4425, 4434, 4448, 4454, 4461, 4465, 4469, 4473, 4478,
		4483, 4488, 4491, 4498, 4502, 4507, 4511, 4515, 4519, 4522, 4527, 4530,
		4538, 4543, 4554, 4561, 4565, 4573, 4580, 4589, 4596, 4599, 4603, 4608,
		4614, 4637, 4642, 4647, 4652, 4655, 4661, 4665, 4670, 4674, 4680, 4685,
		4689, 4696, 4707, 4710, 4718, 4722, 4725, 4729, 4749, 4755, 4762, 4767,
		4774, 4790, 4796, 4803, 4808, 4813, 4826, 4832, 4838, 4844, 4846, 4850,
		4857, 4867, 4871, 4873, 4880, 4887, 4891, 4909, 4915, 4917, 4923, 4928,
		4935, 4939, 4946, 4950, 4957, 4961, 4966, 4971, 4976, 4980, 4990, 4995,
		4999, 5003, 5013, 5016, 5019, 5033, 5041, 5051, 5054, 5061, 5066, 5072,
		5077, 5092, 5097, 5102, 5110, 5117, 5124, 5131, 5137, 5147, 5149, 5280,
		5287, 5294, 5301, 5308, 5315, 5322, 5329, 5336, 5363, 5387, 5393, 5403,
		5422, 5453, 5458, 5465, 5470, 5481, 5486, 5492, 5499, 5505, 5510, 5517,
		5527, 5532, 5541, 5545, 5550, 5553, 5557, 5562, 5567, 5571, 5575, 5579,
		5585, 5589, 5594, 5596, 5600, 5608, 5614, 5617, 5625, 5647, 5656, 5664,
		5675, 5681, 5685, 5692, 5698, 5705, 5707, 5714, 5725, 5733, 5737, 5744,
		5762, 5780, 5782, 5790, 5798, 5810, 5812, 5820, 5829, 5859, 5888, 5890,
		5897, 5900, 5907, 5911, 5916, 5921, 5924, 5945, 5950, 5958, 5963, 5973,
		5982, 5992, 6027, 6035, 6041, 6047, 6057, 6062, 6072, 6076, 6084, 6094,
		6102, 6112, 6120, 6130, 6138, 6148, 6161, 6165, 6176, 6187, 6215, 6225,
		6252, 6264, 6276, 6288, 6291, 6300, 6306, 6310, 6323, 6327, 6338, 6343,
		6351, 6362, 6373, 6387, 6395, 6399, 6412, 6415, 6436, 6445, 6454, 6459,
		6466, 6471, 6475, 6483, 6490, 6500, 6510, 6512, 6521, 6526, 6529, 6533,
		6546, 6555, 6565, 6585, 6592, 6600, 6605, 6612, 6635, 6643, 6648, 6652,
		6657, 6661, 6680, 6682, 6686, 6690, 6700, 6713, 6715, 6722, 6748, 6763,
		6769, 6781, 6788, 6799, 6809, 6817, 6825, 6844, 6854, 6862, 6870, 6877,
		6890, 6903, 6918, 6925, 6929, 6936, 6943, 6959, 6977, 6981, 6999, 7006,
		7012, 7018, 7023, 7026, 7032, 7037, 7040, 7043, 7049, 7054, 7058, 7061,
		7064, 7070, 7075, 7078, 7081, 7087, 7096, 7104, 7117, 7126, 7131, 7143,
		7148, 7150, 7156, 7161, 7169, 7173, 7177, 7184, 7191, 7194, 7204, 7215,
		7226, 7237, 7239, 7256, 7267, 7305, 7312, 7323, 7335, 7344, 7347, 7354,
		7362, 7365, 7368, 7383, 7386, 7411, 7423, 7426, 7429, 7438, 7443, 7447,
		7454, 7461, 7473, 7493, 7504, 7512, 7515, 7522, 7530, 7551, 7560, 7568,
		7573, 7586, 7596, 7601, 7607, 7630, 7635, 7655, 7727, 7731, 7741, 7789,
		7794, 7797, 7805, 7816, 7820, 7827, 7832, 7837, 7842, 7848, 7853, 7857,
		7868, 7875, 7883, 7887, 7893, 7899, 7903, 7908, 7913, 7916, 7921, 7928,
		7935, 7944, 7948, 7950, 7958, 7964, 7972, 7978, 7988, 7994, 8000, 8007,
		8014, 8022, 8033, 8036, 8039, 8046, 8057, 8060, 8063, 8070, 8081, 8084,
		8087, 8089, 8094, 8101, 8106, 8111, 8116, 8121, 8126, 8129, 8141, 8149,
		8170, 8176, 8185, 8201, 8213, 8217, 8229, 8243, 8254, 8264, 8268, 8272,
		8276, 8280, 8286, 8292,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// OBParserInit initializes any static state used to implement OBParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewOBParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func OBParserInit() {
	staticData := &OBParserParserStaticData
	staticData.once.Do(obparserParserInit)
}

// NewOBParser produces a new parser instance for the optional input antlr.TokenStream.
func NewOBParser(input antlr.TokenStream) *OBParser {
	OBParserInit()
	this := new(OBParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &OBParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "OBParser.g4"

	return this
}

// Note that '@members' cannot be changed now, but this should have been 'globals'
// If you are looking to have variables for each instance, use '@structmembers'

var is_pl_parse_ bool = false
var is_pl_parse_expr_ bool = false

// OBParser tokens.
const (
	OBParserEOF                                  = antlr.TokenEOF
	OBParserACCESSIBLE                           = 1
	OBParserADD                                  = 2
	OBParserAGAINST                              = 3
	OBParserALTER                                = 4
	OBParserALWAYS                               = 5
	OBParserAND                                  = 6
	OBParserANALYZE                              = 7
	OBParserALL                                  = 8
	OBParserAS                                   = 9
	OBParserASENSITIVE                           = 10
	OBParserASC                                  = 11
	OBParserBETWEEN                              = 12
	OBParserBEFORE                               = 13
	OBParserBIGINT                               = 14
	OBParserBINARY                               = 15
	OBParserBLOB                                 = 16
	OBParserBOTH                                 = 17
	OBParserBULK                                 = 18
	OBParserBY                                   = 19
	OBParserCALL                                 = 20
	OBParserCASCADE                              = 21
	OBParserCASE                                 = 22
	OBParserCHANGE                               = 23
	OBParserCHARACTER                            = 24
	OBParserCHECK                                = 25
	OBParserCIPHER                               = 26
	OBParserCONDITION                            = 27
	OBParserCONSTRAINT                           = 28
	OBParserCONTINUE                             = 29
	OBParserCONVERT                              = 30
	OBParserCOLLATE                              = 31
	OBParserCOLUMN                               = 32
	OBParserCOLUMNS                              = 33
	OBParserCREATE                               = 34
	OBParserCROSS                                = 35
	OBParserCYCLE                                = 36
	OBParserCURRENT_DATE                         = 37
	OBParserCURRENT_TIME                         = 38
	OBParserCURRENT_TIMESTAMP                    = 39
	OBParserCURRENT_USER                         = 40
	OBParserWITH_ROWID                           = 41
	OBParserCURSOR                               = 42
	OBParserDAY_HOUR                             = 43
	OBParserDAY_MICROSECOND                      = 44
	OBParserDAY_MINUTE                           = 45
	OBParserDAY_SECOND                           = 46
	OBParserDATABASE                             = 47
	OBParserDATABASES                            = 48
	OBParserNUMBER                               = 49
	OBParserDECIMAL                              = 50
	OBParserDECLARE                              = 51
	OBParserDEFAULT                              = 52
	OBParserDELAYED                              = 53
	OBParserDELETE                               = 54
	OBParserDESC                                 = 55
	OBParserDESCRIBE                             = 56
	OBParserDETERMINISTIC                        = 57
	OBParserDIV                                  = 58
	OBParserDISTINCT                             = 59
	OBParserDISTINCTROW                          = 60
	OBParserDOUBLE                               = 61
	OBParserDROP                                 = 62
	OBParserDUAL                                 = 63
	OBParserEACH                                 = 64
	OBParserENCLOSED                             = 65
	OBParserELSE                                 = 66
	OBParserELSEIF                               = 67
	OBParserESCAPED                              = 68
	OBParserEXISTS                               = 69
	OBParserEXIT                                 = 70
	OBParserEXPLAIN                              = 71
	OBParserFETCH                                = 72
	OBParserFIELDS                               = 73
	OBParserFOREIGN                              = 74
	OBParserFLOAT                                = 75
	OBParserFLOAT4                               = 76
	OBParserFLOAT8                               = 77
	OBParserFOR                                  = 78
	OBParserFORCE                                = 79
	OBParserFROM                                 = 80
	OBParserFULL                                 = 81
	OBParserFULLTEXT                             = 82
	OBParserGET                                  = 83
	OBParserGENERATED                            = 84
	OBParserGRANT                                = 85
	OBParserGROUP                                = 86
	OBParserHAVING                               = 87
	OBParserHIGH_PRIORITY                        = 88
	OBParserHOUR_MICROSECOND                     = 89
	OBParserHOUR_MINUTE                          = 90
	OBParserHOUR_SECOND                          = 91
	OBParserID                                   = 92
	OBParserIF                                   = 93
	OBParserIFIGNORE                             = 94
	OBParserIN                                   = 95
	OBParserINDEX                                = 96
	OBParserINNER                                = 97
	OBParserINFILE                               = 98
	OBParserINOUT                                = 99
	OBParserINSENSITIVE                          = 100
	OBParserINTEGER                              = 101
	OBParserINT1                                 = 102
	OBParserINT2                                 = 103
	OBParserINT3                                 = 104
	OBParserINT4                                 = 105
	OBParserINT8                                 = 106
	OBParserINTERVAL                             = 107
	OBParserINSERT                               = 108
	OBParserINTO                                 = 109
	OBParserIO_AFTER_GTIDS                       = 110
	OBParserIO_BEFORE_GTIDS                      = 111
	OBParserIS                                   = 112
	OBParserISSUER                               = 113
	OBParserITERATE                              = 114
	OBParserJOIN                                 = 115
	OBParserKEY                                  = 116
	OBParserKEYS                                 = 117
	OBParserKILL                                 = 118
	OBParserLANGUAGE                             = 119
	OBParserLEADING                              = 120
	OBParserLEAVE                                = 121
	OBParserLEFT                                 = 122
	OBParserLIMIT                                = 123
	OBParserLIKE                                 = 124
	OBParserLINEAR                               = 125
	OBParserLINES                                = 126
	OBParserBISON_LIST                           = 127
	OBParserLOAD                                 = 128
	OBParserLOCAL                                = 129
	OBParserLOCALTIME                            = 130
	OBParserLOCALTIMESTAMP                       = 131
	OBParserLOCK_                                = 132
	OBParserLONG                                 = 133
	OBParserLONGBLOB                             = 134
	OBParserLONGTEXT                             = 135
	OBParserLOOP                                 = 136
	OBParserLOW_PRIORITY                         = 137
	OBParserMASTER_BIND                          = 138
	OBParserMASTER_SSL_VERIFY_SERVER_CERT        = 139
	OBParserMATCH                                = 140
	OBParserMAXVALUE                             = 141
	OBParserMEDIUMBLOB                           = 142
	OBParserMEDIUMINT                            = 143
	OBParserMERGE                                = 144
	OBParserMEDIUMTEXT                           = 145
	OBParserMIDDLEINT                            = 146
	OBParserMINUTE_MICROSECOND                   = 147
	OBParserMINUTE_SECOND                        = 148
	OBParserMOD                                  = 149
	OBParserMODE                                 = 150
	OBParserMODIFIES                             = 151
	OBParserNATURAL                              = 152
	OBParserNO_WRITE_TO_BINLOG                   = 153
	OBParserON                                   = 154
	OBParserOPTION                               = 155
	OBParserOPTIMIZE                             = 156
	OBParserOPTIONALLY                           = 157
	OBParserOR                                   = 158
	OBParserORDER                                = 159
	OBParserOUT                                  = 160
	OBParserOUTER                                = 161
	OBParserOUTFILE                              = 162
	OBParserPARSER                               = 163
	OBParserPROCEDURE                            = 164
	OBParserPURGE                                = 165
	OBParserPARTITION                            = 166
	OBParserPRECISION                            = 167
	OBParserPRIMARY                              = 168
	OBParserPUBLIC                               = 169
	OBParserRANGE                                = 170
	OBParserREAD                                 = 171
	OBParserREAD_WRITE                           = 172
	OBParserREADS                                = 173
	OBParserREAL                                 = 174
	OBParserRELEASE                              = 175
	OBParserREFERENCES                           = 176
	OBParserREGEXP                               = 177
	OBParserRENAME                               = 178
	OBParserREPLACE                              = 179
	OBParserREPEAT                               = 180
	OBParserREQUIRE                              = 181
	OBParserRESIGNAL                             = 182
	OBParserRESTRICT                             = 183
	OBParserRETURN                               = 184
	OBParserREVOKE                               = 185
	OBParserRIGHT                                = 186
	OBParserROWS                                 = 187
	OBParserSECOND_MICROSECOND                   = 188
	OBParserSELECT                               = 189
	OBParserSCHEMA                               = 190
	OBParserSCHEMAS                              = 191
	OBParserSEPARATOR                            = 192
	OBParserSET                                  = 193
	OBParserSENSITIVE                            = 194
	OBParserSHOW                                 = 195
	OBParserSIGNAL                               = 196
	OBParserSMALLINT                             = 197
	OBParserSPATIAL                              = 198
	OBParserSPECIFIC                             = 199
	OBParserSQL                                  = 200
	OBParserSQLEXCEPTION                         = 201
	OBParserSQLSTATE                             = 202
	OBParserSQLWARNING                           = 203
	OBParserSQL_BIG_RESULT                       = 204
	OBParserSQL_CALC_FOUND_ROWS                  = 205
	OBParserSQL_SMALL_RESULT                     = 206
	OBParserSEARCH                               = 207
	OBParserSSL                                  = 208
	OBParserSTARTING                             = 209
	OBParserSTORED                               = 210
	OBParserSTRAIGHT_JOIN                        = 211
	OBParserSUBJECT                              = 212
	OBParserSYNONYM                              = 213
	OBParserSYSDATE                              = 214
	OBParserTERMINATED                           = 215
	OBParserTEXT                                 = 216
	OBParserTINYBLOB                             = 217
	OBParserTINYINT                              = 218
	OBParserTINYTEXT                             = 219
	OBParserTABLE                                = 220
	OBParserTABLEGROUP                           = 221
	OBParserTHEN                                 = 222
	OBParserTO                                   = 223
	OBParserTRAILING                             = 224
	OBParserTRIGGER                              = 225
	OBParserUNDO                                 = 226
	OBParserUNION                                = 227
	OBParserUNIQUE                               = 228
	OBParserUNLOCK                               = 229
	OBParserUNSIGNED                             = 230
	OBParserUPDATE                               = 231
	OBParserUSAGE                                = 232
	OBParserUSE                                  = 233
	OBParserUSING                                = 234
	OBParserUTC_DATE                             = 235
	OBParserUTC_TIME                             = 236
	OBParserUTC_TIMESTAMP                        = 237
	OBParserVALUES                               = 238
	OBParserVARBINARY                            = 239
	OBParserVARCHAR                              = 240
	OBParserVARYING                              = 241
	OBParserVIRTUAL                              = 242
	OBParserWHERE                                = 243
	OBParserWHEN                                 = 244
	OBParserWHILE                                = 245
	OBParserWINDOW                               = 246
	OBParserWITH                                 = 247
	OBParserWRITE                                = 248
	OBParserXOR                                  = 249
	OBParserX509                                 = 250
	OBParserYEAR_MONTH                           = 251
	OBParserZEROFILL                             = 252
	OBParserGLOBAL_ALIAS                         = 253
	OBParserSESSION_ALIAS                        = 254
	OBParserUnderlineUTF8                        = 255
	OBParserUnderlineUTF8MB4                     = 256
	OBParserUnderlineGBK                         = 257
	OBParserUnderlineGB18030                     = 258
	OBParserUnderlineBINARY                      = 259
	OBParserUnderlineUTF16                       = 260
	OBParserSTRONG                               = 261
	OBParserWEAK                                 = 262
	OBParserFROZEN                               = 263
	OBParserEXCEPT                               = 264
	OBParserMINUS                                = 265
	OBParserINTERSECT                            = 266
	OBParserISNULL                               = 267
	OBParserRETURNING                            = 268
	OBParserNOT                                  = 269
	OBParserNULLX                                = 270
	OBParserINTNUM                               = 271
	OBParserAUDIT                                = 272
	OBParserWARNINGS                             = 273
	OBParserFORMAT                               = 274
	OBParserUNINSTALL                            = 275
	OBParserUNDOFILE                             = 276
	OBParserMASTER_SSL_CA                        = 277
	OBParserYEAR                                 = 278
	OBParserSTOP                                 = 279
	OBParserSTORAGE_FORMAT_WORK_VERSION          = 280
	OBParserAT                                   = 281
	OBParserRELAY_LOG_POS                        = 282
	OBParserPOOL                                 = 283
	OBParserCURDATE                              = 284
	OBParserZONE_TYPE                            = 285
	OBParserLOCATION                             = 286
	OBParserWEIGHT_STRING                        = 287
	OBParserCHANGED                              = 288
	OBParserMASTER_SSL_CAPATH                    = 289
	OBParserREWRITE_MERGE_VERSION                = 290
	OBParserNTH_VALUE                            = 291
	OBParserSERIAL                               = 292
	OBParserPROGRESSIVE_MERGE_NUM                = 293
	OBParserTABLET_MAX_SIZE                      = 294
	OBParserILOGCACHE                            = 295
	OBParserAUTHORS                              = 296
	OBParserMIGRATE                              = 297
	OBParserCONSISTENT                           = 298
	OBParserSUSPEND                              = 299
	OBParserSECURITY                             = 300
	OBParserREMOTE_OSS                           = 301
	OBParserSET_SLAVE_CLUSTER                    = 302
	OBParserFAST                                 = 303
	OBParserPREVIEW                              = 304
	OBParserTRUNCATE                             = 305
	OBParserCONSTRAINT_SCHEMA                    = 306
	OBParserMASTER_SSL_CERT                      = 307
	OBParserTABLE_NAME                           = 308
	OBParserDO                                   = 309
	OBParserMASTER_RETRY_COUNT                   = 310
	OBParserREPLICA                              = 311
	OBParserKILL_EXPR                            = 312
	OBParserOLD_KEY                              = 313
	OBParserDISABLE                              = 314
	OBParserPORT                                 = 315
	OBParserREBUILD                              = 316
	OBParserFOLLOWER                             = 317
	OBParserLOWER_OVER                           = 318
	OBParserROOT                                 = 319
	OBParserREDOFILE                             = 320
	OBParserMASTER_SERVER_ID                     = 321
	OBParserNCHAR                                = 322
	OBParserKEY_BLOCK_SIZE                       = 323
	OBParserMIGRATION                            = 324
	OBParserSUBPARTITION                         = 325
	OBParserMYSQL_DRIVER                         = 326
	OBParserROW_NUMBER                           = 327
	OBParserCOMPRESSION                          = 328
	OBParserBIT                                  = 329
	OBParserMAX_DISK_SIZE                        = 330
	OBParserSAMPLE                               = 331
	OBParserUNLOCKED                             = 332
	OBParserCLASS_ORIGIN                         = 333
	OBParserRUDUNDANT                            = 334
	OBParserACTION                               = 335
	OBParserREDUNDANT                            = 336
	OBParserUPGRADE                              = 337
	OBParserVALIDATE                             = 338
	OBParserSTART                                = 339
	OBParserTEMPTABLE                            = 340
	OBParserRECYCLEBIN                           = 341
	OBParserPROFILES                             = 342
	OBParserTIMESTAMP_VALUE                      = 343
	OBParserERRORS                               = 344
	OBParserLEAVES                               = 345
	OBParserUNDEFINED                            = 346
	OBParserEVERY                                = 347
	OBParserBYTE                                 = 348
	OBParserFLUSH                                = 349
	OBParserMIN_ROWS                             = 350
	OBParserERROR_P                              = 351
	OBParserMAX_USER_CONNECTIONS                 = 352
	OBParserMAX_CPU                              = 353
	OBParserLOCKED                               = 354
	OBParserIO                                   = 355
	OBParserBTREE                                = 356
	OBParserSLOT_IDX                             = 357
	OBParserAPPROXNUM                            = 358
	OBParserHASH                                 = 359
	OBParserROTATE                               = 360
	OBParserCOLLATION                            = 361
	OBParserMASTER                               = 362
	OBParserENCRYPTION                           = 363
	OBParserMAX                                  = 364
	OBParserTRANSACTION                          = 365
	OBParserSQL_TSI_MONTH                        = 366
	OBParserIGNORE                               = 367
	OBParserMAX_QUERIES_PER_HOUR                 = 368
	OBParserCOMMENT                              = 369
	OBParserCTX_ID                               = 370
	OBParserMIN_IOPS                             = 371
	OBParserNVARCHAR                             = 372
	OBParserOFF                                  = 373
	OBParserPAUSE                                = 374
	OBParserQUICK                                = 375
	OBParserDUPLICATE                            = 376
	OBParserWAIT                                 = 377
	OBParserDES_KEY_FILE                         = 378
	OBParserENGINES                              = 379
	OBParserRETURNS                              = 380
	OBParserMASTER_USER                          = 381
	OBParserSOCKET                               = 382
	OBParserMASTER_DELAY                         = 383
	OBParserFILE_ID                              = 384
	OBParserFIRST                                = 385
	OBParserTABLET                               = 386
	OBParserCLIENT                               = 387
	OBParserENGINE_                              = 388
	OBParserTABLES                               = 389
	OBParserTRADITIONAL                          = 390
	OBParserBOOTSTRAP                            = 391
	OBParserSTDDEV                               = 392
	OBParserDATAFILE                             = 393
	OBParserVARCHARACTER                         = 394
	OBParserINVOKER                              = 395
	OBParserDEPTH                                = 396
	OBParserNORMAL                               = 397
	OBParserCOLUMN_NAME                          = 398
	OBParserTRIGGERS                             = 399
	OBParserRESET                                = 400
	OBParserEVENT                                = 401
	OBParserCOALESCE                             = 402
	OBParserRESPECT                              = 403
	OBParserSTATUS                               = 404
	OBParserUNBOUNDED                            = 405
	OBParserWRAPPER                              = 406
	OBParserTIMESTAMP                            = 407
	OBParserPARTITIONS                           = 408
	OBParserSUBSTR                               = 409
	OBParserCHUNK                                = 410
	OBParserFILEX                                = 411
	OBParserBACKUPSET                            = 412
	OBParserUNIT                                 = 413
	OBParserPRIVILEGES                           = 414
	OBParserLOWER_ON                             = 415
	OBParserLESS                                 = 416
	OBParserSWITCH                               = 417
	OBParserDIAGNOSTICS                          = 418
	OBParserREDO_BUFFER_SIZE                     = 419
	OBParserNO                                   = 420
	OBParserMAJOR                                = 421
	OBParserACTIVE                               = 422
	OBParserROUTINE                              = 423
	OBParserFOLLOWING                            = 424
	OBParserREAD_ONLY                            = 425
	OBParserROLLBACK                             = 426
	OBParserPARTITION_ID                         = 427
	OBParserDUMP                                 = 428
	OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS       = 429
	OBParserGROUPING                             = 430
	OBParserARCHIVELOG                           = 431
	OBParserMATCHED                              = 432
	OBParserMAX_CONNECTIONS_PER_HOUR             = 433
	OBParserSECOND                               = 434
	OBParserUNKNOWN                              = 435
	OBParserPOINT                                = 436
	OBParserPL                                   = 437
	OBParserPOLYGON                              = 438
	OBParserTABLE_ID                             = 439
	OBParserCONTEXT                              = 440
	OBParserFINAL_COUNT                          = 441
	OBParserMASTER_CONNECT_RETRY                 = 442
	OBParserPOSITION                             = 443
	OBParserDISCARD                              = 444
	OBParserPREV                                 = 445
	OBParserRECOVER                              = 446
	OBParserPROCESS                              = 447
	OBParserDEALLOCATE                           = 448
	OBParserOLD_PASSWORD                         = 449
	OBParserLISTAGG                              = 450
	OBParserSLOW                                 = 451
	OBParserSUM                                  = 452
	OBParserOPTIONS                              = 453
	OBParserMIN                                  = 454
	OBParserRELOAD                               = 455
	OBParserONE                                  = 456
	OBParserDELAY_KEY_WRITE                      = 457
	OBParserORIG_DEFAULT                         = 458
	OBParserRLIKE                                = 459
	OBParserSQL_TSI_HOUR                         = 460
	OBParserTIMESTAMPDIFF                        = 461
	OBParserRESTORE                              = 462
	OBParserOFFSET                               = 463
	OBParserTEMPORARY                            = 464
	OBParserVARIANCE                             = 465
	OBParserSNAPSHOT                             = 466
	OBParserSERVER_TYPE                          = 467
	OBParserCOMMITTED                            = 468
	OBParserINDEXES                              = 469
	OBParserFREEZE                               = 470
	OBParserSCOPE                                = 471
	OBParserIDC                                  = 472
	OBParserVIEW                                 = 473
	OBParserONE_SHOT                             = 474
	OBParserACCOUNT                              = 475
	OBParserLOCALITY                             = 476
	OBParserREVERSE                              = 477
	OBParserCLUSTER_ID                           = 478
	OBParserNOARCHIVELOG                         = 479
	OBParserMAX_SIZE                             = 480
	OBParserPAGE                                 = 481
	OBParserNAME                                 = 482
	OBParserROW_COUNT                            = 483
	OBParserLAST                                 = 484
	OBParserLOGONLY_REPLICA_NUM                  = 485
	OBParserDELAY                                = 486
	OBParserSUBDATE                              = 487
	OBParserINCREMENTAL                          = 488
	OBParserROLLING                              = 489
	OBParserCONTAINS                             = 490
	OBParserGENERAL                              = 491
	OBParserVISIBLE                              = 492
	OBParserSIGNED                               = 493
	OBParserSERVER                               = 494
	OBParserNEXT                                 = 495
	OBParserENDS                                 = 496
	OBParserGLOBAL                               = 497
	OBParserSHUTDOWN                             = 498
	OBParserVERBOSE                              = 499
	OBParserCLUSTER_NAME                         = 500
	OBParserMASTER_PORT                          = 501
	OBParserMYSQL_ERRNO                          = 502
	OBParserLOWER_COMMA                          = 503
	OBParserXA                                   = 504
	OBParserTIME                                 = 505
	OBParserDATETIME                             = 506
	OBParserBOOL                                 = 507
	OBParserDIRECTORY                            = 508
	OBParserDATA_TABLE_ID                        = 509
	OBParserVALID                                = 510
	OBParserMASTER_SSL_KEY                       = 511
	OBParserMASTER_PASSWORD                      = 512
	OBParserPLAN                                 = 513
	OBParserSHARE                                = 514
	OBParserMULTIPOLYGON                         = 515
	OBParserSTDDEV_SAMP                          = 516
	OBParserUSE_BLOOM_FILTER                     = 517
	OBParserCONSTRAINT_CATALOG                   = 518
	OBParserCLUSTER                              = 519
	OBParserEXCHANGE                             = 520
	OBParserGRANTS                               = 521
	OBParserCAST                                 = 522
	OBParserSERVER_PORT                          = 523
	OBParserSQL_CACHE                            = 524
	OBParserMAX_USED_PART_ID                     = 525
	OBParserINSTANCE                             = 526
	OBParserFUNCTION                             = 527
	OBParserNOWAIT                               = 528
	OBParserINVISIBLE                            = 529
	OBParserDENSE_RANK                           = 530
	OBParserCOUNT                                = 531
	OBParserNAMES                                = 532
	OBParserCHAR                                 = 533
	OBParserLOWER_THAN_NEG                       = 534
	OBParserP_ENTITY                             = 535
	OBParserISOLATE                              = 536
	OBParserMAX_ROWS                             = 537
	OBParserCTXCAT                               = 538
	OBParserISOLATION                            = 539
	OBParserREPLICATION                          = 540
	OBParserREMOVE                               = 541
	OBParserSTATS_AUTO_RECALC                    = 542
	OBParserCONSISTENT_MODE                      = 543
	OBParserMODIFY                               = 544
	OBParserUNCOMMITTED                          = 545
	OBParserPHYSICAL                             = 546
	OBParserNO_WAIT                              = 547
	OBParserUNIT_NUM                             = 548
	OBParserMAX_IOPS                             = 549
	OBParserSPFILE                               = 550
	OBParserREPEATABLE                           = 551
	OBParserCOMPLETION                           = 552
	OBParserROOTTABLE                            = 553
	OBParserSUBSTRING                            = 554
	OBParserZONE                                 = 555
	OBParserTEMPLATE                             = 556
	OBParserDATE_SUB                             = 557
	OBParserEXPIRE_INFO                          = 558
	OBParserEXPIRE                               = 559
	OBParserENABLE                               = 560
	OBParserHOSTS                                = 561
	OBParserSCHEMA_NAME                          = 562
	OBParserEXPANSION                            = 563
	OBParserREORGANIZE                           = 564
	OBParserBLOCK_SIZE                           = 565
	OBParserINNER_PARSE                          = 566
	OBParserMINOR                                = 567
	OBParserRESUME                               = 568
	OBParserINT                                  = 569
	OBParserSTATS_PERSISTENT                     = 570
	OBParserNODEGROUP                            = 571
	OBParserPARTITIONING                         = 572
	OBParserSUPER                                = 573
	OBParserCOMMIT                               = 574
	OBParserSAVEPOINT                            = 575
	OBParserUNTIL                                = 576
	OBParserUSER                                 = 577
	OBParserMEMTABLE                             = 578
	OBParserCHARSET                              = 579
	OBParserMOVE                                 = 580
	OBParserXML                                  = 581
	OBParserIPC                                  = 582
	OBParserTRIM                                 = 583
	OBParserRANK                                 = 584
	OBParserDEFAULT_AUTH                         = 585
	OBParserEXTENT_SIZE                          = 586
	OBParserBINLOG                               = 587
	OBParserLEAK_MOD                             = 588
	OBParserCLOG                                 = 589
	OBParserGEOMETRYCOLLECTION                   = 590
	OBParserSTORAGE                              = 591
	OBParserMEDIUM                               = 592
	OBParserUSE_FRM                              = 593
	OBParserCLIENT_VERSION                       = 594
	OBParserMASTER_HEARTBEAT_PERIOD              = 595
	OBParserSUBPARTITIONS                        = 596
	OBParserCUBE                                 = 597
	OBParserBALANCE                              = 598
	OBParserQUERY                                = 599
	OBParserSQL_TSI_QUARTER                      = 600
	OBParserREPAIR                               = 601
	OBParserMASTER_SSL_CIPHER                    = 602
	OBParserKEY_VERSION                          = 603
	OBParserCATALOG_NAME                         = 604
	OBParserNDBCLUSTER                           = 605
	OBParserCONNECTION                           = 606
	OBParserCOMPACT                              = 607
	OBParserSYNCHRONIZATION                      = 608
	OBParserINCR                                 = 609
	OBParserCANCEL                               = 610
	OBParserSIMPLE                               = 611
	OBParserBEGI                                 = 612
	OBParserVARIABLES                            = 613
	OBParserSQL_TSI_WEEK                         = 614
	OBParserP_CHUNK                              = 615
	OBParserSYSTEM                               = 616
	OBParserROOTSERVICE                          = 617
	OBParserPLUGIN_DIR                           = 618
	OBParserASCII                                = 619
	OBParserINFO                                 = 620
	OBParserSQL_THREAD                           = 621
	OBParserTYPES                                = 622
	OBParserLEADER                               = 623
	OBParserLOWER_KEY                            = 624
	OBParserFOUND                                = 625
	OBParserEXTRACT                              = 626
	OBParserFIXED                                = 627
	OBParserCACHE                                = 628
	OBParserCURRENT                              = 629
	OBParserRETURNED_SQLSTATE                    = 630
	OBParserEND                                  = 631
	OBParserPRESERVE                             = 632
	OBParserSQL_BUFFER_RESULT                    = 633
	OBParserJSON                                 = 634
	OBParserSOME                                 = 635
	OBParserINDEX_TABLE_ID                       = 636
	OBParserFREQUENCY                            = 637
	OBParserLOCKS                                = 638
	OBParserMANUAL                               = 639
	OBParserGEOMETRY                             = 640
	OBParserIDENTIFIED                           = 641
	OBParserSTORAGE_FORMAT_VERSION               = 642
	OBParserOVER                                 = 643
	OBParserMAX_SESSION_NUM                      = 644
	OBParserUSER_RESOURCES                       = 645
	OBParserDESTINATION                          = 646
	OBParserSONAME                               = 647
	OBParserOUTLINE                              = 648
	OBParserMASTER_LOG_FILE                      = 649
	OBParserSLAVE                                = 650
	OBParserGTS                                  = 651
	OBParserEXPORT                               = 652
	OBParserAVG_ROW_LENGTH                       = 653
	OBParserFLASHBACK                            = 654
	OBParserSESSION_USER                         = 655
	OBParserTABLEGROUPS                          = 656
	OBParserCURTIME                              = 657
	OBParserREPLICA_TYPE                         = 658
	OBParserAGGREGATE                            = 659
	OBParserPERCENT_RANK                         = 660
	OBParserENUM                                 = 661
	OBParserNATIONAL                             = 662
	OBParserRECYCLE                              = 663
	OBParserREGION                               = 664
	OBParserMUTEX                                = 665
	OBParserLOWER_PARENS                         = 666
	OBParserNDB                                  = 667
	OBParserSYSTEM_USER                          = 668
	OBParserMAX_UPDATES_PER_HOUR                 = 669
	OBParserCURSOR_NAME                          = 670
	OBParserCONCURRENT                           = 671
	OBParserDUMPFILE                             = 672
	OBParserNUMERIC                              = 673
	OBParserCOMPRESSED                           = 674
	OBParserLINESTRING                           = 675
	OBParserDYNAMIC                              = 676
	OBParserCHAIN                                = 677
	OBParserNEG                                  = 678
	OBParserLAG                                  = 679
	OBParserBASELINE_ID                          = 680
	OBParserNEW                                  = 681
	OBParserSQL_TSI_YEAR                         = 682
	OBParserTHAN                                 = 683
	OBParserCPU                                  = 684
	OBParserHOST                                 = 685
	OBParserVALUE                                = 686
	OBParserLOGS                                 = 687
	OBParserSERIALIZABLE                         = 688
	OBParserAUTO_INCREMENT                       = 689
	OBParserBACKUP                               = 690
	OBParserLOGFILE                              = 691
	OBParserROW_FORMAT                           = 692
	OBParserSET_MASTER_CLUSTER                   = 693
	OBParserMINUTE                               = 694
	OBParserSWAPS                                = 695
	OBParserTASK                                 = 696
	OBParserINNODB                               = 697
	OBParserIO_THREAD                            = 698
	OBParserHISTOGRAM                            = 699
	OBParserPCTFREE                              = 700
	OBParserPARAMETERS                           = 701
	OBParserTABLESPACE                           = 702
	OBParserAUTO                                 = 703
	OBParserPASSWORD                             = 704
	OBParserROW                                  = 705
	OBParserMESSAGE_TEXT                         = 706
	OBParserDISK                                 = 707
	OBParserFAULTS                               = 708
	OBParserHOUR                                 = 709
	OBParserREFRESH                              = 710
	OBParserCOLUMN_STAT                          = 711
	OBParserANY                                  = 712
	OBParserERROR_CODE                           = 713
	OBParserPHASE                                = 714
	OBParserENTITY                               = 715
	OBParserPROFILE                              = 716
	OBParserLAST_VALUE                           = 717
	OBParserRESTART                              = 718
	OBParserTRACE                                = 719
	OBParserDATE_ADD                             = 720
	OBParserBLOCK_INDEX                          = 721
	OBParserSERVER_IP                            = 722
	OBParserCODE                                 = 723
	OBParserPLUGINS                              = 724
	OBParserADDDATE                              = 725
	OBParserVIRTUAL_COLUMN_ID                    = 726
	OBParserCOLUMN_FORMAT                        = 727
	OBParserMAX_MEMORY                           = 728
	OBParserCLEAN                                = 729
	OBParserMASTER_SSL                           = 730
	OBParserCLEAR                                = 731
	OBParserCHECKSUM                             = 732
	OBParserINSTALL                              = 733
	OBParserMONTH                                = 734
	OBParserAFTER                                = 735
	OBParserCLOSE                                = 736
	OBParserSET_TP                               = 737
	OBParserOWNER                                = 738
	OBParserBLOOM_FILTER                         = 739
	OBParserILOG                                 = 740
	OBParserMETA                                 = 741
	OBParserSTARTS                               = 742
	OBParserPLANREGRESS                          = 743
	OBParserAUTOEXTEND_SIZE                      = 744
	OBParserSOURCE                               = 745
	OBParserPOW                                  = 746
	OBParserIGNORE_SERVER_IDS                    = 747
	OBParserREPLICA_NUM                          = 748
	OBParserLOWER_THAN_COMP                      = 749
	OBParserBINDING                              = 750
	OBParserMICROSECOND                          = 751
	OBParserUNDO_BUFFER_SIZE                     = 752
	OBParserSWITCHOVER                           = 753
	OBParserEXTENDED_NOADDR                      = 754
	OBParserGLOBAL_NAME                          = 755
	OBParserSPLIT                                = 756
	OBParserBASELINE                             = 757
	OBParserMEMORY                               = 758
	OBParserSEED                                 = 759
	OBParserRTREE                                = 760
	OBParserRESOURCE                             = 761
	OBParserSTDDEV_POP                           = 762
	OBParserRUN                                  = 763
	OBParserSQL_AFTER_GTIDS                      = 764
	OBParserOPEN                                 = 765
	OBParserSQL_TSI_DAY                          = 766
	OBParserSTRING                               = 767
	OBParserRELAY_THREAD                         = 768
	OBParserBREADTH                              = 769
	OBParserUNUSUAL                              = 770
	OBParserRELAYLOG                             = 771
	OBParserSQL_BEFORE_GTIDS                     = 772
	OBParserPRIMARY_ZONE                         = 773
	OBParserTABLE_CHECKSUM                       = 774
	OBParserZONE_LIST                            = 775
	OBParserDATABASE_ID                          = 776
	OBParserTP_NO                                = 777
	OBParserBOOLEAN                              = 778
	OBParserAVG                                  = 779
	OBParserMULTILINESTRING                      = 780
	OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE = 781
	OBParserNOW                                  = 782
	OBParserPROXY                                = 783
	OBParserDUPLICATE_SCOPE                      = 784
	OBParserSTATS_SAMPLE_PAGES                   = 785
	OBParserTABLET_SIZE                          = 786
	OBParserBASE                                 = 787
	OBParserKVCACHE                              = 788
	OBParserRELAY                                = 789
	OBParserCONTRIBUTORS                         = 790
	OBParserPARTIAL                              = 791
	OBParserREPORT                               = 792
	OBParserESCAPE                               = 793
	OBParserMASTER_AUTO_POSITION                 = 794
	OBParserDISKGROUP                            = 795
	OBParserTP_NAME                              = 796
	OBParserACTIVATE                             = 797
	OBParserSQL_AFTER_MTS_GAPS                   = 798
	OBParserEFFECTIVE                            = 799
	OBParserFIRST_VALUE                          = 800
	OBParserSQL_TSI_MINUTE                       = 801
	OBParserUNICODE                              = 802
	OBParserQUARTER                              = 803
	OBParserANALYSE                              = 804
	OBParserDEFINER                              = 805
	OBParserNONE                                 = 806
	OBParserPROCESSLIST                          = 807
	OBParserTYPE                                 = 808
	OBParserINSERT_METHOD                        = 809
	OBParserEXTENDED                             = 810
	OBParserLEVEL                                = 811
	OBParserTIME_ZONE_INFO                       = 812
	OBParserTIMESTAMPADD                         = 813
	OBParserLOWER_INTO                           = 814
	OBParserGET_FORMAT                           = 815
	OBParserPREPARE                              = 816
	OBParserSTANDBY                              = 817
	OBParserMATERIALIZED                         = 818
	OBParserWORK                                 = 819
	OBParserHANDLER                              = 820
	OBParserCUME_DIST                            = 821
	OBParserLEAK                                 = 822
	OBParserINITIAL_SIZE                         = 823
	OBParserRELAY_LOG_FILE                       = 824
	OBParserSTORING                              = 825
	OBParserIMPORT                               = 826
	OBParserMIN_MEMORY                           = 827
	OBParserHELP                                 = 828
	OBParserCREATE_TIMESTAMP                     = 829
	OBParserRANDOM                               = 830
	OBParserSOUNDS                               = 831
	OBParserTABLE_MODE                           = 832
	OBParserCOPY                                 = 833
	OBParserSESSION                              = 834
	OBParserSQL_NO_CACHE                         = 835
	OBParserEXECUTE                              = 836
	OBParserPRECEDING                            = 837
	OBParserSWITCHES                             = 838
	OBParserPACK_KEYS                            = 839
	OBParserSQL_ID                               = 840
	OBParserTENANT_ID                            = 841
	OBParserCHECKPOINT                           = 842
	OBParserDAY                                  = 843
	OBParserGROUP_CONCAT                         = 844
	OBParserLEAD                                 = 845
	OBParserEVENTS                               = 846
	OBParserRECURSIVE                            = 847
	OBParserONLY                                 = 848
	OBParserTABLEGROUP_ID                        = 849
	OBParserMASTER_SSL_CRL                       = 850
	OBParserRESOURCE_POOL_LIST                   = 851
	OBParserTRACING                              = 852
	OBParserNTILE                                = 853
	OBParserBUCKETS                              = 854
	OBParserIS_TENANT_SYS_POOL                   = 855
	OBParserSCHEDULE                             = 856
	OBParserJOB                                  = 857
	OBParserMASTER_LOG_POS                       = 858
	OBParserSUBCLASS_ORIGIN                      = 859
	OBParserMULTIPOINT                           = 860
	OBParserBLOCK                                = 861
	OBParserSQL_TSI_SECOND                       = 862
	OBParserDATE                                 = 863
	OBParserROLLUP                               = 864
	OBParserMIN_CPU                              = 865
	OBParserOCCUR                                = 866
	OBParserDATA                                 = 867
	OBParserMASTER_HOST                          = 868
	OBParserALGORITHM                            = 869
	OBParserEXPIRED                              = 870
	OBParserCONSTRAINT_NAME                      = 871
	OBParserAPPROX_COUNT_DISTINCT                = 872
	OBParserBASIC                                = 873
	OBParserDEFAULT_TABLEGROUP                   = 874
	OBParserLIST_                                = 875
	OBParserWEEK                                 = 876
	OBParserNULLS                                = 877
	OBParserDEC                                  = 878
	OBParserMASTER_SSL_CRLPATH                   = 879
	OBParserCASCADED                             = 880
	OBParserPLUGIN                               = 881
	OBParserTENANT                               = 882
	OBParserDECIMAL_VAL                          = 883
	OBParserBOOL_VALUE                           = 884
	OBParserAt                                   = 885
	OBParserQuote                                = 886
	OBParserHEX_STRING_VALUE                     = 887
	OBParserDATE_VALUE                           = 888
	OBParserHINT_VALUE                           = 889
	OBParserComma                                = 890
	OBParserPlus                                 = 891
	OBParserAnd                                  = 892
	OBParserOr                                   = 893
	OBParserStar                                 = 894
	OBParserNot                                  = 895
	OBParserLeftParen                            = 896
	OBParserMinus                                = 897
	OBParserDiv                                  = 898
	OBParserCaret                                = 899
	OBParserColon                                = 900
	OBParserDot                                  = 901
	OBParserMod                                  = 902
	OBParserRightParen                           = 903
	OBParserTilde                                = 904
	OBParserDELIMITER                            = 905
	OBParserCNNOP                                = 906
	OBParserAND_OP                               = 907
	OBParserCOMP_EQ                              = 908
	OBParserSET_VAR                              = 909
	OBParserCOMP_NSEQ                            = 910
	OBParserCOMP_GE                              = 911
	OBParserCOMP_GT                              = 912
	OBParserCOMP_LE                              = 913
	OBParserCOMP_LT                              = 914
	OBParserCOMP_NE                              = 915
	OBParserSHIFT_LEFT                           = 916
	OBParserSHIFT_RIGHT                          = 917
	OBParserQUESTIONMARK                         = 918
	OBParserSYSTEM_VARIABLE                      = 919
	OBParserUSER_VARIABLE                        = 920
	OBParserNAME_OB                              = 921
	OBParserPARSER_SYNTAX_ERROR                  = 922
	OBParserSTRING_VALUE                         = 923
	OBParserIn_c_comment                         = 924
	OBParserANTLR_SKIP                           = 925
	OBParserBlank                                = 926
	OBParserLOAD_DATA_HINT_BEGIN                 = 927
	OBParserREPLACE_HINT_BEGIN                   = 928
	OBParserINSERT_HINT_BEGIN                    = 929
	OBParserSELECT_HINT_BEGIN                    = 930
	OBParserUPDATE_HINT_BEGIN                    = 931
	OBParserDELETE_HINT_BEGIN                    = 932
	OBParserHINT_END                             = 933
	OBParserNO_REWRITE                           = 934
	OBParserREAD_CONSISTENCY                     = 935
	OBParserINDEX_HINT                           = 936
	OBParserQUERY_TIMEOUT                        = 937
	OBParserFROZEN_VERSION                       = 938
	OBParserTOPK                                 = 939
	OBParserHOTSPOT                              = 940
	OBParserLOG_LEVEL                            = 941
	OBParserLEADING_HINT                         = 942
	OBParserORDERED                              = 943
	OBParserFULL_HINT                            = 944
	OBParserUSE_PLAN_CACHE                       = 945
	OBParserUSE_MERGE                            = 946
	OBParserNO_USE_MERGE                         = 947
	OBParserUSE_HASH                             = 948
	OBParserNO_USE_HASH                          = 949
	OBParserUSE_NL                               = 950
	OBParserNO_USE_NL                            = 951
	OBParserUSE_BNL                              = 952
	OBParserNO_USE_BNL                           = 953
	OBParserUSE_NL_MATERIALIZATION               = 954
	OBParserNO_USE_NL_MATERIALIZATION            = 955
	OBParserUSE_HASH_AGGREGATION                 = 956
	OBParserNO_USE_HASH_AGGREGATION              = 957
	OBParserMERGE_HINT                           = 958
	OBParserNO_MERGE_HINT                        = 959
	OBParserNO_EXPAND                            = 960
	OBParserUSE_CONCAT                           = 961
	OBParserUNNEST                               = 962
	OBParserNO_UNNEST                            = 963
	OBParserPLACE_GROUP_BY                       = 964
	OBParserNO_PLACE_GROUP_BY                    = 965
	OBParserNO_PRED_DEDUCE                       = 966
	OBParserUSE_JIT                              = 967
	OBParserNO_USE_JIT                           = 968
	OBParserUSE_LATE_MATERIALIZATION             = 969
	OBParserNO_USE_LATE_MATERIALIZATION          = 970
	OBParserTRACE_LOG                            = 971
	OBParserSTAT                                 = 972
	OBParserUSE_PX                               = 973
	OBParserNO_USE_PX                            = 974
	OBParserTRANS_PARAM                          = 975
	OBParserPX_JOIN_FILTER                       = 976
	OBParserFORCE_REFRESH_LOCATION_CACHE         = 977
	OBParserQB_NAME                              = 978
	OBParserMAX_CONCURRENT                       = 979
	OBParserPARALLEL                             = 980
	OBParserPQ_DISTRIBUTE                        = 981
	OBParserLOAD_BATCH_SIZE                      = 982
	OBParserRANDOM_LOCAL                         = 983
	OBParserBROADCAST                            = 984
	OBParserHINT_HINT_BEGIN                      = 985
)

// OBParser rules.
const (
	OBParserRULE_sql_stmt                                   = 0
	OBParserRULE_stmt_list                                  = 1
	OBParserRULE_stmt                                       = 2
	OBParserRULE_expr_list                                  = 3
	OBParserRULE_expr_as_list                               = 4
	OBParserRULE_expr_with_opt_alias                        = 5
	OBParserRULE_column_ref                                 = 6
	OBParserRULE_complex_string_literal                     = 7
	OBParserRULE_charset_introducer                         = 8
	OBParserRULE_literal                                    = 9
	OBParserRULE_number_literal                             = 10
	OBParserRULE_expr_const                                 = 11
	OBParserRULE_conf_const                                 = 12
	OBParserRULE_global_or_session_alias                    = 13
	OBParserRULE_bool_pri                                   = 14
	OBParserRULE_predicate                                  = 15
	OBParserRULE_bit_expr                                   = 16
	OBParserRULE_simple_expr                                = 17
	OBParserRULE_expr                                       = 18
	OBParserRULE_not                                        = 19
	OBParserRULE_not2                                       = 20
	OBParserRULE_sub_query_flag                             = 21
	OBParserRULE_in_expr                                    = 22
	OBParserRULE_case_expr                                  = 23
	OBParserRULE_window_function                            = 24
	OBParserRULE_first_or_last                              = 25
	OBParserRULE_respect_or_ignore                          = 26
	OBParserRULE_win_fun_first_last_params                  = 27
	OBParserRULE_win_fun_lead_lag_params                    = 28
	OBParserRULE_new_generalized_window_clause              = 29
	OBParserRULE_new_generalized_window_clause_with_blanket = 30
	OBParserRULE_named_windows                              = 31
	OBParserRULE_named_window                               = 32
	OBParserRULE_generalized_window_clause                  = 33
	OBParserRULE_win_rows_or_range                          = 34
	OBParserRULE_win_preceding_or_following                 = 35
	OBParserRULE_win_interval                               = 36
	OBParserRULE_win_bounding                               = 37
	OBParserRULE_win_window                                 = 38
	OBParserRULE_case_arg                                   = 39
	OBParserRULE_when_clause_list                           = 40
	OBParserRULE_when_clause                                = 41
	OBParserRULE_case_default                               = 42
	OBParserRULE_func_expr                                  = 43
	OBParserRULE_sys_interval_func                          = 44
	OBParserRULE_utc_timestamp_func                         = 45
	OBParserRULE_sysdate_func                               = 46
	OBParserRULE_cur_timestamp_func                         = 47
	OBParserRULE_now_synonyms_func                          = 48
	OBParserRULE_cur_time_func                              = 49
	OBParserRULE_cur_date_func                              = 50
	OBParserRULE_substr_or_substring                        = 51
	OBParserRULE_substr_params                              = 52
	OBParserRULE_date_params                                = 53
	OBParserRULE_timestamp_params                           = 54
	OBParserRULE_delete_stmt                                = 55
	OBParserRULE_multi_delete_table                         = 56
	OBParserRULE_update_stmt                                = 57
	OBParserRULE_update_asgn_list                           = 58
	OBParserRULE_update_asgn_factor                         = 59
	OBParserRULE_create_resource_stmt                       = 60
	OBParserRULE_opt_resource_unit_option_list              = 61
	OBParserRULE_resource_unit_option                       = 62
	OBParserRULE_opt_create_resource_pool_option_list       = 63
	OBParserRULE_create_resource_pool_option                = 64
	OBParserRULE_alter_resource_pool_option_list            = 65
	OBParserRULE_unit_id_list                               = 66
	OBParserRULE_alter_resource_pool_option                 = 67
	OBParserRULE_alter_resource_stmt                        = 68
	OBParserRULE_drop_resource_stmt                         = 69
	OBParserRULE_create_tenant_stmt                         = 70
	OBParserRULE_opt_tenant_option_list                     = 71
	OBParserRULE_tenant_option                              = 72
	OBParserRULE_zone_list                                  = 73
	OBParserRULE_resource_pool_list                         = 74
	OBParserRULE_alter_tenant_stmt                          = 75
	OBParserRULE_drop_tenant_stmt                           = 76
	OBParserRULE_create_database_stmt                       = 77
	OBParserRULE_database_key                               = 78
	OBParserRULE_database_factor                            = 79
	OBParserRULE_database_option_list                       = 80
	OBParserRULE_charset_key                                = 81
	OBParserRULE_database_option                            = 82
	OBParserRULE_read_only_or_write                         = 83
	OBParserRULE_drop_database_stmt                         = 84
	OBParserRULE_alter_database_stmt                        = 85
	OBParserRULE_load_data_stmt                             = 86
	OBParserRULE_load_data_with_opt_hint                    = 87
	OBParserRULE_lines_or_rows                              = 88
	OBParserRULE_field_or_vars_list                         = 89
	OBParserRULE_field_or_vars                              = 90
	OBParserRULE_load_set_list                              = 91
	OBParserRULE_load_set_element                           = 92
	OBParserRULE_use_database_stmt                          = 93
	OBParserRULE_create_synonym_stmt                        = 94
	OBParserRULE_synonym_name                               = 95
	OBParserRULE_synonym_object                             = 96
	OBParserRULE_drop_synonym_stmt                          = 97
	OBParserRULE_temporary_option                           = 98
	OBParserRULE_create_table_like_stmt                     = 99
	OBParserRULE_create_table_stmt                          = 100
	OBParserRULE_ret_type                                   = 101
	OBParserRULE_create_function_stmt                       = 102
	OBParserRULE_drop_function_stmt                         = 103
	OBParserRULE_table_element_list                         = 104
	OBParserRULE_table_element                              = 105
	OBParserRULE_opt_reference_option_list                  = 106
	OBParserRULE_reference_option                           = 107
	OBParserRULE_reference_action                           = 108
	OBParserRULE_match_action                               = 109
	OBParserRULE_column_definition                          = 110
	OBParserRULE_opt_generated_column_attribute_list        = 111
	OBParserRULE_generated_column_attribute                 = 112
	OBParserRULE_column_definition_ref                      = 113
	OBParserRULE_column_definition_list                     = 114
	OBParserRULE_cast_data_type                             = 115
	OBParserRULE_cast_datetime_type_i                       = 116
	OBParserRULE_data_type                                  = 117
	OBParserRULE_string_list                                = 118
	OBParserRULE_text_string                                = 119
	OBParserRULE_int_type_i                                 = 120
	OBParserRULE_float_type_i                               = 121
	OBParserRULE_datetime_type_i                            = 122
	OBParserRULE_date_year_type_i                           = 123
	OBParserRULE_text_type_i                                = 124
	OBParserRULE_blob_type_i                                = 125
	OBParserRULE_string_length_i                            = 126
	OBParserRULE_collation_name                             = 127
	OBParserRULE_trans_param_name                           = 128
	OBParserRULE_trans_param_value                          = 129
	OBParserRULE_charset_name                               = 130
	OBParserRULE_charset_name_or_default                    = 131
	OBParserRULE_collation                                  = 132
	OBParserRULE_opt_column_attribute_list                  = 133
	OBParserRULE_column_attribute                           = 134
	OBParserRULE_now_or_signed_literal                      = 135
	OBParserRULE_signed_literal                             = 136
	OBParserRULE_opt_comma                                  = 137
	OBParserRULE_table_option_list_space_seperated          = 138
	OBParserRULE_table_option_list                          = 139
	OBParserRULE_primary_zone_name                          = 140
	OBParserRULE_tablespace                                 = 141
	OBParserRULE_locality_name                              = 142
	OBParserRULE_table_option                               = 143
	OBParserRULE_relation_name_or_string                    = 144
	OBParserRULE_opt_equal_mark                             = 145
	OBParserRULE_partition_option                           = 146
	OBParserRULE_opt_partition_option                       = 147
	OBParserRULE_hash_partition_option                      = 148
	OBParserRULE_list_partition_option                      = 149
	OBParserRULE_key_partition_option                       = 150
	OBParserRULE_range_partition_option                     = 151
	OBParserRULE_opt_column_partition_option                = 152
	OBParserRULE_column_partition_option                    = 153
	OBParserRULE_aux_column_list                            = 154
	OBParserRULE_vertical_column_name                       = 155
	OBParserRULE_column_name_list                           = 156
	OBParserRULE_subpartition_option                        = 157
	OBParserRULE_opt_list_partition_list                    = 158
	OBParserRULE_opt_list_subpartition_list                 = 159
	OBParserRULE_opt_range_partition_list                   = 160
	OBParserRULE_opt_range_subpartition_list                = 161
	OBParserRULE_list_partition_list                        = 162
	OBParserRULE_list_subpartition_list                     = 163
	OBParserRULE_list_subpartition_element                  = 164
	OBParserRULE_list_partition_element                     = 165
	OBParserRULE_list_partition_expr                        = 166
	OBParserRULE_list_expr                                  = 167
	OBParserRULE_range_partition_list                       = 168
	OBParserRULE_range_partition_element                    = 169
	OBParserRULE_range_subpartition_element                 = 170
	OBParserRULE_range_subpartition_list                    = 171
	OBParserRULE_range_partition_expr                       = 172
	OBParserRULE_range_expr_list                            = 173
	OBParserRULE_range_expr                                 = 174
	OBParserRULE_int_or_decimal                             = 175
	OBParserRULE_tg_hash_partition_option                   = 176
	OBParserRULE_tg_key_partition_option                    = 177
	OBParserRULE_tg_range_partition_option                  = 178
	OBParserRULE_tg_list_partition_option                   = 179
	OBParserRULE_tg_subpartition_option                     = 180
	OBParserRULE_row_format_option                          = 181
	OBParserRULE_create_tablegroup_stmt                     = 182
	OBParserRULE_drop_tablegroup_stmt                       = 183
	OBParserRULE_alter_tablegroup_stmt                      = 184
	OBParserRULE_tablegroup_option_list_space_seperated     = 185
	OBParserRULE_tablegroup_option_list                     = 186
	OBParserRULE_tablegroup_option                          = 187
	OBParserRULE_alter_tablegroup_actions                   = 188
	OBParserRULE_alter_tablegroup_action                    = 189
	OBParserRULE_default_tablegroup                         = 190
	OBParserRULE_create_view_stmt                           = 191
	OBParserRULE_view_select_stmt                           = 192
	OBParserRULE_view_name                                  = 193
	OBParserRULE_create_index_stmt                          = 194
	OBParserRULE_index_name                                 = 195
	OBParserRULE_opt_constraint_name                        = 196
	OBParserRULE_constraint_name                            = 197
	OBParserRULE_sort_column_list                           = 198
	OBParserRULE_sort_column_key                            = 199
	OBParserRULE_opt_index_options                          = 200
	OBParserRULE_index_option                               = 201
	OBParserRULE_index_using_algorithm                      = 202
	OBParserRULE_drop_table_stmt                            = 203
	OBParserRULE_table_or_tables                            = 204
	OBParserRULE_drop_view_stmt                             = 205
	OBParserRULE_table_list                                 = 206
	OBParserRULE_drop_index_stmt                            = 207
	OBParserRULE_insert_stmt                                = 208
	OBParserRULE_single_table_insert                        = 209
	OBParserRULE_values_clause                              = 210
	OBParserRULE_value_or_values                            = 211
	OBParserRULE_replace_with_opt_hint                      = 212
	OBParserRULE_insert_with_opt_hint                       = 213
	OBParserRULE_column_list                                = 214
	OBParserRULE_insert_vals_list                           = 215
	OBParserRULE_insert_vals                                = 216
	OBParserRULE_expr_or_default                            = 217
	OBParserRULE_select_stmt                                = 218
	OBParserRULE_select_into                                = 219
	OBParserRULE_select_with_parens                         = 220
	OBParserRULE_select_no_parens                           = 221
	OBParserRULE_no_table_select                            = 222
	OBParserRULE_select_clause                              = 223
	OBParserRULE_select_clause_set_with_order_and_limit     = 224
	OBParserRULE_select_clause_set                          = 225
	OBParserRULE_select_clause_set_right                    = 226
	OBParserRULE_select_clause_set_left                     = 227
	OBParserRULE_no_table_select_with_order_and_limit       = 228
	OBParserRULE_simple_select_with_order_and_limit         = 229
	OBParserRULE_select_with_parens_with_order_and_limit    = 230
	OBParserRULE_select_with_opt_hint                       = 231
	OBParserRULE_update_with_opt_hint                       = 232
	OBParserRULE_delete_with_opt_hint                       = 233
	OBParserRULE_simple_select                              = 234
	OBParserRULE_set_type_union                             = 235
	OBParserRULE_set_type_other                             = 236
	OBParserRULE_set_type                                   = 237
	OBParserRULE_set_expression_option                      = 238
	OBParserRULE_opt_hint_value                             = 239
	OBParserRULE_limit_clause                               = 240
	OBParserRULE_into_clause                                = 241
	OBParserRULE_into_opt                                   = 242
	OBParserRULE_into_var_list                              = 243
	OBParserRULE_into_var                                   = 244
	OBParserRULE_field_opt                                  = 245
	OBParserRULE_field_term_list                            = 246
	OBParserRULE_field_term                                 = 247
	OBParserRULE_line_opt                                   = 248
	OBParserRULE_line_term_list                             = 249
	OBParserRULE_line_term                                  = 250
	OBParserRULE_hint_list_with_end                         = 251
	OBParserRULE_opt_hint_list                              = 252
	OBParserRULE_hint_options                               = 253
	OBParserRULE_name_list                                  = 254
	OBParserRULE_hint_option                                = 255
	OBParserRULE_consistency_level                          = 256
	OBParserRULE_use_plan_cache_type                        = 257
	OBParserRULE_use_jit_type                               = 258
	OBParserRULE_distribute_method                          = 259
	OBParserRULE_limit_expr                                 = 260
	OBParserRULE_opt_for_update_wait                        = 261
	OBParserRULE_parameterized_trim                         = 262
	OBParserRULE_groupby_clause                             = 263
	OBParserRULE_sort_list_for_group_by                     = 264
	OBParserRULE_sort_key_for_group_by                      = 265
	OBParserRULE_order_by                                   = 266
	OBParserRULE_sort_list                                  = 267
	OBParserRULE_sort_key                                   = 268
	OBParserRULE_query_expression_option_list               = 269
	OBParserRULE_query_expression_option                    = 270
	OBParserRULE_projection                                 = 271
	OBParserRULE_select_expr_list                           = 272
	OBParserRULE_from_list                                  = 273
	OBParserRULE_table_references                           = 274
	OBParserRULE_table_reference                            = 275
	OBParserRULE_table_factor                               = 276
	OBParserRULE_tbl_name                                   = 277
	OBParserRULE_dml_table_name                             = 278
	OBParserRULE_seed                                       = 279
	OBParserRULE_opt_seed                                   = 280
	OBParserRULE_sample_percent                             = 281
	OBParserRULE_sample_clause                              = 282
	OBParserRULE_table_subquery                             = 283
	OBParserRULE_use_partition                              = 284
	OBParserRULE_index_hint_type                            = 285
	OBParserRULE_key_or_index                               = 286
	OBParserRULE_index_hint_scope                           = 287
	OBParserRULE_index_element                              = 288
	OBParserRULE_index_list                                 = 289
	OBParserRULE_index_hint_definition                      = 290
	OBParserRULE_index_hint_list                            = 291
	OBParserRULE_relation_factor                            = 292
	OBParserRULE_relation_with_star_list                    = 293
	OBParserRULE_relation_factor_with_star                  = 294
	OBParserRULE_normal_relation_factor                     = 295
	OBParserRULE_dot_relation_factor                        = 296
	OBParserRULE_relation_factor_in_hint                    = 297
	OBParserRULE_qb_name_option                             = 298
	OBParserRULE_relation_factor_in_hint_list               = 299
	OBParserRULE_relation_sep_option                        = 300
	OBParserRULE_relation_factor_in_pq_hint                 = 301
	OBParserRULE_relation_factor_in_leading_hint            = 302
	OBParserRULE_relation_factor_in_leading_hint_list       = 303
	OBParserRULE_relation_factor_in_leading_hint_list_entry = 304
	OBParserRULE_relation_factor_in_use_join_hint_list      = 305
	OBParserRULE_tracing_num_list                           = 306
	OBParserRULE_join_condition                             = 307
	OBParserRULE_joined_table                               = 308
	OBParserRULE_natural_join_type                          = 309
	OBParserRULE_inner_join_type                            = 310
	OBParserRULE_outer_join_type                            = 311
	OBParserRULE_analyze_stmt                               = 312
	OBParserRULE_create_outline_stmt                        = 313
	OBParserRULE_alter_outline_stmt                         = 314
	OBParserRULE_drop_outline_stmt                          = 315
	OBParserRULE_explain_stmt                               = 316
	OBParserRULE_explain_or_desc                            = 317
	OBParserRULE_explainable_stmt                           = 318
	OBParserRULE_format_name                                = 319
	OBParserRULE_show_stmt                                  = 320
	OBParserRULE_databases_or_schemas                       = 321
	OBParserRULE_opt_for_grant_user                         = 322
	OBParserRULE_columns_or_fields                          = 323
	OBParserRULE_database_or_schema                         = 324
	OBParserRULE_index_or_indexes_or_keys                   = 325
	OBParserRULE_from_or_in                                 = 326
	OBParserRULE_help_stmt                                  = 327
	OBParserRULE_create_tablespace_stmt                     = 328
	OBParserRULE_permanent_tablespace                       = 329
	OBParserRULE_permanent_tablespace_option                = 330
	OBParserRULE_drop_tablespace_stmt                       = 331
	OBParserRULE_alter_tablespace_actions                   = 332
	OBParserRULE_alter_tablespace_action                    = 333
	OBParserRULE_alter_tablespace_stmt                      = 334
	OBParserRULE_rotate_master_key_stmt                     = 335
	OBParserRULE_permanent_tablespace_options               = 336
	OBParserRULE_create_user_stmt                           = 337
	OBParserRULE_user_specification_list                    = 338
	OBParserRULE_user_specification                         = 339
	OBParserRULE_require_specification                      = 340
	OBParserRULE_tls_option_list                            = 341
	OBParserRULE_tls_option                                 = 342
	OBParserRULE_user                                       = 343
	OBParserRULE_opt_host_name                              = 344
	OBParserRULE_user_with_host_name                        = 345
	OBParserRULE_password                                   = 346
	OBParserRULE_drop_user_stmt                             = 347
	OBParserRULE_user_list                                  = 348
	OBParserRULE_set_password_stmt                          = 349
	OBParserRULE_opt_for_user                               = 350
	OBParserRULE_rename_user_stmt                           = 351
	OBParserRULE_rename_info                                = 352
	OBParserRULE_rename_list                                = 353
	OBParserRULE_lock_user_stmt                             = 354
	OBParserRULE_lock_spec_mysql57                          = 355
	OBParserRULE_lock_tables_stmt                           = 356
	OBParserRULE_unlock_tables_stmt                         = 357
	OBParserRULE_lock_table_list                            = 358
	OBParserRULE_lock_table                                 = 359
	OBParserRULE_lock_type                                  = 360
	OBParserRULE_begin_stmt                                 = 361
	OBParserRULE_commit_stmt                                = 362
	OBParserRULE_rollback_stmt                              = 363
	OBParserRULE_kill_stmt                                  = 364
	OBParserRULE_grant_stmt                                 = 365
	OBParserRULE_grant_privileges                           = 366
	OBParserRULE_priv_type_list                             = 367
	OBParserRULE_priv_type                                  = 368
	OBParserRULE_priv_level                                 = 369
	OBParserRULE_grant_options                              = 370
	OBParserRULE_revoke_stmt                                = 371
	OBParserRULE_prepare_stmt                               = 372
	OBParserRULE_stmt_name                                  = 373
	OBParserRULE_preparable_stmt                            = 374
	OBParserRULE_variable_set_stmt                          = 375
	OBParserRULE_sys_var_and_val_list                       = 376
	OBParserRULE_var_and_val_list                           = 377
	OBParserRULE_set_expr_or_default                        = 378
	OBParserRULE_var_and_val                                = 379
	OBParserRULE_sys_var_and_val                            = 380
	OBParserRULE_scope_or_scope_alias                       = 381
	OBParserRULE_to_or_eq                                   = 382
	OBParserRULE_execute_stmt                               = 383
	OBParserRULE_argument_list                              = 384
	OBParserRULE_argument                                   = 385
	OBParserRULE_deallocate_prepare_stmt                    = 386
	OBParserRULE_deallocate_or_drop                         = 387
	OBParserRULE_truncate_table_stmt                        = 388
	OBParserRULE_rename_table_stmt                          = 389
	OBParserRULE_rename_table_actions                       = 390
	OBParserRULE_rename_table_action                        = 391
	OBParserRULE_alter_table_stmt                           = 392
	OBParserRULE_alter_table_actions                        = 393
	OBParserRULE_alter_table_action                         = 394
	OBParserRULE_alter_constraint_option                    = 395
	OBParserRULE_alter_partition_option                     = 396
	OBParserRULE_opt_partition_range_or_list                = 397
	OBParserRULE_alter_tg_partition_option                  = 398
	OBParserRULE_drop_partition_name_list                   = 399
	OBParserRULE_modify_partition_info                      = 400
	OBParserRULE_modify_tg_partition_info                   = 401
	OBParserRULE_alter_index_option                         = 402
	OBParserRULE_alter_foreign_key_action                   = 403
	OBParserRULE_visibility_option                          = 404
	OBParserRULE_alter_column_option                        = 405
	OBParserRULE_alter_tablegroup_option                    = 406
	OBParserRULE_alter_column_behavior                      = 407
	OBParserRULE_flashback_stmt                             = 408
	OBParserRULE_purge_stmt                                 = 409
	OBParserRULE_optimize_stmt                              = 410
	OBParserRULE_dump_memory_stmt                           = 411
	OBParserRULE_alter_system_stmt                          = 412
	OBParserRULE_change_tenant_name_or_tenant_id            = 413
	OBParserRULE_cache_type                                 = 414
	OBParserRULE_balance_task_type                          = 415
	OBParserRULE_tenant_list_tuple                          = 416
	OBParserRULE_tenant_name_list                           = 417
	OBParserRULE_flush_scope                                = 418
	OBParserRULE_server_info_list                           = 419
	OBParserRULE_server_info                                = 420
	OBParserRULE_server_action                              = 421
	OBParserRULE_server_list                                = 422
	OBParserRULE_zone_action                                = 423
	OBParserRULE_ip_port                                    = 424
	OBParserRULE_zone_desc                                  = 425
	OBParserRULE_server_or_zone                             = 426
	OBParserRULE_add_or_alter_zone_option                   = 427
	OBParserRULE_add_or_alter_zone_options                  = 428
	OBParserRULE_alter_or_change_or_modify                  = 429
	OBParserRULE_partition_id_desc                          = 430
	OBParserRULE_partition_id_or_server_or_zone             = 431
	OBParserRULE_migrate_action                             = 432
	OBParserRULE_change_actions                             = 433
	OBParserRULE_change_action                              = 434
	OBParserRULE_replica_type                               = 435
	OBParserRULE_suspend_or_resume                          = 436
	OBParserRULE_baseline_id_expr                           = 437
	OBParserRULE_sql_id_expr                                = 438
	OBParserRULE_baseline_asgn_factor                       = 439
	OBParserRULE_tenant_name                                = 440
	OBParserRULE_cache_name                                 = 441
	OBParserRULE_file_id                                    = 442
	OBParserRULE_cancel_task_type                           = 443
	OBParserRULE_alter_system_set_parameter_actions         = 444
	OBParserRULE_alter_system_set_parameter_action          = 445
	OBParserRULE_alter_system_settp_actions                 = 446
	OBParserRULE_settp_option                               = 447
	OBParserRULE_cluster_role                               = 448
	OBParserRULE_partition_role                             = 449
	OBParserRULE_upgrade_action                             = 450
	OBParserRULE_set_names_stmt                             = 451
	OBParserRULE_set_charset_stmt                           = 452
	OBParserRULE_set_transaction_stmt                       = 453
	OBParserRULE_transaction_characteristics                = 454
	OBParserRULE_transaction_access_mode                    = 455
	OBParserRULE_isolation_level                            = 456
	OBParserRULE_create_savepoint_stmt                      = 457
	OBParserRULE_rollback_savepoint_stmt                    = 458
	OBParserRULE_release_savepoint_stmt                     = 459
	OBParserRULE_alter_cluster_stmt                         = 460
	OBParserRULE_cluster_action                             = 461
	OBParserRULE_switchover_cluster_stmt                    = 462
	OBParserRULE_commit_switchover_clause                   = 463
	OBParserRULE_cluster_name                               = 464
	OBParserRULE_var_name                                   = 465
	OBParserRULE_column_name                                = 466
	OBParserRULE_relation_name                              = 467
	OBParserRULE_function_name                              = 468
	OBParserRULE_column_label                               = 469
	OBParserRULE_date_unit                                  = 470
	OBParserRULE_unreserved_keyword                         = 471
	OBParserRULE_unreserved_keyword_normal                  = 472
	OBParserRULE_unreserved_keyword_special                 = 473
	OBParserRULE_empty                                      = 474
	OBParserRULE_forward_expr                               = 475
	OBParserRULE_forward_sql_stmt                           = 476
)

// ISql_stmtContext is an interface to support dynamic dispatch.
type ISql_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Stmt_list() IStmt_listContext

	// IsSql_stmtContext differentiates from other interfaces.
	IsSql_stmtContext()
}

type Sql_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_stmtContext() *Sql_stmtContext {
	var p = new(Sql_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sql_stmt
	return p
}

func InitEmptySql_stmtContext(p *Sql_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sql_stmt
}

func (*Sql_stmtContext) IsSql_stmtContext() {}

func NewSql_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_stmtContext {
	var p = new(Sql_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_sql_stmt

	return p
}

func (s *Sql_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_stmtContext) Stmt_list() IStmt_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_listContext)
}

func (s *Sql_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sql_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSql_stmt(s)
	}
}

func (s *Sql_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSql_stmt(s)
	}
}

func (s *Sql_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSql_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Sql_stmt() (localctx ISql_stmtContext) {
	localctx = NewSql_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, OBParserRULE_sql_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(954)
		p.Stmt_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmt_listContext is an interface to support dynamic dispatch.
type IStmt_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	DELIMITER() antlr.TerminalNode
	Stmt() IStmtContext

	// IsStmt_listContext differentiates from other interfaces.
	IsStmt_listContext()
}

type Stmt_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmt_listContext() *Stmt_listContext {
	var p = new(Stmt_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_stmt_list
	return p
}

func InitEmptyStmt_listContext(p *Stmt_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_stmt_list
}

func (*Stmt_listContext) IsStmt_listContext() {}

func NewStmt_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Stmt_listContext {
	var p = new(Stmt_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_stmt_list

	return p
}

func (s *Stmt_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Stmt_listContext) EOF() antlr.TerminalNode {
	return s.GetToken(OBParserEOF, 0)
}

func (s *Stmt_listContext) DELIMITER() antlr.TerminalNode {
	return s.GetToken(OBParserDELIMITER, 0)
}

func (s *Stmt_listContext) Stmt() IStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *Stmt_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Stmt_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterStmt_list(s)
	}
}

func (s *Stmt_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitStmt_list(s)
	}
}

func (s *Stmt_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitStmt_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Stmt_list() (localctx IStmt_listContext) {
	localctx = NewStmt_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, OBParserRULE_stmt_list)
	p.SetState(966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(956)
			p.Match(OBParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(957)
			p.Match(OBParserDELIMITER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(958)
			p.Stmt()
		}
		{
			p.SetState(959)
			p.Match(OBParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(961)
			p.Stmt()
		}
		{
			p.SetState(962)
			p.Match(OBParserDELIMITER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(964)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(963)
				p.Match(OBParserEOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_stmt() ISelect_stmtContext
	Insert_stmt() IInsert_stmtContext
	Create_table_stmt() ICreate_table_stmtContext
	Create_function_stmt() ICreate_function_stmtContext
	Drop_function_stmt() IDrop_function_stmtContext
	Create_table_like_stmt() ICreate_table_like_stmtContext
	Create_database_stmt() ICreate_database_stmtContext
	Drop_database_stmt() IDrop_database_stmtContext
	Alter_database_stmt() IAlter_database_stmtContext
	Use_database_stmt() IUse_database_stmtContext
	Update_stmt() IUpdate_stmtContext
	Delete_stmt() IDelete_stmtContext
	Drop_table_stmt() IDrop_table_stmtContext
	Drop_view_stmt() IDrop_view_stmtContext
	Explain_stmt() IExplain_stmtContext
	Create_outline_stmt() ICreate_outline_stmtContext
	Alter_outline_stmt() IAlter_outline_stmtContext
	Drop_outline_stmt() IDrop_outline_stmtContext
	Show_stmt() IShow_stmtContext
	Prepare_stmt() IPrepare_stmtContext
	Variable_set_stmt() IVariable_set_stmtContext
	Execute_stmt() IExecute_stmtContext
	Alter_table_stmt() IAlter_table_stmtContext
	Alter_system_stmt() IAlter_system_stmtContext
	Deallocate_prepare_stmt() IDeallocate_prepare_stmtContext
	Create_user_stmt() ICreate_user_stmtContext
	Drop_user_stmt() IDrop_user_stmtContext
	Set_password_stmt() ISet_password_stmtContext
	Rename_user_stmt() IRename_user_stmtContext
	Lock_user_stmt() ILock_user_stmtContext
	Grant_stmt() IGrant_stmtContext
	Revoke_stmt() IRevoke_stmtContext
	Begin_stmt() IBegin_stmtContext
	Commit_stmt() ICommit_stmtContext
	Rollback_stmt() IRollback_stmtContext
	Create_tablespace_stmt() ICreate_tablespace_stmtContext
	Drop_tablespace_stmt() IDrop_tablespace_stmtContext
	Alter_tablespace_stmt() IAlter_tablespace_stmtContext
	Rotate_master_key_stmt() IRotate_master_key_stmtContext
	Create_index_stmt() ICreate_index_stmtContext
	Drop_index_stmt() IDrop_index_stmtContext
	Kill_stmt() IKill_stmtContext
	Help_stmt() IHelp_stmtContext
	Create_view_stmt() ICreate_view_stmtContext
	Create_tenant_stmt() ICreate_tenant_stmtContext
	Alter_tenant_stmt() IAlter_tenant_stmtContext
	Drop_tenant_stmt() IDrop_tenant_stmtContext
	Create_resource_stmt() ICreate_resource_stmtContext
	Alter_resource_stmt() IAlter_resource_stmtContext
	Drop_resource_stmt() IDrop_resource_stmtContext
	Set_names_stmt() ISet_names_stmtContext
	Set_charset_stmt() ISet_charset_stmtContext
	Create_tablegroup_stmt() ICreate_tablegroup_stmtContext
	Drop_tablegroup_stmt() IDrop_tablegroup_stmtContext
	Alter_tablegroup_stmt() IAlter_tablegroup_stmtContext
	Rename_table_stmt() IRename_table_stmtContext
	Truncate_table_stmt() ITruncate_table_stmtContext
	Set_transaction_stmt() ISet_transaction_stmtContext
	Create_synonym_stmt() ICreate_synonym_stmtContext
	Drop_synonym_stmt() IDrop_synonym_stmtContext
	Create_savepoint_stmt() ICreate_savepoint_stmtContext
	Rollback_savepoint_stmt() IRollback_savepoint_stmtContext
	Release_savepoint_stmt() IRelease_savepoint_stmtContext
	Lock_tables_stmt() ILock_tables_stmtContext
	Unlock_tables_stmt() IUnlock_tables_stmtContext
	Flashback_stmt() IFlashback_stmtContext
	Purge_stmt() IPurge_stmtContext
	Analyze_stmt() IAnalyze_stmtContext
	Load_data_stmt() ILoad_data_stmtContext
	Switchover_cluster_stmt() ISwitchover_cluster_stmtContext
	Alter_cluster_stmt() IAlter_cluster_stmtContext
	Optimize_stmt() IOptimize_stmtContext
	Dump_memory_stmt() IDump_memory_stmtContext

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_stmt
	return p
}

func InitEmptyStmtContext(p *StmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_stmt
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *StmtContext) Insert_stmt() IInsert_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmtContext)
}

func (s *StmtContext) Create_table_stmt() ICreate_table_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_stmtContext)
}

func (s *StmtContext) Create_function_stmt() ICreate_function_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_function_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_function_stmtContext)
}

func (s *StmtContext) Drop_function_stmt() IDrop_function_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_function_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_function_stmtContext)
}

func (s *StmtContext) Create_table_like_stmt() ICreate_table_like_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_like_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_like_stmtContext)
}

func (s *StmtContext) Create_database_stmt() ICreate_database_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_database_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_database_stmtContext)
}

func (s *StmtContext) Drop_database_stmt() IDrop_database_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_database_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_database_stmtContext)
}

func (s *StmtContext) Alter_database_stmt() IAlter_database_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_database_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_database_stmtContext)
}

func (s *StmtContext) Use_database_stmt() IUse_database_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUse_database_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUse_database_stmtContext)
}

func (s *StmtContext) Update_stmt() IUpdate_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_stmtContext)
}

func (s *StmtContext) Delete_stmt() IDelete_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelete_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelete_stmtContext)
}

func (s *StmtContext) Drop_table_stmt() IDrop_table_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_table_stmtContext)
}

func (s *StmtContext) Drop_view_stmt() IDrop_view_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_view_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_view_stmtContext)
}

func (s *StmtContext) Explain_stmt() IExplain_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplain_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplain_stmtContext)
}

func (s *StmtContext) Create_outline_stmt() ICreate_outline_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_outline_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_outline_stmtContext)
}

func (s *StmtContext) Alter_outline_stmt() IAlter_outline_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_outline_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_outline_stmtContext)
}

func (s *StmtContext) Drop_outline_stmt() IDrop_outline_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_outline_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_outline_stmtContext)
}

func (s *StmtContext) Show_stmt() IShow_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShow_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShow_stmtContext)
}

func (s *StmtContext) Prepare_stmt() IPrepare_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrepare_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrepare_stmtContext)
}

func (s *StmtContext) Variable_set_stmt() IVariable_set_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariable_set_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariable_set_stmtContext)
}

func (s *StmtContext) Execute_stmt() IExecute_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecute_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecute_stmtContext)
}

func (s *StmtContext) Alter_table_stmt() IAlter_table_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_stmtContext)
}

func (s *StmtContext) Alter_system_stmt() IAlter_system_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_system_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_system_stmtContext)
}

func (s *StmtContext) Deallocate_prepare_stmt() IDeallocate_prepare_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeallocate_prepare_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeallocate_prepare_stmtContext)
}

func (s *StmtContext) Create_user_stmt() ICreate_user_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_user_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_user_stmtContext)
}

func (s *StmtContext) Drop_user_stmt() IDrop_user_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_user_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_user_stmtContext)
}

func (s *StmtContext) Set_password_stmt() ISet_password_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_password_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_password_stmtContext)
}

func (s *StmtContext) Rename_user_stmt() IRename_user_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRename_user_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRename_user_stmtContext)
}

func (s *StmtContext) Lock_user_stmt() ILock_user_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILock_user_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILock_user_stmtContext)
}

func (s *StmtContext) Grant_stmt() IGrant_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrant_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrant_stmtContext)
}

func (s *StmtContext) Revoke_stmt() IRevoke_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevoke_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevoke_stmtContext)
}

func (s *StmtContext) Begin_stmt() IBegin_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBegin_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBegin_stmtContext)
}

func (s *StmtContext) Commit_stmt() ICommit_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommit_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommit_stmtContext)
}

func (s *StmtContext) Rollback_stmt() IRollback_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollback_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollback_stmtContext)
}

func (s *StmtContext) Create_tablespace_stmt() ICreate_tablespace_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_tablespace_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_tablespace_stmtContext)
}

func (s *StmtContext) Drop_tablespace_stmt() IDrop_tablespace_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_tablespace_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_tablespace_stmtContext)
}

func (s *StmtContext) Alter_tablespace_stmt() IAlter_tablespace_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_tablespace_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_tablespace_stmtContext)
}

func (s *StmtContext) Rotate_master_key_stmt() IRotate_master_key_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRotate_master_key_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRotate_master_key_stmtContext)
}

func (s *StmtContext) Create_index_stmt() ICreate_index_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_index_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_index_stmtContext)
}

func (s *StmtContext) Drop_index_stmt() IDrop_index_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_index_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_index_stmtContext)
}

func (s *StmtContext) Kill_stmt() IKill_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKill_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKill_stmtContext)
}

func (s *StmtContext) Help_stmt() IHelp_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelp_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelp_stmtContext)
}

func (s *StmtContext) Create_view_stmt() ICreate_view_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_view_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_view_stmtContext)
}

func (s *StmtContext) Create_tenant_stmt() ICreate_tenant_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_tenant_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_tenant_stmtContext)
}

func (s *StmtContext) Alter_tenant_stmt() IAlter_tenant_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_tenant_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_tenant_stmtContext)
}

func (s *StmtContext) Drop_tenant_stmt() IDrop_tenant_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_tenant_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_tenant_stmtContext)
}

func (s *StmtContext) Create_resource_stmt() ICreate_resource_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_resource_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_resource_stmtContext)
}

func (s *StmtContext) Alter_resource_stmt() IAlter_resource_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_resource_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_resource_stmtContext)
}

func (s *StmtContext) Drop_resource_stmt() IDrop_resource_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_resource_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_resource_stmtContext)
}

func (s *StmtContext) Set_names_stmt() ISet_names_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_names_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_names_stmtContext)
}

func (s *StmtContext) Set_charset_stmt() ISet_charset_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_charset_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_charset_stmtContext)
}

func (s *StmtContext) Create_tablegroup_stmt() ICreate_tablegroup_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_tablegroup_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_tablegroup_stmtContext)
}

func (s *StmtContext) Drop_tablegroup_stmt() IDrop_tablegroup_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_tablegroup_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_tablegroup_stmtContext)
}

func (s *StmtContext) Alter_tablegroup_stmt() IAlter_tablegroup_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_tablegroup_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_tablegroup_stmtContext)
}

func (s *StmtContext) Rename_table_stmt() IRename_table_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRename_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRename_table_stmtContext)
}

func (s *StmtContext) Truncate_table_stmt() ITruncate_table_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncate_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncate_table_stmtContext)
}

func (s *StmtContext) Set_transaction_stmt() ISet_transaction_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_transaction_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_transaction_stmtContext)
}

func (s *StmtContext) Create_synonym_stmt() ICreate_synonym_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_synonym_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_synonym_stmtContext)
}

func (s *StmtContext) Drop_synonym_stmt() IDrop_synonym_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_synonym_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_synonym_stmtContext)
}

func (s *StmtContext) Create_savepoint_stmt() ICreate_savepoint_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_savepoint_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_savepoint_stmtContext)
}

func (s *StmtContext) Rollback_savepoint_stmt() IRollback_savepoint_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollback_savepoint_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollback_savepoint_stmtContext)
}

func (s *StmtContext) Release_savepoint_stmt() IRelease_savepoint_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelease_savepoint_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelease_savepoint_stmtContext)
}

func (s *StmtContext) Lock_tables_stmt() ILock_tables_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILock_tables_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILock_tables_stmtContext)
}

func (s *StmtContext) Unlock_tables_stmt() IUnlock_tables_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnlock_tables_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnlock_tables_stmtContext)
}

func (s *StmtContext) Flashback_stmt() IFlashback_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlashback_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlashback_stmtContext)
}

func (s *StmtContext) Purge_stmt() IPurge_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPurge_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPurge_stmtContext)
}

func (s *StmtContext) Analyze_stmt() IAnalyze_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyze_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyze_stmtContext)
}

func (s *StmtContext) Load_data_stmt() ILoad_data_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoad_data_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoad_data_stmtContext)
}

func (s *StmtContext) Switchover_cluster_stmt() ISwitchover_cluster_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchover_cluster_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchover_cluster_stmtContext)
}

func (s *StmtContext) Alter_cluster_stmt() IAlter_cluster_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_cluster_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_cluster_stmtContext)
}

func (s *StmtContext) Optimize_stmt() IOptimize_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimize_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimize_stmtContext)
}

func (s *StmtContext) Dump_memory_stmt() IDump_memory_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDump_memory_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDump_memory_stmtContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitStmt(s)
	}
}

func (s *StmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, OBParserRULE_stmt)
	p.SetState(1041)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(968)
			p.Select_stmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(969)
			p.Insert_stmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(970)
			p.Create_table_stmt()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(971)
			p.Create_function_stmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(972)
			p.Drop_function_stmt()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(973)
			p.Create_table_like_stmt()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(974)
			p.Create_database_stmt()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(975)
			p.Drop_database_stmt()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(976)
			p.Alter_database_stmt()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(977)
			p.Use_database_stmt()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(978)
			p.Update_stmt()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(979)
			p.Delete_stmt()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(980)
			p.Drop_table_stmt()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(981)
			p.Drop_view_stmt()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(982)
			p.Explain_stmt()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(983)
			p.Create_outline_stmt()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(984)
			p.Alter_outline_stmt()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(985)
			p.Drop_outline_stmt()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(986)
			p.Show_stmt()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(987)
			p.Prepare_stmt()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(988)
			p.Variable_set_stmt()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(989)
			p.Execute_stmt()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(990)
			p.Alter_table_stmt()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(991)
			p.Alter_system_stmt()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(992)
			p.Deallocate_prepare_stmt()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(993)
			p.Create_user_stmt()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(994)
			p.Drop_user_stmt()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(995)
			p.Set_password_stmt()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(996)
			p.Rename_user_stmt()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(997)
			p.Lock_user_stmt()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(998)
			p.Grant_stmt()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(999)
			p.Revoke_stmt()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1000)
			p.Begin_stmt()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1001)
			p.Commit_stmt()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1002)
			p.Rollback_stmt()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1003)
			p.Create_tablespace_stmt()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1004)
			p.Drop_tablespace_stmt()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(1005)
			p.Alter_tablespace_stmt()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(1006)
			p.Rotate_master_key_stmt()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(1007)
			p.Create_index_stmt()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(1008)
			p.Drop_index_stmt()
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(1009)
			p.Kill_stmt()
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(1010)
			p.Help_stmt()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(1011)
			p.Create_view_stmt()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(1012)
			p.Create_tenant_stmt()
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(1013)
			p.Alter_tenant_stmt()
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(1014)
			p.Drop_tenant_stmt()
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(1015)
			p.Create_resource_stmt()
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(1016)
			p.Alter_resource_stmt()
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(1017)
			p.Drop_resource_stmt()
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(1018)
			p.Set_names_stmt()
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(1019)
			p.Set_charset_stmt()
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(1020)
			p.Create_tablegroup_stmt()
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(1021)
			p.Drop_tablegroup_stmt()
		}

	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(1022)
			p.Alter_tablegroup_stmt()
		}

	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(1023)
			p.Rename_table_stmt()
		}

	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(1024)
			p.Truncate_table_stmt()
		}

	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(1025)
			p.Set_transaction_stmt()
		}

	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(1026)
			p.Create_synonym_stmt()
		}

	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(1027)
			p.Drop_synonym_stmt()
		}

	case 61:
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(1028)
			p.Create_savepoint_stmt()
		}

	case 62:
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(1029)
			p.Rollback_savepoint_stmt()
		}

	case 63:
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(1030)
			p.Release_savepoint_stmt()
		}

	case 64:
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(1031)
			p.Lock_tables_stmt()
		}

	case 65:
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(1032)
			p.Unlock_tables_stmt()
		}

	case 66:
		p.EnterOuterAlt(localctx, 66)
		{
			p.SetState(1033)
			p.Flashback_stmt()
		}

	case 67:
		p.EnterOuterAlt(localctx, 67)
		{
			p.SetState(1034)
			p.Purge_stmt()
		}

	case 68:
		p.EnterOuterAlt(localctx, 68)
		{
			p.SetState(1035)
			p.Analyze_stmt()
		}

	case 69:
		p.EnterOuterAlt(localctx, 69)
		{
			p.SetState(1036)
			p.Load_data_stmt()
		}

	case 70:
		p.EnterOuterAlt(localctx, 70)
		{
			p.SetState(1037)
			p.Switchover_cluster_stmt()
		}

	case 71:
		p.EnterOuterAlt(localctx, 71)
		{
			p.SetState(1038)
			p.Alter_cluster_stmt()
		}

	case 72:
		p.EnterOuterAlt(localctx, 72)
		{
			p.SetState(1039)
			p.Optimize_stmt()
		}

	case 73:
		p.EnterOuterAlt(localctx, 73)
		{
			p.SetState(1040)
			p.Dump_memory_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_listContext is an interface to support dynamic dispatch.
type IExpr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsExpr_listContext differentiates from other interfaces.
	IsExpr_listContext()
}

type Expr_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_listContext() *Expr_listContext {
	var p = new(Expr_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_expr_list
	return p
}

func InitEmptyExpr_listContext(p *Expr_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_expr_list
}

func (*Expr_listContext) IsExpr_listContext() {}

func NewExpr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_listContext {
	var p = new(Expr_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_expr_list

	return p
}

func (s *Expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_listContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_listContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Expr_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterExpr_list(s)
	}
}

func (s *Expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitExpr_list(s)
	}
}

func (s *Expr_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitExpr_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Expr_list() (localctx IExpr_listContext) {
	localctx = NewExpr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, OBParserRULE_expr_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1043)
		p.expr(0)
	}
	p.SetState(1048)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1044)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1045)
				p.expr(0)
			}

		}
		p.SetState(1050)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_as_listContext is an interface to support dynamic dispatch.
type IExpr_as_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr_with_opt_alias() []IExpr_with_opt_aliasContext
	Expr_with_opt_alias(i int) IExpr_with_opt_aliasContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsExpr_as_listContext differentiates from other interfaces.
	IsExpr_as_listContext()
}

type Expr_as_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_as_listContext() *Expr_as_listContext {
	var p = new(Expr_as_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_expr_as_list
	return p
}

func InitEmptyExpr_as_listContext(p *Expr_as_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_expr_as_list
}

func (*Expr_as_listContext) IsExpr_as_listContext() {}

func NewExpr_as_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_as_listContext {
	var p = new(Expr_as_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_expr_as_list

	return p
}

func (s *Expr_as_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_as_listContext) AllExpr_with_opt_alias() []IExpr_with_opt_aliasContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpr_with_opt_aliasContext); ok {
			len++
		}
	}

	tst := make([]IExpr_with_opt_aliasContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpr_with_opt_aliasContext); ok {
			tst[i] = t.(IExpr_with_opt_aliasContext)
			i++
		}
	}

	return tst
}

func (s *Expr_as_listContext) Expr_with_opt_alias(i int) IExpr_with_opt_aliasContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_with_opt_aliasContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_with_opt_aliasContext)
}

func (s *Expr_as_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Expr_as_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Expr_as_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_as_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_as_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterExpr_as_list(s)
	}
}

func (s *Expr_as_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitExpr_as_list(s)
	}
}

func (s *Expr_as_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitExpr_as_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Expr_as_list() (localctx IExpr_as_listContext) {
	localctx = NewExpr_as_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, OBParserRULE_expr_as_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1051)
		p.Expr_with_opt_alias()
	}
	p.SetState(1056)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(1052)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1053)
			p.Expr_with_opt_alias()
		}

		p.SetState(1058)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_with_opt_aliasContext is an interface to support dynamic dispatch.
type IExpr_with_opt_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	Column_label() IColumn_labelContext
	AS() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode

	// IsExpr_with_opt_aliasContext differentiates from other interfaces.
	IsExpr_with_opt_aliasContext()
}

type Expr_with_opt_aliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_with_opt_aliasContext() *Expr_with_opt_aliasContext {
	var p = new(Expr_with_opt_aliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_expr_with_opt_alias
	return p
}

func InitEmptyExpr_with_opt_aliasContext(p *Expr_with_opt_aliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_expr_with_opt_alias
}

func (*Expr_with_opt_aliasContext) IsExpr_with_opt_aliasContext() {}

func NewExpr_with_opt_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_with_opt_aliasContext {
	var p = new(Expr_with_opt_aliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_expr_with_opt_alias

	return p
}

func (s *Expr_with_opt_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_with_opt_aliasContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_with_opt_aliasContext) Column_label() IColumn_labelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_labelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_labelContext)
}

func (s *Expr_with_opt_aliasContext) AS() antlr.TerminalNode {
	return s.GetToken(OBParserAS, 0)
}

func (s *Expr_with_opt_aliasContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Expr_with_opt_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_with_opt_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_with_opt_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterExpr_with_opt_alias(s)
	}
}

func (s *Expr_with_opt_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitExpr_with_opt_alias(s)
	}
}

func (s *Expr_with_opt_aliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitExpr_with_opt_alias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Expr_with_opt_alias() (localctx IExpr_with_opt_aliasContext) {
	localctx = NewExpr_with_opt_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, OBParserRULE_expr_with_opt_alias)
	var _la int

	p.SetState(1072)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1059)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1060)
			p.expr(0)
		}
		p.SetState(1062)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserAS {
			{
				p.SetState(1061)
				p.Match(OBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1064)
			p.Column_label()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1066)
			p.expr(0)
		}
		p.SetState(1068)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserAS {
			{
				p.SetState(1067)
				p.Match(OBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1070)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_refContext is an interface to support dynamic dispatch.
type IColumn_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_name() IColumn_nameContext
	AllRelation_name() []IRelation_nameContext
	Relation_name(i int) IRelation_nameContext
	AllDot() []antlr.TerminalNode
	Dot(i int) antlr.TerminalNode
	Star() antlr.TerminalNode

	// IsColumn_refContext differentiates from other interfaces.
	IsColumn_refContext()
}

type Column_refContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_refContext() *Column_refContext {
	var p = new(Column_refContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_ref
	return p
}

func InitEmptyColumn_refContext(p *Column_refContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_ref
}

func (*Column_refContext) IsColumn_refContext() {}

func NewColumn_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_refContext {
	var p = new(Column_refContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_column_ref

	return p
}

func (s *Column_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_refContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Column_refContext) AllRelation_name() []IRelation_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_nameContext); ok {
			len++
		}
	}

	tst := make([]IRelation_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_nameContext); ok {
			tst[i] = t.(IRelation_nameContext)
			i++
		}
	}

	return tst
}

func (s *Column_refContext) Relation_name(i int) IRelation_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Column_refContext) AllDot() []antlr.TerminalNode {
	return s.GetTokens(OBParserDot)
}

func (s *Column_refContext) Dot(i int) antlr.TerminalNode {
	return s.GetToken(OBParserDot, i)
}

func (s *Column_refContext) Star() antlr.TerminalNode {
	return s.GetToken(OBParserStar, 0)
}

func (s *Column_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterColumn_ref(s)
	}
}

func (s *Column_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitColumn_ref(s)
	}
}

func (s *Column_refContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitColumn_ref(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Column_ref() (localctx IColumn_refContext) {
	localctx = NewColumn_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, OBParserRULE_column_ref)
	p.SetState(1100)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1074)
			p.Column_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1075)
			p.Relation_name()
		}
		{
			p.SetState(1076)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1077)
			p.Column_name()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1079)
			p.Relation_name()
		}
		{
			p.SetState(1080)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1081)
			p.Match(OBParserStar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1083)
			p.Relation_name()
		}
		{
			p.SetState(1084)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1085)
			p.Relation_name()
		}
		{
			p.SetState(1086)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1087)
			p.Column_name()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1089)
			p.Relation_name()
		}
		{
			p.SetState(1090)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1091)
			p.Relation_name()
		}
		{
			p.SetState(1092)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1093)
			p.Match(OBParserStar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1095)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1096)
			p.Relation_name()
		}
		{
			p.SetState(1097)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1098)
			p.Column_name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComplex_string_literalContext is an interface to support dynamic dispatch.
type IComplex_string_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_VALUE() antlr.TerminalNode
	Charset_introducer() ICharset_introducerContext
	HEX_STRING_VALUE() antlr.TerminalNode

	// IsComplex_string_literalContext differentiates from other interfaces.
	IsComplex_string_literalContext()
}

type Complex_string_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplex_string_literalContext() *Complex_string_literalContext {
	var p = new(Complex_string_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_complex_string_literal
	return p
}

func InitEmptyComplex_string_literalContext(p *Complex_string_literalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_complex_string_literal
}

func (*Complex_string_literalContext) IsComplex_string_literalContext() {}

func NewComplex_string_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Complex_string_literalContext {
	var p = new(Complex_string_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_complex_string_literal

	return p
}

func (s *Complex_string_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Complex_string_literalContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Complex_string_literalContext) Charset_introducer() ICharset_introducerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_introducerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_introducerContext)
}

func (s *Complex_string_literalContext) HEX_STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserHEX_STRING_VALUE, 0)
}

func (s *Complex_string_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Complex_string_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Complex_string_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterComplex_string_literal(s)
	}
}

func (s *Complex_string_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitComplex_string_literal(s)
	}
}

func (s *Complex_string_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitComplex_string_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Complex_string_literal() (localctx IComplex_string_literalContext) {
	localctx = NewComplex_string_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, OBParserRULE_complex_string_literal)
	var _la int

	p.SetState(1109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1103)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-255)) & ^0x3f) == 0 && ((int64(1)<<(_la-255))&63) != 0 {
			{
				p.SetState(1102)
				p.Charset_introducer()
			}

		}
		{
			p.SetState(1105)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1106)
			p.Charset_introducer()
		}
		{
			p.SetState(1107)
			p.Match(OBParserHEX_STRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharset_introducerContext is an interface to support dynamic dispatch.
type ICharset_introducerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnderlineUTF8() antlr.TerminalNode
	UnderlineUTF8MB4() antlr.TerminalNode
	UnderlineBINARY() antlr.TerminalNode
	UnderlineGBK() antlr.TerminalNode
	UnderlineGB18030() antlr.TerminalNode
	UnderlineUTF16() antlr.TerminalNode

	// IsCharset_introducerContext differentiates from other interfaces.
	IsCharset_introducerContext()
}

type Charset_introducerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharset_introducerContext() *Charset_introducerContext {
	var p = new(Charset_introducerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_charset_introducer
	return p
}

func InitEmptyCharset_introducerContext(p *Charset_introducerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_charset_introducer
}

func (*Charset_introducerContext) IsCharset_introducerContext() {}

func NewCharset_introducerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Charset_introducerContext {
	var p = new(Charset_introducerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_charset_introducer

	return p
}

func (s *Charset_introducerContext) GetParser() antlr.Parser { return s.parser }

func (s *Charset_introducerContext) UnderlineUTF8() antlr.TerminalNode {
	return s.GetToken(OBParserUnderlineUTF8, 0)
}

func (s *Charset_introducerContext) UnderlineUTF8MB4() antlr.TerminalNode {
	return s.GetToken(OBParserUnderlineUTF8MB4, 0)
}

func (s *Charset_introducerContext) UnderlineBINARY() antlr.TerminalNode {
	return s.GetToken(OBParserUnderlineBINARY, 0)
}

func (s *Charset_introducerContext) UnderlineGBK() antlr.TerminalNode {
	return s.GetToken(OBParserUnderlineGBK, 0)
}

func (s *Charset_introducerContext) UnderlineGB18030() antlr.TerminalNode {
	return s.GetToken(OBParserUnderlineGB18030, 0)
}

func (s *Charset_introducerContext) UnderlineUTF16() antlr.TerminalNode {
	return s.GetToken(OBParserUnderlineUTF16, 0)
}

func (s *Charset_introducerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Charset_introducerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Charset_introducerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCharset_introducer(s)
	}
}

func (s *Charset_introducerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCharset_introducer(s)
	}
}

func (s *Charset_introducerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCharset_introducer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Charset_introducer() (localctx ICharset_introducerContext) {
	localctx = NewCharset_introducerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, OBParserRULE_charset_introducer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1111)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-255)) & ^0x3f) == 0 && ((int64(1)<<(_la-255))&63) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Complex_string_literal() IComplex_string_literalContext
	DATE_VALUE() antlr.TerminalNode
	TIMESTAMP_VALUE() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	APPROXNUM() antlr.TerminalNode
	DECIMAL_VAL() antlr.TerminalNode
	BOOL_VALUE() antlr.TerminalNode
	NULLX() antlr.TerminalNode
	HEX_STRING_VALUE() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) Complex_string_literal() IComplex_string_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComplex_string_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComplex_string_literalContext)
}

func (s *LiteralContext) DATE_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserDATE_VALUE, 0)
}

func (s *LiteralContext) TIMESTAMP_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserTIMESTAMP_VALUE, 0)
}

func (s *LiteralContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *LiteralContext) APPROXNUM() antlr.TerminalNode {
	return s.GetToken(OBParserAPPROXNUM, 0)
}

func (s *LiteralContext) DECIMAL_VAL() antlr.TerminalNode {
	return s.GetToken(OBParserDECIMAL_VAL, 0)
}

func (s *LiteralContext) BOOL_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserBOOL_VALUE, 0)
}

func (s *LiteralContext) NULLX() antlr.TerminalNode {
	return s.GetToken(OBParserNULLX, 0)
}

func (s *LiteralContext) HEX_STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserHEX_STRING_VALUE, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, OBParserRULE_literal)
	p.SetState(1122)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserUnderlineUTF8, OBParserUnderlineUTF8MB4, OBParserUnderlineGBK, OBParserUnderlineGB18030, OBParserUnderlineBINARY, OBParserUnderlineUTF16, OBParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1113)
			p.Complex_string_literal()
		}

	case OBParserDATE_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1114)
			p.Match(OBParserDATE_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserTIMESTAMP_VALUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1115)
			p.Match(OBParserTIMESTAMP_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserINTNUM:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1116)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserAPPROXNUM:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1117)
			p.Match(OBParserAPPROXNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserDECIMAL_VAL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1118)
			p.Match(OBParserDECIMAL_VAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserBOOL_VALUE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1119)
			p.Match(OBParserBOOL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserNULLX:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1120)
			p.Match(OBParserNULLX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserHEX_STRING_VALUE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1121)
			p.Match(OBParserHEX_STRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumber_literalContext is an interface to support dynamic dispatch.
type INumber_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTNUM() antlr.TerminalNode
	DECIMAL_VAL() antlr.TerminalNode

	// IsNumber_literalContext differentiates from other interfaces.
	IsNumber_literalContext()
}

type Number_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumber_literalContext() *Number_literalContext {
	var p = new(Number_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_number_literal
	return p
}

func InitEmptyNumber_literalContext(p *Number_literalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_number_literal
}

func (*Number_literalContext) IsNumber_literalContext() {}

func NewNumber_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Number_literalContext {
	var p = new(Number_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_number_literal

	return p
}

func (s *Number_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Number_literalContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Number_literalContext) DECIMAL_VAL() antlr.TerminalNode {
	return s.GetToken(OBParserDECIMAL_VAL, 0)
}

func (s *Number_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Number_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Number_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterNumber_literal(s)
	}
}

func (s *Number_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitNumber_literal(s)
	}
}

func (s *Number_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitNumber_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Number_literal() (localctx INumber_literalContext) {
	localctx = NewNumber_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, OBParserRULE_number_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1124)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserINTNUM || _la == OBParserDECIMAL_VAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_constContext is an interface to support dynamic dispatch.
type IExpr_constContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	SYSTEM_VARIABLE() antlr.TerminalNode
	QUESTIONMARK() antlr.TerminalNode
	Global_or_session_alias() IGlobal_or_session_aliasContext
	Dot() antlr.TerminalNode
	Column_name() IColumn_nameContext

	// IsExpr_constContext differentiates from other interfaces.
	IsExpr_constContext()
}

type Expr_constContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_constContext() *Expr_constContext {
	var p = new(Expr_constContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_expr_const
	return p
}

func InitEmptyExpr_constContext(p *Expr_constContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_expr_const
}

func (*Expr_constContext) IsExpr_constContext() {}

func NewExpr_constContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_constContext {
	var p = new(Expr_constContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_expr_const

	return p
}

func (s *Expr_constContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_constContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *Expr_constContext) SYSTEM_VARIABLE() antlr.TerminalNode {
	return s.GetToken(OBParserSYSTEM_VARIABLE, 0)
}

func (s *Expr_constContext) QUESTIONMARK() antlr.TerminalNode {
	return s.GetToken(OBParserQUESTIONMARK, 0)
}

func (s *Expr_constContext) Global_or_session_alias() IGlobal_or_session_aliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobal_or_session_aliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobal_or_session_aliasContext)
}

func (s *Expr_constContext) Dot() antlr.TerminalNode {
	return s.GetToken(OBParserDot, 0)
}

func (s *Expr_constContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Expr_constContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_constContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_constContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterExpr_const(s)
	}
}

func (s *Expr_constContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitExpr_const(s)
	}
}

func (s *Expr_constContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitExpr_const(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Expr_const() (localctx IExpr_constContext) {
	localctx = NewExpr_constContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, OBParserRULE_expr_const)
	p.SetState(1133)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserUnderlineUTF8, OBParserUnderlineUTF8MB4, OBParserUnderlineGBK, OBParserUnderlineGB18030, OBParserUnderlineBINARY, OBParserUnderlineUTF16, OBParserNULLX, OBParserINTNUM, OBParserTIMESTAMP_VALUE, OBParserAPPROXNUM, OBParserDECIMAL_VAL, OBParserBOOL_VALUE, OBParserHEX_STRING_VALUE, OBParserDATE_VALUE, OBParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1126)
			p.Literal()
		}

	case OBParserSYSTEM_VARIABLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1127)
			p.Match(OBParserSYSTEM_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserQUESTIONMARK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1128)
			p.Match(OBParserQUESTIONMARK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserGLOBAL_ALIAS, OBParserSESSION_ALIAS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1129)
			p.Global_or_session_alias()
		}
		{
			p.SetState(1130)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1131)
			p.Column_name()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConf_constContext is an interface to support dynamic dispatch.
type IConf_constContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_VALUE() antlr.TerminalNode
	DATE_VALUE() antlr.TerminalNode
	TIMESTAMP_VALUE() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	APPROXNUM() antlr.TerminalNode
	DECIMAL_VAL() antlr.TerminalNode
	BOOL_VALUE() antlr.TerminalNode
	NULLX() antlr.TerminalNode
	SYSTEM_VARIABLE() antlr.TerminalNode
	Global_or_session_alias() IGlobal_or_session_aliasContext
	Dot() antlr.TerminalNode
	Column_name() IColumn_nameContext
	Minus() antlr.TerminalNode

	// IsConf_constContext differentiates from other interfaces.
	IsConf_constContext()
}

type Conf_constContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConf_constContext() *Conf_constContext {
	var p = new(Conf_constContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_conf_const
	return p
}

func InitEmptyConf_constContext(p *Conf_constContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_conf_const
}

func (*Conf_constContext) IsConf_constContext() {}

func NewConf_constContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conf_constContext {
	var p = new(Conf_constContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_conf_const

	return p
}

func (s *Conf_constContext) GetParser() antlr.Parser { return s.parser }

func (s *Conf_constContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Conf_constContext) DATE_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserDATE_VALUE, 0)
}

func (s *Conf_constContext) TIMESTAMP_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserTIMESTAMP_VALUE, 0)
}

func (s *Conf_constContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Conf_constContext) APPROXNUM() antlr.TerminalNode {
	return s.GetToken(OBParserAPPROXNUM, 0)
}

func (s *Conf_constContext) DECIMAL_VAL() antlr.TerminalNode {
	return s.GetToken(OBParserDECIMAL_VAL, 0)
}

func (s *Conf_constContext) BOOL_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserBOOL_VALUE, 0)
}

func (s *Conf_constContext) NULLX() antlr.TerminalNode {
	return s.GetToken(OBParserNULLX, 0)
}

func (s *Conf_constContext) SYSTEM_VARIABLE() antlr.TerminalNode {
	return s.GetToken(OBParserSYSTEM_VARIABLE, 0)
}

func (s *Conf_constContext) Global_or_session_alias() IGlobal_or_session_aliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobal_or_session_aliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobal_or_session_aliasContext)
}

func (s *Conf_constContext) Dot() antlr.TerminalNode {
	return s.GetToken(OBParserDot, 0)
}

func (s *Conf_constContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Conf_constContext) Minus() antlr.TerminalNode {
	return s.GetToken(OBParserMinus, 0)
}

func (s *Conf_constContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conf_constContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conf_constContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterConf_const(s)
	}
}

func (s *Conf_constContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitConf_const(s)
	}
}

func (s *Conf_constContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitConf_const(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Conf_const() (localctx IConf_constContext) {
	localctx = NewConf_constContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, OBParserRULE_conf_const)
	p.SetState(1152)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1135)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1136)
			p.Match(OBParserDATE_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1137)
			p.Match(OBParserTIMESTAMP_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1138)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1139)
			p.Match(OBParserAPPROXNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1140)
			p.Match(OBParserDECIMAL_VAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1141)
			p.Match(OBParserBOOL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1142)
			p.Match(OBParserNULLX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1143)
			p.Match(OBParserSYSTEM_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1144)
			p.Global_or_session_alias()
		}
		{
			p.SetState(1145)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1146)
			p.Column_name()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1148)
			p.Match(OBParserMinus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1149)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1150)
			p.Match(OBParserMinus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1151)
			p.Match(OBParserDECIMAL_VAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGlobal_or_session_aliasContext is an interface to support dynamic dispatch.
type IGlobal_or_session_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL_ALIAS() antlr.TerminalNode
	SESSION_ALIAS() antlr.TerminalNode

	// IsGlobal_or_session_aliasContext differentiates from other interfaces.
	IsGlobal_or_session_aliasContext()
}

type Global_or_session_aliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobal_or_session_aliasContext() *Global_or_session_aliasContext {
	var p = new(Global_or_session_aliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_global_or_session_alias
	return p
}

func InitEmptyGlobal_or_session_aliasContext(p *Global_or_session_aliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_global_or_session_alias
}

func (*Global_or_session_aliasContext) IsGlobal_or_session_aliasContext() {}

func NewGlobal_or_session_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_or_session_aliasContext {
	var p = new(Global_or_session_aliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_global_or_session_alias

	return p
}

func (s *Global_or_session_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_or_session_aliasContext) GLOBAL_ALIAS() antlr.TerminalNode {
	return s.GetToken(OBParserGLOBAL_ALIAS, 0)
}

func (s *Global_or_session_aliasContext) SESSION_ALIAS() antlr.TerminalNode {
	return s.GetToken(OBParserSESSION_ALIAS, 0)
}

func (s *Global_or_session_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_or_session_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Global_or_session_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterGlobal_or_session_alias(s)
	}
}

func (s *Global_or_session_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitGlobal_or_session_alias(s)
	}
}

func (s *Global_or_session_aliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitGlobal_or_session_alias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Global_or_session_alias() (localctx IGlobal_or_session_aliasContext) {
	localctx = NewGlobal_or_session_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, OBParserRULE_global_or_session_alias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1154)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserGLOBAL_ALIAS || _la == OBParserSESSION_ALIAS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_priContext is an interface to support dynamic dispatch.
type IBool_priContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Predicate() IPredicateContext
	Bool_pri() IBool_priContext
	IS() antlr.TerminalNode
	NULLX() antlr.TerminalNode
	Not() INotContext
	COMP_LE() antlr.TerminalNode
	Sub_query_flag() ISub_query_flagContext
	LeftParen() antlr.TerminalNode
	Select_no_parens() ISelect_no_parensContext
	RightParen() antlr.TerminalNode
	COMP_LT() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode
	COMP_NSEQ() antlr.TerminalNode
	COMP_GE() antlr.TerminalNode
	COMP_GT() antlr.TerminalNode
	COMP_NE() antlr.TerminalNode

	// IsBool_priContext differentiates from other interfaces.
	IsBool_priContext()
}

type Bool_priContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_priContext() *Bool_priContext {
	var p = new(Bool_priContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_bool_pri
	return p
}

func InitEmptyBool_priContext(p *Bool_priContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_bool_pri
}

func (*Bool_priContext) IsBool_priContext() {}

func NewBool_priContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_priContext {
	var p = new(Bool_priContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_bool_pri

	return p
}

func (s *Bool_priContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_priContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *Bool_priContext) Bool_pri() IBool_priContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_priContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_priContext)
}

func (s *Bool_priContext) IS() antlr.TerminalNode {
	return s.GetToken(OBParserIS, 0)
}

func (s *Bool_priContext) NULLX() antlr.TerminalNode {
	return s.GetToken(OBParserNULLX, 0)
}

func (s *Bool_priContext) Not() INotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotContext)
}

func (s *Bool_priContext) COMP_LE() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_LE, 0)
}

func (s *Bool_priContext) Sub_query_flag() ISub_query_flagContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISub_query_flagContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISub_query_flagContext)
}

func (s *Bool_priContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Bool_priContext) Select_no_parens() ISelect_no_parensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_no_parensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_no_parensContext)
}

func (s *Bool_priContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Bool_priContext) COMP_LT() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_LT, 0)
}

func (s *Bool_priContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Bool_priContext) COMP_NSEQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_NSEQ, 0)
}

func (s *Bool_priContext) COMP_GE() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_GE, 0)
}

func (s *Bool_priContext) COMP_GT() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_GT, 0)
}

func (s *Bool_priContext) COMP_NE() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_NE, 0)
}

func (s *Bool_priContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_priContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_priContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterBool_pri(s)
	}
}

func (s *Bool_priContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitBool_pri(s)
	}
}

func (s *Bool_priContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitBool_pri(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Bool_pri() (localctx IBool_priContext) {
	return p.bool_pri(0)
}

func (p *OBParser) bool_pri(_p int) (localctx IBool_priContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBool_priContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBool_priContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 28
	p.EnterRecursionRule(localctx, 28, OBParserRULE_bool_pri, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1157)
		p.Predicate()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1232)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1230)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBool_priContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bool_pri)
				p.SetState(1159)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(1160)
					p.Match(OBParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1161)
					p.Match(OBParserNULLX)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewBool_priContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bool_pri)
				p.SetState(1162)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(1163)
					p.Match(OBParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1164)
					p.Not()
				}
				{
					p.SetState(1165)
					p.Match(OBParserNULLX)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 3:
				localctx = NewBool_priContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bool_pri)
				p.SetState(1167)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(1168)
					p.Match(OBParserCOMP_LE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1169)
					p.Predicate()
				}

			case 4:
				localctx = NewBool_priContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bool_pri)
				p.SetState(1170)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(1171)
					p.Match(OBParserCOMP_LE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1172)
					p.Sub_query_flag()
				}
				{
					p.SetState(1173)
					p.Match(OBParserLeftParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1174)
					p.Select_no_parens()
				}
				{
					p.SetState(1175)
					p.Match(OBParserRightParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 5:
				localctx = NewBool_priContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bool_pri)
				p.SetState(1177)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(1178)
					p.Match(OBParserCOMP_LT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1179)
					p.Predicate()
				}

			case 6:
				localctx = NewBool_priContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bool_pri)
				p.SetState(1180)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(1181)
					p.Match(OBParserCOMP_LT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1182)
					p.Sub_query_flag()
				}
				{
					p.SetState(1183)
					p.Match(OBParserLeftParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1184)
					p.Select_no_parens()
				}
				{
					p.SetState(1185)
					p.Match(OBParserRightParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 7:
				localctx = NewBool_priContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bool_pri)
				p.SetState(1187)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(1188)
					p.Match(OBParserCOMP_EQ)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1189)
					p.Predicate()
				}

			case 8:
				localctx = NewBool_priContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bool_pri)
				p.SetState(1190)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(1191)
					p.Match(OBParserCOMP_EQ)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1192)
					p.Sub_query_flag()
				}
				{
					p.SetState(1193)
					p.Match(OBParserLeftParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1194)
					p.Select_no_parens()
				}
				{
					p.SetState(1195)
					p.Match(OBParserRightParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 9:
				localctx = NewBool_priContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bool_pri)
				p.SetState(1197)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(1198)
					p.Match(OBParserCOMP_NSEQ)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1199)
					p.Predicate()
				}

			case 10:
				localctx = NewBool_priContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bool_pri)
				p.SetState(1200)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(1201)
					p.Match(OBParserCOMP_GE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1202)
					p.Predicate()
				}

			case 11:
				localctx = NewBool_priContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bool_pri)
				p.SetState(1203)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(1204)
					p.Match(OBParserCOMP_GE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1205)
					p.Sub_query_flag()
				}
				{
					p.SetState(1206)
					p.Match(OBParserLeftParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1207)
					p.Select_no_parens()
				}
				{
					p.SetState(1208)
					p.Match(OBParserRightParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 12:
				localctx = NewBool_priContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bool_pri)
				p.SetState(1210)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(1211)
					p.Match(OBParserCOMP_GT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1212)
					p.Predicate()
				}

			case 13:
				localctx = NewBool_priContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bool_pri)
				p.SetState(1213)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(1214)
					p.Match(OBParserCOMP_GT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1215)
					p.Sub_query_flag()
				}
				{
					p.SetState(1216)
					p.Match(OBParserLeftParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1217)
					p.Select_no_parens()
				}
				{
					p.SetState(1218)
					p.Match(OBParserRightParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 14:
				localctx = NewBool_priContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bool_pri)
				p.SetState(1220)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1221)
					p.Match(OBParserCOMP_NE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1222)
					p.Predicate()
				}

			case 15:
				localctx = NewBool_priContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bool_pri)
				p.SetState(1223)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1224)
					p.Match(OBParserCOMP_NE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1225)
					p.Sub_query_flag()
				}
				{
					p.SetState(1226)
					p.Match(OBParserLeftParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1227)
					p.Select_no_parens()
				}
				{
					p.SetState(1228)
					p.Match(OBParserRightParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1234)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBit_expr() []IBit_exprContext
	Bit_expr(i int) IBit_exprContext
	IN() antlr.TerminalNode
	In_expr() IIn_exprContext
	Not() INotContext
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode
	Predicate() IPredicateContext
	LIKE() antlr.TerminalNode
	AllSimple_expr() []ISimple_exprContext
	Simple_expr(i int) ISimple_exprContext
	ESCAPE() antlr.TerminalNode
	REGEXP() antlr.TerminalNode

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) AllBit_expr() []IBit_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBit_exprContext); ok {
			len++
		}
	}

	tst := make([]IBit_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBit_exprContext); ok {
			tst[i] = t.(IBit_exprContext)
			i++
		}
	}

	return tst
}

func (s *PredicateContext) Bit_expr(i int) IBit_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBit_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBit_exprContext)
}

func (s *PredicateContext) IN() antlr.TerminalNode {
	return s.GetToken(OBParserIN, 0)
}

func (s *PredicateContext) In_expr() IIn_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIn_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIn_exprContext)
}

func (s *PredicateContext) Not() INotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotContext)
}

func (s *PredicateContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(OBParserBETWEEN, 0)
}

func (s *PredicateContext) AND() antlr.TerminalNode {
	return s.GetToken(OBParserAND, 0)
}

func (s *PredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(OBParserLIKE, 0)
}

func (s *PredicateContext) AllSimple_expr() []ISimple_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimple_exprContext); ok {
			len++
		}
	}

	tst := make([]ISimple_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimple_exprContext); ok {
			tst[i] = t.(ISimple_exprContext)
			i++
		}
	}

	return tst
}

func (s *PredicateContext) Simple_expr(i int) ISimple_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_exprContext)
}

func (s *PredicateContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(OBParserESCAPE, 0)
}

func (s *PredicateContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(OBParserREGEXP, 0)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (s *PredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, OBParserRULE_predicate)
	p.SetState(1289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1235)
			p.bit_expr(0)
		}
		{
			p.SetState(1236)
			p.Match(OBParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1237)
			p.In_expr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1239)
			p.bit_expr(0)
		}
		{
			p.SetState(1240)
			p.Not()
		}
		{
			p.SetState(1241)
			p.Match(OBParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1242)
			p.In_expr()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1244)
			p.bit_expr(0)
		}
		{
			p.SetState(1245)
			p.Not()
		}
		{
			p.SetState(1246)
			p.Match(OBParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1247)
			p.bit_expr(0)
		}
		{
			p.SetState(1248)
			p.Match(OBParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1249)
			p.Predicate()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1251)
			p.bit_expr(0)
		}
		{
			p.SetState(1252)
			p.Match(OBParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1253)
			p.bit_expr(0)
		}
		{
			p.SetState(1254)
			p.Match(OBParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1255)
			p.Predicate()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1257)
			p.bit_expr(0)
		}
		{
			p.SetState(1258)
			p.Match(OBParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1259)
			p.simple_expr(0)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1261)
			p.bit_expr(0)
		}
		{
			p.SetState(1262)
			p.Match(OBParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1263)
			p.simple_expr(0)
		}
		{
			p.SetState(1264)
			p.Match(OBParserESCAPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1265)
			p.simple_expr(0)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1267)
			p.bit_expr(0)
		}
		{
			p.SetState(1268)
			p.Not()
		}
		{
			p.SetState(1269)
			p.Match(OBParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1270)
			p.simple_expr(0)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1272)
			p.bit_expr(0)
		}
		{
			p.SetState(1273)
			p.Not()
		}
		{
			p.SetState(1274)
			p.Match(OBParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1275)
			p.simple_expr(0)
		}
		{
			p.SetState(1276)
			p.Match(OBParserESCAPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1277)
			p.simple_expr(0)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1279)
			p.bit_expr(0)
		}
		{
			p.SetState(1280)
			p.Match(OBParserREGEXP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1281)
			p.bit_expr(0)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1283)
			p.bit_expr(0)
		}
		{
			p.SetState(1284)
			p.Not()
		}
		{
			p.SetState(1285)
			p.Match(OBParserREGEXP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1286)
			p.bit_expr(0)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1288)
			p.bit_expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBit_exprContext is an interface to support dynamic dispatch.
type IBit_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Simple_expr() ISimple_exprContext
	AllBit_expr() []IBit_exprContext
	Bit_expr(i int) IBit_exprContext
	Or() antlr.TerminalNode
	And() antlr.TerminalNode
	SHIFT_LEFT() antlr.TerminalNode
	SHIFT_RIGHT() antlr.TerminalNode
	Plus() antlr.TerminalNode
	Minus() antlr.TerminalNode
	Star() antlr.TerminalNode
	Div() antlr.TerminalNode
	Mod() antlr.TerminalNode
	MOD() antlr.TerminalNode
	DIV() antlr.TerminalNode
	Caret() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	Expr() IExprContext
	Date_unit() IDate_unitContext

	// IsBit_exprContext differentiates from other interfaces.
	IsBit_exprContext()
}

type Bit_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBit_exprContext() *Bit_exprContext {
	var p = new(Bit_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_bit_expr
	return p
}

func InitEmptyBit_exprContext(p *Bit_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_bit_expr
}

func (*Bit_exprContext) IsBit_exprContext() {}

func NewBit_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bit_exprContext {
	var p = new(Bit_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_bit_expr

	return p
}

func (s *Bit_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Bit_exprContext) Simple_expr() ISimple_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_exprContext)
}

func (s *Bit_exprContext) AllBit_expr() []IBit_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBit_exprContext); ok {
			len++
		}
	}

	tst := make([]IBit_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBit_exprContext); ok {
			tst[i] = t.(IBit_exprContext)
			i++
		}
	}

	return tst
}

func (s *Bit_exprContext) Bit_expr(i int) IBit_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBit_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBit_exprContext)
}

func (s *Bit_exprContext) Or() antlr.TerminalNode {
	return s.GetToken(OBParserOr, 0)
}

func (s *Bit_exprContext) And() antlr.TerminalNode {
	return s.GetToken(OBParserAnd, 0)
}

func (s *Bit_exprContext) SHIFT_LEFT() antlr.TerminalNode {
	return s.GetToken(OBParserSHIFT_LEFT, 0)
}

func (s *Bit_exprContext) SHIFT_RIGHT() antlr.TerminalNode {
	return s.GetToken(OBParserSHIFT_RIGHT, 0)
}

func (s *Bit_exprContext) Plus() antlr.TerminalNode {
	return s.GetToken(OBParserPlus, 0)
}

func (s *Bit_exprContext) Minus() antlr.TerminalNode {
	return s.GetToken(OBParserMinus, 0)
}

func (s *Bit_exprContext) Star() antlr.TerminalNode {
	return s.GetToken(OBParserStar, 0)
}

func (s *Bit_exprContext) Div() antlr.TerminalNode {
	return s.GetToken(OBParserDiv, 0)
}

func (s *Bit_exprContext) Mod() antlr.TerminalNode {
	return s.GetToken(OBParserMod, 0)
}

func (s *Bit_exprContext) MOD() antlr.TerminalNode {
	return s.GetToken(OBParserMOD, 0)
}

func (s *Bit_exprContext) DIV() antlr.TerminalNode {
	return s.GetToken(OBParserDIV, 0)
}

func (s *Bit_exprContext) Caret() antlr.TerminalNode {
	return s.GetToken(OBParserCaret, 0)
}

func (s *Bit_exprContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(OBParserINTERVAL, 0)
}

func (s *Bit_exprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bit_exprContext) Date_unit() IDate_unitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDate_unitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDate_unitContext)
}

func (s *Bit_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bit_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bit_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterBit_expr(s)
	}
}

func (s *Bit_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitBit_expr(s)
	}
}

func (s *Bit_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitBit_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Bit_expr() (localctx IBit_exprContext) {
	return p.bit_expr(0)
}

func (p *OBParser) bit_expr(_p int) (localctx IBit_exprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBit_exprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBit_exprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 32
	p.EnterRecursionRule(localctx, 32, OBParserRULE_bit_expr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1292)
		p.simple_expr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1342)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBit_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bit_expr)
				p.SetState(1294)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(1295)
					p.Match(OBParserOr)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1296)
					p.bit_expr(16)
				}

			case 2:
				localctx = NewBit_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bit_expr)
				p.SetState(1297)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(1298)
					p.Match(OBParserAnd)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1299)
					p.bit_expr(15)
				}

			case 3:
				localctx = NewBit_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bit_expr)
				p.SetState(1300)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(1301)
					p.Match(OBParserSHIFT_LEFT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1302)
					p.bit_expr(14)
				}

			case 4:
				localctx = NewBit_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bit_expr)
				p.SetState(1303)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(1304)
					p.Match(OBParserSHIFT_RIGHT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1305)
					p.bit_expr(13)
				}

			case 5:
				localctx = NewBit_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bit_expr)
				p.SetState(1306)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(1307)
					p.Match(OBParserPlus)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1308)
					p.bit_expr(12)
				}

			case 6:
				localctx = NewBit_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bit_expr)
				p.SetState(1309)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(1310)
					p.Match(OBParserMinus)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1311)
					p.bit_expr(11)
				}

			case 7:
				localctx = NewBit_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bit_expr)
				p.SetState(1312)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(1313)
					p.Match(OBParserStar)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1314)
					p.bit_expr(8)
				}

			case 8:
				localctx = NewBit_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bit_expr)
				p.SetState(1315)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(1316)
					p.Match(OBParserDiv)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1317)
					p.bit_expr(7)
				}

			case 9:
				localctx = NewBit_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bit_expr)
				p.SetState(1318)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(1319)
					p.Match(OBParserMod)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1320)
					p.bit_expr(6)
				}

			case 10:
				localctx = NewBit_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bit_expr)
				p.SetState(1321)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(1322)
					p.Match(OBParserMOD)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1323)
					p.bit_expr(5)
				}

			case 11:
				localctx = NewBit_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bit_expr)
				p.SetState(1324)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1325)
					p.Match(OBParserDIV)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1326)
					p.bit_expr(4)
				}

			case 12:
				localctx = NewBit_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bit_expr)
				p.SetState(1327)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1328)
					p.Match(OBParserCaret)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1329)
					p.bit_expr(3)
				}

			case 13:
				localctx = NewBit_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bit_expr)
				p.SetState(1330)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(1331)
					p.Match(OBParserPlus)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1332)
					p.Match(OBParserINTERVAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1333)
					p.expr(0)
				}
				{
					p.SetState(1334)
					p.Date_unit()
				}

			case 14:
				localctx = NewBit_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_bit_expr)
				p.SetState(1336)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(1337)
					p.Match(OBParserMinus)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1338)
					p.Match(OBParserINTERVAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1339)
					p.expr(0)
				}
				{
					p.SetState(1340)
					p.Date_unit()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1346)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimple_exprContext is an interface to support dynamic dispatch.
type ISimple_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINARY() antlr.TerminalNode
	AllSimple_expr() []ISimple_exprContext
	Simple_expr(i int) ISimple_exprContext
	Column_ref() IColumn_refContext
	Expr_const() IExpr_constContext
	Plus() antlr.TerminalNode
	Minus() antlr.TerminalNode
	Tilde() antlr.TerminalNode
	Not2() INot2Context
	Select_with_parens() ISelect_with_parensContext
	AllLeftParen() []antlr.TerminalNode
	LeftParen(i int) antlr.TerminalNode
	Expr() IExprContext
	AllRightParen() []antlr.TerminalNode
	RightParen(i int) antlr.TerminalNode
	Expr_list() IExpr_listContext
	Comma() antlr.TerminalNode
	ROW() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	Column_list() IColumn_listContext
	AGAINST() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	IN() antlr.TerminalNode
	NATURAL() antlr.TerminalNode
	LANGUAGE() antlr.TerminalNode
	MODE() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	Case_expr() ICase_exprContext
	Func_expr() IFunc_exprContext
	Window_function() IWindow_functionContext
	USER_VARIABLE() antlr.TerminalNode
	CNNOP() antlr.TerminalNode
	Collation() ICollationContext

	// IsSimple_exprContext differentiates from other interfaces.
	IsSimple_exprContext()
}

type Simple_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_exprContext() *Simple_exprContext {
	var p = new(Simple_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_simple_expr
	return p
}

func InitEmptySimple_exprContext(p *Simple_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_simple_expr
}

func (*Simple_exprContext) IsSimple_exprContext() {}

func NewSimple_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_exprContext {
	var p = new(Simple_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_simple_expr

	return p
}

func (s *Simple_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_exprContext) BINARY() antlr.TerminalNode {
	return s.GetToken(OBParserBINARY, 0)
}

func (s *Simple_exprContext) AllSimple_expr() []ISimple_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimple_exprContext); ok {
			len++
		}
	}

	tst := make([]ISimple_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimple_exprContext); ok {
			tst[i] = t.(ISimple_exprContext)
			i++
		}
	}

	return tst
}

func (s *Simple_exprContext) Simple_expr(i int) ISimple_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_exprContext)
}

func (s *Simple_exprContext) Column_ref() IColumn_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_refContext)
}

func (s *Simple_exprContext) Expr_const() IExpr_constContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_constContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_constContext)
}

func (s *Simple_exprContext) Plus() antlr.TerminalNode {
	return s.GetToken(OBParserPlus, 0)
}

func (s *Simple_exprContext) Minus() antlr.TerminalNode {
	return s.GetToken(OBParserMinus, 0)
}

func (s *Simple_exprContext) Tilde() antlr.TerminalNode {
	return s.GetToken(OBParserTilde, 0)
}

func (s *Simple_exprContext) Not2() INot2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INot2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INot2Context)
}

func (s *Simple_exprContext) Select_with_parens() ISelect_with_parensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_with_parensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_with_parensContext)
}

func (s *Simple_exprContext) AllLeftParen() []antlr.TerminalNode {
	return s.GetTokens(OBParserLeftParen)
}

func (s *Simple_exprContext) LeftParen(i int) antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, i)
}

func (s *Simple_exprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Simple_exprContext) AllRightParen() []antlr.TerminalNode {
	return s.GetTokens(OBParserRightParen)
}

func (s *Simple_exprContext) RightParen(i int) antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, i)
}

func (s *Simple_exprContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Simple_exprContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Simple_exprContext) ROW() antlr.TerminalNode {
	return s.GetToken(OBParserROW, 0)
}

func (s *Simple_exprContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Simple_exprContext) MATCH() antlr.TerminalNode {
	return s.GetToken(OBParserMATCH, 0)
}

func (s *Simple_exprContext) Column_list() IColumn_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_listContext)
}

func (s *Simple_exprContext) AGAINST() antlr.TerminalNode {
	return s.GetToken(OBParserAGAINST, 0)
}

func (s *Simple_exprContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Simple_exprContext) IN() antlr.TerminalNode {
	return s.GetToken(OBParserIN, 0)
}

func (s *Simple_exprContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(OBParserNATURAL, 0)
}

func (s *Simple_exprContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(OBParserLANGUAGE, 0)
}

func (s *Simple_exprContext) MODE() antlr.TerminalNode {
	return s.GetToken(OBParserMODE, 0)
}

func (s *Simple_exprContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(OBParserBOOLEAN, 0)
}

func (s *Simple_exprContext) Case_expr() ICase_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICase_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICase_exprContext)
}

func (s *Simple_exprContext) Func_expr() IFunc_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_exprContext)
}

func (s *Simple_exprContext) Window_function() IWindow_functionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindow_functionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindow_functionContext)
}

func (s *Simple_exprContext) USER_VARIABLE() antlr.TerminalNode {
	return s.GetToken(OBParserUSER_VARIABLE, 0)
}

func (s *Simple_exprContext) CNNOP() antlr.TerminalNode {
	return s.GetToken(OBParserCNNOP, 0)
}

func (s *Simple_exprContext) Collation() ICollationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationContext)
}

func (s *Simple_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSimple_expr(s)
	}
}

func (s *Simple_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSimple_expr(s)
	}
}

func (s *Simple_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSimple_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Simple_expr() (localctx ISimple_exprContext) {
	return p.simple_expr(0)
}

func (p *OBParser) simple_expr(_p int) (localctx ISimple_exprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewSimple_exprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISimple_exprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 34
	p.EnterRecursionRule(localctx, 34, OBParserRULE_simple_expr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1348)
			p.Match(OBParserBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1349)
			p.simple_expr(18)
		}

	case 2:
		{
			p.SetState(1350)
			p.Column_ref()
		}

	case 3:
		{
			p.SetState(1351)
			p.Expr_const()
		}

	case 4:
		{
			p.SetState(1352)
			p.Match(OBParserPlus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1353)
			p.simple_expr(14)
		}

	case 5:
		{
			p.SetState(1354)
			p.Match(OBParserMinus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1355)
			p.simple_expr(13)
		}

	case 6:
		{
			p.SetState(1356)
			p.Match(OBParserTilde)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1357)
			p.simple_expr(12)
		}

	case 7:
		{
			p.SetState(1358)
			p.Not2()
		}
		{
			p.SetState(1359)
			p.simple_expr(11)
		}

	case 8:
		{
			p.SetState(1361)
			p.Select_with_parens()
		}

	case 9:
		{
			p.SetState(1362)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1363)
			p.expr(0)
		}
		{
			p.SetState(1364)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		{
			p.SetState(1366)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1367)
			p.Expr_list()
		}
		{
			p.SetState(1368)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1369)
			p.expr(0)
		}
		{
			p.SetState(1370)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		{
			p.SetState(1372)
			p.Match(OBParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1373)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1374)
			p.Expr_list()
		}
		{
			p.SetState(1375)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1376)
			p.expr(0)
		}
		{
			p.SetState(1377)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		{
			p.SetState(1379)
			p.Match(OBParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1380)
			p.Select_with_parens()
		}

	case 13:
		{
			p.SetState(1381)
			p.Match(OBParserMATCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1382)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1383)
			p.Column_list()
		}
		{
			p.SetState(1384)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1385)
			p.Match(OBParserAGAINST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1386)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1387)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1395)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1388)
				p.Match(OBParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1389)
				p.Match(OBParserNATURAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1390)
				p.Match(OBParserLANGUAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1391)
				p.Match(OBParserMODE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1392)
				p.Match(OBParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1393)
				p.Match(OBParserBOOLEAN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1394)
				p.Match(OBParserMODE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1397)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		{
			p.SetState(1399)
			p.Case_expr()
		}

	case 15:
		{
			p.SetState(1400)
			p.Func_expr()
		}

	case 16:
		{
			p.SetState(1401)
			p.Window_function()
		}

	case 17:
		{
			p.SetState(1402)
			p.Match(OBParserUSER_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1410)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSimple_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_simple_expr)
				p.SetState(1405)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(1406)
					p.Match(OBParserCNNOP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1407)
					p.simple_expr(16)
				}

			case 2:
				localctx = NewSimple_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_simple_expr)
				p.SetState(1408)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(1409)
					p.Collation()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	Bool_pri() IBool_priContext
	IS() antlr.TerminalNode
	BOOL_VALUE() antlr.TerminalNode
	Not() INotContext
	UNKNOWN() antlr.TerminalNode
	USER_VARIABLE() antlr.TerminalNode
	SET_VAR() antlr.TerminalNode
	AND() antlr.TerminalNode
	AND_OP() antlr.TerminalNode
	OR() antlr.TerminalNode
	CNNOP() antlr.TerminalNode
	XOR() antlr.TerminalNode

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(OBParserNOT, 0)
}

func (s *ExprContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprContext) Bool_pri() IBool_priContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_priContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_priContext)
}

func (s *ExprContext) IS() antlr.TerminalNode {
	return s.GetToken(OBParserIS, 0)
}

func (s *ExprContext) BOOL_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserBOOL_VALUE, 0)
}

func (s *ExprContext) Not() INotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotContext)
}

func (s *ExprContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(OBParserUNKNOWN, 0)
}

func (s *ExprContext) USER_VARIABLE() antlr.TerminalNode {
	return s.GetToken(OBParserUSER_VARIABLE, 0)
}

func (s *ExprContext) SET_VAR() antlr.TerminalNode {
	return s.GetToken(OBParserSET_VAR, 0)
}

func (s *ExprContext) AND() antlr.TerminalNode {
	return s.GetToken(OBParserAND, 0)
}

func (s *ExprContext) AND_OP() antlr.TerminalNode {
	return s.GetToken(OBParserAND_OP, 0)
}

func (s *ExprContext) OR() antlr.TerminalNode {
	return s.GetToken(OBParserOR, 0)
}

func (s *ExprContext) CNNOP() antlr.TerminalNode {
	return s.GetToken(OBParserCNNOP, 0)
}

func (s *ExprContext) XOR() antlr.TerminalNode {
	return s.GetToken(OBParserXOR, 0)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *OBParser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 36
	p.EnterRecursionRule(localctx, 36, OBParserRULE_expr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1440)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1416)
			p.Match(OBParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1417)
			p.expr(7)
		}

	case 2:
		{
			p.SetState(1418)
			p.bool_pri(0)
		}
		{
			p.SetState(1419)
			p.Match(OBParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1420)
			p.Match(OBParserBOOL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(1422)
			p.bool_pri(0)
		}
		{
			p.SetState(1423)
			p.Match(OBParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1424)
			p.Not()
		}
		{
			p.SetState(1425)
			p.Match(OBParserBOOL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(1427)
			p.bool_pri(0)
		}
		{
			p.SetState(1428)
			p.Match(OBParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1429)
			p.Match(OBParserUNKNOWN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		{
			p.SetState(1431)
			p.bool_pri(0)
		}
		{
			p.SetState(1432)
			p.Match(OBParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1433)
			p.Not()
		}
		{
			p.SetState(1434)
			p.Match(OBParserUNKNOWN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		{
			p.SetState(1436)
			p.bool_pri(0)
		}

	case 7:
		{
			p.SetState(1437)
			p.Match(OBParserUSER_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1438)
			p.Match(OBParserSET_VAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1439)
			p.expr(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1457)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_expr)
				p.SetState(1442)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(1443)
					p.Match(OBParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1444)
					p.expr(13)
				}

			case 2:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_expr)
				p.SetState(1445)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(1446)
					p.Match(OBParserAND_OP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1447)
					p.expr(12)
				}

			case 3:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_expr)
				p.SetState(1448)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(1449)
					p.Match(OBParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1450)
					p.expr(11)
				}

			case 4:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_expr)
				p.SetState(1451)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(1452)
					p.Match(OBParserCNNOP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1453)
					p.expr(10)
				}

			case 5:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_expr)
				p.SetState(1454)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(1455)
					p.Match(OBParserXOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1456)
					p.expr(9)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1461)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INotContext is an interface to support dynamic dispatch.
type INotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT() antlr.TerminalNode

	// IsNotContext differentiates from other interfaces.
	IsNotContext()
}

type NotContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotContext() *NotContext {
	var p = new(NotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_not
	return p
}

func InitEmptyNotContext(p *NotContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_not
}

func (*NotContext) IsNotContext() {}

func NewNotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotContext {
	var p = new(NotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_not

	return p
}

func (s *NotContext) GetParser() antlr.Parser { return s.parser }

func (s *NotContext) NOT() antlr.TerminalNode {
	return s.GetToken(OBParserNOT, 0)
}

func (s *NotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterNot(s)
	}
}

func (s *NotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitNot(s)
	}
}

func (s *NotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitNot(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Not() (localctx INotContext) {
	localctx = NewNotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, OBParserRULE_not)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1462)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserNOT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INot2Context is an interface to support dynamic dispatch.
type INot2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Not() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsNot2Context differentiates from other interfaces.
	IsNot2Context()
}

type Not2Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNot2Context() *Not2Context {
	var p = new(Not2Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_not2
	return p
}

func InitEmptyNot2Context(p *Not2Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_not2
}

func (*Not2Context) IsNot2Context() {}

func NewNot2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Not2Context {
	var p = new(Not2Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_not2

	return p
}

func (s *Not2Context) GetParser() antlr.Parser { return s.parser }

func (s *Not2Context) Not() antlr.TerminalNode {
	return s.GetToken(OBParserNot, 0)
}

func (s *Not2Context) NOT() antlr.TerminalNode {
	return s.GetToken(OBParserNOT, 0)
}

func (s *Not2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Not2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Not2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterNot2(s)
	}
}

func (s *Not2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitNot2(s)
	}
}

func (s *Not2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitNot2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Not2() (localctx INot2Context) {
	localctx = NewNot2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, OBParserRULE_not2)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1464)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserNOT || _la == OBParserNot) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISub_query_flagContext is an interface to support dynamic dispatch.
type ISub_query_flagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	ANY() antlr.TerminalNode
	SOME() antlr.TerminalNode

	// IsSub_query_flagContext differentiates from other interfaces.
	IsSub_query_flagContext()
}

type Sub_query_flagContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySub_query_flagContext() *Sub_query_flagContext {
	var p = new(Sub_query_flagContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sub_query_flag
	return p
}

func InitEmptySub_query_flagContext(p *Sub_query_flagContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sub_query_flag
}

func (*Sub_query_flagContext) IsSub_query_flagContext() {}

func NewSub_query_flagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sub_query_flagContext {
	var p = new(Sub_query_flagContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_sub_query_flag

	return p
}

func (s *Sub_query_flagContext) GetParser() antlr.Parser { return s.parser }

func (s *Sub_query_flagContext) ALL() antlr.TerminalNode {
	return s.GetToken(OBParserALL, 0)
}

func (s *Sub_query_flagContext) ANY() antlr.TerminalNode {
	return s.GetToken(OBParserANY, 0)
}

func (s *Sub_query_flagContext) SOME() antlr.TerminalNode {
	return s.GetToken(OBParserSOME, 0)
}

func (s *Sub_query_flagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sub_query_flagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sub_query_flagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSub_query_flag(s)
	}
}

func (s *Sub_query_flagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSub_query_flag(s)
	}
}

func (s *Sub_query_flagContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSub_query_flag(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Sub_query_flag() (localctx ISub_query_flagContext) {
	localctx = NewSub_query_flagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, OBParserRULE_sub_query_flag)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1466)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserALL || _la == OBParserSOME || _la == OBParserANY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIn_exprContext is an interface to support dynamic dispatch.
type IIn_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_with_parens() ISelect_with_parensContext
	LeftParen() antlr.TerminalNode
	Expr_list() IExpr_listContext
	RightParen() antlr.TerminalNode

	// IsIn_exprContext differentiates from other interfaces.
	IsIn_exprContext()
}

type In_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIn_exprContext() *In_exprContext {
	var p = new(In_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_in_expr
	return p
}

func InitEmptyIn_exprContext(p *In_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_in_expr
}

func (*In_exprContext) IsIn_exprContext() {}

func NewIn_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *In_exprContext {
	var p = new(In_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_in_expr

	return p
}

func (s *In_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *In_exprContext) Select_with_parens() ISelect_with_parensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_with_parensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_with_parensContext)
}

func (s *In_exprContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *In_exprContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *In_exprContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *In_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *In_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *In_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterIn_expr(s)
	}
}

func (s *In_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitIn_expr(s)
	}
}

func (s *In_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitIn_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) In_expr() (localctx IIn_exprContext) {
	localctx = NewIn_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, OBParserRULE_in_expr)
	p.SetState(1473)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1468)
			p.Select_with_parens()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1469)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1470)
			p.Expr_list()
		}
		{
			p.SetState(1471)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICase_exprContext is an interface to support dynamic dispatch.
type ICase_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	Case_arg() ICase_argContext
	When_clause_list() IWhen_clause_listContext
	Case_default() ICase_defaultContext
	END() antlr.TerminalNode

	// IsCase_exprContext differentiates from other interfaces.
	IsCase_exprContext()
}

type Case_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_exprContext() *Case_exprContext {
	var p = new(Case_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_case_expr
	return p
}

func InitEmptyCase_exprContext(p *Case_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_case_expr
}

func (*Case_exprContext) IsCase_exprContext() {}

func NewCase_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_exprContext {
	var p = new(Case_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_case_expr

	return p
}

func (s *Case_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_exprContext) CASE() antlr.TerminalNode {
	return s.GetToken(OBParserCASE, 0)
}

func (s *Case_exprContext) Case_arg() ICase_argContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICase_argContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICase_argContext)
}

func (s *Case_exprContext) When_clause_list() IWhen_clause_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhen_clause_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhen_clause_listContext)
}

func (s *Case_exprContext) Case_default() ICase_defaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICase_defaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICase_defaultContext)
}

func (s *Case_exprContext) END() antlr.TerminalNode {
	return s.GetToken(OBParserEND, 0)
}

func (s *Case_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCase_expr(s)
	}
}

func (s *Case_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCase_expr(s)
	}
}

func (s *Case_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCase_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Case_expr() (localctx ICase_exprContext) {
	localctx = NewCase_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, OBParserRULE_case_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1475)
		p.Match(OBParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1476)
		p.Case_arg()
	}
	{
		p.SetState(1477)
		p.When_clause_list()
	}
	{
		p.SetState(1478)
		p.Case_default()
	}
	{
		p.SetState(1479)
		p.Match(OBParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindow_functionContext is an interface to support dynamic dispatch.
type IWindow_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COUNT() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Star() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	OVER() antlr.TerminalNode
	New_generalized_window_clause() INew_generalized_window_clauseContext
	ALL() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	DISTINCT() antlr.TerminalNode
	Expr_list() IExpr_listContext
	APPROX_COUNT_DISTINCT() antlr.TerminalNode
	APPROX_COUNT_DISTINCT_SYNOPSIS() antlr.TerminalNode
	APPROX_COUNT_DISTINCT_SYNOPSIS_MERGE() antlr.TerminalNode
	SUM() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	AVG() antlr.TerminalNode
	STDDEV() antlr.TerminalNode
	VARIANCE() antlr.TerminalNode
	STDDEV_POP() antlr.TerminalNode
	STDDEV_SAMP() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	Order_by() IOrder_byContext
	SEPARATOR() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	LISTAGG() antlr.TerminalNode
	RANK() antlr.TerminalNode
	DENSE_RANK() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	ROW_NUMBER() antlr.TerminalNode
	NTILE() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	FIRST_VALUE() antlr.TerminalNode
	Win_fun_first_last_params() IWin_fun_first_last_paramsContext
	LAST_VALUE() antlr.TerminalNode
	LEAD() antlr.TerminalNode
	Win_fun_lead_lag_params() IWin_fun_lead_lag_paramsContext
	LAG() antlr.TerminalNode
	NTH_VALUE() antlr.TerminalNode
	Comma() antlr.TerminalNode
	FROM() antlr.TerminalNode
	First_or_last() IFirst_or_lastContext
	Respect_or_ignore() IRespect_or_ignoreContext
	NULLS() antlr.TerminalNode

	// IsWindow_functionContext differentiates from other interfaces.
	IsWindow_functionContext()
}

type Window_functionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_functionContext() *Window_functionContext {
	var p = new(Window_functionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_window_function
	return p
}

func InitEmptyWindow_functionContext(p *Window_functionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_window_function
}

func (*Window_functionContext) IsWindow_functionContext() {}

func NewWindow_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_functionContext {
	var p = new(Window_functionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_window_function

	return p
}

func (s *Window_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_functionContext) COUNT() antlr.TerminalNode {
	return s.GetToken(OBParserCOUNT, 0)
}

func (s *Window_functionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Window_functionContext) Star() antlr.TerminalNode {
	return s.GetToken(OBParserStar, 0)
}

func (s *Window_functionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Window_functionContext) OVER() antlr.TerminalNode {
	return s.GetToken(OBParserOVER, 0)
}

func (s *Window_functionContext) New_generalized_window_clause() INew_generalized_window_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INew_generalized_window_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INew_generalized_window_clauseContext)
}

func (s *Window_functionContext) ALL() antlr.TerminalNode {
	return s.GetToken(OBParserALL, 0)
}

func (s *Window_functionContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Window_functionContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Window_functionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(OBParserDISTINCT, 0)
}

func (s *Window_functionContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Window_functionContext) APPROX_COUNT_DISTINCT() antlr.TerminalNode {
	return s.GetToken(OBParserAPPROX_COUNT_DISTINCT, 0)
}

func (s *Window_functionContext) APPROX_COUNT_DISTINCT_SYNOPSIS() antlr.TerminalNode {
	return s.GetToken(OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, 0)
}

func (s *Window_functionContext) APPROX_COUNT_DISTINCT_SYNOPSIS_MERGE() antlr.TerminalNode {
	return s.GetToken(OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, 0)
}

func (s *Window_functionContext) SUM() antlr.TerminalNode {
	return s.GetToken(OBParserSUM, 0)
}

func (s *Window_functionContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(OBParserUNIQUE, 0)
}

func (s *Window_functionContext) MAX() antlr.TerminalNode {
	return s.GetToken(OBParserMAX, 0)
}

func (s *Window_functionContext) MIN() antlr.TerminalNode {
	return s.GetToken(OBParserMIN, 0)
}

func (s *Window_functionContext) AVG() antlr.TerminalNode {
	return s.GetToken(OBParserAVG, 0)
}

func (s *Window_functionContext) STDDEV() antlr.TerminalNode {
	return s.GetToken(OBParserSTDDEV, 0)
}

func (s *Window_functionContext) VARIANCE() antlr.TerminalNode {
	return s.GetToken(OBParserVARIANCE, 0)
}

func (s *Window_functionContext) STDDEV_POP() antlr.TerminalNode {
	return s.GetToken(OBParserSTDDEV_POP, 0)
}

func (s *Window_functionContext) STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(OBParserSTDDEV_SAMP, 0)
}

func (s *Window_functionContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(OBParserGROUP_CONCAT, 0)
}

func (s *Window_functionContext) Order_by() IOrder_byContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_byContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_byContext)
}

func (s *Window_functionContext) SEPARATOR() antlr.TerminalNode {
	return s.GetToken(OBParserSEPARATOR, 0)
}

func (s *Window_functionContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Window_functionContext) LISTAGG() antlr.TerminalNode {
	return s.GetToken(OBParserLISTAGG, 0)
}

func (s *Window_functionContext) RANK() antlr.TerminalNode {
	return s.GetToken(OBParserRANK, 0)
}

func (s *Window_functionContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(OBParserDENSE_RANK, 0)
}

func (s *Window_functionContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(OBParserPERCENT_RANK, 0)
}

func (s *Window_functionContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(OBParserROW_NUMBER, 0)
}

func (s *Window_functionContext) NTILE() antlr.TerminalNode {
	return s.GetToken(OBParserNTILE, 0)
}

func (s *Window_functionContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(OBParserCUME_DIST, 0)
}

func (s *Window_functionContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserFIRST_VALUE, 0)
}

func (s *Window_functionContext) Win_fun_first_last_params() IWin_fun_first_last_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWin_fun_first_last_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWin_fun_first_last_paramsContext)
}

func (s *Window_functionContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserLAST_VALUE, 0)
}

func (s *Window_functionContext) LEAD() antlr.TerminalNode {
	return s.GetToken(OBParserLEAD, 0)
}

func (s *Window_functionContext) Win_fun_lead_lag_params() IWin_fun_lead_lag_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWin_fun_lead_lag_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWin_fun_lead_lag_paramsContext)
}

func (s *Window_functionContext) LAG() antlr.TerminalNode {
	return s.GetToken(OBParserLAG, 0)
}

func (s *Window_functionContext) NTH_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserNTH_VALUE, 0)
}

func (s *Window_functionContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Window_functionContext) FROM() antlr.TerminalNode {
	return s.GetToken(OBParserFROM, 0)
}

func (s *Window_functionContext) First_or_last() IFirst_or_lastContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFirst_or_lastContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFirst_or_lastContext)
}

func (s *Window_functionContext) Respect_or_ignore() IRespect_or_ignoreContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRespect_or_ignoreContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRespect_or_ignoreContext)
}

func (s *Window_functionContext) NULLS() antlr.TerminalNode {
	return s.GetToken(OBParserNULLS, 0)
}

func (s *Window_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterWindow_function(s)
	}
}

func (s *Window_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitWindow_function(s)
	}
}

func (s *Window_functionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitWindow_function(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Window_function() (localctx IWindow_functionContext) {
	localctx = NewWindow_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, OBParserRULE_window_function)
	var _la int

	p.SetState(1713)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1481)
			p.Match(OBParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1482)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1484)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL {
			{
				p.SetState(1483)
				p.Match(OBParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1486)
			p.Match(OBParserStar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1487)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1488)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1489)
			p.New_generalized_window_clause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1490)
			p.Match(OBParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1491)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1493)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL {
			{
				p.SetState(1492)
				p.Match(OBParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1495)
			p.expr(0)
		}
		{
			p.SetState(1496)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1497)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1498)
			p.New_generalized_window_clause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1500)
			p.Match(OBParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1501)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1502)
			p.Match(OBParserDISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1503)
			p.Expr_list()
		}
		{
			p.SetState(1504)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1505)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1506)
			p.New_generalized_window_clause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1508)
			p.Match(OBParserAPPROX_COUNT_DISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1509)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1510)
			p.Expr_list()
		}
		{
			p.SetState(1511)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1512)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1513)
			p.New_generalized_window_clause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1515)
			p.Match(OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1516)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1517)
			p.Expr_list()
		}
		{
			p.SetState(1518)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1519)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1520)
			p.New_generalized_window_clause()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1522)
			p.Match(OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1523)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1524)
			p.expr(0)
		}
		{
			p.SetState(1525)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1526)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1527)
			p.New_generalized_window_clause()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1529)
			p.Match(OBParserSUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1530)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1532)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1531)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1534)
			p.expr(0)
		}
		{
			p.SetState(1535)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1536)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1537)
			p.New_generalized_window_clause()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1539)
			p.Match(OBParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1540)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1541)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1544)
			p.expr(0)
		}
		{
			p.SetState(1545)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1546)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1547)
			p.New_generalized_window_clause()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1549)
			p.Match(OBParserMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1550)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1551)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1554)
			p.expr(0)
		}
		{
			p.SetState(1555)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1556)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1557)
			p.New_generalized_window_clause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1559)
			p.Match(OBParserAVG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1560)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1562)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1561)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1564)
			p.expr(0)
		}
		{
			p.SetState(1565)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1566)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1567)
			p.New_generalized_window_clause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1569)
			p.Match(OBParserSTDDEV)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1570)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1572)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1571)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1574)
			p.expr(0)
		}
		{
			p.SetState(1575)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1576)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1577)
			p.New_generalized_window_clause()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1579)
			p.Match(OBParserVARIANCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1580)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1581)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1584)
			p.expr(0)
		}
		{
			p.SetState(1585)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1586)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1587)
			p.New_generalized_window_clause()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1589)
			p.Match(OBParserSTDDEV_POP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1590)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1592)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1591)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1594)
			p.expr(0)
		}
		{
			p.SetState(1595)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1596)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1597)
			p.New_generalized_window_clause()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1599)
			p.Match(OBParserSTDDEV_SAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1600)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1602)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1601)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1604)
			p.expr(0)
		}
		{
			p.SetState(1605)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1606)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1607)
			p.New_generalized_window_clause()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1609)
			p.Match(OBParserGROUP_CONCAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1610)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1612)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1611)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1614)
			p.Expr_list()
		}
		p.SetState(1616)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserORDER {
			{
				p.SetState(1615)
				p.Order_by()
			}

		}
		p.SetState(1620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSEPARATOR {
			{
				p.SetState(1618)
				p.Match(OBParserSEPARATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1619)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1622)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1623)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1624)
			p.New_generalized_window_clause()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1626)
			p.Match(OBParserLISTAGG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1627)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1629)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1628)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1631)
			p.Expr_list()
		}
		p.SetState(1633)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserORDER {
			{
				p.SetState(1632)
				p.Order_by()
			}

		}
		p.SetState(1637)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSEPARATOR {
			{
				p.SetState(1635)
				p.Match(OBParserSEPARATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1636)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1639)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1640)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1641)
			p.New_generalized_window_clause()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1643)
			p.Match(OBParserRANK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1644)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1645)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1646)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1647)
			p.New_generalized_window_clause()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1648)
			p.Match(OBParserDENSE_RANK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1649)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1650)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1651)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1652)
			p.New_generalized_window_clause()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1653)
			p.Match(OBParserPERCENT_RANK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1654)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1655)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1656)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1657)
			p.New_generalized_window_clause()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1658)
			p.Match(OBParserROW_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1659)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1660)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1661)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1662)
			p.New_generalized_window_clause()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1663)
			p.Match(OBParserNTILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1664)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1665)
			p.expr(0)
		}
		{
			p.SetState(1666)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1667)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1668)
			p.New_generalized_window_clause()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1670)
			p.Match(OBParserCUME_DIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1671)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1672)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1673)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1674)
			p.New_generalized_window_clause()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1675)
			p.Match(OBParserFIRST_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1676)
			p.Win_fun_first_last_params()
		}
		{
			p.SetState(1677)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1678)
			p.New_generalized_window_clause()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1680)
			p.Match(OBParserLAST_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1681)
			p.Win_fun_first_last_params()
		}
		{
			p.SetState(1682)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1683)
			p.New_generalized_window_clause()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1685)
			p.Match(OBParserLEAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1686)
			p.Win_fun_lead_lag_params()
		}
		{
			p.SetState(1687)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1688)
			p.New_generalized_window_clause()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1690)
			p.Match(OBParserLAG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1691)
			p.Win_fun_lead_lag_params()
		}
		{
			p.SetState(1692)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1693)
			p.New_generalized_window_clause()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1695)
			p.Match(OBParserNTH_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1696)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1697)
			p.expr(0)
		}
		{
			p.SetState(1698)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1699)
			p.expr(0)
		}
		{
			p.SetState(1700)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFROM {
			{
				p.SetState(1701)
				p.Match(OBParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1702)
				p.First_or_last()
			}

		}
		p.SetState(1708)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIGNORE || _la == OBParserRESPECT {
			{
				p.SetState(1705)
				p.Respect_or_ignore()
			}
			{
				p.SetState(1706)
				p.Match(OBParserNULLS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1710)
			p.Match(OBParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1711)
			p.New_generalized_window_clause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFirst_or_lastContext is an interface to support dynamic dispatch.
type IFirst_or_lastContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode

	// IsFirst_or_lastContext differentiates from other interfaces.
	IsFirst_or_lastContext()
}

type First_or_lastContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFirst_or_lastContext() *First_or_lastContext {
	var p = new(First_or_lastContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_first_or_last
	return p
}

func InitEmptyFirst_or_lastContext(p *First_or_lastContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_first_or_last
}

func (*First_or_lastContext) IsFirst_or_lastContext() {}

func NewFirst_or_lastContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *First_or_lastContext {
	var p = new(First_or_lastContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_first_or_last

	return p
}

func (s *First_or_lastContext) GetParser() antlr.Parser { return s.parser }

func (s *First_or_lastContext) FIRST() antlr.TerminalNode {
	return s.GetToken(OBParserFIRST, 0)
}

func (s *First_or_lastContext) LAST() antlr.TerminalNode {
	return s.GetToken(OBParserLAST, 0)
}

func (s *First_or_lastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *First_or_lastContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *First_or_lastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterFirst_or_last(s)
	}
}

func (s *First_or_lastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitFirst_or_last(s)
	}
}

func (s *First_or_lastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitFirst_or_last(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) First_or_last() (localctx IFirst_or_lastContext) {
	localctx = NewFirst_or_lastContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, OBParserRULE_first_or_last)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1715)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserFIRST || _la == OBParserLAST) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRespect_or_ignoreContext is an interface to support dynamic dispatch.
type IRespect_or_ignoreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESPECT() antlr.TerminalNode
	IGNORE() antlr.TerminalNode

	// IsRespect_or_ignoreContext differentiates from other interfaces.
	IsRespect_or_ignoreContext()
}

type Respect_or_ignoreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRespect_or_ignoreContext() *Respect_or_ignoreContext {
	var p = new(Respect_or_ignoreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_respect_or_ignore
	return p
}

func InitEmptyRespect_or_ignoreContext(p *Respect_or_ignoreContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_respect_or_ignore
}

func (*Respect_or_ignoreContext) IsRespect_or_ignoreContext() {}

func NewRespect_or_ignoreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Respect_or_ignoreContext {
	var p = new(Respect_or_ignoreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_respect_or_ignore

	return p
}

func (s *Respect_or_ignoreContext) GetParser() antlr.Parser { return s.parser }

func (s *Respect_or_ignoreContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(OBParserRESPECT, 0)
}

func (s *Respect_or_ignoreContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(OBParserIGNORE, 0)
}

func (s *Respect_or_ignoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Respect_or_ignoreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Respect_or_ignoreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRespect_or_ignore(s)
	}
}

func (s *Respect_or_ignoreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRespect_or_ignore(s)
	}
}

func (s *Respect_or_ignoreContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRespect_or_ignore(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Respect_or_ignore() (localctx IRespect_or_ignoreContext) {
	localctx = NewRespect_or_ignoreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, OBParserRULE_respect_or_ignore)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1717)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserIGNORE || _la == OBParserRESPECT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWin_fun_first_last_paramsContext is an interface to support dynamic dispatch.
type IWin_fun_first_last_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	Expr() IExprContext
	Respect_or_ignore() IRespect_or_ignoreContext
	NULLS() antlr.TerminalNode
	RightParen() antlr.TerminalNode

	// IsWin_fun_first_last_paramsContext differentiates from other interfaces.
	IsWin_fun_first_last_paramsContext()
}

type Win_fun_first_last_paramsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWin_fun_first_last_paramsContext() *Win_fun_first_last_paramsContext {
	var p = new(Win_fun_first_last_paramsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_win_fun_first_last_params
	return p
}

func InitEmptyWin_fun_first_last_paramsContext(p *Win_fun_first_last_paramsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_win_fun_first_last_params
}

func (*Win_fun_first_last_paramsContext) IsWin_fun_first_last_paramsContext() {}

func NewWin_fun_first_last_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Win_fun_first_last_paramsContext {
	var p = new(Win_fun_first_last_paramsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_win_fun_first_last_params

	return p
}

func (s *Win_fun_first_last_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Win_fun_first_last_paramsContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Win_fun_first_last_paramsContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Win_fun_first_last_paramsContext) Respect_or_ignore() IRespect_or_ignoreContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRespect_or_ignoreContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRespect_or_ignoreContext)
}

func (s *Win_fun_first_last_paramsContext) NULLS() antlr.TerminalNode {
	return s.GetToken(OBParserNULLS, 0)
}

func (s *Win_fun_first_last_paramsContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Win_fun_first_last_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Win_fun_first_last_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Win_fun_first_last_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterWin_fun_first_last_params(s)
	}
}

func (s *Win_fun_first_last_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitWin_fun_first_last_params(s)
	}
}

func (s *Win_fun_first_last_paramsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitWin_fun_first_last_params(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Win_fun_first_last_params() (localctx IWin_fun_first_last_paramsContext) {
	localctx = NewWin_fun_first_last_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, OBParserRULE_win_fun_first_last_params)
	var _la int

	p.SetState(1733)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1719)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1720)
			p.expr(0)
		}
		{
			p.SetState(1721)
			p.Respect_or_ignore()
		}
		{
			p.SetState(1722)
			p.Match(OBParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1723)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1725)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1726)
			p.expr(0)
		}
		{
			p.SetState(1727)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1731)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIGNORE || _la == OBParserRESPECT {
			{
				p.SetState(1728)
				p.Respect_or_ignore()
			}
			{
				p.SetState(1729)
				p.Match(OBParserNULLS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWin_fun_lead_lag_paramsContext is an interface to support dynamic dispatch.
type IWin_fun_lead_lag_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	Expr() IExprContext
	Respect_or_ignore() IRespect_or_ignoreContext
	NULLS() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	Comma() antlr.TerminalNode
	Expr_list() IExpr_listContext

	// IsWin_fun_lead_lag_paramsContext differentiates from other interfaces.
	IsWin_fun_lead_lag_paramsContext()
}

type Win_fun_lead_lag_paramsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWin_fun_lead_lag_paramsContext() *Win_fun_lead_lag_paramsContext {
	var p = new(Win_fun_lead_lag_paramsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_win_fun_lead_lag_params
	return p
}

func InitEmptyWin_fun_lead_lag_paramsContext(p *Win_fun_lead_lag_paramsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_win_fun_lead_lag_params
}

func (*Win_fun_lead_lag_paramsContext) IsWin_fun_lead_lag_paramsContext() {}

func NewWin_fun_lead_lag_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Win_fun_lead_lag_paramsContext {
	var p = new(Win_fun_lead_lag_paramsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_win_fun_lead_lag_params

	return p
}

func (s *Win_fun_lead_lag_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Win_fun_lead_lag_paramsContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Win_fun_lead_lag_paramsContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Win_fun_lead_lag_paramsContext) Respect_or_ignore() IRespect_or_ignoreContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRespect_or_ignoreContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRespect_or_ignoreContext)
}

func (s *Win_fun_lead_lag_paramsContext) NULLS() antlr.TerminalNode {
	return s.GetToken(OBParserNULLS, 0)
}

func (s *Win_fun_lead_lag_paramsContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Win_fun_lead_lag_paramsContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Win_fun_lead_lag_paramsContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Win_fun_lead_lag_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Win_fun_lead_lag_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Win_fun_lead_lag_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterWin_fun_lead_lag_params(s)
	}
}

func (s *Win_fun_lead_lag_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitWin_fun_lead_lag_params(s)
	}
}

func (s *Win_fun_lead_lag_paramsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitWin_fun_lead_lag_params(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Win_fun_lead_lag_params() (localctx IWin_fun_lead_lag_paramsContext) {
	localctx = NewWin_fun_lead_lag_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, OBParserRULE_win_fun_lead_lag_params)
	var _la int

	p.SetState(1757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1735)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1736)
			p.expr(0)
		}
		{
			p.SetState(1737)
			p.Respect_or_ignore()
		}
		{
			p.SetState(1738)
			p.Match(OBParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1739)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1741)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1742)
			p.expr(0)
		}
		{
			p.SetState(1743)
			p.Respect_or_ignore()
		}
		{
			p.SetState(1744)
			p.Match(OBParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1745)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1746)
			p.Expr_list()
		}
		{
			p.SetState(1747)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1749)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1750)
			p.Expr_list()
		}
		{
			p.SetState(1751)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1755)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIGNORE || _la == OBParserRESPECT {
			{
				p.SetState(1752)
				p.Respect_or_ignore()
			}
			{
				p.SetState(1753)
				p.Match(OBParserNULLS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INew_generalized_window_clauseContext is an interface to support dynamic dispatch.
type INew_generalized_window_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME_OB() antlr.TerminalNode
	New_generalized_window_clause_with_blanket() INew_generalized_window_clause_with_blanketContext

	// IsNew_generalized_window_clauseContext differentiates from other interfaces.
	IsNew_generalized_window_clauseContext()
}

type New_generalized_window_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNew_generalized_window_clauseContext() *New_generalized_window_clauseContext {
	var p = new(New_generalized_window_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_new_generalized_window_clause
	return p
}

func InitEmptyNew_generalized_window_clauseContext(p *New_generalized_window_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_new_generalized_window_clause
}

func (*New_generalized_window_clauseContext) IsNew_generalized_window_clauseContext() {}

func NewNew_generalized_window_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *New_generalized_window_clauseContext {
	var p = new(New_generalized_window_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_new_generalized_window_clause

	return p
}

func (s *New_generalized_window_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *New_generalized_window_clauseContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *New_generalized_window_clauseContext) New_generalized_window_clause_with_blanket() INew_generalized_window_clause_with_blanketContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INew_generalized_window_clause_with_blanketContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INew_generalized_window_clause_with_blanketContext)
}

func (s *New_generalized_window_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *New_generalized_window_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *New_generalized_window_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterNew_generalized_window_clause(s)
	}
}

func (s *New_generalized_window_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitNew_generalized_window_clause(s)
	}
}

func (s *New_generalized_window_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitNew_generalized_window_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) New_generalized_window_clause() (localctx INew_generalized_window_clauseContext) {
	localctx = NewNew_generalized_window_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, OBParserRULE_new_generalized_window_clause)
	p.SetState(1761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserNAME_OB:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1759)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserLeftParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1760)
			p.New_generalized_window_clause_with_blanket()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INew_generalized_window_clause_with_blanketContext is an interface to support dynamic dispatch.
type INew_generalized_window_clause_with_blanketContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	NAME_OB() antlr.TerminalNode
	Generalized_window_clause() IGeneralized_window_clauseContext
	RightParen() antlr.TerminalNode

	// IsNew_generalized_window_clause_with_blanketContext differentiates from other interfaces.
	IsNew_generalized_window_clause_with_blanketContext()
}

type New_generalized_window_clause_with_blanketContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNew_generalized_window_clause_with_blanketContext() *New_generalized_window_clause_with_blanketContext {
	var p = new(New_generalized_window_clause_with_blanketContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_new_generalized_window_clause_with_blanket
	return p
}

func InitEmptyNew_generalized_window_clause_with_blanketContext(p *New_generalized_window_clause_with_blanketContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_new_generalized_window_clause_with_blanket
}

func (*New_generalized_window_clause_with_blanketContext) IsNew_generalized_window_clause_with_blanketContext() {
}

func NewNew_generalized_window_clause_with_blanketContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *New_generalized_window_clause_with_blanketContext {
	var p = new(New_generalized_window_clause_with_blanketContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_new_generalized_window_clause_with_blanket

	return p
}

func (s *New_generalized_window_clause_with_blanketContext) GetParser() antlr.Parser { return s.parser }

func (s *New_generalized_window_clause_with_blanketContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *New_generalized_window_clause_with_blanketContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *New_generalized_window_clause_with_blanketContext) Generalized_window_clause() IGeneralized_window_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralized_window_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralized_window_clauseContext)
}

func (s *New_generalized_window_clause_with_blanketContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *New_generalized_window_clause_with_blanketContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *New_generalized_window_clause_with_blanketContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *New_generalized_window_clause_with_blanketContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterNew_generalized_window_clause_with_blanket(s)
	}
}

func (s *New_generalized_window_clause_with_blanketContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitNew_generalized_window_clause_with_blanket(s)
	}
}

func (s *New_generalized_window_clause_with_blanketContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitNew_generalized_window_clause_with_blanket(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) New_generalized_window_clause_with_blanket() (localctx INew_generalized_window_clause_with_blanketContext) {
	localctx = NewNew_generalized_window_clause_with_blanketContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, OBParserRULE_new_generalized_window_clause_with_blanket)
	p.SetState(1772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1763)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1764)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1765)
			p.Generalized_window_clause()
		}
		{
			p.SetState(1766)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1768)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1769)
			p.Generalized_window_clause()
		}
		{
			p.SetState(1770)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamed_windowsContext is an interface to support dynamic dispatch.
type INamed_windowsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamed_window() []INamed_windowContext
	Named_window(i int) INamed_windowContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsNamed_windowsContext differentiates from other interfaces.
	IsNamed_windowsContext()
}

type Named_windowsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_windowsContext() *Named_windowsContext {
	var p = new(Named_windowsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_named_windows
	return p
}

func InitEmptyNamed_windowsContext(p *Named_windowsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_named_windows
}

func (*Named_windowsContext) IsNamed_windowsContext() {}

func NewNamed_windowsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_windowsContext {
	var p = new(Named_windowsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_named_windows

	return p
}

func (s *Named_windowsContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_windowsContext) AllNamed_window() []INamed_windowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamed_windowContext); ok {
			len++
		}
	}

	tst := make([]INamed_windowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamed_windowContext); ok {
			tst[i] = t.(INamed_windowContext)
			i++
		}
	}

	return tst
}

func (s *Named_windowsContext) Named_window(i int) INamed_windowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_windowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_windowContext)
}

func (s *Named_windowsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Named_windowsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Named_windowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_windowsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_windowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterNamed_windows(s)
	}
}

func (s *Named_windowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitNamed_windows(s)
	}
}

func (s *Named_windowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitNamed_windows(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Named_windows() (localctx INamed_windowsContext) {
	localctx = NewNamed_windowsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, OBParserRULE_named_windows)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1774)
		p.Named_window()
	}
	p.SetState(1779)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1775)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1776)
				p.Named_window()
			}

		}
		p.SetState(1781)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamed_windowContext is an interface to support dynamic dispatch.
type INamed_windowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME_OB() antlr.TerminalNode
	AS() antlr.TerminalNode
	New_generalized_window_clause_with_blanket() INew_generalized_window_clause_with_blanketContext

	// IsNamed_windowContext differentiates from other interfaces.
	IsNamed_windowContext()
}

type Named_windowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_windowContext() *Named_windowContext {
	var p = new(Named_windowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_named_window
	return p
}

func InitEmptyNamed_windowContext(p *Named_windowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_named_window
}

func (*Named_windowContext) IsNamed_windowContext() {}

func NewNamed_windowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_windowContext {
	var p = new(Named_windowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_named_window

	return p
}

func (s *Named_windowContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_windowContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Named_windowContext) AS() antlr.TerminalNode {
	return s.GetToken(OBParserAS, 0)
}

func (s *Named_windowContext) New_generalized_window_clause_with_blanket() INew_generalized_window_clause_with_blanketContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INew_generalized_window_clause_with_blanketContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INew_generalized_window_clause_with_blanketContext)
}

func (s *Named_windowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_windowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_windowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterNamed_window(s)
	}
}

func (s *Named_windowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitNamed_window(s)
	}
}

func (s *Named_windowContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitNamed_window(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Named_window() (localctx INamed_windowContext) {
	localctx = NewNamed_windowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, OBParserRULE_named_window)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1782)
		p.Match(OBParserNAME_OB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1783)
		p.Match(OBParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1784)
		p.New_generalized_window_clause_with_blanket()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneralized_window_clauseContext is an interface to support dynamic dispatch.
type IGeneralized_window_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	Expr_list() IExpr_listContext
	Order_by() IOrder_byContext
	Win_window() IWin_windowContext

	// IsGeneralized_window_clauseContext differentiates from other interfaces.
	IsGeneralized_window_clauseContext()
}

type Generalized_window_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralized_window_clauseContext() *Generalized_window_clauseContext {
	var p = new(Generalized_window_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_generalized_window_clause
	return p
}

func InitEmptyGeneralized_window_clauseContext(p *Generalized_window_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_generalized_window_clause
}

func (*Generalized_window_clauseContext) IsGeneralized_window_clauseContext() {}

func NewGeneralized_window_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generalized_window_clauseContext {
	var p = new(Generalized_window_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_generalized_window_clause

	return p
}

func (s *Generalized_window_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Generalized_window_clauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *Generalized_window_clauseContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Generalized_window_clauseContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Generalized_window_clauseContext) Order_by() IOrder_byContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_byContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_byContext)
}

func (s *Generalized_window_clauseContext) Win_window() IWin_windowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWin_windowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWin_windowContext)
}

func (s *Generalized_window_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generalized_window_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generalized_window_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterGeneralized_window_clause(s)
	}
}

func (s *Generalized_window_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitGeneralized_window_clause(s)
	}
}

func (s *Generalized_window_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitGeneralized_window_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Generalized_window_clause() (localctx IGeneralized_window_clauseContext) {
	localctx = NewGeneralized_window_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, OBParserRULE_generalized_window_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1789)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserPARTITION {
		{
			p.SetState(1786)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1787)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1788)
			p.Expr_list()
		}

	}
	p.SetState(1792)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserORDER {
		{
			p.SetState(1791)
			p.Order_by()
		}

	}
	p.SetState(1795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserRANGE || _la == OBParserROWS {
		{
			p.SetState(1794)
			p.Win_window()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWin_rows_or_rangeContext is an interface to support dynamic dispatch.
type IWin_rows_or_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS() antlr.TerminalNode
	RANGE() antlr.TerminalNode

	// IsWin_rows_or_rangeContext differentiates from other interfaces.
	IsWin_rows_or_rangeContext()
}

type Win_rows_or_rangeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWin_rows_or_rangeContext() *Win_rows_or_rangeContext {
	var p = new(Win_rows_or_rangeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_win_rows_or_range
	return p
}

func InitEmptyWin_rows_or_rangeContext(p *Win_rows_or_rangeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_win_rows_or_range
}

func (*Win_rows_or_rangeContext) IsWin_rows_or_rangeContext() {}

func NewWin_rows_or_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Win_rows_or_rangeContext {
	var p = new(Win_rows_or_rangeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_win_rows_or_range

	return p
}

func (s *Win_rows_or_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Win_rows_or_rangeContext) ROWS() antlr.TerminalNode {
	return s.GetToken(OBParserROWS, 0)
}

func (s *Win_rows_or_rangeContext) RANGE() antlr.TerminalNode {
	return s.GetToken(OBParserRANGE, 0)
}

func (s *Win_rows_or_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Win_rows_or_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Win_rows_or_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterWin_rows_or_range(s)
	}
}

func (s *Win_rows_or_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitWin_rows_or_range(s)
	}
}

func (s *Win_rows_or_rangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitWin_rows_or_range(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Win_rows_or_range() (localctx IWin_rows_or_rangeContext) {
	localctx = NewWin_rows_or_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, OBParserRULE_win_rows_or_range)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1797)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserRANGE || _la == OBParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWin_preceding_or_followingContext is an interface to support dynamic dispatch.
type IWin_preceding_or_followingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRECEDING() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode

	// IsWin_preceding_or_followingContext differentiates from other interfaces.
	IsWin_preceding_or_followingContext()
}

type Win_preceding_or_followingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWin_preceding_or_followingContext() *Win_preceding_or_followingContext {
	var p = new(Win_preceding_or_followingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_win_preceding_or_following
	return p
}

func InitEmptyWin_preceding_or_followingContext(p *Win_preceding_or_followingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_win_preceding_or_following
}

func (*Win_preceding_or_followingContext) IsWin_preceding_or_followingContext() {}

func NewWin_preceding_or_followingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Win_preceding_or_followingContext {
	var p = new(Win_preceding_or_followingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_win_preceding_or_following

	return p
}

func (s *Win_preceding_or_followingContext) GetParser() antlr.Parser { return s.parser }

func (s *Win_preceding_or_followingContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(OBParserPRECEDING, 0)
}

func (s *Win_preceding_or_followingContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(OBParserFOLLOWING, 0)
}

func (s *Win_preceding_or_followingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Win_preceding_or_followingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Win_preceding_or_followingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterWin_preceding_or_following(s)
	}
}

func (s *Win_preceding_or_followingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitWin_preceding_or_following(s)
	}
}

func (s *Win_preceding_or_followingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitWin_preceding_or_following(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Win_preceding_or_following() (localctx IWin_preceding_or_followingContext) {
	localctx = NewWin_preceding_or_followingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, OBParserRULE_win_preceding_or_following)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1799)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserFOLLOWING || _la == OBParserPRECEDING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWin_intervalContext is an interface to support dynamic dispatch.
type IWin_intervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	INTERVAL() antlr.TerminalNode
	Date_unit() IDate_unitContext

	// IsWin_intervalContext differentiates from other interfaces.
	IsWin_intervalContext()
}

type Win_intervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWin_intervalContext() *Win_intervalContext {
	var p = new(Win_intervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_win_interval
	return p
}

func InitEmptyWin_intervalContext(p *Win_intervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_win_interval
}

func (*Win_intervalContext) IsWin_intervalContext() {}

func NewWin_intervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Win_intervalContext {
	var p = new(Win_intervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_win_interval

	return p
}

func (s *Win_intervalContext) GetParser() antlr.Parser { return s.parser }

func (s *Win_intervalContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Win_intervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(OBParserINTERVAL, 0)
}

func (s *Win_intervalContext) Date_unit() IDate_unitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDate_unitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDate_unitContext)
}

func (s *Win_intervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Win_intervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Win_intervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterWin_interval(s)
	}
}

func (s *Win_intervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitWin_interval(s)
	}
}

func (s *Win_intervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitWin_interval(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Win_interval() (localctx IWin_intervalContext) {
	localctx = NewWin_intervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, OBParserRULE_win_interval)
	p.SetState(1806)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1801)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1802)
			p.Match(OBParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1803)
			p.expr(0)
		}
		{
			p.SetState(1804)
			p.Date_unit()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWin_boundingContext is an interface to support dynamic dispatch.
type IWin_boundingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT() antlr.TerminalNode
	ROW() antlr.TerminalNode
	Win_interval() IWin_intervalContext
	Win_preceding_or_following() IWin_preceding_or_followingContext

	// IsWin_boundingContext differentiates from other interfaces.
	IsWin_boundingContext()
}

type Win_boundingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWin_boundingContext() *Win_boundingContext {
	var p = new(Win_boundingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_win_bounding
	return p
}

func InitEmptyWin_boundingContext(p *Win_boundingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_win_bounding
}

func (*Win_boundingContext) IsWin_boundingContext() {}

func NewWin_boundingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Win_boundingContext {
	var p = new(Win_boundingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_win_bounding

	return p
}

func (s *Win_boundingContext) GetParser() antlr.Parser { return s.parser }

func (s *Win_boundingContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(OBParserCURRENT, 0)
}

func (s *Win_boundingContext) ROW() antlr.TerminalNode {
	return s.GetToken(OBParserROW, 0)
}

func (s *Win_boundingContext) Win_interval() IWin_intervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWin_intervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWin_intervalContext)
}

func (s *Win_boundingContext) Win_preceding_or_following() IWin_preceding_or_followingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWin_preceding_or_followingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWin_preceding_or_followingContext)
}

func (s *Win_boundingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Win_boundingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Win_boundingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterWin_bounding(s)
	}
}

func (s *Win_boundingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitWin_bounding(s)
	}
}

func (s *Win_boundingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitWin_bounding(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Win_bounding() (localctx IWin_boundingContext) {
	localctx = NewWin_boundingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, OBParserRULE_win_bounding)
	p.SetState(1813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1808)
			p.Match(OBParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1809)
			p.Match(OBParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1810)
			p.Win_interval()
		}
		{
			p.SetState(1811)
			p.Win_preceding_or_following()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWin_windowContext is an interface to support dynamic dispatch.
type IWin_windowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Win_rows_or_range() IWin_rows_or_rangeContext
	BETWEEN() antlr.TerminalNode
	AllWin_bounding() []IWin_boundingContext
	Win_bounding(i int) IWin_boundingContext
	AND() antlr.TerminalNode

	// IsWin_windowContext differentiates from other interfaces.
	IsWin_windowContext()
}

type Win_windowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWin_windowContext() *Win_windowContext {
	var p = new(Win_windowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_win_window
	return p
}

func InitEmptyWin_windowContext(p *Win_windowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_win_window
}

func (*Win_windowContext) IsWin_windowContext() {}

func NewWin_windowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Win_windowContext {
	var p = new(Win_windowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_win_window

	return p
}

func (s *Win_windowContext) GetParser() antlr.Parser { return s.parser }

func (s *Win_windowContext) Win_rows_or_range() IWin_rows_or_rangeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWin_rows_or_rangeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWin_rows_or_rangeContext)
}

func (s *Win_windowContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(OBParserBETWEEN, 0)
}

func (s *Win_windowContext) AllWin_bounding() []IWin_boundingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWin_boundingContext); ok {
			len++
		}
	}

	tst := make([]IWin_boundingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWin_boundingContext); ok {
			tst[i] = t.(IWin_boundingContext)
			i++
		}
	}

	return tst
}

func (s *Win_windowContext) Win_bounding(i int) IWin_boundingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWin_boundingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWin_boundingContext)
}

func (s *Win_windowContext) AND() antlr.TerminalNode {
	return s.GetToken(OBParserAND, 0)
}

func (s *Win_windowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Win_windowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Win_windowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterWin_window(s)
	}
}

func (s *Win_windowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitWin_window(s)
	}
}

func (s *Win_windowContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitWin_window(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Win_window() (localctx IWin_windowContext) {
	localctx = NewWin_windowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, OBParserRULE_win_window)
	p.SetState(1824)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1815)
			p.Win_rows_or_range()
		}
		{
			p.SetState(1816)
			p.Match(OBParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1817)
			p.Win_bounding()
		}
		{
			p.SetState(1818)
			p.Match(OBParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1819)
			p.Win_bounding()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1821)
			p.Win_rows_or_range()
		}
		{
			p.SetState(1822)
			p.Win_bounding()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICase_argContext is an interface to support dynamic dispatch.
type ICase_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsCase_argContext differentiates from other interfaces.
	IsCase_argContext()
}

type Case_argContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_argContext() *Case_argContext {
	var p = new(Case_argContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_case_arg
	return p
}

func InitEmptyCase_argContext(p *Case_argContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_case_arg
}

func (*Case_argContext) IsCase_argContext() {}

func NewCase_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_argContext {
	var p = new(Case_argContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_case_arg

	return p
}

func (s *Case_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_argContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Case_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCase_arg(s)
	}
}

func (s *Case_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCase_arg(s)
	}
}

func (s *Case_argContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCase_arg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Case_arg() (localctx ICase_argContext) {
	localctx = NewCase_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, OBParserRULE_case_arg)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&5209358405238784) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&8080602048254443537) != 0) || ((int64((_la-140)) & ^0x3f) == 0 && ((int64(1)<<(_la-140))&212755508364801) != 0) || ((int64((_la-212)) & ^0x3f) == 0 && ((int64(1)<<(_la-212))&-1260446869755002859) != 0) || ((int64((_la-276)) & ^0x3f) == 0 && ((int64(1)<<(_la-276))&-4901046761520365569) != 0) || ((int64((_la-340)) & ^0x3f) == 0 && ((int64(1)<<(_la-340))&-18014407267188737) != 0) || ((int64((_la-404)) & ^0x3f) == 0 && ((int64(1)<<(_la-404))&-54043204522084609) != 0) || ((int64((_la-468)) & ^0x3f) == 0 && ((int64(1)<<(_la-468))&-34360788993) != 0) || ((int64((_la-532)) & ^0x3f) == 0 && ((int64(1)<<(_la-532))&-4683743767084138503) != 0) || ((int64((_la-596)) & ^0x3f) == 0 && ((int64(1)<<(_la-596))&-288230376422309889) != 0) || ((int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-549756084289) != 0) || ((int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-37748737) != 0) || ((int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-577028117550333953) != 0) || ((int64((_la-853)) & ^0x3f) == 0 && ((int64(1)<<(_la-853))&2564391777992701) != 0) || ((int64((_la-918)) & ^0x3f) == 0 && ((int64(1)<<(_la-918))&18014398509482031) != 0) {
		{
			p.SetState(1826)
			p.expr(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhen_clause_listContext is an interface to support dynamic dispatch.
type IWhen_clause_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWhen_clause() []IWhen_clauseContext
	When_clause(i int) IWhen_clauseContext

	// IsWhen_clause_listContext differentiates from other interfaces.
	IsWhen_clause_listContext()
}

type When_clause_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhen_clause_listContext() *When_clause_listContext {
	var p = new(When_clause_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_when_clause_list
	return p
}

func InitEmptyWhen_clause_listContext(p *When_clause_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_when_clause_list
}

func (*When_clause_listContext) IsWhen_clause_listContext() {}

func NewWhen_clause_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *When_clause_listContext {
	var p = new(When_clause_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_when_clause_list

	return p
}

func (s *When_clause_listContext) GetParser() antlr.Parser { return s.parser }

func (s *When_clause_listContext) AllWhen_clause() []IWhen_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhen_clauseContext); ok {
			len++
		}
	}

	tst := make([]IWhen_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhen_clauseContext); ok {
			tst[i] = t.(IWhen_clauseContext)
			i++
		}
	}

	return tst
}

func (s *When_clause_listContext) When_clause(i int) IWhen_clauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhen_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhen_clauseContext)
}

func (s *When_clause_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *When_clause_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *When_clause_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterWhen_clause_list(s)
	}
}

func (s *When_clause_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitWhen_clause_list(s)
	}
}

func (s *When_clause_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitWhen_clause_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) When_clause_list() (localctx IWhen_clause_listContext) {
	localctx = NewWhen_clause_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, OBParserRULE_when_clause_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == OBParserWHEN {
		{
			p.SetState(1829)
			p.When_clause()
		}

		p.SetState(1832)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhen_clauseContext is an interface to support dynamic dispatch.
type IWhen_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	THEN() antlr.TerminalNode

	// IsWhen_clauseContext differentiates from other interfaces.
	IsWhen_clauseContext()
}

type When_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhen_clauseContext() *When_clauseContext {
	var p = new(When_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_when_clause
	return p
}

func InitEmptyWhen_clauseContext(p *When_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_when_clause
}

func (*When_clauseContext) IsWhen_clauseContext() {}

func NewWhen_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *When_clauseContext {
	var p = new(When_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_when_clause

	return p
}

func (s *When_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *When_clauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(OBParserWHEN, 0)
}

func (s *When_clauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *When_clauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *When_clauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(OBParserTHEN, 0)
}

func (s *When_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *When_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *When_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterWhen_clause(s)
	}
}

func (s *When_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitWhen_clause(s)
	}
}

func (s *When_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitWhen_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) When_clause() (localctx IWhen_clauseContext) {
	localctx = NewWhen_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, OBParserRULE_when_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1834)
		p.Match(OBParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1835)
		p.expr(0)
	}
	{
		p.SetState(1836)
		p.Match(OBParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1837)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICase_defaultContext is an interface to support dynamic dispatch.
type ICase_defaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSE() antlr.TerminalNode
	Expr() IExprContext
	Empty() IEmptyContext

	// IsCase_defaultContext differentiates from other interfaces.
	IsCase_defaultContext()
}

type Case_defaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_defaultContext() *Case_defaultContext {
	var p = new(Case_defaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_case_default
	return p
}

func InitEmptyCase_defaultContext(p *Case_defaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_case_default
}

func (*Case_defaultContext) IsCase_defaultContext() {}

func NewCase_defaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_defaultContext {
	var p = new(Case_defaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_case_default

	return p
}

func (s *Case_defaultContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_defaultContext) ELSE() antlr.TerminalNode {
	return s.GetToken(OBParserELSE, 0)
}

func (s *Case_defaultContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Case_defaultContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Case_defaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_defaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_defaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCase_default(s)
	}
}

func (s *Case_defaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCase_default(s)
	}
}

func (s *Case_defaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCase_default(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Case_default() (localctx ICase_defaultContext) {
	localctx = NewCase_defaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, OBParserRULE_case_default)
	p.SetState(1842)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserELSE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1839)
			p.Match(OBParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1840)
			p.expr(0)
		}

	case OBParserEND:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1841)
			p.Empty()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunc_exprContext is an interface to support dynamic dispatch.
type IFunc_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MOD() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode
	RightParen() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	Star() antlr.TerminalNode
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	Expr_list() IExpr_listContext
	UNIQUE() antlr.TerminalNode
	APPROX_COUNT_DISTINCT() antlr.TerminalNode
	APPROX_COUNT_DISTINCT_SYNOPSIS() antlr.TerminalNode
	APPROX_COUNT_DISTINCT_SYNOPSIS_MERGE() antlr.TerminalNode
	SUM() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	AVG() antlr.TerminalNode
	STDDEV() antlr.TerminalNode
	VARIANCE() antlr.TerminalNode
	STDDEV_POP() antlr.TerminalNode
	STDDEV_SAMP() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	Order_by() IOrder_byContext
	SEPARATOR() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	IF() antlr.TerminalNode
	ISNULL() antlr.TerminalNode
	Cur_timestamp_func() ICur_timestamp_funcContext
	Sysdate_func() ISysdate_funcContext
	Cur_time_func() ICur_time_funcContext
	Cur_date_func() ICur_date_funcContext
	Utc_timestamp_func() IUtc_timestamp_funcContext
	CAST() antlr.TerminalNode
	AS() antlr.TerminalNode
	Cast_data_type() ICast_data_typeContext
	INSERT() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	CONVERT() antlr.TerminalNode
	USING() antlr.TerminalNode
	Charset_name() ICharset_nameContext
	POSITION() antlr.TerminalNode
	Bit_expr() IBit_exprContext
	IN() antlr.TerminalNode
	Substr_or_substring() ISubstr_or_substringContext
	Substr_params() ISubstr_paramsContext
	TRIM() antlr.TerminalNode
	Parameterized_trim() IParameterized_trimContext
	DATE() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	TIME() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	DATE_ADD() antlr.TerminalNode
	Date_params() IDate_paramsContext
	DATE_SUB() antlr.TerminalNode
	ADDDATE() antlr.TerminalNode
	SUBDATE() antlr.TerminalNode
	TIMESTAMPDIFF() antlr.TerminalNode
	Timestamp_params() ITimestamp_paramsContext
	TIMESTAMPADD() antlr.TerminalNode
	EXTRACT() antlr.TerminalNode
	Date_unit() IDate_unitContext
	FROM() antlr.TerminalNode
	ASCII() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	Column_definition_ref() IColumn_definition_refContext
	VALUES() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	Function_name() IFunction_nameContext
	Expr_as_list() IExpr_as_listContext
	Relation_name() IRelation_nameContext
	Dot() antlr.TerminalNode
	Sys_interval_func() ISys_interval_funcContext

	// IsFunc_exprContext differentiates from other interfaces.
	IsFunc_exprContext()
}

type Func_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_exprContext() *Func_exprContext {
	var p = new(Func_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_func_expr
	return p
}

func InitEmptyFunc_exprContext(p *Func_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_func_expr
}

func (*Func_exprContext) IsFunc_exprContext() {}

func NewFunc_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_exprContext {
	var p = new(Func_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_func_expr

	return p
}

func (s *Func_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_exprContext) MOD() antlr.TerminalNode {
	return s.GetToken(OBParserMOD, 0)
}

func (s *Func_exprContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Func_exprContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Func_exprContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Func_exprContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Func_exprContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Func_exprContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Func_exprContext) COUNT() antlr.TerminalNode {
	return s.GetToken(OBParserCOUNT, 0)
}

func (s *Func_exprContext) Star() antlr.TerminalNode {
	return s.GetToken(OBParserStar, 0)
}

func (s *Func_exprContext) ALL() antlr.TerminalNode {
	return s.GetToken(OBParserALL, 0)
}

func (s *Func_exprContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(OBParserDISTINCT, 0)
}

func (s *Func_exprContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Func_exprContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(OBParserUNIQUE, 0)
}

func (s *Func_exprContext) APPROX_COUNT_DISTINCT() antlr.TerminalNode {
	return s.GetToken(OBParserAPPROX_COUNT_DISTINCT, 0)
}

func (s *Func_exprContext) APPROX_COUNT_DISTINCT_SYNOPSIS() antlr.TerminalNode {
	return s.GetToken(OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, 0)
}

func (s *Func_exprContext) APPROX_COUNT_DISTINCT_SYNOPSIS_MERGE() antlr.TerminalNode {
	return s.GetToken(OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, 0)
}

func (s *Func_exprContext) SUM() antlr.TerminalNode {
	return s.GetToken(OBParserSUM, 0)
}

func (s *Func_exprContext) MAX() antlr.TerminalNode {
	return s.GetToken(OBParserMAX, 0)
}

func (s *Func_exprContext) MIN() antlr.TerminalNode {
	return s.GetToken(OBParserMIN, 0)
}

func (s *Func_exprContext) AVG() antlr.TerminalNode {
	return s.GetToken(OBParserAVG, 0)
}

func (s *Func_exprContext) STDDEV() antlr.TerminalNode {
	return s.GetToken(OBParserSTDDEV, 0)
}

func (s *Func_exprContext) VARIANCE() antlr.TerminalNode {
	return s.GetToken(OBParserVARIANCE, 0)
}

func (s *Func_exprContext) STDDEV_POP() antlr.TerminalNode {
	return s.GetToken(OBParserSTDDEV_POP, 0)
}

func (s *Func_exprContext) STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(OBParserSTDDEV_SAMP, 0)
}

func (s *Func_exprContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(OBParserGROUPING, 0)
}

func (s *Func_exprContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(OBParserGROUP_CONCAT, 0)
}

func (s *Func_exprContext) Order_by() IOrder_byContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_byContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_byContext)
}

func (s *Func_exprContext) SEPARATOR() antlr.TerminalNode {
	return s.GetToken(OBParserSEPARATOR, 0)
}

func (s *Func_exprContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Func_exprContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Func_exprContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(OBParserISNULL, 0)
}

func (s *Func_exprContext) Cur_timestamp_func() ICur_timestamp_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICur_timestamp_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICur_timestamp_funcContext)
}

func (s *Func_exprContext) Sysdate_func() ISysdate_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISysdate_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISysdate_funcContext)
}

func (s *Func_exprContext) Cur_time_func() ICur_time_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICur_time_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICur_time_funcContext)
}

func (s *Func_exprContext) Cur_date_func() ICur_date_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICur_date_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICur_date_funcContext)
}

func (s *Func_exprContext) Utc_timestamp_func() IUtc_timestamp_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUtc_timestamp_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUtc_timestamp_funcContext)
}

func (s *Func_exprContext) CAST() antlr.TerminalNode {
	return s.GetToken(OBParserCAST, 0)
}

func (s *Func_exprContext) AS() antlr.TerminalNode {
	return s.GetToken(OBParserAS, 0)
}

func (s *Func_exprContext) Cast_data_type() ICast_data_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICast_data_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICast_data_typeContext)
}

func (s *Func_exprContext) INSERT() antlr.TerminalNode {
	return s.GetToken(OBParserINSERT, 0)
}

func (s *Func_exprContext) LEFT() antlr.TerminalNode {
	return s.GetToken(OBParserLEFT, 0)
}

func (s *Func_exprContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(OBParserCONVERT, 0)
}

func (s *Func_exprContext) USING() antlr.TerminalNode {
	return s.GetToken(OBParserUSING, 0)
}

func (s *Func_exprContext) Charset_name() ICharset_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_nameContext)
}

func (s *Func_exprContext) POSITION() antlr.TerminalNode {
	return s.GetToken(OBParserPOSITION, 0)
}

func (s *Func_exprContext) Bit_expr() IBit_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBit_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBit_exprContext)
}

func (s *Func_exprContext) IN() antlr.TerminalNode {
	return s.GetToken(OBParserIN, 0)
}

func (s *Func_exprContext) Substr_or_substring() ISubstr_or_substringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubstr_or_substringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubstr_or_substringContext)
}

func (s *Func_exprContext) Substr_params() ISubstr_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubstr_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubstr_paramsContext)
}

func (s *Func_exprContext) TRIM() antlr.TerminalNode {
	return s.GetToken(OBParserTRIM, 0)
}

func (s *Func_exprContext) Parameterized_trim() IParameterized_trimContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterized_trimContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterized_trimContext)
}

func (s *Func_exprContext) DATE() antlr.TerminalNode {
	return s.GetToken(OBParserDATE, 0)
}

func (s *Func_exprContext) YEAR() antlr.TerminalNode {
	return s.GetToken(OBParserYEAR, 0)
}

func (s *Func_exprContext) TIME() antlr.TerminalNode {
	return s.GetToken(OBParserTIME, 0)
}

func (s *Func_exprContext) MONTH() antlr.TerminalNode {
	return s.GetToken(OBParserMONTH, 0)
}

func (s *Func_exprContext) WEEK() antlr.TerminalNode {
	return s.GetToken(OBParserWEEK, 0)
}

func (s *Func_exprContext) SECOND() antlr.TerminalNode {
	return s.GetToken(OBParserSECOND, 0)
}

func (s *Func_exprContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(OBParserMINUTE, 0)
}

func (s *Func_exprContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(OBParserMICROSECOND, 0)
}

func (s *Func_exprContext) HOUR() antlr.TerminalNode {
	return s.GetToken(OBParserHOUR, 0)
}

func (s *Func_exprContext) DATE_ADD() antlr.TerminalNode {
	return s.GetToken(OBParserDATE_ADD, 0)
}

func (s *Func_exprContext) Date_params() IDate_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDate_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDate_paramsContext)
}

func (s *Func_exprContext) DATE_SUB() antlr.TerminalNode {
	return s.GetToken(OBParserDATE_SUB, 0)
}

func (s *Func_exprContext) ADDDATE() antlr.TerminalNode {
	return s.GetToken(OBParserADDDATE, 0)
}

func (s *Func_exprContext) SUBDATE() antlr.TerminalNode {
	return s.GetToken(OBParserSUBDATE, 0)
}

func (s *Func_exprContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(OBParserTIMESTAMPDIFF, 0)
}

func (s *Func_exprContext) Timestamp_params() ITimestamp_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestamp_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestamp_paramsContext)
}

func (s *Func_exprContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(OBParserTIMESTAMPADD, 0)
}

func (s *Func_exprContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(OBParserEXTRACT, 0)
}

func (s *Func_exprContext) Date_unit() IDate_unitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDate_unitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDate_unitContext)
}

func (s *Func_exprContext) FROM() antlr.TerminalNode {
	return s.GetToken(OBParserFROM, 0)
}

func (s *Func_exprContext) ASCII() antlr.TerminalNode {
	return s.GetToken(OBParserASCII, 0)
}

func (s *Func_exprContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT, 0)
}

func (s *Func_exprContext) Column_definition_ref() IColumn_definition_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_definition_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_definition_refContext)
}

func (s *Func_exprContext) VALUES() antlr.TerminalNode {
	return s.GetToken(OBParserVALUES, 0)
}

func (s *Func_exprContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(OBParserCHARACTER, 0)
}

func (s *Func_exprContext) Function_name() IFunction_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_nameContext)
}

func (s *Func_exprContext) Expr_as_list() IExpr_as_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_as_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_as_listContext)
}

func (s *Func_exprContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Func_exprContext) Dot() antlr.TerminalNode {
	return s.GetToken(OBParserDot, 0)
}

func (s *Func_exprContext) Sys_interval_func() ISys_interval_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISys_interval_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISys_interval_funcContext)
}

func (s *Func_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterFunc_expr(s)
	}
}

func (s *Func_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitFunc_expr(s)
	}
}

func (s *Func_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitFunc_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Func_expr() (localctx IFunc_exprContext) {
	localctx = NewFunc_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, OBParserRULE_func_expr)
	var _la int

	p.SetState(2199)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1844)
			p.Match(OBParserMOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1845)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1846)
			p.expr(0)
		}
		{
			p.SetState(1847)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1848)
			p.expr(0)
		}
		{
			p.SetState(1849)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1851)
			p.Match(OBParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1852)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1854)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL {
			{
				p.SetState(1853)
				p.Match(OBParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1856)
			p.Match(OBParserStar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1857)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1858)
			p.Match(OBParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1859)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1861)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL {
			{
				p.SetState(1860)
				p.Match(OBParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1863)
			p.expr(0)
		}
		{
			p.SetState(1864)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1866)
			p.Match(OBParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1867)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1868)
			p.Match(OBParserDISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1869)
			p.Expr_list()
		}
		{
			p.SetState(1870)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1872)
			p.Match(OBParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1873)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1874)
			p.Match(OBParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1875)
			p.Expr_list()
		}
		{
			p.SetState(1876)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1878)
			p.Match(OBParserAPPROX_COUNT_DISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1879)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1880)
			p.Expr_list()
		}
		{
			p.SetState(1881)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1883)
			p.Match(OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1884)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1885)
			p.Expr_list()
		}
		{
			p.SetState(1886)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1888)
			p.Match(OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1889)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1890)
			p.expr(0)
		}
		{
			p.SetState(1891)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1893)
			p.Match(OBParserSUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1894)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1896)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1895)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1898)
			p.expr(0)
		}
		{
			p.SetState(1899)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1901)
			p.Match(OBParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1902)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1903)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1906)
			p.expr(0)
		}
		{
			p.SetState(1907)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1909)
			p.Match(OBParserMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1910)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1912)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1911)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1914)
			p.expr(0)
		}
		{
			p.SetState(1915)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1917)
			p.Match(OBParserAVG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1918)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1920)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1919)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1922)
			p.expr(0)
		}
		{
			p.SetState(1923)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1925)
			p.Match(OBParserSTDDEV)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1926)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1928)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1927)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1930)
			p.expr(0)
		}
		{
			p.SetState(1931)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1933)
			p.Match(OBParserVARIANCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1934)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1936)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1935)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1938)
			p.expr(0)
		}
		{
			p.SetState(1939)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1941)
			p.Match(OBParserSTDDEV_POP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1942)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1944)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1943)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1946)
			p.expr(0)
		}
		{
			p.SetState(1947)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1949)
			p.Match(OBParserSTDDEV_SAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1950)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1952)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1951)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1954)
			p.expr(0)
		}
		{
			p.SetState(1955)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1957)
			p.Match(OBParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1958)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1959)
			p.expr(0)
		}
		{
			p.SetState(1960)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1962)
			p.Match(OBParserGROUP_CONCAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1963)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1965)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserDISTINCT || _la == OBParserUNIQUE {
			{
				p.SetState(1964)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserDISTINCT || _la == OBParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1967)
			p.Expr_list()
		}
		p.SetState(1969)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserORDER {
			{
				p.SetState(1968)
				p.Order_by()
			}

		}
		p.SetState(1973)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSEPARATOR {
			{
				p.SetState(1971)
				p.Match(OBParserSEPARATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1972)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1975)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1977)
			p.Match(OBParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1978)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1979)
			p.expr(0)
		}
		{
			p.SetState(1980)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1981)
			p.expr(0)
		}
		{
			p.SetState(1982)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1983)
			p.expr(0)
		}
		{
			p.SetState(1984)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1986)
			p.Match(OBParserISNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1987)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1988)
			p.expr(0)
		}
		{
			p.SetState(1989)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1991)
			p.Cur_timestamp_func()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1992)
			p.Sysdate_func()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1993)
			p.Cur_time_func()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1994)
			p.Cur_date_func()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1995)
			p.Utc_timestamp_func()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1996)
			p.Match(OBParserCAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1997)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1998)
			p.expr(0)
		}
		{
			p.SetState(1999)
			p.Match(OBParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2000)
			p.Cast_data_type()
		}
		{
			p.SetState(2001)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(2003)
			p.Match(OBParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2004)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2005)
			p.expr(0)
		}
		{
			p.SetState(2006)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2007)
			p.expr(0)
		}
		{
			p.SetState(2008)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2009)
			p.expr(0)
		}
		{
			p.SetState(2010)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2011)
			p.expr(0)
		}
		{
			p.SetState(2012)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(2014)
			p.Match(OBParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2015)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2016)
			p.expr(0)
		}
		{
			p.SetState(2017)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2018)
			p.expr(0)
		}
		{
			p.SetState(2019)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(2021)
			p.Match(OBParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2022)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2023)
			p.expr(0)
		}
		{
			p.SetState(2024)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2025)
			p.Cast_data_type()
		}
		{
			p.SetState(2026)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(2028)
			p.Match(OBParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2029)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2030)
			p.expr(0)
		}
		{
			p.SetState(2031)
			p.Match(OBParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2032)
			p.Charset_name()
		}
		{
			p.SetState(2033)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(2035)
			p.Match(OBParserPOSITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2036)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2037)
			p.bit_expr(0)
		}
		{
			p.SetState(2038)
			p.Match(OBParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2039)
			p.expr(0)
		}
		{
			p.SetState(2040)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(2042)
			p.Substr_or_substring()
		}
		{
			p.SetState(2043)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2044)
			p.Substr_params()
		}
		{
			p.SetState(2045)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(2047)
			p.Match(OBParserTRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2048)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2049)
			p.Parameterized_trim()
		}
		{
			p.SetState(2050)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(2052)
			p.Match(OBParserDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2053)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2054)
			p.expr(0)
		}
		{
			p.SetState(2055)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2057)
			p.Match(OBParserYEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2058)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2059)
			p.expr(0)
		}
		{
			p.SetState(2060)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(2062)
			p.Match(OBParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2063)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2064)
			p.expr(0)
		}
		{
			p.SetState(2065)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(2067)
			p.Match(OBParserMONTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2068)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2069)
			p.expr(0)
		}
		{
			p.SetState(2070)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(2072)
			p.Match(OBParserWEEK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2073)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2074)
			p.expr(0)
		}
		{
			p.SetState(2075)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(2077)
			p.Match(OBParserWEEK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2078)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2079)
			p.expr(0)
		}
		{
			p.SetState(2080)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2081)
			p.expr(0)
		}
		{
			p.SetState(2082)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(2084)
			p.Match(OBParserSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2085)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2086)
			p.expr(0)
		}
		{
			p.SetState(2087)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(2089)
			p.Match(OBParserMINUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2090)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2091)
			p.expr(0)
		}
		{
			p.SetState(2092)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(2094)
			p.Match(OBParserMICROSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2095)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2096)
			p.expr(0)
		}
		{
			p.SetState(2097)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(2099)
			p.Match(OBParserHOUR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2100)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2101)
			p.expr(0)
		}
		{
			p.SetState(2102)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(2104)
			p.Match(OBParserDATE_ADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2105)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2106)
			p.Date_params()
		}
		{
			p.SetState(2107)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(2109)
			p.Match(OBParserDATE_SUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2110)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2111)
			p.Date_params()
		}
		{
			p.SetState(2112)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(2114)
			p.Match(OBParserADDDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2115)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2116)
			p.Date_params()
		}
		{
			p.SetState(2117)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(2119)
			p.Match(OBParserSUBDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2120)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2121)
			p.Date_params()
		}
		{
			p.SetState(2122)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(2124)
			p.Match(OBParserADDDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2125)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2126)
			p.expr(0)
		}
		{
			p.SetState(2127)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2128)
			p.expr(0)
		}
		{
			p.SetState(2129)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(2131)
			p.Match(OBParserSUBDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2132)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2133)
			p.expr(0)
		}
		{
			p.SetState(2134)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2135)
			p.expr(0)
		}
		{
			p.SetState(2136)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(2138)
			p.Match(OBParserTIMESTAMPDIFF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2139)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2140)
			p.Timestamp_params()
		}
		{
			p.SetState(2141)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(2143)
			p.Match(OBParserTIMESTAMPADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2144)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2145)
			p.Timestamp_params()
		}
		{
			p.SetState(2146)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(2148)
			p.Match(OBParserEXTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2149)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2150)
			p.Date_unit()
		}
		{
			p.SetState(2151)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2152)
			p.expr(0)
		}
		{
			p.SetState(2153)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(2155)
			p.Match(OBParserASCII)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2156)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2157)
			p.expr(0)
		}
		{
			p.SetState(2158)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(2160)
			p.Match(OBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2161)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2162)
			p.Column_definition_ref()
		}
		{
			p.SetState(2163)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(2165)
			p.Match(OBParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2166)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2167)
			p.Column_definition_ref()
		}
		{
			p.SetState(2168)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(2170)
			p.Match(OBParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2171)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2172)
			p.Expr_list()
		}
		{
			p.SetState(2173)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(2175)
			p.Match(OBParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2176)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2177)
			p.Expr_list()
		}
		{
			p.SetState(2178)
			p.Match(OBParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2179)
			p.Charset_name()
		}
		{
			p.SetState(2180)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(2182)
			p.Function_name()
		}
		{
			p.SetState(2183)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2185)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&5209358405238784) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&8080602048254443537) != 0) || ((int64((_la-140)) & ^0x3f) == 0 && ((int64(1)<<(_la-140))&212755508364801) != 0) || ((int64((_la-212)) & ^0x3f) == 0 && ((int64(1)<<(_la-212))&-1260446869755002859) != 0) || ((int64((_la-276)) & ^0x3f) == 0 && ((int64(1)<<(_la-276))&-4901046761520365569) != 0) || ((int64((_la-340)) & ^0x3f) == 0 && ((int64(1)<<(_la-340))&-18014407267188737) != 0) || ((int64((_la-404)) & ^0x3f) == 0 && ((int64(1)<<(_la-404))&-54043204522084609) != 0) || ((int64((_la-468)) & ^0x3f) == 0 && ((int64(1)<<(_la-468))&-34360788993) != 0) || ((int64((_la-532)) & ^0x3f) == 0 && ((int64(1)<<(_la-532))&-4683743767084138503) != 0) || ((int64((_la-596)) & ^0x3f) == 0 && ((int64(1)<<(_la-596))&-288230376422309889) != 0) || ((int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-549756084289) != 0) || ((int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-37748737) != 0) || ((int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-577028117550333953) != 0) || ((int64((_la-853)) & ^0x3f) == 0 && ((int64(1)<<(_la-853))&2564391777992701) != 0) || ((int64((_la-918)) & ^0x3f) == 0 && ((int64(1)<<(_la-918))&18014398509482031) != 0) {
			{
				p.SetState(2184)
				p.Expr_as_list()
			}

		}
		{
			p.SetState(2187)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(2189)
			p.Relation_name()
		}
		{
			p.SetState(2190)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2191)
			p.Function_name()
		}
		{
			p.SetState(2192)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2194)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&5209358405238784) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&8080602048254443537) != 0) || ((int64((_la-140)) & ^0x3f) == 0 && ((int64(1)<<(_la-140))&212755508364801) != 0) || ((int64((_la-212)) & ^0x3f) == 0 && ((int64(1)<<(_la-212))&-1260446869755002859) != 0) || ((int64((_la-276)) & ^0x3f) == 0 && ((int64(1)<<(_la-276))&-4901046761520365569) != 0) || ((int64((_la-340)) & ^0x3f) == 0 && ((int64(1)<<(_la-340))&-18014407267188737) != 0) || ((int64((_la-404)) & ^0x3f) == 0 && ((int64(1)<<(_la-404))&-54043204522084609) != 0) || ((int64((_la-468)) & ^0x3f) == 0 && ((int64(1)<<(_la-468))&-34360788993) != 0) || ((int64((_la-532)) & ^0x3f) == 0 && ((int64(1)<<(_la-532))&-4683743767084138503) != 0) || ((int64((_la-596)) & ^0x3f) == 0 && ((int64(1)<<(_la-596))&-288230376422309889) != 0) || ((int64((_la-660)) & ^0x3f) == 0 && ((int64(1)<<(_la-660))&-549756084289) != 0) || ((int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&-37748737) != 0) || ((int64((_la-788)) & ^0x3f) == 0 && ((int64(1)<<(_la-788))&-577028117550333953) != 0) || ((int64((_la-853)) & ^0x3f) == 0 && ((int64(1)<<(_la-853))&2564391777992701) != 0) || ((int64((_la-918)) & ^0x3f) == 0 && ((int64(1)<<(_la-918))&18014398509482031) != 0) {
			{
				p.SetState(2193)
				p.Expr_as_list()
			}

		}
		{
			p.SetState(2196)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(2198)
			p.Sys_interval_func()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISys_interval_funcContext is an interface to support dynamic dispatch.
type ISys_interval_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERVAL() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode
	RightParen() antlr.TerminalNode
	Expr_list() IExpr_listContext

	// IsSys_interval_funcContext differentiates from other interfaces.
	IsSys_interval_funcContext()
}

type Sys_interval_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySys_interval_funcContext() *Sys_interval_funcContext {
	var p = new(Sys_interval_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sys_interval_func
	return p
}

func InitEmptySys_interval_funcContext(p *Sys_interval_funcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sys_interval_func
}

func (*Sys_interval_funcContext) IsSys_interval_funcContext() {}

func NewSys_interval_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sys_interval_funcContext {
	var p = new(Sys_interval_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_sys_interval_func

	return p
}

func (s *Sys_interval_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Sys_interval_funcContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(OBParserINTERVAL, 0)
}

func (s *Sys_interval_funcContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Sys_interval_funcContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Sys_interval_funcContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Sys_interval_funcContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Sys_interval_funcContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Sys_interval_funcContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Sys_interval_funcContext) Expr_list() IExpr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_listContext)
}

func (s *Sys_interval_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sys_interval_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sys_interval_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSys_interval_func(s)
	}
}

func (s *Sys_interval_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSys_interval_func(s)
	}
}

func (s *Sys_interval_funcContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSys_interval_func(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Sys_interval_func() (localctx ISys_interval_funcContext) {
	localctx = NewSys_interval_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, OBParserRULE_sys_interval_func)
	p.SetState(2217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2201)
			p.Match(OBParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2202)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2203)
			p.expr(0)
		}
		{
			p.SetState(2204)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2205)
			p.expr(0)
		}
		{
			p.SetState(2206)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2208)
			p.Match(OBParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2209)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2210)
			p.expr(0)
		}
		{
			p.SetState(2211)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2212)
			p.expr(0)
		}
		{
			p.SetState(2213)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2214)
			p.Expr_list()
		}
		{
			p.SetState(2215)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUtc_timestamp_funcContext is an interface to support dynamic dispatch.
type IUtc_timestamp_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UTC_TIMESTAMP() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	INTNUM() antlr.TerminalNode

	// IsUtc_timestamp_funcContext differentiates from other interfaces.
	IsUtc_timestamp_funcContext()
}

type Utc_timestamp_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUtc_timestamp_funcContext() *Utc_timestamp_funcContext {
	var p = new(Utc_timestamp_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_utc_timestamp_func
	return p
}

func InitEmptyUtc_timestamp_funcContext(p *Utc_timestamp_funcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_utc_timestamp_func
}

func (*Utc_timestamp_funcContext) IsUtc_timestamp_funcContext() {}

func NewUtc_timestamp_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Utc_timestamp_funcContext {
	var p = new(Utc_timestamp_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_utc_timestamp_func

	return p
}

func (s *Utc_timestamp_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Utc_timestamp_funcContext) UTC_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(OBParserUTC_TIMESTAMP, 0)
}

func (s *Utc_timestamp_funcContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Utc_timestamp_funcContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Utc_timestamp_funcContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Utc_timestamp_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Utc_timestamp_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Utc_timestamp_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUtc_timestamp_func(s)
	}
}

func (s *Utc_timestamp_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUtc_timestamp_func(s)
	}
}

func (s *Utc_timestamp_funcContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUtc_timestamp_func(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Utc_timestamp_func() (localctx IUtc_timestamp_funcContext) {
	localctx = NewUtc_timestamp_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, OBParserRULE_utc_timestamp_func)
	p.SetState(2226)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2219)
			p.Match(OBParserUTC_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2220)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2221)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2222)
			p.Match(OBParserUTC_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2223)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2224)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2225)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISysdate_funcContext is an interface to support dynamic dispatch.
type ISysdate_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYSDATE() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	INTNUM() antlr.TerminalNode

	// IsSysdate_funcContext differentiates from other interfaces.
	IsSysdate_funcContext()
}

type Sysdate_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySysdate_funcContext() *Sysdate_funcContext {
	var p = new(Sysdate_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sysdate_func
	return p
}

func InitEmptySysdate_funcContext(p *Sysdate_funcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sysdate_func
}

func (*Sysdate_funcContext) IsSysdate_funcContext() {}

func NewSysdate_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sysdate_funcContext {
	var p = new(Sysdate_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_sysdate_func

	return p
}

func (s *Sysdate_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Sysdate_funcContext) SYSDATE() antlr.TerminalNode {
	return s.GetToken(OBParserSYSDATE, 0)
}

func (s *Sysdate_funcContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Sysdate_funcContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Sysdate_funcContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Sysdate_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sysdate_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sysdate_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSysdate_func(s)
	}
}

func (s *Sysdate_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSysdate_func(s)
	}
}

func (s *Sysdate_funcContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSysdate_func(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Sysdate_func() (localctx ISysdate_funcContext) {
	localctx = NewSysdate_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, OBParserRULE_sysdate_func)
	p.SetState(2235)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2228)
			p.Match(OBParserSYSDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2229)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2230)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2231)
			p.Match(OBParserSYSDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2232)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2233)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2234)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICur_timestamp_funcContext is an interface to support dynamic dispatch.
type ICur_timestamp_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOW() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	Now_synonyms_func() INow_synonyms_funcContext

	// IsCur_timestamp_funcContext differentiates from other interfaces.
	IsCur_timestamp_funcContext()
}

type Cur_timestamp_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCur_timestamp_funcContext() *Cur_timestamp_funcContext {
	var p = new(Cur_timestamp_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cur_timestamp_func
	return p
}

func InitEmptyCur_timestamp_funcContext(p *Cur_timestamp_funcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cur_timestamp_func
}

func (*Cur_timestamp_funcContext) IsCur_timestamp_funcContext() {}

func NewCur_timestamp_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cur_timestamp_funcContext {
	var p = new(Cur_timestamp_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_cur_timestamp_func

	return p
}

func (s *Cur_timestamp_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Cur_timestamp_funcContext) NOW() antlr.TerminalNode {
	return s.GetToken(OBParserNOW, 0)
}

func (s *Cur_timestamp_funcContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Cur_timestamp_funcContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Cur_timestamp_funcContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Cur_timestamp_funcContext) Now_synonyms_func() INow_synonyms_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INow_synonyms_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INow_synonyms_funcContext)
}

func (s *Cur_timestamp_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cur_timestamp_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cur_timestamp_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCur_timestamp_func(s)
	}
}

func (s *Cur_timestamp_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCur_timestamp_func(s)
	}
}

func (s *Cur_timestamp_funcContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCur_timestamp_func(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Cur_timestamp_func() (localctx ICur_timestamp_funcContext) {
	localctx = NewCur_timestamp_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, OBParserRULE_cur_timestamp_func)
	p.SetState(2252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2237)
			p.Match(OBParserNOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2238)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2239)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2240)
			p.Match(OBParserNOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2241)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2242)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2243)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2244)
			p.Now_synonyms_func()
		}
		p.SetState(2250)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2245)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2246)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2247)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(2248)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2249)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INow_synonyms_funcContext is an interface to support dynamic dispatch.
type INow_synonyms_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT_TIMESTAMP() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode

	// IsNow_synonyms_funcContext differentiates from other interfaces.
	IsNow_synonyms_funcContext()
}

type Now_synonyms_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNow_synonyms_funcContext() *Now_synonyms_funcContext {
	var p = new(Now_synonyms_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_now_synonyms_func
	return p
}

func InitEmptyNow_synonyms_funcContext(p *Now_synonyms_funcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_now_synonyms_func
}

func (*Now_synonyms_funcContext) IsNow_synonyms_funcContext() {}

func NewNow_synonyms_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Now_synonyms_funcContext {
	var p = new(Now_synonyms_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_now_synonyms_func

	return p
}

func (s *Now_synonyms_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Now_synonyms_funcContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(OBParserCURRENT_TIMESTAMP, 0)
}

func (s *Now_synonyms_funcContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(OBParserLOCALTIME, 0)
}

func (s *Now_synonyms_funcContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(OBParserLOCALTIMESTAMP, 0)
}

func (s *Now_synonyms_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Now_synonyms_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Now_synonyms_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterNow_synonyms_func(s)
	}
}

func (s *Now_synonyms_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitNow_synonyms_func(s)
	}
}

func (s *Now_synonyms_funcContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitNow_synonyms_func(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Now_synonyms_func() (localctx INow_synonyms_funcContext) {
	localctx = NewNow_synonyms_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, OBParserRULE_now_synonyms_func)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2254)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserCURRENT_TIMESTAMP || _la == OBParserLOCALTIME || _la == OBParserLOCALTIMESTAMP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICur_time_funcContext is an interface to support dynamic dispatch.
type ICur_time_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURTIME() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode

	// IsCur_time_funcContext differentiates from other interfaces.
	IsCur_time_funcContext()
}

type Cur_time_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCur_time_funcContext() *Cur_time_funcContext {
	var p = new(Cur_time_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cur_time_func
	return p
}

func InitEmptyCur_time_funcContext(p *Cur_time_funcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cur_time_func
}

func (*Cur_time_funcContext) IsCur_time_funcContext() {}

func NewCur_time_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cur_time_funcContext {
	var p = new(Cur_time_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_cur_time_func

	return p
}

func (s *Cur_time_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Cur_time_funcContext) CURTIME() antlr.TerminalNode {
	return s.GetToken(OBParserCURTIME, 0)
}

func (s *Cur_time_funcContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Cur_time_funcContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Cur_time_funcContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Cur_time_funcContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(OBParserCURRENT_TIME, 0)
}

func (s *Cur_time_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cur_time_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cur_time_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCur_time_func(s)
	}
}

func (s *Cur_time_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCur_time_func(s)
	}
}

func (s *Cur_time_funcContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCur_time_func(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Cur_time_func() (localctx ICur_time_funcContext) {
	localctx = NewCur_time_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, OBParserRULE_cur_time_func)
	p.SetState(2271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2256)
			p.Match(OBParserCURTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2257)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2258)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2259)
			p.Match(OBParserCURTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2260)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2261)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2262)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2263)
			p.Match(OBParserCURRENT_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2269)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2264)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2265)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2266)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(2267)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2268)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICur_date_funcContext is an interface to support dynamic dispatch.
type ICur_date_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURDATE() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode

	// IsCur_date_funcContext differentiates from other interfaces.
	IsCur_date_funcContext()
}

type Cur_date_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCur_date_funcContext() *Cur_date_funcContext {
	var p = new(Cur_date_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cur_date_func
	return p
}

func InitEmptyCur_date_funcContext(p *Cur_date_funcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cur_date_func
}

func (*Cur_date_funcContext) IsCur_date_funcContext() {}

func NewCur_date_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cur_date_funcContext {
	var p = new(Cur_date_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_cur_date_func

	return p
}

func (s *Cur_date_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Cur_date_funcContext) CURDATE() antlr.TerminalNode {
	return s.GetToken(OBParserCURDATE, 0)
}

func (s *Cur_date_funcContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Cur_date_funcContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Cur_date_funcContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(OBParserCURRENT_DATE, 0)
}

func (s *Cur_date_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cur_date_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cur_date_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCur_date_func(s)
	}
}

func (s *Cur_date_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCur_date_func(s)
	}
}

func (s *Cur_date_funcContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCur_date_func(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Cur_date_func() (localctx ICur_date_funcContext) {
	localctx = NewCur_date_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, OBParserRULE_cur_date_func)
	p.SetState(2280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2273)
			p.Match(OBParserCURDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2274)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2275)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2276)
			p.Match(OBParserCURRENT_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2277)
			p.Match(OBParserCURRENT_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2278)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2279)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubstr_or_substringContext is an interface to support dynamic dispatch.
type ISubstr_or_substringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBSTR() antlr.TerminalNode
	SUBSTRING() antlr.TerminalNode

	// IsSubstr_or_substringContext differentiates from other interfaces.
	IsSubstr_or_substringContext()
}

type Substr_or_substringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubstr_or_substringContext() *Substr_or_substringContext {
	var p = new(Substr_or_substringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_substr_or_substring
	return p
}

func InitEmptySubstr_or_substringContext(p *Substr_or_substringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_substr_or_substring
}

func (*Substr_or_substringContext) IsSubstr_or_substringContext() {}

func NewSubstr_or_substringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Substr_or_substringContext {
	var p = new(Substr_or_substringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_substr_or_substring

	return p
}

func (s *Substr_or_substringContext) GetParser() antlr.Parser { return s.parser }

func (s *Substr_or_substringContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(OBParserSUBSTR, 0)
}

func (s *Substr_or_substringContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(OBParserSUBSTRING, 0)
}

func (s *Substr_or_substringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Substr_or_substringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Substr_or_substringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSubstr_or_substring(s)
	}
}

func (s *Substr_or_substringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSubstr_or_substring(s)
	}
}

func (s *Substr_or_substringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSubstr_or_substring(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Substr_or_substring() (localctx ISubstr_or_substringContext) {
	localctx = NewSubstr_or_substringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, OBParserRULE_substr_or_substring)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2282)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserSUBSTR || _la == OBParserSUBSTRING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubstr_paramsContext is an interface to support dynamic dispatch.
type ISubstr_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode
	FROM() antlr.TerminalNode
	FOR() antlr.TerminalNode

	// IsSubstr_paramsContext differentiates from other interfaces.
	IsSubstr_paramsContext()
}

type Substr_paramsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubstr_paramsContext() *Substr_paramsContext {
	var p = new(Substr_paramsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_substr_params
	return p
}

func InitEmptySubstr_paramsContext(p *Substr_paramsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_substr_params
}

func (*Substr_paramsContext) IsSubstr_paramsContext() {}

func NewSubstr_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Substr_paramsContext {
	var p = new(Substr_paramsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_substr_params

	return p
}

func (s *Substr_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Substr_paramsContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Substr_paramsContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Substr_paramsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Substr_paramsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Substr_paramsContext) FROM() antlr.TerminalNode {
	return s.GetToken(OBParserFROM, 0)
}

func (s *Substr_paramsContext) FOR() antlr.TerminalNode {
	return s.GetToken(OBParserFOR, 0)
}

func (s *Substr_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Substr_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Substr_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSubstr_params(s)
	}
}

func (s *Substr_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSubstr_params(s)
	}
}

func (s *Substr_paramsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSubstr_params(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Substr_params() (localctx ISubstr_paramsContext) {
	localctx = NewSubstr_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, OBParserRULE_substr_params)
	p.SetState(2304)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2284)
			p.expr(0)
		}
		{
			p.SetState(2285)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2286)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2288)
			p.expr(0)
		}
		{
			p.SetState(2289)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2290)
			p.expr(0)
		}
		{
			p.SetState(2291)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2292)
			p.expr(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2294)
			p.expr(0)
		}
		{
			p.SetState(2295)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2296)
			p.expr(0)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2298)
			p.expr(0)
		}
		{
			p.SetState(2299)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2300)
			p.expr(0)
		}
		{
			p.SetState(2301)
			p.Match(OBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2302)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDate_paramsContext is an interface to support dynamic dispatch.
type IDate_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	Comma() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	Date_unit() IDate_unitContext

	// IsDate_paramsContext differentiates from other interfaces.
	IsDate_paramsContext()
}

type Date_paramsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDate_paramsContext() *Date_paramsContext {
	var p = new(Date_paramsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_date_params
	return p
}

func InitEmptyDate_paramsContext(p *Date_paramsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_date_params
}

func (*Date_paramsContext) IsDate_paramsContext() {}

func NewDate_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Date_paramsContext {
	var p = new(Date_paramsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_date_params

	return p
}

func (s *Date_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Date_paramsContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Date_paramsContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Date_paramsContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Date_paramsContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(OBParserINTERVAL, 0)
}

func (s *Date_paramsContext) Date_unit() IDate_unitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDate_unitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDate_unitContext)
}

func (s *Date_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Date_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Date_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDate_params(s)
	}
}

func (s *Date_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDate_params(s)
	}
}

func (s *Date_paramsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDate_params(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Date_params() (localctx IDate_paramsContext) {
	localctx = NewDate_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, OBParserRULE_date_params)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2306)
		p.expr(0)
	}
	{
		p.SetState(2307)
		p.Match(OBParserComma)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2308)
		p.Match(OBParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2309)
		p.expr(0)
	}
	{
		p.SetState(2310)
		p.Date_unit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimestamp_paramsContext is an interface to support dynamic dispatch.
type ITimestamp_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Date_unit() IDate_unitContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext

	// IsTimestamp_paramsContext differentiates from other interfaces.
	IsTimestamp_paramsContext()
}

type Timestamp_paramsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimestamp_paramsContext() *Timestamp_paramsContext {
	var p = new(Timestamp_paramsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_timestamp_params
	return p
}

func InitEmptyTimestamp_paramsContext(p *Timestamp_paramsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_timestamp_params
}

func (*Timestamp_paramsContext) IsTimestamp_paramsContext() {}

func NewTimestamp_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timestamp_paramsContext {
	var p = new(Timestamp_paramsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_timestamp_params

	return p
}

func (s *Timestamp_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Timestamp_paramsContext) Date_unit() IDate_unitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDate_unitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDate_unitContext)
}

func (s *Timestamp_paramsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Timestamp_paramsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Timestamp_paramsContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Timestamp_paramsContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Timestamp_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timestamp_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timestamp_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTimestamp_params(s)
	}
}

func (s *Timestamp_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTimestamp_params(s)
	}
}

func (s *Timestamp_paramsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTimestamp_params(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Timestamp_params() (localctx ITimestamp_paramsContext) {
	localctx = NewTimestamp_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, OBParserRULE_timestamp_params)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2312)
		p.Date_unit()
	}
	{
		p.SetState(2313)
		p.Match(OBParserComma)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2314)
		p.expr(0)
	}
	{
		p.SetState(2315)
		p.Match(OBParserComma)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2316)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelete_stmtContext is an interface to support dynamic dispatch.
type IDelete_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Delete_with_opt_hint() IDelete_with_opt_hintContext
	FROM() antlr.TerminalNode
	Tbl_name() ITbl_nameContext
	WHERE() antlr.TerminalNode
	Opt_hint_value() IOpt_hint_valueContext
	Expr() IExprContext
	Order_by() IOrder_byContext
	Limit_clause() ILimit_clauseContext
	Multi_delete_table() IMulti_delete_tableContext

	// IsDelete_stmtContext differentiates from other interfaces.
	IsDelete_stmtContext()
}

type Delete_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelete_stmtContext() *Delete_stmtContext {
	var p = new(Delete_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_delete_stmt
	return p
}

func InitEmptyDelete_stmtContext(p *Delete_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_delete_stmt
}

func (*Delete_stmtContext) IsDelete_stmtContext() {}

func NewDelete_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_stmtContext {
	var p = new(Delete_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_delete_stmt

	return p
}

func (s *Delete_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Delete_stmtContext) Delete_with_opt_hint() IDelete_with_opt_hintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelete_with_opt_hintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelete_with_opt_hintContext)
}

func (s *Delete_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(OBParserFROM, 0)
}

func (s *Delete_stmtContext) Tbl_name() ITbl_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITbl_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITbl_nameContext)
}

func (s *Delete_stmtContext) WHERE() antlr.TerminalNode {
	return s.GetToken(OBParserWHERE, 0)
}

func (s *Delete_stmtContext) Opt_hint_value() IOpt_hint_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_hint_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_hint_valueContext)
}

func (s *Delete_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Delete_stmtContext) Order_by() IOrder_byContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_byContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_byContext)
}

func (s *Delete_stmtContext) Limit_clause() ILimit_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimit_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimit_clauseContext)
}

func (s *Delete_stmtContext) Multi_delete_table() IMulti_delete_tableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMulti_delete_tableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMulti_delete_tableContext)
}

func (s *Delete_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delete_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDelete_stmt(s)
	}
}

func (s *Delete_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDelete_stmt(s)
	}
}

func (s *Delete_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDelete_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Delete_stmt() (localctx IDelete_stmtContext) {
	localctx = NewDelete_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, OBParserRULE_delete_stmt)
	var _la int

	p.SetState(2341)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2318)
			p.Delete_with_opt_hint()
		}
		{
			p.SetState(2319)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2320)
			p.Tbl_name()
		}
		p.SetState(2325)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserWHERE {
			{
				p.SetState(2321)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2322)
				p.Opt_hint_value()
			}
			{
				p.SetState(2323)
				p.expr(0)
			}

		}
		p.SetState(2328)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserORDER {
			{
				p.SetState(2327)
				p.Order_by()
			}

		}
		p.SetState(2331)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserLIMIT {
			{
				p.SetState(2330)
				p.Limit_clause()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2333)
			p.Delete_with_opt_hint()
		}
		{
			p.SetState(2334)
			p.Multi_delete_table()
		}
		p.SetState(2339)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserWHERE {
			{
				p.SetState(2335)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2336)
				p.Opt_hint_value()
			}
			{
				p.SetState(2337)
				p.expr(0)
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMulti_delete_tableContext is an interface to support dynamic dispatch.
type IMulti_delete_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Relation_with_star_list() IRelation_with_star_listContext
	FROM() antlr.TerminalNode
	Table_references() ITable_referencesContext
	USING() antlr.TerminalNode

	// IsMulti_delete_tableContext differentiates from other interfaces.
	IsMulti_delete_tableContext()
}

type Multi_delete_tableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMulti_delete_tableContext() *Multi_delete_tableContext {
	var p = new(Multi_delete_tableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_multi_delete_table
	return p
}

func InitEmptyMulti_delete_tableContext(p *Multi_delete_tableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_multi_delete_table
}

func (*Multi_delete_tableContext) IsMulti_delete_tableContext() {}

func NewMulti_delete_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multi_delete_tableContext {
	var p = new(Multi_delete_tableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_multi_delete_table

	return p
}

func (s *Multi_delete_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Multi_delete_tableContext) Relation_with_star_list() IRelation_with_star_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_with_star_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_with_star_listContext)
}

func (s *Multi_delete_tableContext) FROM() antlr.TerminalNode {
	return s.GetToken(OBParserFROM, 0)
}

func (s *Multi_delete_tableContext) Table_references() ITable_referencesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_referencesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_referencesContext)
}

func (s *Multi_delete_tableContext) USING() antlr.TerminalNode {
	return s.GetToken(OBParserUSING, 0)
}

func (s *Multi_delete_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multi_delete_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multi_delete_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterMulti_delete_table(s)
	}
}

func (s *Multi_delete_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitMulti_delete_table(s)
	}
}

func (s *Multi_delete_tableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitMulti_delete_table(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Multi_delete_table() (localctx IMulti_delete_tableContext) {
	localctx = NewMulti_delete_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, OBParserRULE_multi_delete_table)
	p.SetState(2352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserNAME_OB, OBParserSTAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2343)
			p.Relation_with_star_list()
		}
		{
			p.SetState(2344)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2345)
			p.Table_references()
		}

	case OBParserFROM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2347)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2348)
			p.Relation_with_star_list()
		}
		{
			p.SetState(2349)
			p.Match(OBParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2350)
			p.Table_references()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_stmtContext is an interface to support dynamic dispatch.
type IUpdate_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Update_with_opt_hint() IUpdate_with_opt_hintContext
	Table_references() ITable_referencesContext
	SET() antlr.TerminalNode
	Update_asgn_list() IUpdate_asgn_listContext
	IGNORE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Opt_hint_value() IOpt_hint_valueContext
	Expr() IExprContext
	Order_by() IOrder_byContext
	Limit_clause() ILimit_clauseContext

	// IsUpdate_stmtContext differentiates from other interfaces.
	IsUpdate_stmtContext()
}

type Update_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_stmtContext() *Update_stmtContext {
	var p = new(Update_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_update_stmt
	return p
}

func InitEmptyUpdate_stmtContext(p *Update_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_update_stmt
}

func (*Update_stmtContext) IsUpdate_stmtContext() {}

func NewUpdate_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_stmtContext {
	var p = new(Update_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_update_stmt

	return p
}

func (s *Update_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_stmtContext) Update_with_opt_hint() IUpdate_with_opt_hintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_with_opt_hintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_with_opt_hintContext)
}

func (s *Update_stmtContext) Table_references() ITable_referencesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_referencesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_referencesContext)
}

func (s *Update_stmtContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Update_stmtContext) Update_asgn_list() IUpdate_asgn_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_asgn_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_asgn_listContext)
}

func (s *Update_stmtContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(OBParserIGNORE, 0)
}

func (s *Update_stmtContext) WHERE() antlr.TerminalNode {
	return s.GetToken(OBParserWHERE, 0)
}

func (s *Update_stmtContext) Opt_hint_value() IOpt_hint_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_hint_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_hint_valueContext)
}

func (s *Update_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Update_stmtContext) Order_by() IOrder_byContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_byContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_byContext)
}

func (s *Update_stmtContext) Limit_clause() ILimit_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimit_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimit_clauseContext)
}

func (s *Update_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUpdate_stmt(s)
	}
}

func (s *Update_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUpdate_stmt(s)
	}
}

func (s *Update_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUpdate_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Update_stmt() (localctx IUpdate_stmtContext) {
	localctx = NewUpdate_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, OBParserRULE_update_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2354)
		p.Update_with_opt_hint()
	}
	p.SetState(2356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserIGNORE {
		{
			p.SetState(2355)
			p.Match(OBParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2358)
		p.Table_references()
	}
	{
		p.SetState(2359)
		p.Match(OBParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2360)
		p.Update_asgn_list()
	}
	p.SetState(2365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserWHERE {
		{
			p.SetState(2361)
			p.Match(OBParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2362)
			p.Opt_hint_value()
		}
		{
			p.SetState(2363)
			p.expr(0)
		}

	}
	p.SetState(2368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserORDER {
		{
			p.SetState(2367)
			p.Order_by()
		}

	}
	p.SetState(2371)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserLIMIT {
		{
			p.SetState(2370)
			p.Limit_clause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_asgn_listContext is an interface to support dynamic dispatch.
type IUpdate_asgn_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUpdate_asgn_factor() []IUpdate_asgn_factorContext
	Update_asgn_factor(i int) IUpdate_asgn_factorContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsUpdate_asgn_listContext differentiates from other interfaces.
	IsUpdate_asgn_listContext()
}

type Update_asgn_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_asgn_listContext() *Update_asgn_listContext {
	var p = new(Update_asgn_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_update_asgn_list
	return p
}

func InitEmptyUpdate_asgn_listContext(p *Update_asgn_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_update_asgn_list
}

func (*Update_asgn_listContext) IsUpdate_asgn_listContext() {}

func NewUpdate_asgn_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_asgn_listContext {
	var p = new(Update_asgn_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_update_asgn_list

	return p
}

func (s *Update_asgn_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_asgn_listContext) AllUpdate_asgn_factor() []IUpdate_asgn_factorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdate_asgn_factorContext); ok {
			len++
		}
	}

	tst := make([]IUpdate_asgn_factorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdate_asgn_factorContext); ok {
			tst[i] = t.(IUpdate_asgn_factorContext)
			i++
		}
	}

	return tst
}

func (s *Update_asgn_listContext) Update_asgn_factor(i int) IUpdate_asgn_factorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_asgn_factorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_asgn_factorContext)
}

func (s *Update_asgn_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Update_asgn_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Update_asgn_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_asgn_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_asgn_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUpdate_asgn_list(s)
	}
}

func (s *Update_asgn_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUpdate_asgn_list(s)
	}
}

func (s *Update_asgn_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUpdate_asgn_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Update_asgn_list() (localctx IUpdate_asgn_listContext) {
	localctx = NewUpdate_asgn_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, OBParserRULE_update_asgn_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2373)
		p.Update_asgn_factor()
	}
	p.SetState(2378)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(2374)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2375)
			p.Update_asgn_factor()
		}

		p.SetState(2380)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_asgn_factorContext is an interface to support dynamic dispatch.
type IUpdate_asgn_factorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_definition_ref() IColumn_definition_refContext
	COMP_EQ() antlr.TerminalNode
	Expr_or_default() IExpr_or_defaultContext

	// IsUpdate_asgn_factorContext differentiates from other interfaces.
	IsUpdate_asgn_factorContext()
}

type Update_asgn_factorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_asgn_factorContext() *Update_asgn_factorContext {
	var p = new(Update_asgn_factorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_update_asgn_factor
	return p
}

func InitEmptyUpdate_asgn_factorContext(p *Update_asgn_factorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_update_asgn_factor
}

func (*Update_asgn_factorContext) IsUpdate_asgn_factorContext() {}

func NewUpdate_asgn_factorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_asgn_factorContext {
	var p = new(Update_asgn_factorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_update_asgn_factor

	return p
}

func (s *Update_asgn_factorContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_asgn_factorContext) Column_definition_ref() IColumn_definition_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_definition_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_definition_refContext)
}

func (s *Update_asgn_factorContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Update_asgn_factorContext) Expr_or_default() IExpr_or_defaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_or_defaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_or_defaultContext)
}

func (s *Update_asgn_factorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_asgn_factorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_asgn_factorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUpdate_asgn_factor(s)
	}
}

func (s *Update_asgn_factorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUpdate_asgn_factor(s)
	}
}

func (s *Update_asgn_factorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUpdate_asgn_factor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Update_asgn_factor() (localctx IUpdate_asgn_factorContext) {
	localctx = NewUpdate_asgn_factorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, OBParserRULE_update_asgn_factor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2381)
		p.Column_definition_ref()
	}
	{
		p.SetState(2382)
		p.Match(OBParserCOMP_EQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2383)
		p.Expr_or_default()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_resource_stmtContext is an interface to support dynamic dispatch.
type ICreate_resource_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	UNIT() antlr.TerminalNode
	Relation_name() IRelation_nameContext
	IF() antlr.TerminalNode
	Not() INotContext
	EXISTS() antlr.TerminalNode
	Resource_unit_option() IResource_unit_optionContext
	Opt_resource_unit_option_list() IOpt_resource_unit_option_listContext
	Comma() antlr.TerminalNode
	POOL() antlr.TerminalNode
	Create_resource_pool_option() ICreate_resource_pool_optionContext
	Opt_create_resource_pool_option_list() IOpt_create_resource_pool_option_listContext

	// IsCreate_resource_stmtContext differentiates from other interfaces.
	IsCreate_resource_stmtContext()
}

type Create_resource_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_resource_stmtContext() *Create_resource_stmtContext {
	var p = new(Create_resource_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_resource_stmt
	return p
}

func InitEmptyCreate_resource_stmtContext(p *Create_resource_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_resource_stmt
}

func (*Create_resource_stmtContext) IsCreate_resource_stmtContext() {}

func NewCreate_resource_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_resource_stmtContext {
	var p = new(Create_resource_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_create_resource_stmt

	return p
}

func (s *Create_resource_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_resource_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE, 0)
}

func (s *Create_resource_stmtContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(OBParserRESOURCE, 0)
}

func (s *Create_resource_stmtContext) UNIT() antlr.TerminalNode {
	return s.GetToken(OBParserUNIT, 0)
}

func (s *Create_resource_stmtContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Create_resource_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Create_resource_stmtContext) Not() INotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotContext)
}

func (s *Create_resource_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Create_resource_stmtContext) Resource_unit_option() IResource_unit_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResource_unit_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResource_unit_optionContext)
}

func (s *Create_resource_stmtContext) Opt_resource_unit_option_list() IOpt_resource_unit_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_resource_unit_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_resource_unit_option_listContext)
}

func (s *Create_resource_stmtContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Create_resource_stmtContext) POOL() antlr.TerminalNode {
	return s.GetToken(OBParserPOOL, 0)
}

func (s *Create_resource_stmtContext) Create_resource_pool_option() ICreate_resource_pool_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_resource_pool_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_resource_pool_optionContext)
}

func (s *Create_resource_stmtContext) Opt_create_resource_pool_option_list() IOpt_create_resource_pool_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_create_resource_pool_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_create_resource_pool_option_listContext)
}

func (s *Create_resource_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_resource_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_resource_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCreate_resource_stmt(s)
	}
}

func (s *Create_resource_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCreate_resource_stmt(s)
	}
}

func (s *Create_resource_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCreate_resource_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Create_resource_stmt() (localctx ICreate_resource_stmtContext) {
	localctx = NewCreate_resource_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, OBParserRULE_create_resource_stmt)
	var _la int

	p.SetState(2419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2385)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2386)
			p.Match(OBParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2387)
			p.Match(OBParserUNIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2392)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIF {
			{
				p.SetState(2388)
				p.Match(OBParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2389)
				p.Not()
			}
			{
				p.SetState(2390)
				p.Match(OBParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2394)
			p.Relation_name()
		}
		p.SetState(2400)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2395)
				p.Resource_unit_option()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(2396)
				p.opt_resource_unit_option_list(0)
			}
			{
				p.SetState(2397)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2398)
				p.Resource_unit_option()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2402)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2403)
			p.Match(OBParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2404)
			p.Match(OBParserPOOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2409)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIF {
			{
				p.SetState(2405)
				p.Match(OBParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2406)
				p.Not()
			}
			{
				p.SetState(2407)
				p.Match(OBParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2411)
			p.Relation_name()
		}
		p.SetState(2417)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2412)
				p.Create_resource_pool_option()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(2413)
				p.opt_create_resource_pool_option_list(0)
			}
			{
				p.SetState(2414)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2415)
				p.Create_resource_pool_option()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_resource_unit_option_listContext is an interface to support dynamic dispatch.
type IOpt_resource_unit_option_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Resource_unit_option() IResource_unit_optionContext
	Empty() IEmptyContext
	Opt_resource_unit_option_list() IOpt_resource_unit_option_listContext
	Comma() antlr.TerminalNode

	// IsOpt_resource_unit_option_listContext differentiates from other interfaces.
	IsOpt_resource_unit_option_listContext()
}

type Opt_resource_unit_option_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_resource_unit_option_listContext() *Opt_resource_unit_option_listContext {
	var p = new(Opt_resource_unit_option_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_resource_unit_option_list
	return p
}

func InitEmptyOpt_resource_unit_option_listContext(p *Opt_resource_unit_option_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_resource_unit_option_list
}

func (*Opt_resource_unit_option_listContext) IsOpt_resource_unit_option_listContext() {}

func NewOpt_resource_unit_option_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_resource_unit_option_listContext {
	var p = new(Opt_resource_unit_option_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_resource_unit_option_list

	return p
}

func (s *Opt_resource_unit_option_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_resource_unit_option_listContext) Resource_unit_option() IResource_unit_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResource_unit_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResource_unit_optionContext)
}

func (s *Opt_resource_unit_option_listContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Opt_resource_unit_option_listContext) Opt_resource_unit_option_list() IOpt_resource_unit_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_resource_unit_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_resource_unit_option_listContext)
}

func (s *Opt_resource_unit_option_listContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Opt_resource_unit_option_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_resource_unit_option_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_resource_unit_option_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_resource_unit_option_list(s)
	}
}

func (s *Opt_resource_unit_option_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_resource_unit_option_list(s)
	}
}

func (s *Opt_resource_unit_option_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_resource_unit_option_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_resource_unit_option_list() (localctx IOpt_resource_unit_option_listContext) {
	return p.opt_resource_unit_option_list(0)
}

func (p *OBParser) opt_resource_unit_option_list(_p int) (localctx IOpt_resource_unit_option_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewOpt_resource_unit_option_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IOpt_resource_unit_option_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 122
	p.EnterRecursionRule(localctx, 122, OBParserRULE_opt_resource_unit_option_list, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2424)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2422)
			p.Resource_unit_option()
		}

	case 2:
		{
			p.SetState(2423)
			p.Empty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewOpt_resource_unit_option_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, OBParserRULE_opt_resource_unit_option_list)
			p.SetState(2426)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(2427)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2428)
				p.Resource_unit_option()
			}

		}
		p.SetState(2433)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResource_unit_optionContext is an interface to support dynamic dispatch.
type IResource_unit_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MIN_CPU() antlr.TerminalNode
	Conf_const() IConf_constContext
	COMP_EQ() antlr.TerminalNode
	MIN_IOPS() antlr.TerminalNode
	MIN_MEMORY() antlr.TerminalNode
	MAX_CPU() antlr.TerminalNode
	MAX_MEMORY() antlr.TerminalNode
	MAX_IOPS() antlr.TerminalNode
	MAX_DISK_SIZE() antlr.TerminalNode
	MAX_SESSION_NUM() antlr.TerminalNode

	// IsResource_unit_optionContext differentiates from other interfaces.
	IsResource_unit_optionContext()
}

type Resource_unit_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResource_unit_optionContext() *Resource_unit_optionContext {
	var p = new(Resource_unit_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_resource_unit_option
	return p
}

func InitEmptyResource_unit_optionContext(p *Resource_unit_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_resource_unit_option
}

func (*Resource_unit_optionContext) IsResource_unit_optionContext() {}

func NewResource_unit_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Resource_unit_optionContext {
	var p = new(Resource_unit_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_resource_unit_option

	return p
}

func (s *Resource_unit_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Resource_unit_optionContext) MIN_CPU() antlr.TerminalNode {
	return s.GetToken(OBParserMIN_CPU, 0)
}

func (s *Resource_unit_optionContext) Conf_const() IConf_constContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConf_constContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConf_constContext)
}

func (s *Resource_unit_optionContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Resource_unit_optionContext) MIN_IOPS() antlr.TerminalNode {
	return s.GetToken(OBParserMIN_IOPS, 0)
}

func (s *Resource_unit_optionContext) MIN_MEMORY() antlr.TerminalNode {
	return s.GetToken(OBParserMIN_MEMORY, 0)
}

func (s *Resource_unit_optionContext) MAX_CPU() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_CPU, 0)
}

func (s *Resource_unit_optionContext) MAX_MEMORY() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_MEMORY, 0)
}

func (s *Resource_unit_optionContext) MAX_IOPS() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_IOPS, 0)
}

func (s *Resource_unit_optionContext) MAX_DISK_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_DISK_SIZE, 0)
}

func (s *Resource_unit_optionContext) MAX_SESSION_NUM() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_SESSION_NUM, 0)
}

func (s *Resource_unit_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Resource_unit_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Resource_unit_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterResource_unit_option(s)
	}
}

func (s *Resource_unit_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitResource_unit_option(s)
	}
}

func (s *Resource_unit_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitResource_unit_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Resource_unit_option() (localctx IResource_unit_optionContext) {
	localctx = NewResource_unit_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, OBParserRULE_resource_unit_option)
	var _la int

	p.SetState(2474)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserMIN_CPU:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2434)
			p.Match(OBParserMIN_CPU)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2435)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2438)
			p.Conf_const()
		}

	case OBParserMIN_IOPS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2439)
			p.Match(OBParserMIN_IOPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2441)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2440)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2443)
			p.Conf_const()
		}

	case OBParserMIN_MEMORY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2444)
			p.Match(OBParserMIN_MEMORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2446)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2445)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2448)
			p.Conf_const()
		}

	case OBParserMAX_CPU:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2449)
			p.Match(OBParserMAX_CPU)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2451)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2450)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2453)
			p.Conf_const()
		}

	case OBParserMAX_MEMORY:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2454)
			p.Match(OBParserMAX_MEMORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2456)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2455)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2458)
			p.Conf_const()
		}

	case OBParserMAX_IOPS:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2459)
			p.Match(OBParserMAX_IOPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2461)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2460)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2463)
			p.Conf_const()
		}

	case OBParserMAX_DISK_SIZE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2464)
			p.Match(OBParserMAX_DISK_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2466)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2465)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2468)
			p.Conf_const()
		}

	case OBParserMAX_SESSION_NUM:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2469)
			p.Match(OBParserMAX_SESSION_NUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2471)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2470)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2473)
			p.Conf_const()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_create_resource_pool_option_listContext is an interface to support dynamic dispatch.
type IOpt_create_resource_pool_option_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Create_resource_pool_option() ICreate_resource_pool_optionContext
	Empty() IEmptyContext
	Opt_create_resource_pool_option_list() IOpt_create_resource_pool_option_listContext
	Comma() antlr.TerminalNode

	// IsOpt_create_resource_pool_option_listContext differentiates from other interfaces.
	IsOpt_create_resource_pool_option_listContext()
}

type Opt_create_resource_pool_option_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_create_resource_pool_option_listContext() *Opt_create_resource_pool_option_listContext {
	var p = new(Opt_create_resource_pool_option_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_create_resource_pool_option_list
	return p
}

func InitEmptyOpt_create_resource_pool_option_listContext(p *Opt_create_resource_pool_option_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_create_resource_pool_option_list
}

func (*Opt_create_resource_pool_option_listContext) IsOpt_create_resource_pool_option_listContext() {}

func NewOpt_create_resource_pool_option_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_create_resource_pool_option_listContext {
	var p = new(Opt_create_resource_pool_option_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_create_resource_pool_option_list

	return p
}

func (s *Opt_create_resource_pool_option_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_create_resource_pool_option_listContext) Create_resource_pool_option() ICreate_resource_pool_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_resource_pool_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_resource_pool_optionContext)
}

func (s *Opt_create_resource_pool_option_listContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Opt_create_resource_pool_option_listContext) Opt_create_resource_pool_option_list() IOpt_create_resource_pool_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_create_resource_pool_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_create_resource_pool_option_listContext)
}

func (s *Opt_create_resource_pool_option_listContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Opt_create_resource_pool_option_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_create_resource_pool_option_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_create_resource_pool_option_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_create_resource_pool_option_list(s)
	}
}

func (s *Opt_create_resource_pool_option_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_create_resource_pool_option_list(s)
	}
}

func (s *Opt_create_resource_pool_option_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_create_resource_pool_option_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_create_resource_pool_option_list() (localctx IOpt_create_resource_pool_option_listContext) {
	return p.opt_create_resource_pool_option_list(0)
}

func (p *OBParser) opt_create_resource_pool_option_list(_p int) (localctx IOpt_create_resource_pool_option_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewOpt_create_resource_pool_option_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IOpt_create_resource_pool_option_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 126
	p.EnterRecursionRule(localctx, 126, OBParserRULE_opt_create_resource_pool_option_list, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2477)
			p.Create_resource_pool_option()
		}

	case 2:
		{
			p.SetState(2478)
			p.Empty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewOpt_create_resource_pool_option_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, OBParserRULE_opt_create_resource_pool_option_list)
			p.SetState(2481)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(2482)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2483)
				p.Create_resource_pool_option()
			}

		}
		p.SetState(2488)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_resource_pool_optionContext is an interface to support dynamic dispatch.
type ICreate_resource_pool_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNIT() antlr.TerminalNode
	Relation_name_or_string() IRelation_name_or_stringContext
	COMP_EQ() antlr.TerminalNode
	UNIT_NUM() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	ZONE_LIST() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Zone_list() IZone_listContext
	RightParen() antlr.TerminalNode
	REPLICA_TYPE() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	IS_TENANT_SYS_POOL() antlr.TerminalNode
	BOOL_VALUE() antlr.TerminalNode

	// IsCreate_resource_pool_optionContext differentiates from other interfaces.
	IsCreate_resource_pool_optionContext()
}

type Create_resource_pool_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_resource_pool_optionContext() *Create_resource_pool_optionContext {
	var p = new(Create_resource_pool_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_resource_pool_option
	return p
}

func InitEmptyCreate_resource_pool_optionContext(p *Create_resource_pool_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_resource_pool_option
}

func (*Create_resource_pool_optionContext) IsCreate_resource_pool_optionContext() {}

func NewCreate_resource_pool_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_resource_pool_optionContext {
	var p = new(Create_resource_pool_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_create_resource_pool_option

	return p
}

func (s *Create_resource_pool_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_resource_pool_optionContext) UNIT() antlr.TerminalNode {
	return s.GetToken(OBParserUNIT, 0)
}

func (s *Create_resource_pool_optionContext) Relation_name_or_string() IRelation_name_or_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_name_or_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_name_or_stringContext)
}

func (s *Create_resource_pool_optionContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Create_resource_pool_optionContext) UNIT_NUM() antlr.TerminalNode {
	return s.GetToken(OBParserUNIT_NUM, 0)
}

func (s *Create_resource_pool_optionContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Create_resource_pool_optionContext) ZONE_LIST() antlr.TerminalNode {
	return s.GetToken(OBParserZONE_LIST, 0)
}

func (s *Create_resource_pool_optionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Create_resource_pool_optionContext) Zone_list() IZone_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IZone_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IZone_listContext)
}

func (s *Create_resource_pool_optionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Create_resource_pool_optionContext) REPLICA_TYPE() antlr.TerminalNode {
	return s.GetToken(OBParserREPLICA_TYPE, 0)
}

func (s *Create_resource_pool_optionContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Create_resource_pool_optionContext) IS_TENANT_SYS_POOL() antlr.TerminalNode {
	return s.GetToken(OBParserIS_TENANT_SYS_POOL, 0)
}

func (s *Create_resource_pool_optionContext) BOOL_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserBOOL_VALUE, 0)
}

func (s *Create_resource_pool_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_resource_pool_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_resource_pool_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCreate_resource_pool_option(s)
	}
}

func (s *Create_resource_pool_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCreate_resource_pool_option(s)
	}
}

func (s *Create_resource_pool_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCreate_resource_pool_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Create_resource_pool_option() (localctx ICreate_resource_pool_optionContext) {
	localctx = NewCreate_resource_pool_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, OBParserRULE_create_resource_pool_option)
	var _la int

	p.SetState(2517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserUNIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2489)
			p.Match(OBParserUNIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2491)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2490)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2493)
			p.Relation_name_or_string()
		}

	case OBParserUNIT_NUM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2494)
			p.Match(OBParserUNIT_NUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2496)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2495)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2498)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserZONE_LIST:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2499)
			p.Match(OBParserZONE_LIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2501)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2500)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2503)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2504)
			p.Zone_list()
		}
		{
			p.SetState(2505)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserREPLICA_TYPE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2507)
			p.Match(OBParserREPLICA_TYPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2509)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2508)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2511)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserIS_TENANT_SYS_POOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2512)
			p.Match(OBParserIS_TENANT_SYS_POOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2514)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2513)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2516)
			p.Match(OBParserBOOL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_resource_pool_option_listContext is an interface to support dynamic dispatch.
type IAlter_resource_pool_option_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlter_resource_pool_option() []IAlter_resource_pool_optionContext
	Alter_resource_pool_option(i int) IAlter_resource_pool_optionContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsAlter_resource_pool_option_listContext differentiates from other interfaces.
	IsAlter_resource_pool_option_listContext()
}

type Alter_resource_pool_option_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_resource_pool_option_listContext() *Alter_resource_pool_option_listContext {
	var p = new(Alter_resource_pool_option_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_resource_pool_option_list
	return p
}

func InitEmptyAlter_resource_pool_option_listContext(p *Alter_resource_pool_option_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_resource_pool_option_list
}

func (*Alter_resource_pool_option_listContext) IsAlter_resource_pool_option_listContext() {}

func NewAlter_resource_pool_option_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_resource_pool_option_listContext {
	var p = new(Alter_resource_pool_option_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_resource_pool_option_list

	return p
}

func (s *Alter_resource_pool_option_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_resource_pool_option_listContext) AllAlter_resource_pool_option() []IAlter_resource_pool_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_resource_pool_optionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_resource_pool_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_resource_pool_optionContext); ok {
			tst[i] = t.(IAlter_resource_pool_optionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_resource_pool_option_listContext) Alter_resource_pool_option(i int) IAlter_resource_pool_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_resource_pool_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_resource_pool_optionContext)
}

func (s *Alter_resource_pool_option_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Alter_resource_pool_option_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Alter_resource_pool_option_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_resource_pool_option_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_resource_pool_option_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_resource_pool_option_list(s)
	}
}

func (s *Alter_resource_pool_option_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_resource_pool_option_list(s)
	}
}

func (s *Alter_resource_pool_option_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_resource_pool_option_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_resource_pool_option_list() (localctx IAlter_resource_pool_option_listContext) {
	localctx = NewAlter_resource_pool_option_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, OBParserRULE_alter_resource_pool_option_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2519)
		p.Alter_resource_pool_option()
	}
	p.SetState(2524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(2520)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2521)
			p.Alter_resource_pool_option()
		}

		p.SetState(2526)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnit_id_listContext is an interface to support dynamic dispatch.
type IUnit_id_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllINTNUM() []antlr.TerminalNode
	INTNUM(i int) antlr.TerminalNode
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsUnit_id_listContext differentiates from other interfaces.
	IsUnit_id_listContext()
}

type Unit_id_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnit_id_listContext() *Unit_id_listContext {
	var p = new(Unit_id_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_unit_id_list
	return p
}

func InitEmptyUnit_id_listContext(p *Unit_id_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_unit_id_list
}

func (*Unit_id_listContext) IsUnit_id_listContext() {}

func NewUnit_id_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unit_id_listContext {
	var p = new(Unit_id_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_unit_id_list

	return p
}

func (s *Unit_id_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Unit_id_listContext) AllINTNUM() []antlr.TerminalNode {
	return s.GetTokens(OBParserINTNUM)
}

func (s *Unit_id_listContext) INTNUM(i int) antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, i)
}

func (s *Unit_id_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Unit_id_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Unit_id_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unit_id_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unit_id_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUnit_id_list(s)
	}
}

func (s *Unit_id_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUnit_id_list(s)
	}
}

func (s *Unit_id_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUnit_id_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Unit_id_list() (localctx IUnit_id_listContext) {
	localctx = NewUnit_id_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, OBParserRULE_unit_id_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2527)
		p.Match(OBParserINTNUM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2532)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(2528)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2529)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2534)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_resource_pool_optionContext is an interface to support dynamic dispatch.
type IAlter_resource_pool_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNIT() antlr.TerminalNode
	Relation_name_or_string() IRelation_name_or_stringContext
	COMP_EQ() antlr.TerminalNode
	UNIT_NUM() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	Opt_equal_mark() IOpt_equal_markContext
	LeftParen() antlr.TerminalNode
	Unit_id_list() IUnit_id_listContext
	RightParen() antlr.TerminalNode
	ZONE_LIST() antlr.TerminalNode
	Zone_list() IZone_listContext

	// IsAlter_resource_pool_optionContext differentiates from other interfaces.
	IsAlter_resource_pool_optionContext()
}

type Alter_resource_pool_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_resource_pool_optionContext() *Alter_resource_pool_optionContext {
	var p = new(Alter_resource_pool_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_resource_pool_option
	return p
}

func InitEmptyAlter_resource_pool_optionContext(p *Alter_resource_pool_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_resource_pool_option
}

func (*Alter_resource_pool_optionContext) IsAlter_resource_pool_optionContext() {}

func NewAlter_resource_pool_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_resource_pool_optionContext {
	var p = new(Alter_resource_pool_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_resource_pool_option

	return p
}

func (s *Alter_resource_pool_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_resource_pool_optionContext) UNIT() antlr.TerminalNode {
	return s.GetToken(OBParserUNIT, 0)
}

func (s *Alter_resource_pool_optionContext) Relation_name_or_string() IRelation_name_or_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_name_or_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_name_or_stringContext)
}

func (s *Alter_resource_pool_optionContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Alter_resource_pool_optionContext) UNIT_NUM() antlr.TerminalNode {
	return s.GetToken(OBParserUNIT_NUM, 0)
}

func (s *Alter_resource_pool_optionContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Alter_resource_pool_optionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(OBParserDELETE, 0)
}

func (s *Alter_resource_pool_optionContext) Opt_equal_mark() IOpt_equal_markContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_equal_markContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_equal_markContext)
}

func (s *Alter_resource_pool_optionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Alter_resource_pool_optionContext) Unit_id_list() IUnit_id_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnit_id_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnit_id_listContext)
}

func (s *Alter_resource_pool_optionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Alter_resource_pool_optionContext) ZONE_LIST() antlr.TerminalNode {
	return s.GetToken(OBParserZONE_LIST, 0)
}

func (s *Alter_resource_pool_optionContext) Zone_list() IZone_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IZone_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IZone_listContext)
}

func (s *Alter_resource_pool_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_resource_pool_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_resource_pool_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_resource_pool_option(s)
	}
}

func (s *Alter_resource_pool_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_resource_pool_option(s)
	}
}

func (s *Alter_resource_pool_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_resource_pool_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_resource_pool_option() (localctx IAlter_resource_pool_optionContext) {
	localctx = NewAlter_resource_pool_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, OBParserRULE_alter_resource_pool_option)
	var _la int

	p.SetState(2562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserUNIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2535)
			p.Match(OBParserUNIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2537)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2536)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2539)
			p.Relation_name_or_string()
		}

	case OBParserUNIT_NUM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2540)
			p.Match(OBParserUNIT_NUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2541)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2544)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserDELETE {
			{
				p.SetState(2545)
				p.Match(OBParserDELETE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2546)
				p.Match(OBParserUNIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2547)
				p.Opt_equal_mark()
			}
			{
				p.SetState(2548)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2549)
				p.Unit_id_list()
			}
			{
				p.SetState(2550)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case OBParserZONE_LIST:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2554)
			p.Match(OBParserZONE_LIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2556)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2555)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2558)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2559)
			p.Zone_list()
		}
		{
			p.SetState(2560)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_resource_stmtContext is an interface to support dynamic dispatch.
type IAlter_resource_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	UNIT() antlr.TerminalNode
	Relation_name() IRelation_nameContext
	Resource_unit_option() IResource_unit_optionContext
	Opt_resource_unit_option_list() IOpt_resource_unit_option_listContext
	Comma() antlr.TerminalNode
	POOL() antlr.TerminalNode
	Alter_resource_pool_option_list() IAlter_resource_pool_option_listContext
	SPLIT() antlr.TerminalNode
	INTO() antlr.TerminalNode
	AllLeftParen() []antlr.TerminalNode
	LeftParen(i int) antlr.TerminalNode
	Resource_pool_list() IResource_pool_listContext
	AllRightParen() []antlr.TerminalNode
	RightParen(i int) antlr.TerminalNode
	ON() antlr.TerminalNode
	Zone_list() IZone_listContext

	// IsAlter_resource_stmtContext differentiates from other interfaces.
	IsAlter_resource_stmtContext()
}

type Alter_resource_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_resource_stmtContext() *Alter_resource_stmtContext {
	var p = new(Alter_resource_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_resource_stmt
	return p
}

func InitEmptyAlter_resource_stmtContext(p *Alter_resource_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_resource_stmt
}

func (*Alter_resource_stmtContext) IsAlter_resource_stmtContext() {}

func NewAlter_resource_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_resource_stmtContext {
	var p = new(Alter_resource_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_resource_stmt

	return p
}

func (s *Alter_resource_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_resource_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(OBParserALTER, 0)
}

func (s *Alter_resource_stmtContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(OBParserRESOURCE, 0)
}

func (s *Alter_resource_stmtContext) UNIT() antlr.TerminalNode {
	return s.GetToken(OBParserUNIT, 0)
}

func (s *Alter_resource_stmtContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Alter_resource_stmtContext) Resource_unit_option() IResource_unit_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResource_unit_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResource_unit_optionContext)
}

func (s *Alter_resource_stmtContext) Opt_resource_unit_option_list() IOpt_resource_unit_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_resource_unit_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_resource_unit_option_listContext)
}

func (s *Alter_resource_stmtContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Alter_resource_stmtContext) POOL() antlr.TerminalNode {
	return s.GetToken(OBParserPOOL, 0)
}

func (s *Alter_resource_stmtContext) Alter_resource_pool_option_list() IAlter_resource_pool_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_resource_pool_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_resource_pool_option_listContext)
}

func (s *Alter_resource_stmtContext) SPLIT() antlr.TerminalNode {
	return s.GetToken(OBParserSPLIT, 0)
}

func (s *Alter_resource_stmtContext) INTO() antlr.TerminalNode {
	return s.GetToken(OBParserINTO, 0)
}

func (s *Alter_resource_stmtContext) AllLeftParen() []antlr.TerminalNode {
	return s.GetTokens(OBParserLeftParen)
}

func (s *Alter_resource_stmtContext) LeftParen(i int) antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, i)
}

func (s *Alter_resource_stmtContext) Resource_pool_list() IResource_pool_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResource_pool_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResource_pool_listContext)
}

func (s *Alter_resource_stmtContext) AllRightParen() []antlr.TerminalNode {
	return s.GetTokens(OBParserRightParen)
}

func (s *Alter_resource_stmtContext) RightParen(i int) antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, i)
}

func (s *Alter_resource_stmtContext) ON() antlr.TerminalNode {
	return s.GetToken(OBParserON, 0)
}

func (s *Alter_resource_stmtContext) Zone_list() IZone_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IZone_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IZone_listContext)
}

func (s *Alter_resource_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_resource_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_resource_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_resource_stmt(s)
	}
}

func (s *Alter_resource_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_resource_stmt(s)
	}
}

func (s *Alter_resource_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_resource_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_resource_stmt() (localctx IAlter_resource_stmtContext) {
	localctx = NewAlter_resource_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, OBParserRULE_alter_resource_stmt)
	p.SetState(2595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2564)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2565)
			p.Match(OBParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2566)
			p.Match(OBParserUNIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2567)
			p.Relation_name()
		}
		p.SetState(2573)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2568)
				p.Resource_unit_option()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(2569)
				p.opt_resource_unit_option_list(0)
			}
			{
				p.SetState(2570)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2571)
				p.Resource_unit_option()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2575)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2576)
			p.Match(OBParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2577)
			p.Match(OBParserPOOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2578)
			p.Relation_name()
		}
		{
			p.SetState(2579)
			p.Alter_resource_pool_option_list()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2581)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2582)
			p.Match(OBParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2583)
			p.Match(OBParserPOOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2584)
			p.Relation_name()
		}
		{
			p.SetState(2585)
			p.Match(OBParserSPLIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2586)
			p.Match(OBParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2587)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2588)
			p.Resource_pool_list()
		}
		{
			p.SetState(2589)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2590)
			p.Match(OBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2591)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2592)
			p.Zone_list()
		}
		{
			p.SetState(2593)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_resource_stmtContext is an interface to support dynamic dispatch.
type IDrop_resource_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	UNIT() antlr.TerminalNode
	Relation_name() IRelation_nameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	POOL() antlr.TerminalNode

	// IsDrop_resource_stmtContext differentiates from other interfaces.
	IsDrop_resource_stmtContext()
}

type Drop_resource_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_resource_stmtContext() *Drop_resource_stmtContext {
	var p = new(Drop_resource_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_resource_stmt
	return p
}

func InitEmptyDrop_resource_stmtContext(p *Drop_resource_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_resource_stmt
}

func (*Drop_resource_stmtContext) IsDrop_resource_stmtContext() {}

func NewDrop_resource_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_resource_stmtContext {
	var p = new(Drop_resource_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_drop_resource_stmt

	return p
}

func (s *Drop_resource_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_resource_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Drop_resource_stmtContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(OBParserRESOURCE, 0)
}

func (s *Drop_resource_stmtContext) UNIT() antlr.TerminalNode {
	return s.GetToken(OBParserUNIT, 0)
}

func (s *Drop_resource_stmtContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Drop_resource_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Drop_resource_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Drop_resource_stmtContext) POOL() antlr.TerminalNode {
	return s.GetToken(OBParserPOOL, 0)
}

func (s *Drop_resource_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_resource_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_resource_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDrop_resource_stmt(s)
	}
}

func (s *Drop_resource_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDrop_resource_stmt(s)
	}
}

func (s *Drop_resource_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDrop_resource_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Drop_resource_stmt() (localctx IDrop_resource_stmtContext) {
	localctx = NewDrop_resource_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, OBParserRULE_drop_resource_stmt)
	var _la int

	p.SetState(2613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2597)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2598)
			p.Match(OBParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2599)
			p.Match(OBParserUNIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2602)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIF {
			{
				p.SetState(2600)
				p.Match(OBParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2601)
				p.Match(OBParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2604)
			p.Relation_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2605)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2606)
			p.Match(OBParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2607)
			p.Match(OBParserPOOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2610)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIF {
			{
				p.SetState(2608)
				p.Match(OBParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2609)
				p.Match(OBParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2612)
			p.Relation_name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_tenant_stmtContext is an interface to support dynamic dispatch.
type ICreate_tenant_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TENANT() antlr.TerminalNode
	Relation_name() IRelation_nameContext
	IF() antlr.TerminalNode
	Not() INotContext
	EXISTS() antlr.TerminalNode
	Tenant_option() ITenant_optionContext
	Opt_tenant_option_list() IOpt_tenant_option_listContext
	Comma() antlr.TerminalNode
	SET() antlr.TerminalNode
	Sys_var_and_val_list() ISys_var_and_val_listContext
	VARIABLES() antlr.TerminalNode

	// IsCreate_tenant_stmtContext differentiates from other interfaces.
	IsCreate_tenant_stmtContext()
}

type Create_tenant_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_tenant_stmtContext() *Create_tenant_stmtContext {
	var p = new(Create_tenant_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_tenant_stmt
	return p
}

func InitEmptyCreate_tenant_stmtContext(p *Create_tenant_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_tenant_stmt
}

func (*Create_tenant_stmtContext) IsCreate_tenant_stmtContext() {}

func NewCreate_tenant_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_tenant_stmtContext {
	var p = new(Create_tenant_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_create_tenant_stmt

	return p
}

func (s *Create_tenant_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_tenant_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE, 0)
}

func (s *Create_tenant_stmtContext) TENANT() antlr.TerminalNode {
	return s.GetToken(OBParserTENANT, 0)
}

func (s *Create_tenant_stmtContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Create_tenant_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Create_tenant_stmtContext) Not() INotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotContext)
}

func (s *Create_tenant_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Create_tenant_stmtContext) Tenant_option() ITenant_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITenant_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITenant_optionContext)
}

func (s *Create_tenant_stmtContext) Opt_tenant_option_list() IOpt_tenant_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_tenant_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_tenant_option_listContext)
}

func (s *Create_tenant_stmtContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Create_tenant_stmtContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Create_tenant_stmtContext) Sys_var_and_val_list() ISys_var_and_val_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISys_var_and_val_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISys_var_and_val_listContext)
}

func (s *Create_tenant_stmtContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(OBParserVARIABLES, 0)
}

func (s *Create_tenant_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_tenant_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_tenant_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCreate_tenant_stmt(s)
	}
}

func (s *Create_tenant_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCreate_tenant_stmt(s)
	}
}

func (s *Create_tenant_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCreate_tenant_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Create_tenant_stmt() (localctx ICreate_tenant_stmtContext) {
	localctx = NewCreate_tenant_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, OBParserRULE_create_tenant_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2615)
		p.Match(OBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2616)
		p.Match(OBParserTENANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserIF {
		{
			p.SetState(2617)
			p.Match(OBParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2618)
			p.Not()
		}
		{
			p.SetState(2619)
			p.Match(OBParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2623)
		p.Relation_name()
	}
	p.SetState(2629)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2624)
			p.Tenant_option()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(2625)
			p.opt_tenant_option_list(0)
		}
		{
			p.SetState(2626)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2627)
			p.Tenant_option()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2638)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2631)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2632)
			p.Sys_var_and_val_list()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(2633)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2634)
			p.Match(OBParserVARIABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2635)
			p.Sys_var_and_val_list()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(2636)
			p.Match(OBParserVARIABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2637)
			p.Sys_var_and_val_list()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_tenant_option_listContext is an interface to support dynamic dispatch.
type IOpt_tenant_option_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Tenant_option() ITenant_optionContext
	Empty() IEmptyContext
	Opt_tenant_option_list() IOpt_tenant_option_listContext
	Comma() antlr.TerminalNode

	// IsOpt_tenant_option_listContext differentiates from other interfaces.
	IsOpt_tenant_option_listContext()
}

type Opt_tenant_option_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_tenant_option_listContext() *Opt_tenant_option_listContext {
	var p = new(Opt_tenant_option_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_tenant_option_list
	return p
}

func InitEmptyOpt_tenant_option_listContext(p *Opt_tenant_option_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_tenant_option_list
}

func (*Opt_tenant_option_listContext) IsOpt_tenant_option_listContext() {}

func NewOpt_tenant_option_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_tenant_option_listContext {
	var p = new(Opt_tenant_option_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_tenant_option_list

	return p
}

func (s *Opt_tenant_option_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_tenant_option_listContext) Tenant_option() ITenant_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITenant_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITenant_optionContext)
}

func (s *Opt_tenant_option_listContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Opt_tenant_option_listContext) Opt_tenant_option_list() IOpt_tenant_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_tenant_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_tenant_option_listContext)
}

func (s *Opt_tenant_option_listContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Opt_tenant_option_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_tenant_option_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_tenant_option_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_tenant_option_list(s)
	}
}

func (s *Opt_tenant_option_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_tenant_option_list(s)
	}
}

func (s *Opt_tenant_option_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_tenant_option_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_tenant_option_list() (localctx IOpt_tenant_option_listContext) {
	return p.opt_tenant_option_list(0)
}

func (p *OBParser) opt_tenant_option_list(_p int) (localctx IOpt_tenant_option_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewOpt_tenant_option_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IOpt_tenant_option_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 142
	p.EnterRecursionRule(localctx, 142, OBParserRULE_opt_tenant_option_list, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 137, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2641)
			p.Tenant_option()
		}

	case 2:
		{
			p.SetState(2642)
			p.Empty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2650)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewOpt_tenant_option_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, OBParserRULE_opt_tenant_option_list)
			p.SetState(2645)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(2646)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2647)
				p.Tenant_option()
			}

		}
		p.SetState(2652)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITenant_optionContext is an interface to support dynamic dispatch.
type ITenant_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOGONLY_REPLICA_NUM() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode
	LOCALITY() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	REPLICA_NUM() antlr.TerminalNode
	REWRITE_MERGE_VERSION() antlr.TerminalNode
	STORAGE_FORMAT_VERSION() antlr.TerminalNode
	STORAGE_FORMAT_WORK_VERSION() antlr.TerminalNode
	PRIMARY_ZONE() antlr.TerminalNode
	Primary_zone_name() IPrimary_zone_nameContext
	RESOURCE_POOL_LIST() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Resource_pool_list() IResource_pool_listContext
	RightParen() antlr.TerminalNode
	ZONE_LIST() antlr.TerminalNode
	Zone_list() IZone_listContext
	Charset_key() ICharset_keyContext
	Charset_name() ICharset_nameContext
	COLLATE() antlr.TerminalNode
	Collation_name() ICollation_nameContext
	Read_only_or_write() IRead_only_or_writeContext
	COMMENT() antlr.TerminalNode
	Default_tablegroup() IDefault_tablegroupContext
	PROGRESSIVE_MERGE_NUM() antlr.TerminalNode

	// IsTenant_optionContext differentiates from other interfaces.
	IsTenant_optionContext()
}

type Tenant_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTenant_optionContext() *Tenant_optionContext {
	var p = new(Tenant_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tenant_option
	return p
}

func InitEmptyTenant_optionContext(p *Tenant_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tenant_option
}

func (*Tenant_optionContext) IsTenant_optionContext() {}

func NewTenant_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tenant_optionContext {
	var p = new(Tenant_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tenant_option

	return p
}

func (s *Tenant_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tenant_optionContext) LOGONLY_REPLICA_NUM() antlr.TerminalNode {
	return s.GetToken(OBParserLOGONLY_REPLICA_NUM, 0)
}

func (s *Tenant_optionContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Tenant_optionContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Tenant_optionContext) LOCALITY() antlr.TerminalNode {
	return s.GetToken(OBParserLOCALITY, 0)
}

func (s *Tenant_optionContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Tenant_optionContext) FORCE() antlr.TerminalNode {
	return s.GetToken(OBParserFORCE, 0)
}

func (s *Tenant_optionContext) REPLICA_NUM() antlr.TerminalNode {
	return s.GetToken(OBParserREPLICA_NUM, 0)
}

func (s *Tenant_optionContext) REWRITE_MERGE_VERSION() antlr.TerminalNode {
	return s.GetToken(OBParserREWRITE_MERGE_VERSION, 0)
}

func (s *Tenant_optionContext) STORAGE_FORMAT_VERSION() antlr.TerminalNode {
	return s.GetToken(OBParserSTORAGE_FORMAT_VERSION, 0)
}

func (s *Tenant_optionContext) STORAGE_FORMAT_WORK_VERSION() antlr.TerminalNode {
	return s.GetToken(OBParserSTORAGE_FORMAT_WORK_VERSION, 0)
}

func (s *Tenant_optionContext) PRIMARY_ZONE() antlr.TerminalNode {
	return s.GetToken(OBParserPRIMARY_ZONE, 0)
}

func (s *Tenant_optionContext) Primary_zone_name() IPrimary_zone_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimary_zone_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimary_zone_nameContext)
}

func (s *Tenant_optionContext) RESOURCE_POOL_LIST() antlr.TerminalNode {
	return s.GetToken(OBParserRESOURCE_POOL_LIST, 0)
}

func (s *Tenant_optionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Tenant_optionContext) Resource_pool_list() IResource_pool_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResource_pool_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResource_pool_listContext)
}

func (s *Tenant_optionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Tenant_optionContext) ZONE_LIST() antlr.TerminalNode {
	return s.GetToken(OBParserZONE_LIST, 0)
}

func (s *Tenant_optionContext) Zone_list() IZone_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IZone_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IZone_listContext)
}

func (s *Tenant_optionContext) Charset_key() ICharset_keyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_keyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_keyContext)
}

func (s *Tenant_optionContext) Charset_name() ICharset_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_nameContext)
}

func (s *Tenant_optionContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(OBParserCOLLATE, 0)
}

func (s *Tenant_optionContext) Collation_name() ICollation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollation_nameContext)
}

func (s *Tenant_optionContext) Read_only_or_write() IRead_only_or_writeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRead_only_or_writeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRead_only_or_writeContext)
}

func (s *Tenant_optionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(OBParserCOMMENT, 0)
}

func (s *Tenant_optionContext) Default_tablegroup() IDefault_tablegroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefault_tablegroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefault_tablegroupContext)
}

func (s *Tenant_optionContext) PROGRESSIVE_MERGE_NUM() antlr.TerminalNode {
	return s.GetToken(OBParserPROGRESSIVE_MERGE_NUM, 0)
}

func (s *Tenant_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tenant_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tenant_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTenant_option(s)
	}
}

func (s *Tenant_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTenant_option(s)
	}
}

func (s *Tenant_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTenant_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tenant_option() (localctx ITenant_optionContext) {
	localctx = NewTenant_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, OBParserRULE_tenant_option)
	var _la int

	p.SetState(2730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserLOGONLY_REPLICA_NUM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2653)
			p.Match(OBParserLOGONLY_REPLICA_NUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2655)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2654)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2657)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserLOCALITY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2658)
			p.Match(OBParserLOCALITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2660)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2659)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2662)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2664)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2663)
				p.Match(OBParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case OBParserREPLICA_NUM:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2666)
			p.Match(OBParserREPLICA_NUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2668)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2667)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2670)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserREWRITE_MERGE_VERSION:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2671)
			p.Match(OBParserREWRITE_MERGE_VERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2673)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2672)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2675)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserSTORAGE_FORMAT_VERSION:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2676)
			p.Match(OBParserSTORAGE_FORMAT_VERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2678)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2677)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2680)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserSTORAGE_FORMAT_WORK_VERSION:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2681)
			p.Match(OBParserSTORAGE_FORMAT_WORK_VERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2683)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2682)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2685)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserPRIMARY_ZONE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2686)
			p.Match(OBParserPRIMARY_ZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2688)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2687)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2690)
			p.Primary_zone_name()
		}

	case OBParserRESOURCE_POOL_LIST:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2691)
			p.Match(OBParserRESOURCE_POOL_LIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2693)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2692)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2695)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2696)
			p.Resource_pool_list()
		}
		{
			p.SetState(2697)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserZONE_LIST:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2699)
			p.Match(OBParserZONE_LIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2701)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2700)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2703)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2704)
			p.Zone_list()
		}
		{
			p.SetState(2705)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserCHARACTER, OBParserCHARSET:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2707)
			p.Charset_key()
		}
		p.SetState(2709)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2708)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2711)
			p.Charset_name()
		}

	case OBParserCOLLATE:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2713)
			p.Match(OBParserCOLLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2715)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2714)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2717)
			p.Collation_name()
		}

	case OBParserREAD:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2718)
			p.Read_only_or_write()
		}

	case OBParserCOMMENT:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2719)
			p.Match(OBParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2721)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2720)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2723)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserDEFAULT, OBParserTABLEGROUP:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2724)
			p.Default_tablegroup()
		}

	case OBParserPROGRESSIVE_MERGE_NUM:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2725)
			p.Match(OBParserPROGRESSIVE_MERGE_NUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2726)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2729)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IZone_listContext is an interface to support dynamic dispatch.
type IZone_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_VALUE() []antlr.TerminalNode
	STRING_VALUE(i int) antlr.TerminalNode
	AllOpt_comma() []IOpt_commaContext
	Opt_comma(i int) IOpt_commaContext

	// IsZone_listContext differentiates from other interfaces.
	IsZone_listContext()
}

type Zone_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyZone_listContext() *Zone_listContext {
	var p = new(Zone_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_zone_list
	return p
}

func InitEmptyZone_listContext(p *Zone_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_zone_list
}

func (*Zone_listContext) IsZone_listContext() {}

func NewZone_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Zone_listContext {
	var p = new(Zone_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_zone_list

	return p
}

func (s *Zone_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Zone_listContext) AllSTRING_VALUE() []antlr.TerminalNode {
	return s.GetTokens(OBParserSTRING_VALUE)
}

func (s *Zone_listContext) STRING_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, i)
}

func (s *Zone_listContext) AllOpt_comma() []IOpt_commaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOpt_commaContext); ok {
			len++
		}
	}

	tst := make([]IOpt_commaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOpt_commaContext); ok {
			tst[i] = t.(IOpt_commaContext)
			i++
		}
	}

	return tst
}

func (s *Zone_listContext) Opt_comma(i int) IOpt_commaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_commaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_commaContext)
}

func (s *Zone_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Zone_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Zone_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterZone_list(s)
	}
}

func (s *Zone_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitZone_list(s)
	}
}

func (s *Zone_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitZone_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Zone_list() (localctx IZone_listContext) {
	localctx = NewZone_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, OBParserRULE_zone_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2732)
		p.Match(OBParserSTRING_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2738)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma || _la == OBParserSTRING_VALUE {
		{
			p.SetState(2733)
			p.Opt_comma()
		}
		{
			p.SetState(2734)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2740)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResource_pool_listContext is an interface to support dynamic dispatch.
type IResource_pool_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_VALUE() []antlr.TerminalNode
	STRING_VALUE(i int) antlr.TerminalNode
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsResource_pool_listContext differentiates from other interfaces.
	IsResource_pool_listContext()
}

type Resource_pool_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResource_pool_listContext() *Resource_pool_listContext {
	var p = new(Resource_pool_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_resource_pool_list
	return p
}

func InitEmptyResource_pool_listContext(p *Resource_pool_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_resource_pool_list
}

func (*Resource_pool_listContext) IsResource_pool_listContext() {}

func NewResource_pool_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Resource_pool_listContext {
	var p = new(Resource_pool_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_resource_pool_list

	return p
}

func (s *Resource_pool_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Resource_pool_listContext) AllSTRING_VALUE() []antlr.TerminalNode {
	return s.GetTokens(OBParserSTRING_VALUE)
}

func (s *Resource_pool_listContext) STRING_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, i)
}

func (s *Resource_pool_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Resource_pool_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Resource_pool_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Resource_pool_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Resource_pool_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterResource_pool_list(s)
	}
}

func (s *Resource_pool_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitResource_pool_list(s)
	}
}

func (s *Resource_pool_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitResource_pool_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Resource_pool_list() (localctx IResource_pool_listContext) {
	localctx = NewResource_pool_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, OBParserRULE_resource_pool_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2741)
		p.Match(OBParserSTRING_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(2742)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2743)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2748)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_tenant_stmtContext is an interface to support dynamic dispatch.
type IAlter_tenant_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	TENANT() antlr.TerminalNode
	AllRelation_name() []IRelation_nameContext
	Relation_name(i int) IRelation_nameContext
	SET() antlr.TerminalNode
	Tenant_option() ITenant_optionContext
	VARIABLES() antlr.TerminalNode
	Sys_var_and_val_list() ISys_var_and_val_listContext
	Opt_tenant_option_list() IOpt_tenant_option_listContext
	Comma() antlr.TerminalNode
	ALL() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	GLOBAL_NAME() antlr.TerminalNode
	TO() antlr.TerminalNode
	Lock_spec_mysql57() ILock_spec_mysql57Context

	// IsAlter_tenant_stmtContext differentiates from other interfaces.
	IsAlter_tenant_stmtContext()
}

type Alter_tenant_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_tenant_stmtContext() *Alter_tenant_stmtContext {
	var p = new(Alter_tenant_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tenant_stmt
	return p
}

func InitEmptyAlter_tenant_stmtContext(p *Alter_tenant_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tenant_stmt
}

func (*Alter_tenant_stmtContext) IsAlter_tenant_stmtContext() {}

func NewAlter_tenant_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_tenant_stmtContext {
	var p = new(Alter_tenant_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_tenant_stmt

	return p
}

func (s *Alter_tenant_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_tenant_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(OBParserALTER, 0)
}

func (s *Alter_tenant_stmtContext) TENANT() antlr.TerminalNode {
	return s.GetToken(OBParserTENANT, 0)
}

func (s *Alter_tenant_stmtContext) AllRelation_name() []IRelation_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_nameContext); ok {
			len++
		}
	}

	tst := make([]IRelation_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_nameContext); ok {
			tst[i] = t.(IRelation_nameContext)
			i++
		}
	}

	return tst
}

func (s *Alter_tenant_stmtContext) Relation_name(i int) IRelation_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Alter_tenant_stmtContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Alter_tenant_stmtContext) Tenant_option() ITenant_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITenant_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITenant_optionContext)
}

func (s *Alter_tenant_stmtContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(OBParserVARIABLES, 0)
}

func (s *Alter_tenant_stmtContext) Sys_var_and_val_list() ISys_var_and_val_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISys_var_and_val_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISys_var_and_val_listContext)
}

func (s *Alter_tenant_stmtContext) Opt_tenant_option_list() IOpt_tenant_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_tenant_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_tenant_option_listContext)
}

func (s *Alter_tenant_stmtContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Alter_tenant_stmtContext) ALL() antlr.TerminalNode {
	return s.GetToken(OBParserALL, 0)
}

func (s *Alter_tenant_stmtContext) RENAME() antlr.TerminalNode {
	return s.GetToken(OBParserRENAME, 0)
}

func (s *Alter_tenant_stmtContext) GLOBAL_NAME() antlr.TerminalNode {
	return s.GetToken(OBParserGLOBAL_NAME, 0)
}

func (s *Alter_tenant_stmtContext) TO() antlr.TerminalNode {
	return s.GetToken(OBParserTO, 0)
}

func (s *Alter_tenant_stmtContext) Lock_spec_mysql57() ILock_spec_mysql57Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILock_spec_mysql57Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILock_spec_mysql57Context)
}

func (s *Alter_tenant_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_tenant_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_tenant_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_tenant_stmt(s)
	}
}

func (s *Alter_tenant_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_tenant_stmt(s)
	}
}

func (s *Alter_tenant_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_tenant_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_tenant_stmt() (localctx IAlter_tenant_stmtContext) {
	localctx = NewAlter_tenant_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, OBParserRULE_alter_tenant_stmt)
	var _la int

	p.SetState(2796)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2749)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2750)
			p.Match(OBParserTENANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2751)
			p.Relation_name()
		}
		p.SetState(2753)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2752)
				p.Match(OBParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2760)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2755)
				p.Tenant_option()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(2756)
				p.opt_tenant_option_list(0)
			}
			{
				p.SetState(2757)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2758)
				p.Tenant_option()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2764)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserVARIABLES {
			{
				p.SetState(2762)
				p.Match(OBParserVARIABLES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2763)
				p.Sys_var_and_val_list()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2766)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2767)
			p.Match(OBParserTENANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2768)
			p.Match(OBParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2770)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2769)
				p.Match(OBParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2777)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 160, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2772)
				p.Tenant_option()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 160, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(2773)
				p.opt_tenant_option_list(0)
			}
			{
				p.SetState(2774)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2775)
				p.Tenant_option()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2781)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserVARIABLES {
			{
				p.SetState(2779)
				p.Match(OBParserVARIABLES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2780)
				p.Sys_var_and_val_list()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2783)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2784)
			p.Match(OBParserTENANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2785)
			p.Relation_name()
		}
		{
			p.SetState(2786)
			p.Match(OBParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2787)
			p.Match(OBParserGLOBAL_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2788)
			p.Match(OBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2789)
			p.Relation_name()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2791)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2792)
			p.Match(OBParserTENANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2793)
			p.Relation_name()
		}
		{
			p.SetState(2794)
			p.Lock_spec_mysql57()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_tenant_stmtContext is an interface to support dynamic dispatch.
type IDrop_tenant_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TENANT() antlr.TerminalNode
	Relation_name() IRelation_nameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	FORCE() antlr.TerminalNode

	// IsDrop_tenant_stmtContext differentiates from other interfaces.
	IsDrop_tenant_stmtContext()
}

type Drop_tenant_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_tenant_stmtContext() *Drop_tenant_stmtContext {
	var p = new(Drop_tenant_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_tenant_stmt
	return p
}

func InitEmptyDrop_tenant_stmtContext(p *Drop_tenant_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_tenant_stmt
}

func (*Drop_tenant_stmtContext) IsDrop_tenant_stmtContext() {}

func NewDrop_tenant_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_tenant_stmtContext {
	var p = new(Drop_tenant_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_drop_tenant_stmt

	return p
}

func (s *Drop_tenant_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_tenant_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Drop_tenant_stmtContext) TENANT() antlr.TerminalNode {
	return s.GetToken(OBParserTENANT, 0)
}

func (s *Drop_tenant_stmtContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Drop_tenant_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Drop_tenant_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Drop_tenant_stmtContext) FORCE() antlr.TerminalNode {
	return s.GetToken(OBParserFORCE, 0)
}

func (s *Drop_tenant_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_tenant_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_tenant_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDrop_tenant_stmt(s)
	}
}

func (s *Drop_tenant_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDrop_tenant_stmt(s)
	}
}

func (s *Drop_tenant_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDrop_tenant_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Drop_tenant_stmt() (localctx IDrop_tenant_stmtContext) {
	localctx = NewDrop_tenant_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, OBParserRULE_drop_tenant_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2798)
		p.Match(OBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2799)
		p.Match(OBParserTENANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2802)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserIF {
		{
			p.SetState(2800)
			p.Match(OBParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2801)
			p.Match(OBParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2804)
		p.Relation_name()
	}
	p.SetState(2806)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserFORCE {
		{
			p.SetState(2805)
			p.Match(OBParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_database_stmtContext is an interface to support dynamic dispatch.
type ICreate_database_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	Database_key() IDatabase_keyContext
	Database_factor() IDatabase_factorContext
	IF() antlr.TerminalNode
	Not() INotContext
	EXISTS() antlr.TerminalNode
	Database_option_list() IDatabase_option_listContext

	// IsCreate_database_stmtContext differentiates from other interfaces.
	IsCreate_database_stmtContext()
}

type Create_database_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_database_stmtContext() *Create_database_stmtContext {
	var p = new(Create_database_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_database_stmt
	return p
}

func InitEmptyCreate_database_stmtContext(p *Create_database_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_database_stmt
}

func (*Create_database_stmtContext) IsCreate_database_stmtContext() {}

func NewCreate_database_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_database_stmtContext {
	var p = new(Create_database_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_create_database_stmt

	return p
}

func (s *Create_database_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_database_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE, 0)
}

func (s *Create_database_stmtContext) Database_key() IDatabase_keyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_keyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_keyContext)
}

func (s *Create_database_stmtContext) Database_factor() IDatabase_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_factorContext)
}

func (s *Create_database_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Create_database_stmtContext) Not() INotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotContext)
}

func (s *Create_database_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Create_database_stmtContext) Database_option_list() IDatabase_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_option_listContext)
}

func (s *Create_database_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_database_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_database_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCreate_database_stmt(s)
	}
}

func (s *Create_database_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCreate_database_stmt(s)
	}
}

func (s *Create_database_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCreate_database_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Create_database_stmt() (localctx ICreate_database_stmtContext) {
	localctx = NewCreate_database_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, OBParserRULE_create_database_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2808)
		p.Match(OBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2809)
		p.Database_key()
	}
	p.SetState(2814)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserIF {
		{
			p.SetState(2810)
			p.Match(OBParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2811)
			p.Not()
		}
		{
			p.SetState(2812)
			p.Match(OBParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2816)
		p.Database_factor()
	}
	p.SetState(2818)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4503601791631360) != 0) || _la == OBParserREAD || _la == OBParserTABLEGROUP || _la == OBParserCHARSET || ((int64((_la-748)) & ^0x3f) == 0 && ((int64(1)<<(_la-748))&301989889) != 0) {
		{
			p.SetState(2817)
			p.Database_option_list()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatabase_keyContext is an interface to support dynamic dispatch.
type IDatabase_keyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode

	// IsDatabase_keyContext differentiates from other interfaces.
	IsDatabase_keyContext()
}

type Database_keyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabase_keyContext() *Database_keyContext {
	var p = new(Database_keyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_database_key
	return p
}

func InitEmptyDatabase_keyContext(p *Database_keyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_database_key
}

func (*Database_keyContext) IsDatabase_keyContext() {}

func NewDatabase_keyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Database_keyContext {
	var p = new(Database_keyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_database_key

	return p
}

func (s *Database_keyContext) GetParser() antlr.Parser { return s.parser }

func (s *Database_keyContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(OBParserDATABASE, 0)
}

func (s *Database_keyContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(OBParserSCHEMA, 0)
}

func (s *Database_keyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Database_keyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Database_keyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDatabase_key(s)
	}
}

func (s *Database_keyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDatabase_key(s)
	}
}

func (s *Database_keyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDatabase_key(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Database_key() (localctx IDatabase_keyContext) {
	localctx = NewDatabase_keyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, OBParserRULE_database_key)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2820)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserDATABASE || _la == OBParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatabase_factorContext is an interface to support dynamic dispatch.
type IDatabase_factorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Relation_name() IRelation_nameContext

	// IsDatabase_factorContext differentiates from other interfaces.
	IsDatabase_factorContext()
}

type Database_factorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabase_factorContext() *Database_factorContext {
	var p = new(Database_factorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_database_factor
	return p
}

func InitEmptyDatabase_factorContext(p *Database_factorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_database_factor
}

func (*Database_factorContext) IsDatabase_factorContext() {}

func NewDatabase_factorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Database_factorContext {
	var p = new(Database_factorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_database_factor

	return p
}

func (s *Database_factorContext) GetParser() antlr.Parser { return s.parser }

func (s *Database_factorContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Database_factorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Database_factorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Database_factorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDatabase_factor(s)
	}
}

func (s *Database_factorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDatabase_factor(s)
	}
}

func (s *Database_factorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDatabase_factor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Database_factor() (localctx IDatabase_factorContext) {
	localctx = NewDatabase_factorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, OBParserRULE_database_factor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2822)
		p.Relation_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatabase_option_listContext is an interface to support dynamic dispatch.
type IDatabase_option_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDatabase_option() []IDatabase_optionContext
	Database_option(i int) IDatabase_optionContext

	// IsDatabase_option_listContext differentiates from other interfaces.
	IsDatabase_option_listContext()
}

type Database_option_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabase_option_listContext() *Database_option_listContext {
	var p = new(Database_option_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_database_option_list
	return p
}

func InitEmptyDatabase_option_listContext(p *Database_option_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_database_option_list
}

func (*Database_option_listContext) IsDatabase_option_listContext() {}

func NewDatabase_option_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Database_option_listContext {
	var p = new(Database_option_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_database_option_list

	return p
}

func (s *Database_option_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Database_option_listContext) AllDatabase_option() []IDatabase_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDatabase_optionContext); ok {
			len++
		}
	}

	tst := make([]IDatabase_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDatabase_optionContext); ok {
			tst[i] = t.(IDatabase_optionContext)
			i++
		}
	}

	return tst
}

func (s *Database_option_listContext) Database_option(i int) IDatabase_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_optionContext)
}

func (s *Database_option_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Database_option_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Database_option_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDatabase_option_list(s)
	}
}

func (s *Database_option_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDatabase_option_list(s)
	}
}

func (s *Database_option_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDatabase_option_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Database_option_list() (localctx IDatabase_option_listContext) {
	localctx = NewDatabase_option_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, OBParserRULE_database_option_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2825)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4503601791631360) != 0) || _la == OBParserREAD || _la == OBParserTABLEGROUP || _la == OBParserCHARSET || ((int64((_la-748)) & ^0x3f) == 0 && ((int64(1)<<(_la-748))&301989889) != 0) {
		{
			p.SetState(2824)
			p.Database_option()
		}

		p.SetState(2827)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharset_keyContext is an interface to support dynamic dispatch.
type ICharset_keyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHARSET() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	SET() antlr.TerminalNode

	// IsCharset_keyContext differentiates from other interfaces.
	IsCharset_keyContext()
}

type Charset_keyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharset_keyContext() *Charset_keyContext {
	var p = new(Charset_keyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_charset_key
	return p
}

func InitEmptyCharset_keyContext(p *Charset_keyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_charset_key
}

func (*Charset_keyContext) IsCharset_keyContext() {}

func NewCharset_keyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Charset_keyContext {
	var p = new(Charset_keyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_charset_key

	return p
}

func (s *Charset_keyContext) GetParser() antlr.Parser { return s.parser }

func (s *Charset_keyContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(OBParserCHARSET, 0)
}

func (s *Charset_keyContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(OBParserCHARACTER, 0)
}

func (s *Charset_keyContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Charset_keyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Charset_keyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Charset_keyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCharset_key(s)
	}
}

func (s *Charset_keyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCharset_key(s)
	}
}

func (s *Charset_keyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCharset_key(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Charset_key() (localctx ICharset_keyContext) {
	localctx = NewCharset_keyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, OBParserRULE_charset_key)
	p.SetState(2832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserCHARSET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2829)
			p.Match(OBParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserCHARACTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2830)
			p.Match(OBParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2831)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatabase_optionContext is an interface to support dynamic dispatch.
type IDatabase_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Charset_key() ICharset_keyContext
	Charset_name() ICharset_nameContext
	DEFAULT() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	Collation_name() ICollation_nameContext
	REPLICA_NUM() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	PRIMARY_ZONE() antlr.TerminalNode
	Primary_zone_name() IPrimary_zone_nameContext
	Read_only_or_write() IRead_only_or_writeContext
	Default_tablegroup() IDefault_tablegroupContext
	DATABASE_ID() antlr.TerminalNode

	// IsDatabase_optionContext differentiates from other interfaces.
	IsDatabase_optionContext()
}

type Database_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabase_optionContext() *Database_optionContext {
	var p = new(Database_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_database_option
	return p
}

func InitEmptyDatabase_optionContext(p *Database_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_database_option
}

func (*Database_optionContext) IsDatabase_optionContext() {}

func NewDatabase_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Database_optionContext {
	var p = new(Database_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_database_option

	return p
}

func (s *Database_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Database_optionContext) Charset_key() ICharset_keyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_keyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_keyContext)
}

func (s *Database_optionContext) Charset_name() ICharset_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_nameContext)
}

func (s *Database_optionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT, 0)
}

func (s *Database_optionContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Database_optionContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(OBParserCOLLATE, 0)
}

func (s *Database_optionContext) Collation_name() ICollation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollation_nameContext)
}

func (s *Database_optionContext) REPLICA_NUM() antlr.TerminalNode {
	return s.GetToken(OBParserREPLICA_NUM, 0)
}

func (s *Database_optionContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Database_optionContext) PRIMARY_ZONE() antlr.TerminalNode {
	return s.GetToken(OBParserPRIMARY_ZONE, 0)
}

func (s *Database_optionContext) Primary_zone_name() IPrimary_zone_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimary_zone_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimary_zone_nameContext)
}

func (s *Database_optionContext) Read_only_or_write() IRead_only_or_writeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRead_only_or_writeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRead_only_or_writeContext)
}

func (s *Database_optionContext) Default_tablegroup() IDefault_tablegroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefault_tablegroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefault_tablegroupContext)
}

func (s *Database_optionContext) DATABASE_ID() antlr.TerminalNode {
	return s.GetToken(OBParserDATABASE_ID, 0)
}

func (s *Database_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Database_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Database_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDatabase_option(s)
	}
}

func (s *Database_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDatabase_option(s)
	}
}

func (s *Database_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDatabase_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Database_option() (localctx IDatabase_optionContext) {
	localctx = NewDatabase_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, OBParserRULE_database_option)
	var _la int

	p.SetState(2868)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserDEFAULT {
			{
				p.SetState(2834)
				p.Match(OBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2837)
			p.Charset_key()
		}
		p.SetState(2839)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2838)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2841)
			p.Charset_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2844)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserDEFAULT {
			{
				p.SetState(2843)
				p.Match(OBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2846)
			p.Match(OBParserCOLLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2848)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2847)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2850)
			p.Collation_name()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2851)
			p.Match(OBParserREPLICA_NUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2853)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2852)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2855)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2856)
			p.Match(OBParserPRIMARY_ZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2858)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2857)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2860)
			p.Primary_zone_name()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2861)
			p.Read_only_or_write()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2862)
			p.Default_tablegroup()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2863)
			p.Match(OBParserDATABASE_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2865)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(2864)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2867)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRead_only_or_writeContext is an interface to support dynamic dispatch.
type IRead_only_or_writeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	WRITE() antlr.TerminalNode

	// IsRead_only_or_writeContext differentiates from other interfaces.
	IsRead_only_or_writeContext()
}

type Read_only_or_writeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRead_only_or_writeContext() *Read_only_or_writeContext {
	var p = new(Read_only_or_writeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_read_only_or_write
	return p
}

func InitEmptyRead_only_or_writeContext(p *Read_only_or_writeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_read_only_or_write
}

func (*Read_only_or_writeContext) IsRead_only_or_writeContext() {}

func NewRead_only_or_writeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Read_only_or_writeContext {
	var p = new(Read_only_or_writeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_read_only_or_write

	return p
}

func (s *Read_only_or_writeContext) GetParser() antlr.Parser { return s.parser }

func (s *Read_only_or_writeContext) READ() antlr.TerminalNode {
	return s.GetToken(OBParserREAD, 0)
}

func (s *Read_only_or_writeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(OBParserONLY, 0)
}

func (s *Read_only_or_writeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(OBParserWRITE, 0)
}

func (s *Read_only_or_writeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Read_only_or_writeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Read_only_or_writeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRead_only_or_write(s)
	}
}

func (s *Read_only_or_writeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRead_only_or_write(s)
	}
}

func (s *Read_only_or_writeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRead_only_or_write(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Read_only_or_write() (localctx IRead_only_or_writeContext) {
	localctx = NewRead_only_or_writeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, OBParserRULE_read_only_or_write)
	p.SetState(2874)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2870)
			p.Match(OBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2871)
			p.Match(OBParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2872)
			p.Match(OBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2873)
			p.Match(OBParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_database_stmtContext is an interface to support dynamic dispatch.
type IDrop_database_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	Database_key() IDatabase_keyContext
	Database_factor() IDatabase_factorContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDrop_database_stmtContext differentiates from other interfaces.
	IsDrop_database_stmtContext()
}

type Drop_database_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_database_stmtContext() *Drop_database_stmtContext {
	var p = new(Drop_database_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_database_stmt
	return p
}

func InitEmptyDrop_database_stmtContext(p *Drop_database_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_database_stmt
}

func (*Drop_database_stmtContext) IsDrop_database_stmtContext() {}

func NewDrop_database_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_database_stmtContext {
	var p = new(Drop_database_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_drop_database_stmt

	return p
}

func (s *Drop_database_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_database_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Drop_database_stmtContext) Database_key() IDatabase_keyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_keyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_keyContext)
}

func (s *Drop_database_stmtContext) Database_factor() IDatabase_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_factorContext)
}

func (s *Drop_database_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Drop_database_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Drop_database_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_database_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_database_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDrop_database_stmt(s)
	}
}

func (s *Drop_database_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDrop_database_stmt(s)
	}
}

func (s *Drop_database_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDrop_database_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Drop_database_stmt() (localctx IDrop_database_stmtContext) {
	localctx = NewDrop_database_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, OBParserRULE_drop_database_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2876)
		p.Match(OBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2877)
		p.Database_key()
	}
	p.SetState(2880)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserIF {
		{
			p.SetState(2878)
			p.Match(OBParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2879)
			p.Match(OBParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2882)
		p.Database_factor()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_database_stmtContext is an interface to support dynamic dispatch.
type IAlter_database_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	Database_key() IDatabase_keyContext
	Database_option_list() IDatabase_option_listContext
	NAME_OB() antlr.TerminalNode
	SET() antlr.TerminalNode

	// IsAlter_database_stmtContext differentiates from other interfaces.
	IsAlter_database_stmtContext()
}

type Alter_database_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_database_stmtContext() *Alter_database_stmtContext {
	var p = new(Alter_database_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_database_stmt
	return p
}

func InitEmptyAlter_database_stmtContext(p *Alter_database_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_database_stmt
}

func (*Alter_database_stmtContext) IsAlter_database_stmtContext() {}

func NewAlter_database_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_database_stmtContext {
	var p = new(Alter_database_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_database_stmt

	return p
}

func (s *Alter_database_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_database_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(OBParserALTER, 0)
}

func (s *Alter_database_stmtContext) Database_key() IDatabase_keyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_keyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_keyContext)
}

func (s *Alter_database_stmtContext) Database_option_list() IDatabase_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_option_listContext)
}

func (s *Alter_database_stmtContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Alter_database_stmtContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Alter_database_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_database_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_database_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_database_stmt(s)
	}
}

func (s *Alter_database_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_database_stmt(s)
	}
}

func (s *Alter_database_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_database_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_database_stmt() (localctx IAlter_database_stmtContext) {
	localctx = NewAlter_database_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, OBParserRULE_alter_database_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2884)
		p.Match(OBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2885)
		p.Database_key()
	}
	p.SetState(2887)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserNAME_OB {
		{
			p.SetState(2886)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2890)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserSET {
		{
			p.SetState(2889)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2892)
		p.Database_option_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoad_data_stmtContext is an interface to support dynamic dispatch.
type ILoad_data_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Load_data_with_opt_hint() ILoad_data_with_opt_hintContext
	INFILE() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Relation_factor() IRelation_factorContext
	Field_opt() IField_optContext
	Line_opt() ILine_optContext
	Use_partition() IUse_partitionContext
	CHARACTER() antlr.TerminalNode
	AllSET() []antlr.TerminalNode
	SET(i int) antlr.TerminalNode
	Charset_name_or_default() ICharset_name_or_defaultContext
	Load_set_list() ILoad_set_listContext
	LOCAL() antlr.TerminalNode
	REMOTE_OSS() antlr.TerminalNode
	AllIGNORE() []antlr.TerminalNode
	IGNORE(i int) antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	Lines_or_rows() ILines_or_rowsContext
	GENERATED() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	Field_or_vars_list() IField_or_vars_listContext

	// IsLoad_data_stmtContext differentiates from other interfaces.
	IsLoad_data_stmtContext()
}

type Load_data_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoad_data_stmtContext() *Load_data_stmtContext {
	var p = new(Load_data_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_load_data_stmt
	return p
}

func InitEmptyLoad_data_stmtContext(p *Load_data_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_load_data_stmt
}

func (*Load_data_stmtContext) IsLoad_data_stmtContext() {}

func NewLoad_data_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Load_data_stmtContext {
	var p = new(Load_data_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_load_data_stmt

	return p
}

func (s *Load_data_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Load_data_stmtContext) Load_data_with_opt_hint() ILoad_data_with_opt_hintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoad_data_with_opt_hintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoad_data_with_opt_hintContext)
}

func (s *Load_data_stmtContext) INFILE() antlr.TerminalNode {
	return s.GetToken(OBParserINFILE, 0)
}

func (s *Load_data_stmtContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Load_data_stmtContext) INTO() antlr.TerminalNode {
	return s.GetToken(OBParserINTO, 0)
}

func (s *Load_data_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE, 0)
}

func (s *Load_data_stmtContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Load_data_stmtContext) Field_opt() IField_optContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IField_optContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IField_optContext)
}

func (s *Load_data_stmtContext) Line_opt() ILine_optContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILine_optContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILine_optContext)
}

func (s *Load_data_stmtContext) Use_partition() IUse_partitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUse_partitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUse_partitionContext)
}

func (s *Load_data_stmtContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(OBParserCHARACTER, 0)
}

func (s *Load_data_stmtContext) AllSET() []antlr.TerminalNode {
	return s.GetTokens(OBParserSET)
}

func (s *Load_data_stmtContext) SET(i int) antlr.TerminalNode {
	return s.GetToken(OBParserSET, i)
}

func (s *Load_data_stmtContext) Charset_name_or_default() ICharset_name_or_defaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_name_or_defaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_name_or_defaultContext)
}

func (s *Load_data_stmtContext) Load_set_list() ILoad_set_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoad_set_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoad_set_listContext)
}

func (s *Load_data_stmtContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(OBParserLOCAL, 0)
}

func (s *Load_data_stmtContext) REMOTE_OSS() antlr.TerminalNode {
	return s.GetToken(OBParserREMOTE_OSS, 0)
}

func (s *Load_data_stmtContext) AllIGNORE() []antlr.TerminalNode {
	return s.GetTokens(OBParserIGNORE)
}

func (s *Load_data_stmtContext) IGNORE(i int) antlr.TerminalNode {
	return s.GetToken(OBParserIGNORE, i)
}

func (s *Load_data_stmtContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(OBParserREPLACE, 0)
}

func (s *Load_data_stmtContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Load_data_stmtContext) Lines_or_rows() ILines_or_rowsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILines_or_rowsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILines_or_rowsContext)
}

func (s *Load_data_stmtContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(OBParserGENERATED, 0)
}

func (s *Load_data_stmtContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Load_data_stmtContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Load_data_stmtContext) Field_or_vars_list() IField_or_vars_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IField_or_vars_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IField_or_vars_listContext)
}

func (s *Load_data_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Load_data_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Load_data_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLoad_data_stmt(s)
	}
}

func (s *Load_data_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLoad_data_stmt(s)
	}
}

func (s *Load_data_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLoad_data_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Load_data_stmt() (localctx ILoad_data_stmtContext) {
	localctx = NewLoad_data_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, OBParserRULE_load_data_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2894)
		p.Load_data_with_opt_hint()
	}
	p.SetState(2896)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserLOCAL || _la == OBParserREMOTE_OSS {
		{
			p.SetState(2895)
			_la = p.GetTokenStream().LA(1)

			if !(_la == OBParserLOCAL || _la == OBParserREMOTE_OSS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(2898)
		p.Match(OBParserINFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2899)
		p.Match(OBParserSTRING_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2901)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserREPLACE || _la == OBParserIGNORE {
		{
			p.SetState(2900)
			_la = p.GetTokenStream().LA(1)

			if !(_la == OBParserREPLACE || _la == OBParserIGNORE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(2903)
		p.Match(OBParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2904)
		p.Match(OBParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2905)
		p.Relation_factor()
	}
	p.SetState(2907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserPARTITION {
		{
			p.SetState(2906)
			p.Use_partition()
		}

	}
	p.SetState(2912)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCHARACTER {
		{
			p.SetState(2909)
			p.Match(OBParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2910)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2911)
			p.Charset_name_or_default()
		}

	}
	{
		p.SetState(2914)
		p.Field_opt()
	}
	{
		p.SetState(2915)
		p.Line_opt()
	}
	p.SetState(2922)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case OBParserIGNORE:
		{
			p.SetState(2916)
			p.Match(OBParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2917)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2918)
			p.Lines_or_rows()
		}

	case OBParserGENERATED:
		{
			p.SetState(2919)
			p.Match(OBParserGENERATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2920)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2921)
			p.Lines_or_rows()
		}

	case OBParserEOF, OBParserSET, OBParserLeftParen, OBParserDELIMITER:

	default:
	}
	p.SetState(2930)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2924)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2925)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(2926)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2927)
			p.Field_or_vars_list()
		}
		{
			p.SetState(2928)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2934)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserSET {
		{
			p.SetState(2932)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2933)
			p.Load_set_list()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoad_data_with_opt_hintContext is an interface to support dynamic dispatch.
type ILoad_data_with_opt_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOAD() antlr.TerminalNode
	DATA() antlr.TerminalNode
	LOAD_DATA_HINT_BEGIN() antlr.TerminalNode
	Hint_list_with_end() IHint_list_with_endContext

	// IsLoad_data_with_opt_hintContext differentiates from other interfaces.
	IsLoad_data_with_opt_hintContext()
}

type Load_data_with_opt_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoad_data_with_opt_hintContext() *Load_data_with_opt_hintContext {
	var p = new(Load_data_with_opt_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_load_data_with_opt_hint
	return p
}

func InitEmptyLoad_data_with_opt_hintContext(p *Load_data_with_opt_hintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_load_data_with_opt_hint
}

func (*Load_data_with_opt_hintContext) IsLoad_data_with_opt_hintContext() {}

func NewLoad_data_with_opt_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Load_data_with_opt_hintContext {
	var p = new(Load_data_with_opt_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_load_data_with_opt_hint

	return p
}

func (s *Load_data_with_opt_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *Load_data_with_opt_hintContext) LOAD() antlr.TerminalNode {
	return s.GetToken(OBParserLOAD, 0)
}

func (s *Load_data_with_opt_hintContext) DATA() antlr.TerminalNode {
	return s.GetToken(OBParserDATA, 0)
}

func (s *Load_data_with_opt_hintContext) LOAD_DATA_HINT_BEGIN() antlr.TerminalNode {
	return s.GetToken(OBParserLOAD_DATA_HINT_BEGIN, 0)
}

func (s *Load_data_with_opt_hintContext) Hint_list_with_end() IHint_list_with_endContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHint_list_with_endContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHint_list_with_endContext)
}

func (s *Load_data_with_opt_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Load_data_with_opt_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Load_data_with_opt_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLoad_data_with_opt_hint(s)
	}
}

func (s *Load_data_with_opt_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLoad_data_with_opt_hint(s)
	}
}

func (s *Load_data_with_opt_hintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLoad_data_with_opt_hint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Load_data_with_opt_hint() (localctx ILoad_data_with_opt_hintContext) {
	localctx = NewLoad_data_with_opt_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, OBParserRULE_load_data_with_opt_hint)
	p.SetState(2940)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserLOAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2936)
			p.Match(OBParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2937)
			p.Match(OBParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserLOAD_DATA_HINT_BEGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2938)
			p.Match(OBParserLOAD_DATA_HINT_BEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2939)
			p.Hint_list_with_end()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILines_or_rowsContext is an interface to support dynamic dispatch.
type ILines_or_rowsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LINES() antlr.TerminalNode
	ROWS() antlr.TerminalNode

	// IsLines_or_rowsContext differentiates from other interfaces.
	IsLines_or_rowsContext()
}

type Lines_or_rowsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLines_or_rowsContext() *Lines_or_rowsContext {
	var p = new(Lines_or_rowsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_lines_or_rows
	return p
}

func InitEmptyLines_or_rowsContext(p *Lines_or_rowsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_lines_or_rows
}

func (*Lines_or_rowsContext) IsLines_or_rowsContext() {}

func NewLines_or_rowsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lines_or_rowsContext {
	var p = new(Lines_or_rowsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_lines_or_rows

	return p
}

func (s *Lines_or_rowsContext) GetParser() antlr.Parser { return s.parser }

func (s *Lines_or_rowsContext) LINES() antlr.TerminalNode {
	return s.GetToken(OBParserLINES, 0)
}

func (s *Lines_or_rowsContext) ROWS() antlr.TerminalNode {
	return s.GetToken(OBParserROWS, 0)
}

func (s *Lines_or_rowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lines_or_rowsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lines_or_rowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLines_or_rows(s)
	}
}

func (s *Lines_or_rowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLines_or_rows(s)
	}
}

func (s *Lines_or_rowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLines_or_rows(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Lines_or_rows() (localctx ILines_or_rowsContext) {
	localctx = NewLines_or_rowsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, OBParserRULE_lines_or_rows)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2942)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserLINES || _la == OBParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IField_or_vars_listContext is an interface to support dynamic dispatch.
type IField_or_vars_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllField_or_vars() []IField_or_varsContext
	Field_or_vars(i int) IField_or_varsContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsField_or_vars_listContext differentiates from other interfaces.
	IsField_or_vars_listContext()
}

type Field_or_vars_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_or_vars_listContext() *Field_or_vars_listContext {
	var p = new(Field_or_vars_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_field_or_vars_list
	return p
}

func InitEmptyField_or_vars_listContext(p *Field_or_vars_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_field_or_vars_list
}

func (*Field_or_vars_listContext) IsField_or_vars_listContext() {}

func NewField_or_vars_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_or_vars_listContext {
	var p = new(Field_or_vars_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_field_or_vars_list

	return p
}

func (s *Field_or_vars_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_or_vars_listContext) AllField_or_vars() []IField_or_varsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IField_or_varsContext); ok {
			len++
		}
	}

	tst := make([]IField_or_varsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IField_or_varsContext); ok {
			tst[i] = t.(IField_or_varsContext)
			i++
		}
	}

	return tst
}

func (s *Field_or_vars_listContext) Field_or_vars(i int) IField_or_varsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IField_or_varsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IField_or_varsContext)
}

func (s *Field_or_vars_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Field_or_vars_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Field_or_vars_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_or_vars_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_or_vars_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterField_or_vars_list(s)
	}
}

func (s *Field_or_vars_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitField_or_vars_list(s)
	}
}

func (s *Field_or_vars_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitField_or_vars_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Field_or_vars_list() (localctx IField_or_vars_listContext) {
	localctx = NewField_or_vars_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, OBParserRULE_field_or_vars_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2944)
		p.Field_or_vars()
	}
	p.SetState(2949)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(2945)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2946)
			p.Field_or_vars()
		}

		p.SetState(2951)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IField_or_varsContext is an interface to support dynamic dispatch.
type IField_or_varsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_definition_ref() IColumn_definition_refContext
	USER_VARIABLE() antlr.TerminalNode

	// IsField_or_varsContext differentiates from other interfaces.
	IsField_or_varsContext()
}

type Field_or_varsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_or_varsContext() *Field_or_varsContext {
	var p = new(Field_or_varsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_field_or_vars
	return p
}

func InitEmptyField_or_varsContext(p *Field_or_varsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_field_or_vars
}

func (*Field_or_varsContext) IsField_or_varsContext() {}

func NewField_or_varsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_or_varsContext {
	var p = new(Field_or_varsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_field_or_vars

	return p
}

func (s *Field_or_varsContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_or_varsContext) Column_definition_ref() IColumn_definition_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_definition_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_definition_refContext)
}

func (s *Field_or_varsContext) USER_VARIABLE() antlr.TerminalNode {
	return s.GetToken(OBParserUSER_VARIABLE, 0)
}

func (s *Field_or_varsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_or_varsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_or_varsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterField_or_vars(s)
	}
}

func (s *Field_or_varsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitField_or_vars(s)
	}
}

func (s *Field_or_varsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitField_or_vars(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Field_or_vars() (localctx IField_or_varsContext) {
	localctx = NewField_or_varsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, OBParserRULE_field_or_vars)
	p.SetState(2954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserNAME_OB, OBParserSTAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2952)
			p.Column_definition_ref()
		}

	case OBParserUSER_VARIABLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2953)
			p.Match(OBParserUSER_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoad_set_listContext is an interface to support dynamic dispatch.
type ILoad_set_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLoad_set_element() []ILoad_set_elementContext
	Load_set_element(i int) ILoad_set_elementContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsLoad_set_listContext differentiates from other interfaces.
	IsLoad_set_listContext()
}

type Load_set_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoad_set_listContext() *Load_set_listContext {
	var p = new(Load_set_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_load_set_list
	return p
}

func InitEmptyLoad_set_listContext(p *Load_set_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_load_set_list
}

func (*Load_set_listContext) IsLoad_set_listContext() {}

func NewLoad_set_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Load_set_listContext {
	var p = new(Load_set_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_load_set_list

	return p
}

func (s *Load_set_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Load_set_listContext) AllLoad_set_element() []ILoad_set_elementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoad_set_elementContext); ok {
			len++
		}
	}

	tst := make([]ILoad_set_elementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoad_set_elementContext); ok {
			tst[i] = t.(ILoad_set_elementContext)
			i++
		}
	}

	return tst
}

func (s *Load_set_listContext) Load_set_element(i int) ILoad_set_elementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoad_set_elementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoad_set_elementContext)
}

func (s *Load_set_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Load_set_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Load_set_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Load_set_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Load_set_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLoad_set_list(s)
	}
}

func (s *Load_set_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLoad_set_list(s)
	}
}

func (s *Load_set_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLoad_set_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Load_set_list() (localctx ILoad_set_listContext) {
	localctx = NewLoad_set_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, OBParserRULE_load_set_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2956)
		p.Load_set_element()
	}
	p.SetState(2961)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(2957)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2958)
			p.Load_set_element()
		}

		p.SetState(2963)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoad_set_elementContext is an interface to support dynamic dispatch.
type ILoad_set_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_definition_ref() IColumn_definition_refContext
	COMP_EQ() antlr.TerminalNode
	Expr_or_default() IExpr_or_defaultContext

	// IsLoad_set_elementContext differentiates from other interfaces.
	IsLoad_set_elementContext()
}

type Load_set_elementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoad_set_elementContext() *Load_set_elementContext {
	var p = new(Load_set_elementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_load_set_element
	return p
}

func InitEmptyLoad_set_elementContext(p *Load_set_elementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_load_set_element
}

func (*Load_set_elementContext) IsLoad_set_elementContext() {}

func NewLoad_set_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Load_set_elementContext {
	var p = new(Load_set_elementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_load_set_element

	return p
}

func (s *Load_set_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Load_set_elementContext) Column_definition_ref() IColumn_definition_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_definition_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_definition_refContext)
}

func (s *Load_set_elementContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Load_set_elementContext) Expr_or_default() IExpr_or_defaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_or_defaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_or_defaultContext)
}

func (s *Load_set_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Load_set_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Load_set_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLoad_set_element(s)
	}
}

func (s *Load_set_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLoad_set_element(s)
	}
}

func (s *Load_set_elementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLoad_set_element(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Load_set_element() (localctx ILoad_set_elementContext) {
	localctx = NewLoad_set_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, OBParserRULE_load_set_element)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2964)
		p.Column_definition_ref()
	}
	{
		p.SetState(2965)
		p.Match(OBParserCOMP_EQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2966)
		p.Expr_or_default()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUse_database_stmtContext is an interface to support dynamic dispatch.
type IUse_database_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	Database_factor() IDatabase_factorContext

	// IsUse_database_stmtContext differentiates from other interfaces.
	IsUse_database_stmtContext()
}

type Use_database_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_database_stmtContext() *Use_database_stmtContext {
	var p = new(Use_database_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_use_database_stmt
	return p
}

func InitEmptyUse_database_stmtContext(p *Use_database_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_use_database_stmt
}

func (*Use_database_stmtContext) IsUse_database_stmtContext() {}

func NewUse_database_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_database_stmtContext {
	var p = new(Use_database_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_use_database_stmt

	return p
}

func (s *Use_database_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_database_stmtContext) USE() antlr.TerminalNode {
	return s.GetToken(OBParserUSE, 0)
}

func (s *Use_database_stmtContext) Database_factor() IDatabase_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_factorContext)
}

func (s *Use_database_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_database_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_database_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUse_database_stmt(s)
	}
}

func (s *Use_database_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUse_database_stmt(s)
	}
}

func (s *Use_database_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUse_database_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Use_database_stmt() (localctx IUse_database_stmtContext) {
	localctx = NewUse_database_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, OBParserRULE_use_database_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2968)
		p.Match(OBParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2969)
		p.Database_factor()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_synonym_stmtContext is an interface to support dynamic dispatch.
type ICreate_synonym_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	SYNONYM() antlr.TerminalNode
	Synonym_name() ISynonym_nameContext
	FOR() antlr.TerminalNode
	Synonym_object() ISynonym_objectContext
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	PUBLIC() antlr.TerminalNode
	At() antlr.TerminalNode
	Ip_port() IIp_portContext
	AllDatabase_factor() []IDatabase_factorContext
	Database_factor(i int) IDatabase_factorContext
	AllDot() []antlr.TerminalNode
	Dot(i int) antlr.TerminalNode

	// IsCreate_synonym_stmtContext differentiates from other interfaces.
	IsCreate_synonym_stmtContext()
}

type Create_synonym_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_synonym_stmtContext() *Create_synonym_stmtContext {
	var p = new(Create_synonym_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_synonym_stmt
	return p
}

func InitEmptyCreate_synonym_stmtContext(p *Create_synonym_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_synonym_stmt
}

func (*Create_synonym_stmtContext) IsCreate_synonym_stmtContext() {}

func NewCreate_synonym_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_synonym_stmtContext {
	var p = new(Create_synonym_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_create_synonym_stmt

	return p
}

func (s *Create_synonym_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_synonym_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE, 0)
}

func (s *Create_synonym_stmtContext) SYNONYM() antlr.TerminalNode {
	return s.GetToken(OBParserSYNONYM, 0)
}

func (s *Create_synonym_stmtContext) Synonym_name() ISynonym_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISynonym_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISynonym_nameContext)
}

func (s *Create_synonym_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(OBParserFOR, 0)
}

func (s *Create_synonym_stmtContext) Synonym_object() ISynonym_objectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISynonym_objectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISynonym_objectContext)
}

func (s *Create_synonym_stmtContext) OR() antlr.TerminalNode {
	return s.GetToken(OBParserOR, 0)
}

func (s *Create_synonym_stmtContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(OBParserREPLACE, 0)
}

func (s *Create_synonym_stmtContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(OBParserPUBLIC, 0)
}

func (s *Create_synonym_stmtContext) At() antlr.TerminalNode {
	return s.GetToken(OBParserAt, 0)
}

func (s *Create_synonym_stmtContext) Ip_port() IIp_portContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIp_portContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIp_portContext)
}

func (s *Create_synonym_stmtContext) AllDatabase_factor() []IDatabase_factorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDatabase_factorContext); ok {
			len++
		}
	}

	tst := make([]IDatabase_factorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDatabase_factorContext); ok {
			tst[i] = t.(IDatabase_factorContext)
			i++
		}
	}

	return tst
}

func (s *Create_synonym_stmtContext) Database_factor(i int) IDatabase_factorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_factorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_factorContext)
}

func (s *Create_synonym_stmtContext) AllDot() []antlr.TerminalNode {
	return s.GetTokens(OBParserDot)
}

func (s *Create_synonym_stmtContext) Dot(i int) antlr.TerminalNode {
	return s.GetToken(OBParserDot, i)
}

func (s *Create_synonym_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_synonym_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_synonym_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCreate_synonym_stmt(s)
	}
}

func (s *Create_synonym_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCreate_synonym_stmt(s)
	}
}

func (s *Create_synonym_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCreate_synonym_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Create_synonym_stmt() (localctx ICreate_synonym_stmtContext) {
	localctx = NewCreate_synonym_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, OBParserRULE_create_synonym_stmt)
	var _la int

	p.SetState(3043)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2971)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2974)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserOR {
			{
				p.SetState(2972)
				p.Match(OBParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2973)
				p.Match(OBParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2977)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPUBLIC {
			{
				p.SetState(2976)
				p.Match(OBParserPUBLIC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2979)
			p.Match(OBParserSYNONYM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2980)
			p.Synonym_name()
		}
		{
			p.SetState(2981)
			p.Match(OBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2982)
			p.Synonym_object()
		}
		p.SetState(2985)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserAt {
			{
				p.SetState(2983)
				p.Match(OBParserAt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2984)
				p.Ip_port()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2987)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserOR {
			{
				p.SetState(2988)
				p.Match(OBParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2989)
				p.Match(OBParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2993)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPUBLIC {
			{
				p.SetState(2992)
				p.Match(OBParserPUBLIC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2995)
			p.Match(OBParserSYNONYM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2996)
			p.Database_factor()
		}
		{
			p.SetState(2997)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2998)
			p.Synonym_name()
		}
		{
			p.SetState(2999)
			p.Match(OBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3000)
			p.Synonym_object()
		}
		p.SetState(3003)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserAt {
			{
				p.SetState(3001)
				p.Match(OBParserAt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3002)
				p.Ip_port()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3005)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3008)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserOR {
			{
				p.SetState(3006)
				p.Match(OBParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3007)
				p.Match(OBParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3011)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPUBLIC {
			{
				p.SetState(3010)
				p.Match(OBParserPUBLIC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3013)
			p.Match(OBParserSYNONYM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3014)
			p.Synonym_name()
		}
		{
			p.SetState(3015)
			p.Match(OBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3016)
			p.Database_factor()
		}
		{
			p.SetState(3017)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3018)
			p.Synonym_object()
		}
		p.SetState(3021)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserAt {
			{
				p.SetState(3019)
				p.Match(OBParserAt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3020)
				p.Ip_port()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3023)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3026)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserOR {
			{
				p.SetState(3024)
				p.Match(OBParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3025)
				p.Match(OBParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3029)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPUBLIC {
			{
				p.SetState(3028)
				p.Match(OBParserPUBLIC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3031)
			p.Match(OBParserSYNONYM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3032)
			p.Database_factor()
		}
		{
			p.SetState(3033)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3034)
			p.Synonym_name()
		}
		{
			p.SetState(3035)
			p.Match(OBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3036)
			p.Database_factor()
		}
		{
			p.SetState(3037)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3038)
			p.Synonym_object()
		}
		p.SetState(3041)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserAt {
			{
				p.SetState(3039)
				p.Match(OBParserAt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3040)
				p.Ip_port()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISynonym_nameContext is an interface to support dynamic dispatch.
type ISynonym_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME_OB() antlr.TerminalNode
	Unreserved_keyword() IUnreserved_keywordContext

	// IsSynonym_nameContext differentiates from other interfaces.
	IsSynonym_nameContext()
}

type Synonym_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySynonym_nameContext() *Synonym_nameContext {
	var p = new(Synonym_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_synonym_name
	return p
}

func InitEmptySynonym_nameContext(p *Synonym_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_synonym_name
}

func (*Synonym_nameContext) IsSynonym_nameContext() {}

func NewSynonym_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Synonym_nameContext {
	var p = new(Synonym_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_synonym_name

	return p
}

func (s *Synonym_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Synonym_nameContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Synonym_nameContext) Unreserved_keyword() IUnreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keywordContext)
}

func (s *Synonym_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Synonym_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Synonym_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSynonym_name(s)
	}
}

func (s *Synonym_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSynonym_name(s)
	}
}

func (s *Synonym_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSynonym_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Synonym_name() (localctx ISynonym_nameContext) {
	localctx = NewSynonym_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, OBParserRULE_synonym_name)
	p.SetState(3047)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserNAME_OB:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3045)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserSTAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3046)
			p.Unreserved_keyword()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISynonym_objectContext is an interface to support dynamic dispatch.
type ISynonym_objectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME_OB() antlr.TerminalNode
	Unreserved_keyword() IUnreserved_keywordContext

	// IsSynonym_objectContext differentiates from other interfaces.
	IsSynonym_objectContext()
}

type Synonym_objectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySynonym_objectContext() *Synonym_objectContext {
	var p = new(Synonym_objectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_synonym_object
	return p
}

func InitEmptySynonym_objectContext(p *Synonym_objectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_synonym_object
}

func (*Synonym_objectContext) IsSynonym_objectContext() {}

func NewSynonym_objectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Synonym_objectContext {
	var p = new(Synonym_objectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_synonym_object

	return p
}

func (s *Synonym_objectContext) GetParser() antlr.Parser { return s.parser }

func (s *Synonym_objectContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Synonym_objectContext) Unreserved_keyword() IUnreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keywordContext)
}

func (s *Synonym_objectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Synonym_objectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Synonym_objectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSynonym_object(s)
	}
}

func (s *Synonym_objectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSynonym_object(s)
	}
}

func (s *Synonym_objectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSynonym_object(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Synonym_object() (localctx ISynonym_objectContext) {
	localctx = NewSynonym_objectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, OBParserRULE_synonym_object)
	p.SetState(3051)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserNAME_OB:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3049)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserSTAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3050)
			p.Unreserved_keyword()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_synonym_stmtContext is an interface to support dynamic dispatch.
type IDrop_synonym_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	SYNONYM() antlr.TerminalNode
	Synonym_name() ISynonym_nameContext
	PUBLIC() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	Database_factor() IDatabase_factorContext
	Dot() antlr.TerminalNode

	// IsDrop_synonym_stmtContext differentiates from other interfaces.
	IsDrop_synonym_stmtContext()
}

type Drop_synonym_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_synonym_stmtContext() *Drop_synonym_stmtContext {
	var p = new(Drop_synonym_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_synonym_stmt
	return p
}

func InitEmptyDrop_synonym_stmtContext(p *Drop_synonym_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_synonym_stmt
}

func (*Drop_synonym_stmtContext) IsDrop_synonym_stmtContext() {}

func NewDrop_synonym_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_synonym_stmtContext {
	var p = new(Drop_synonym_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_drop_synonym_stmt

	return p
}

func (s *Drop_synonym_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_synonym_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Drop_synonym_stmtContext) SYNONYM() antlr.TerminalNode {
	return s.GetToken(OBParserSYNONYM, 0)
}

func (s *Drop_synonym_stmtContext) Synonym_name() ISynonym_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISynonym_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISynonym_nameContext)
}

func (s *Drop_synonym_stmtContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(OBParserPUBLIC, 0)
}

func (s *Drop_synonym_stmtContext) FORCE() antlr.TerminalNode {
	return s.GetToken(OBParserFORCE, 0)
}

func (s *Drop_synonym_stmtContext) Database_factor() IDatabase_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_factorContext)
}

func (s *Drop_synonym_stmtContext) Dot() antlr.TerminalNode {
	return s.GetToken(OBParserDot, 0)
}

func (s *Drop_synonym_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_synonym_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_synonym_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDrop_synonym_stmt(s)
	}
}

func (s *Drop_synonym_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDrop_synonym_stmt(s)
	}
}

func (s *Drop_synonym_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDrop_synonym_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Drop_synonym_stmt() (localctx IDrop_synonym_stmtContext) {
	localctx = NewDrop_synonym_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, OBParserRULE_drop_synonym_stmt)
	var _la int

	p.SetState(3073)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 211, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3053)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3055)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPUBLIC {
			{
				p.SetState(3054)
				p.Match(OBParserPUBLIC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3057)
			p.Match(OBParserSYNONYM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3058)
			p.Synonym_name()
		}
		p.SetState(3060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFORCE {
			{
				p.SetState(3059)
				p.Match(OBParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3062)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPUBLIC {
			{
				p.SetState(3063)
				p.Match(OBParserPUBLIC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3066)
			p.Match(OBParserSYNONYM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3067)
			p.Database_factor()
		}
		{
			p.SetState(3068)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3069)
			p.Synonym_name()
		}
		p.SetState(3071)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFORCE {
			{
				p.SetState(3070)
				p.Match(OBParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemporary_optionContext is an interface to support dynamic dispatch.
type ITemporary_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TEMPORARY() antlr.TerminalNode

	// IsTemporary_optionContext differentiates from other interfaces.
	IsTemporary_optionContext()
}

type Temporary_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemporary_optionContext() *Temporary_optionContext {
	var p = new(Temporary_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_temporary_option
	return p
}

func InitEmptyTemporary_optionContext(p *Temporary_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_temporary_option
}

func (*Temporary_optionContext) IsTemporary_optionContext() {}

func NewTemporary_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Temporary_optionContext {
	var p = new(Temporary_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_temporary_option

	return p
}

func (s *Temporary_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Temporary_optionContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(OBParserTEMPORARY, 0)
}

func (s *Temporary_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Temporary_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Temporary_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTemporary_option(s)
	}
}

func (s *Temporary_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTemporary_option(s)
	}
}

func (s *Temporary_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTemporary_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Temporary_option() (localctx ITemporary_optionContext) {
	localctx = NewTemporary_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, OBParserRULE_temporary_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserTEMPORARY {
		{
			p.SetState(3075)
			p.Match(OBParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_like_stmtContext is an interface to support dynamic dispatch.
type ICreate_table_like_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	Temporary_option() ITemporary_optionContext
	TABLE() antlr.TerminalNode
	AllRelation_factor() []IRelation_factorContext
	Relation_factor(i int) IRelation_factorContext
	LIKE() antlr.TerminalNode
	IF() antlr.TerminalNode
	Not() INotContext
	EXISTS() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode

	// IsCreate_table_like_stmtContext differentiates from other interfaces.
	IsCreate_table_like_stmtContext()
}

type Create_table_like_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_like_stmtContext() *Create_table_like_stmtContext {
	var p = new(Create_table_like_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_table_like_stmt
	return p
}

func InitEmptyCreate_table_like_stmtContext(p *Create_table_like_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_table_like_stmt
}

func (*Create_table_like_stmtContext) IsCreate_table_like_stmtContext() {}

func NewCreate_table_like_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_like_stmtContext {
	var p = new(Create_table_like_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_create_table_like_stmt

	return p
}

func (s *Create_table_like_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_like_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE, 0)
}

func (s *Create_table_like_stmtContext) Temporary_option() ITemporary_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemporary_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemporary_optionContext)
}

func (s *Create_table_like_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE, 0)
}

func (s *Create_table_like_stmtContext) AllRelation_factor() []IRelation_factorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_factorContext); ok {
			len++
		}
	}

	tst := make([]IRelation_factorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_factorContext); ok {
			tst[i] = t.(IRelation_factorContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_like_stmtContext) Relation_factor(i int) IRelation_factorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Create_table_like_stmtContext) LIKE() antlr.TerminalNode {
	return s.GetToken(OBParserLIKE, 0)
}

func (s *Create_table_like_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Create_table_like_stmtContext) Not() INotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotContext)
}

func (s *Create_table_like_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Create_table_like_stmtContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Create_table_like_stmtContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Create_table_like_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_like_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_like_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCreate_table_like_stmt(s)
	}
}

func (s *Create_table_like_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCreate_table_like_stmt(s)
	}
}

func (s *Create_table_like_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCreate_table_like_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Create_table_like_stmt() (localctx ICreate_table_like_stmtContext) {
	localctx = NewCreate_table_like_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, OBParserRULE_create_table_like_stmt)
	var _la int

	p.SetState(3106)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 215, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3078)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3079)
			p.Temporary_option()
		}
		{
			p.SetState(3080)
			p.Match(OBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3085)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIF {
			{
				p.SetState(3081)
				p.Match(OBParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3082)
				p.Not()
			}
			{
				p.SetState(3083)
				p.Match(OBParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3087)
			p.Relation_factor()
		}
		{
			p.SetState(3088)
			p.Match(OBParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3089)
			p.Relation_factor()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3091)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3092)
			p.Temporary_option()
		}
		{
			p.SetState(3093)
			p.Match(OBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3098)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIF {
			{
				p.SetState(3094)
				p.Match(OBParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3095)
				p.Not()
			}
			{
				p.SetState(3096)
				p.Match(OBParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3100)
			p.Relation_factor()
		}
		{
			p.SetState(3101)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3102)
			p.Match(OBParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3103)
			p.Relation_factor()
		}
		{
			p.SetState(3104)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_stmtContext is an interface to support dynamic dispatch.
type ICreate_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	Temporary_option() ITemporary_optionContext
	TABLE() antlr.TerminalNode
	Relation_factor() IRelation_factorContext
	LeftParen() antlr.TerminalNode
	Table_element_list() ITable_element_listContext
	RightParen() antlr.TerminalNode
	Opt_partition_option() IOpt_partition_optionContext
	IF() antlr.TerminalNode
	Not() INotContext
	EXISTS() antlr.TerminalNode
	Table_option_list() ITable_option_listContext
	Select_stmt() ISelect_stmtContext
	AS() antlr.TerminalNode
	Partition_option() IPartition_optionContext

	// IsCreate_table_stmtContext differentiates from other interfaces.
	IsCreate_table_stmtContext()
}

type Create_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_stmtContext() *Create_table_stmtContext {
	var p = new(Create_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_table_stmt
	return p
}

func InitEmptyCreate_table_stmtContext(p *Create_table_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_table_stmt
}

func (*Create_table_stmtContext) IsCreate_table_stmtContext() {}

func NewCreate_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_stmtContext {
	var p = new(Create_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_create_table_stmt

	return p
}

func (s *Create_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE, 0)
}

func (s *Create_table_stmtContext) Temporary_option() ITemporary_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemporary_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemporary_optionContext)
}

func (s *Create_table_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE, 0)
}

func (s *Create_table_stmtContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Create_table_stmtContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Create_table_stmtContext) Table_element_list() ITable_element_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_element_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_element_listContext)
}

func (s *Create_table_stmtContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Create_table_stmtContext) Opt_partition_option() IOpt_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_partition_optionContext)
}

func (s *Create_table_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Create_table_stmtContext) Not() INotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotContext)
}

func (s *Create_table_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Create_table_stmtContext) Table_option_list() ITable_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_option_listContext)
}

func (s *Create_table_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Create_table_stmtContext) AS() antlr.TerminalNode {
	return s.GetToken(OBParserAS, 0)
}

func (s *Create_table_stmtContext) Partition_option() IPartition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartition_optionContext)
}

func (s *Create_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCreate_table_stmt(s)
	}
}

func (s *Create_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCreate_table_stmt(s)
	}
}

func (s *Create_table_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCreate_table_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Create_table_stmt() (localctx ICreate_table_stmtContext) {
	localctx = NewCreate_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, OBParserRULE_create_table_stmt)
	var _la int

	p.SetState(3206)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 227, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3108)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3109)
			p.Temporary_option()
		}
		{
			p.SetState(3110)
			p.Match(OBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3115)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIF {
			{
				p.SetState(3111)
				p.Match(OBParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3112)
				p.Not()
			}
			{
				p.SetState(3113)
				p.Match(OBParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3117)
			p.Relation_factor()
		}
		{
			p.SetState(3118)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3119)
			p.Table_element_list()
		}
		{
			p.SetState(3120)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3122)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4503601791631360) != 0) || _la == OBParserREAD || _la == OBParserTABLEGROUP || _la == OBParserPROGRESSIVE_MERGE_NUM || _la == OBParserCOMPRESSION || _la == OBParserCOMMENT || _la == OBParserENGINE_ || _la == OBParserTABLE_ID || _la == OBParserLOCALITY || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&4611969692427354369) != 0) || ((int64((_la-642)) & ^0x3f) == 0 && ((int64(1)<<(_la-642))&1442418518153756673) != 0) || ((int64((_la-748)) & ^0x3f) == 0 && ((int64(1)<<(_la-748))&343630938113) != 0) || _la == OBParserTABLE_MODE {
			{
				p.SetState(3121)
				p.Table_option_list()
			}

		}
		{
			p.SetState(3124)
			p.Opt_partition_option()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3126)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3127)
			p.Temporary_option()
		}
		{
			p.SetState(3128)
			p.Match(OBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3133)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIF {
			{
				p.SetState(3129)
				p.Match(OBParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3130)
				p.Not()
			}
			{
				p.SetState(3131)
				p.Match(OBParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3135)
			p.Relation_factor()
		}
		{
			p.SetState(3136)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3137)
			p.Table_element_list()
		}
		{
			p.SetState(3138)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3140)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4503601791631360) != 0) || _la == OBParserREAD || _la == OBParserTABLEGROUP || _la == OBParserPROGRESSIVE_MERGE_NUM || _la == OBParserCOMPRESSION || _la == OBParserCOMMENT || _la == OBParserENGINE_ || _la == OBParserTABLE_ID || _la == OBParserLOCALITY || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&4611969692427354369) != 0) || ((int64((_la-642)) & ^0x3f) == 0 && ((int64(1)<<(_la-642))&1442418518153756673) != 0) || ((int64((_la-748)) & ^0x3f) == 0 && ((int64(1)<<(_la-748))&343630938113) != 0) || _la == OBParserTABLE_MODE {
			{
				p.SetState(3139)
				p.Table_option_list()
			}

		}
		{
			p.SetState(3142)
			p.Opt_partition_option()
		}
		p.SetState(3144)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserAS {
			{
				p.SetState(3143)
				p.Match(OBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3146)
			p.Select_stmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3148)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3149)
			p.Temporary_option()
		}
		{
			p.SetState(3150)
			p.Match(OBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3155)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIF {
			{
				p.SetState(3151)
				p.Match(OBParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3152)
				p.Not()
			}
			{
				p.SetState(3153)
				p.Match(OBParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3157)
			p.Relation_factor()
		}
		{
			p.SetState(3158)
			p.Table_option_list()
		}
		{
			p.SetState(3159)
			p.Opt_partition_option()
		}
		p.SetState(3161)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserAS {
			{
				p.SetState(3160)
				p.Match(OBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3163)
			p.Select_stmt()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3165)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3166)
			p.Temporary_option()
		}
		{
			p.SetState(3167)
			p.Match(OBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3172)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIF {
			{
				p.SetState(3168)
				p.Match(OBParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3169)
				p.Not()
			}
			{
				p.SetState(3170)
				p.Match(OBParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3174)
			p.Relation_factor()
		}
		{
			p.SetState(3175)
			p.Partition_option()
		}
		p.SetState(3177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserAS {
			{
				p.SetState(3176)
				p.Match(OBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3179)
			p.Select_stmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3181)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3182)
			p.Temporary_option()
		}
		{
			p.SetState(3183)
			p.Match(OBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3188)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIF {
			{
				p.SetState(3184)
				p.Match(OBParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3185)
				p.Not()
			}
			{
				p.SetState(3186)
				p.Match(OBParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3190)
			p.Relation_factor()
		}
		{
			p.SetState(3191)
			p.Select_stmt()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3193)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3194)
			p.Temporary_option()
		}
		{
			p.SetState(3195)
			p.Match(OBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3200)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIF {
			{
				p.SetState(3196)
				p.Match(OBParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3197)
				p.Not()
			}
			{
				p.SetState(3198)
				p.Match(OBParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3202)
			p.Relation_factor()
		}
		{
			p.SetState(3203)
			p.Match(OBParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3204)
			p.Select_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRet_typeContext is an interface to support dynamic dispatch.
type IRet_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	REAL() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode

	// IsRet_typeContext differentiates from other interfaces.
	IsRet_typeContext()
}

type Ret_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRet_typeContext() *Ret_typeContext {
	var p = new(Ret_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_ret_type
	return p
}

func InitEmptyRet_typeContext(p *Ret_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_ret_type
}

func (*Ret_typeContext) IsRet_typeContext() {}

func NewRet_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ret_typeContext {
	var p = new(Ret_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_ret_type

	return p
}

func (s *Ret_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Ret_typeContext) STRING() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING, 0)
}

func (s *Ret_typeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(OBParserINTEGER, 0)
}

func (s *Ret_typeContext) REAL() antlr.TerminalNode {
	return s.GetToken(OBParserREAL, 0)
}

func (s *Ret_typeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(OBParserDECIMAL, 0)
}

func (s *Ret_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ret_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ret_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRet_type(s)
	}
}

func (s *Ret_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRet_type(s)
	}
}

func (s *Ret_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRet_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Ret_type() (localctx IRet_typeContext) {
	localctx = NewRet_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, OBParserRULE_ret_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3208)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserDECIMAL || _la == OBParserINTEGER || _la == OBParserREAL || _la == OBParserSTRING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_function_stmtContext is an interface to support dynamic dispatch.
type ICreate_function_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	NAME_OB() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	Ret_type() IRet_typeContext
	SONAME() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode

	// IsCreate_function_stmtContext differentiates from other interfaces.
	IsCreate_function_stmtContext()
}

type Create_function_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_function_stmtContext() *Create_function_stmtContext {
	var p = new(Create_function_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_function_stmt
	return p
}

func InitEmptyCreate_function_stmtContext(p *Create_function_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_function_stmt
}

func (*Create_function_stmtContext) IsCreate_function_stmtContext() {}

func NewCreate_function_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_function_stmtContext {
	var p = new(Create_function_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_create_function_stmt

	return p
}

func (s *Create_function_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_function_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE, 0)
}

func (s *Create_function_stmtContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(OBParserFUNCTION, 0)
}

func (s *Create_function_stmtContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Create_function_stmtContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(OBParserRETURNS, 0)
}

func (s *Create_function_stmtContext) Ret_type() IRet_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRet_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRet_typeContext)
}

func (s *Create_function_stmtContext) SONAME() antlr.TerminalNode {
	return s.GetToken(OBParserSONAME, 0)
}

func (s *Create_function_stmtContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Create_function_stmtContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(OBParserAGGREGATE, 0)
}

func (s *Create_function_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_function_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_function_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCreate_function_stmt(s)
	}
}

func (s *Create_function_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCreate_function_stmt(s)
	}
}

func (s *Create_function_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCreate_function_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Create_function_stmt() (localctx ICreate_function_stmtContext) {
	localctx = NewCreate_function_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, OBParserRULE_create_function_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3210)
		p.Match(OBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3212)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserAGGREGATE {
		{
			p.SetState(3211)
			p.Match(OBParserAGGREGATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3214)
		p.Match(OBParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3215)
		p.Match(OBParserNAME_OB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3216)
		p.Match(OBParserRETURNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3217)
		p.Ret_type()
	}
	{
		p.SetState(3218)
		p.Match(OBParserSONAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3219)
		p.Match(OBParserSTRING_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_function_stmtContext is an interface to support dynamic dispatch.
type IDrop_function_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	NAME_OB() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDrop_function_stmtContext differentiates from other interfaces.
	IsDrop_function_stmtContext()
}

type Drop_function_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_function_stmtContext() *Drop_function_stmtContext {
	var p = new(Drop_function_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_function_stmt
	return p
}

func InitEmptyDrop_function_stmtContext(p *Drop_function_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_function_stmt
}

func (*Drop_function_stmtContext) IsDrop_function_stmtContext() {}

func NewDrop_function_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_function_stmtContext {
	var p = new(Drop_function_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_drop_function_stmt

	return p
}

func (s *Drop_function_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_function_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Drop_function_stmtContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(OBParserFUNCTION, 0)
}

func (s *Drop_function_stmtContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Drop_function_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Drop_function_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Drop_function_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_function_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_function_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDrop_function_stmt(s)
	}
}

func (s *Drop_function_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDrop_function_stmt(s)
	}
}

func (s *Drop_function_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDrop_function_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Drop_function_stmt() (localctx IDrop_function_stmtContext) {
	localctx = NewDrop_function_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, OBParserRULE_drop_function_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3221)
		p.Match(OBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3222)
		p.Match(OBParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserIF {
		{
			p.SetState(3223)
			p.Match(OBParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3224)
			p.Match(OBParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3227)
		p.Match(OBParserNAME_OB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_element_listContext is an interface to support dynamic dispatch.
type ITable_element_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTable_element() []ITable_elementContext
	Table_element(i int) ITable_elementContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsTable_element_listContext differentiates from other interfaces.
	IsTable_element_listContext()
}

type Table_element_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_element_listContext() *Table_element_listContext {
	var p = new(Table_element_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_element_list
	return p
}

func InitEmptyTable_element_listContext(p *Table_element_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_element_list
}

func (*Table_element_listContext) IsTable_element_listContext() {}

func NewTable_element_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_element_listContext {
	var p = new(Table_element_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_table_element_list

	return p
}

func (s *Table_element_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_element_listContext) AllTable_element() []ITable_elementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITable_elementContext); ok {
			len++
		}
	}

	tst := make([]ITable_elementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITable_elementContext); ok {
			tst[i] = t.(ITable_elementContext)
			i++
		}
	}

	return tst
}

func (s *Table_element_listContext) Table_element(i int) ITable_elementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_elementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_elementContext)
}

func (s *Table_element_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Table_element_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Table_element_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_element_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_element_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTable_element_list(s)
	}
}

func (s *Table_element_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTable_element_list(s)
	}
}

func (s *Table_element_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTable_element_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Table_element_list() (localctx ITable_element_listContext) {
	localctx = NewTable_element_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, OBParserRULE_table_element_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3229)
		p.Table_element()
	}
	p.SetState(3234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(3230)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3231)
			p.Table_element()
		}

		p.SetState(3236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_elementContext is an interface to support dynamic dispatch.
type ITable_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_definition() IColumn_definitionContext
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	AllLeftParen() []antlr.TerminalNode
	LeftParen(i int) antlr.TerminalNode
	AllColumn_name_list() []IColumn_name_listContext
	Column_name_list(i int) IColumn_name_listContext
	AllRightParen() []antlr.TerminalNode
	RightParen(i int) antlr.TerminalNode
	CONSTRAINT() antlr.TerminalNode
	Opt_constraint_name() IOpt_constraint_nameContext
	AllIndex_using_algorithm() []IIndex_using_algorithmContext
	Index_using_algorithm(i int) IIndex_using_algorithmContext
	COMMENT() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	Key_or_index() IKey_or_indexContext
	Sort_column_list() ISort_column_listContext
	Index_name() IIndex_nameContext
	Opt_index_options() IOpt_index_optionsContext
	UNIQUE() antlr.TerminalNode
	Constraint_name() IConstraint_nameContext
	FULLTEXT() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	Expr() IExprContext
	FOREIGN() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	Relation_factor() IRelation_factorContext
	MATCH() antlr.TerminalNode
	Match_action() IMatch_actionContext
	Opt_reference_option_list() IOpt_reference_option_listContext
	Reference_option() IReference_optionContext

	// IsTable_elementContext differentiates from other interfaces.
	IsTable_elementContext()
}

type Table_elementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_elementContext() *Table_elementContext {
	var p = new(Table_elementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_element
	return p
}

func InitEmptyTable_elementContext(p *Table_elementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_element
}

func (*Table_elementContext) IsTable_elementContext() {}

func NewTable_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_elementContext {
	var p = new(Table_elementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_table_element

	return p
}

func (s *Table_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_elementContext) Column_definition() IColumn_definitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_definitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_definitionContext)
}

func (s *Table_elementContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(OBParserPRIMARY, 0)
}

func (s *Table_elementContext) KEY() antlr.TerminalNode {
	return s.GetToken(OBParserKEY, 0)
}

func (s *Table_elementContext) AllLeftParen() []antlr.TerminalNode {
	return s.GetTokens(OBParserLeftParen)
}

func (s *Table_elementContext) LeftParen(i int) antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, i)
}

func (s *Table_elementContext) AllColumn_name_list() []IColumn_name_listContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_name_listContext); ok {
			len++
		}
	}

	tst := make([]IColumn_name_listContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_name_listContext); ok {
			tst[i] = t.(IColumn_name_listContext)
			i++
		}
	}

	return tst
}

func (s *Table_elementContext) Column_name_list(i int) IColumn_name_listContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_name_listContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_name_listContext)
}

func (s *Table_elementContext) AllRightParen() []antlr.TerminalNode {
	return s.GetTokens(OBParserRightParen)
}

func (s *Table_elementContext) RightParen(i int) antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, i)
}

func (s *Table_elementContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(OBParserCONSTRAINT, 0)
}

func (s *Table_elementContext) Opt_constraint_name() IOpt_constraint_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_constraint_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_constraint_nameContext)
}

func (s *Table_elementContext) AllIndex_using_algorithm() []IIndex_using_algorithmContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndex_using_algorithmContext); ok {
			len++
		}
	}

	tst := make([]IIndex_using_algorithmContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndex_using_algorithmContext); ok {
			tst[i] = t.(IIndex_using_algorithmContext)
			i++
		}
	}

	return tst
}

func (s *Table_elementContext) Index_using_algorithm(i int) IIndex_using_algorithmContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_using_algorithmContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_using_algorithmContext)
}

func (s *Table_elementContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(OBParserCOMMENT, 0)
}

func (s *Table_elementContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Table_elementContext) Key_or_index() IKey_or_indexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKey_or_indexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKey_or_indexContext)
}

func (s *Table_elementContext) Sort_column_list() ISort_column_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISort_column_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISort_column_listContext)
}

func (s *Table_elementContext) Index_name() IIndex_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_nameContext)
}

func (s *Table_elementContext) Opt_index_options() IOpt_index_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_index_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_index_optionsContext)
}

func (s *Table_elementContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(OBParserUNIQUE, 0)
}

func (s *Table_elementContext) Constraint_name() IConstraint_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraint_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraint_nameContext)
}

func (s *Table_elementContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(OBParserFULLTEXT, 0)
}

func (s *Table_elementContext) CHECK() antlr.TerminalNode {
	return s.GetToken(OBParserCHECK, 0)
}

func (s *Table_elementContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Table_elementContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(OBParserFOREIGN, 0)
}

func (s *Table_elementContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(OBParserREFERENCES, 0)
}

func (s *Table_elementContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Table_elementContext) MATCH() antlr.TerminalNode {
	return s.GetToken(OBParserMATCH, 0)
}

func (s *Table_elementContext) Match_action() IMatch_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatch_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatch_actionContext)
}

func (s *Table_elementContext) Opt_reference_option_list() IOpt_reference_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_reference_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_reference_option_listContext)
}

func (s *Table_elementContext) Reference_option() IReference_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReference_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReference_optionContext)
}

func (s *Table_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTable_element(s)
	}
}

func (s *Table_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTable_element(s)
	}
}

func (s *Table_elementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTable_element(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Table_element() (localctx ITable_elementContext) {
	localctx = NewTable_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, OBParserRULE_table_element)
	var _la int

	p.SetState(3355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 255, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3237)
			p.Column_definition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3240)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCONSTRAINT {
			{
				p.SetState(3238)
				p.Match(OBParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3239)
				p.Opt_constraint_name()
			}

		}
		{
			p.SetState(3242)
			p.Match(OBParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3243)
			p.Match(OBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3245)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserUSING {
			{
				p.SetState(3244)
				p.Index_using_algorithm()
			}

		}
		{
			p.SetState(3247)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3248)
			p.Column_name_list()
		}
		{
			p.SetState(3249)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserUSING {
			{
				p.SetState(3250)
				p.Index_using_algorithm()
			}

		}
		p.SetState(3255)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMMENT {
			{
				p.SetState(3253)
				p.Match(OBParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3254)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3257)
			p.Key_or_index()
		}
		p.SetState(3259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&140737496744065) != 0) || ((int64((_la-92)) & ^0x3f) == 0 && ((int64(1)<<(_la-92))&288230513726980097) != 0) || ((int64((_la-163)) & ^0x3f) == 0 && ((int64(1)<<(_la-163))&11821949038624769) != 0) || ((int64((_la-250)) & ^0x3f) == 0 && ((int64(1)<<(_la-250))&-4629700416945258495) != 0) || ((int64((_la-314)) & ^0x3f) == 0 && ((int64(1)<<(_la-314))&-587737344112594961) != 0) || ((int64((_la-378)) & ^0x3f) == 0 && ((int64(1)<<(_la-378))&-603552873430712321) != 0) || ((int64((_la-442)) & ^0x3f) == 0 && ((int64(1)<<(_la-442))&-2305913515397021697) != 0) || ((int64((_la-506)) & ^0x3f) == 0 && ((int64(1)<<(_la-506))&8070450531845275647) != 0) || ((int64((_la-570)) & ^0x3f) == 0 && ((int64(1)<<(_la-570))&-18159534061387777) != 0) || ((int64((_la-634)) & ^0x3f) == 0 && ((int64(1)<<(_la-634))&-18146237874177) != 0) || ((int64((_la-698)) & ^0x3f) == 0 && ((int64(1)<<(_la-698))&-2533274790395907) != 0) || ((int64((_la-762)) & ^0x3f) == 0 && ((int64(1)<<(_la-762))&-1157425104234217473) != 0) || ((int64((_la-826)) & ^0x3f) == 0 && ((int64(1)<<(_la-826))&137342196111112175) != 0) || _la == OBParserNAME_OB || _la == OBParserSTAT {
			{
				p.SetState(3258)
				p.Index_name()
			}

		}
		p.SetState(3262)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserUSING {
			{
				p.SetState(3261)
				p.Index_using_algorithm()
			}

		}
		{
			p.SetState(3264)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3265)
			p.Sort_column_list()
		}
		{
			p.SetState(3266)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3268)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserWITH_ROWID || _la == OBParserLOCAL || _la == OBParserUSING || _la == OBParserWITH || _la == OBParserCOMMENT || ((int64((_la-492)) & ^0x3f) == 0 && ((int64(1)<<(_la-492))&70514773196833) != 0) || _la == OBParserBLOCK_SIZE || _la == OBParserINDEX_TABLE_ID || _la == OBParserVIRTUAL_COLUMN_ID || _la == OBParserSTORING {
			{
				p.SetState(3267)
				p.Opt_index_options()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3270)
			p.Match(OBParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3272)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserINDEX || _la == OBParserKEY {
			{
				p.SetState(3271)
				p.Key_or_index()
			}

		}
		p.SetState(3275)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&140737496744065) != 0) || ((int64((_la-92)) & ^0x3f) == 0 && ((int64(1)<<(_la-92))&288230513726980097) != 0) || ((int64((_la-163)) & ^0x3f) == 0 && ((int64(1)<<(_la-163))&11821949038624769) != 0) || ((int64((_la-250)) & ^0x3f) == 0 && ((int64(1)<<(_la-250))&-4629700416945258495) != 0) || ((int64((_la-314)) & ^0x3f) == 0 && ((int64(1)<<(_la-314))&-587737344112594961) != 0) || ((int64((_la-378)) & ^0x3f) == 0 && ((int64(1)<<(_la-378))&-603552873430712321) != 0) || ((int64((_la-442)) & ^0x3f) == 0 && ((int64(1)<<(_la-442))&-2305913515397021697) != 0) || ((int64((_la-506)) & ^0x3f) == 0 && ((int64(1)<<(_la-506))&8070450531845275647) != 0) || ((int64((_la-570)) & ^0x3f) == 0 && ((int64(1)<<(_la-570))&-18159534061387777) != 0) || ((int64((_la-634)) & ^0x3f) == 0 && ((int64(1)<<(_la-634))&-18146237874177) != 0) || ((int64((_la-698)) & ^0x3f) == 0 && ((int64(1)<<(_la-698))&-2533274790395907) != 0) || ((int64((_la-762)) & ^0x3f) == 0 && ((int64(1)<<(_la-762))&-1157425104234217473) != 0) || ((int64((_la-826)) & ^0x3f) == 0 && ((int64(1)<<(_la-826))&137342196111112175) != 0) || _la == OBParserNAME_OB || _la == OBParserSTAT {
			{
				p.SetState(3274)
				p.Index_name()
			}

		}
		p.SetState(3278)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserUSING {
			{
				p.SetState(3277)
				p.Index_using_algorithm()
			}

		}
		{
			p.SetState(3280)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3281)
			p.Sort_column_list()
		}
		{
			p.SetState(3282)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3284)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserWITH_ROWID || _la == OBParserLOCAL || _la == OBParserUSING || _la == OBParserWITH || _la == OBParserCOMMENT || ((int64((_la-492)) & ^0x3f) == 0 && ((int64(1)<<(_la-492))&70514773196833) != 0) || _la == OBParserBLOCK_SIZE || _la == OBParserINDEX_TABLE_ID || _la == OBParserVIRTUAL_COLUMN_ID || _la == OBParserSTORING {
			{
				p.SetState(3283)
				p.Opt_index_options()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3286)
			p.Match(OBParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3288)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&140737496744065) != 0) || ((int64((_la-92)) & ^0x3f) == 0 && ((int64(1)<<(_la-92))&288230513726980097) != 0) || ((int64((_la-163)) & ^0x3f) == 0 && ((int64(1)<<(_la-163))&11821949038624769) != 0) || ((int64((_la-250)) & ^0x3f) == 0 && ((int64(1)<<(_la-250))&-4629700416945258495) != 0) || ((int64((_la-314)) & ^0x3f) == 0 && ((int64(1)<<(_la-314))&-587737344112594961) != 0) || ((int64((_la-378)) & ^0x3f) == 0 && ((int64(1)<<(_la-378))&-603552873430712321) != 0) || ((int64((_la-442)) & ^0x3f) == 0 && ((int64(1)<<(_la-442))&-2305913515397021697) != 0) || ((int64((_la-506)) & ^0x3f) == 0 && ((int64(1)<<(_la-506))&8070450531845275647) != 0) || ((int64((_la-570)) & ^0x3f) == 0 && ((int64(1)<<(_la-570))&-18159534061387777) != 0) || ((int64((_la-634)) & ^0x3f) == 0 && ((int64(1)<<(_la-634))&-18146237874177) != 0) || ((int64((_la-698)) & ^0x3f) == 0 && ((int64(1)<<(_la-698))&-2533274790395907) != 0) || ((int64((_la-762)) & ^0x3f) == 0 && ((int64(1)<<(_la-762))&-1157425104234217473) != 0) || ((int64((_la-826)) & ^0x3f) == 0 && ((int64(1)<<(_la-826))&137342196111112175) != 0) || _la == OBParserNAME_OB || _la == OBParserSTAT {
			{
				p.SetState(3287)
				p.Constraint_name()
			}

		}
		{
			p.SetState(3290)
			p.Match(OBParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3292)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserINDEX || _la == OBParserKEY {
			{
				p.SetState(3291)
				p.Key_or_index()
			}

		}
		p.SetState(3295)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&140737496744065) != 0) || ((int64((_la-92)) & ^0x3f) == 0 && ((int64(1)<<(_la-92))&288230513726980097) != 0) || ((int64((_la-163)) & ^0x3f) == 0 && ((int64(1)<<(_la-163))&11821949038624769) != 0) || ((int64((_la-250)) & ^0x3f) == 0 && ((int64(1)<<(_la-250))&-4629700416945258495) != 0) || ((int64((_la-314)) & ^0x3f) == 0 && ((int64(1)<<(_la-314))&-587737344112594961) != 0) || ((int64((_la-378)) & ^0x3f) == 0 && ((int64(1)<<(_la-378))&-603552873430712321) != 0) || ((int64((_la-442)) & ^0x3f) == 0 && ((int64(1)<<(_la-442))&-2305913515397021697) != 0) || ((int64((_la-506)) & ^0x3f) == 0 && ((int64(1)<<(_la-506))&8070450531845275647) != 0) || ((int64((_la-570)) & ^0x3f) == 0 && ((int64(1)<<(_la-570))&-18159534061387777) != 0) || ((int64((_la-634)) & ^0x3f) == 0 && ((int64(1)<<(_la-634))&-18146237874177) != 0) || ((int64((_la-698)) & ^0x3f) == 0 && ((int64(1)<<(_la-698))&-2533274790395907) != 0) || ((int64((_la-762)) & ^0x3f) == 0 && ((int64(1)<<(_la-762))&-1157425104234217473) != 0) || ((int64((_la-826)) & ^0x3f) == 0 && ((int64(1)<<(_la-826))&137342196111112175) != 0) || _la == OBParserNAME_OB || _la == OBParserSTAT {
			{
				p.SetState(3294)
				p.Index_name()
			}

		}
		p.SetState(3298)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserUSING {
			{
				p.SetState(3297)
				p.Index_using_algorithm()
			}

		}
		{
			p.SetState(3300)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3301)
			p.Sort_column_list()
		}
		{
			p.SetState(3302)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3304)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserWITH_ROWID || _la == OBParserLOCAL || _la == OBParserUSING || _la == OBParserWITH || _la == OBParserCOMMENT || ((int64((_la-492)) & ^0x3f) == 0 && ((int64(1)<<(_la-492))&70514773196833) != 0) || _la == OBParserBLOCK_SIZE || _la == OBParserINDEX_TABLE_ID || _la == OBParserVIRTUAL_COLUMN_ID || _la == OBParserSTORING {
			{
				p.SetState(3303)
				p.Opt_index_options()
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3306)
			p.Match(OBParserFULLTEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserINDEX || _la == OBParserKEY {
			{
				p.SetState(3307)
				p.Key_or_index()
			}

		}
		p.SetState(3311)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&140737496744065) != 0) || ((int64((_la-92)) & ^0x3f) == 0 && ((int64(1)<<(_la-92))&288230513726980097) != 0) || ((int64((_la-163)) & ^0x3f) == 0 && ((int64(1)<<(_la-163))&11821949038624769) != 0) || ((int64((_la-250)) & ^0x3f) == 0 && ((int64(1)<<(_la-250))&-4629700416945258495) != 0) || ((int64((_la-314)) & ^0x3f) == 0 && ((int64(1)<<(_la-314))&-587737344112594961) != 0) || ((int64((_la-378)) & ^0x3f) == 0 && ((int64(1)<<(_la-378))&-603552873430712321) != 0) || ((int64((_la-442)) & ^0x3f) == 0 && ((int64(1)<<(_la-442))&-2305913515397021697) != 0) || ((int64((_la-506)) & ^0x3f) == 0 && ((int64(1)<<(_la-506))&8070450531845275647) != 0) || ((int64((_la-570)) & ^0x3f) == 0 && ((int64(1)<<(_la-570))&-18159534061387777) != 0) || ((int64((_la-634)) & ^0x3f) == 0 && ((int64(1)<<(_la-634))&-18146237874177) != 0) || ((int64((_la-698)) & ^0x3f) == 0 && ((int64(1)<<(_la-698))&-2533274790395907) != 0) || ((int64((_la-762)) & ^0x3f) == 0 && ((int64(1)<<(_la-762))&-1157425104234217473) != 0) || ((int64((_la-826)) & ^0x3f) == 0 && ((int64(1)<<(_la-826))&137342196111112175) != 0) || _la == OBParserNAME_OB || _la == OBParserSTAT {
			{
				p.SetState(3310)
				p.Index_name()
			}

		}
		p.SetState(3314)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserUSING {
			{
				p.SetState(3313)
				p.Index_using_algorithm()
			}

		}
		{
			p.SetState(3316)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3317)
			p.Sort_column_list()
		}
		{
			p.SetState(3318)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3320)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserWITH_ROWID || _la == OBParserLOCAL || _la == OBParserUSING || _la == OBParserWITH || _la == OBParserCOMMENT || ((int64((_la-492)) & ^0x3f) == 0 && ((int64(1)<<(_la-492))&70514773196833) != 0) || _la == OBParserBLOCK_SIZE || _la == OBParserINDEX_TABLE_ID || _la == OBParserVIRTUAL_COLUMN_ID || _la == OBParserSTORING {
			{
				p.SetState(3319)
				p.Opt_index_options()
			}

		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3322)
			p.Match(OBParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3323)
			p.Constraint_name()
		}
		{
			p.SetState(3324)
			p.Match(OBParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3325)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3326)
			p.expr(0)
		}
		{
			p.SetState(3327)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(3331)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCONSTRAINT {
			{
				p.SetState(3329)
				p.Match(OBParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3330)
				p.Opt_constraint_name()
			}

		}
		{
			p.SetState(3333)
			p.Match(OBParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3334)
			p.Match(OBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&140737496744065) != 0) || ((int64((_la-92)) & ^0x3f) == 0 && ((int64(1)<<(_la-92))&288230513726980097) != 0) || ((int64((_la-163)) & ^0x3f) == 0 && ((int64(1)<<(_la-163))&11821949038624769) != 0) || ((int64((_la-250)) & ^0x3f) == 0 && ((int64(1)<<(_la-250))&-4629700416945258495) != 0) || ((int64((_la-314)) & ^0x3f) == 0 && ((int64(1)<<(_la-314))&-587737344112594961) != 0) || ((int64((_la-378)) & ^0x3f) == 0 && ((int64(1)<<(_la-378))&-603552873430712321) != 0) || ((int64((_la-442)) & ^0x3f) == 0 && ((int64(1)<<(_la-442))&-2305913515397021697) != 0) || ((int64((_la-506)) & ^0x3f) == 0 && ((int64(1)<<(_la-506))&8070450531845275647) != 0) || ((int64((_la-570)) & ^0x3f) == 0 && ((int64(1)<<(_la-570))&-18159534061387777) != 0) || ((int64((_la-634)) & ^0x3f) == 0 && ((int64(1)<<(_la-634))&-18146237874177) != 0) || ((int64((_la-698)) & ^0x3f) == 0 && ((int64(1)<<(_la-698))&-2533274790395907) != 0) || ((int64((_la-762)) & ^0x3f) == 0 && ((int64(1)<<(_la-762))&-1157425104234217473) != 0) || ((int64((_la-826)) & ^0x3f) == 0 && ((int64(1)<<(_la-826))&137342196111112175) != 0) || _la == OBParserNAME_OB || _la == OBParserSTAT {
			{
				p.SetState(3335)
				p.Index_name()
			}

		}
		{
			p.SetState(3338)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3339)
			p.Column_name_list()
		}
		{
			p.SetState(3340)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3341)
			p.Match(OBParserREFERENCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3342)
			p.Relation_factor()
		}
		{
			p.SetState(3343)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3344)
			p.Column_name_list()
		}
		{
			p.SetState(3345)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3348)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 253, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3346)
				p.Match(OBParserMATCH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3347)
				p.Match_action()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3353)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 254, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3350)
				p.opt_reference_option_list(0)
			}
			{
				p.SetState(3351)
				p.Reference_option()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_reference_option_listContext is an interface to support dynamic dispatch.
type IOpt_reference_option_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Empty() IEmptyContext
	Opt_reference_option_list() IOpt_reference_option_listContext
	Reference_option() IReference_optionContext

	// IsOpt_reference_option_listContext differentiates from other interfaces.
	IsOpt_reference_option_listContext()
}

type Opt_reference_option_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_reference_option_listContext() *Opt_reference_option_listContext {
	var p = new(Opt_reference_option_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_reference_option_list
	return p
}

func InitEmptyOpt_reference_option_listContext(p *Opt_reference_option_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_reference_option_list
}

func (*Opt_reference_option_listContext) IsOpt_reference_option_listContext() {}

func NewOpt_reference_option_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_reference_option_listContext {
	var p = new(Opt_reference_option_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_reference_option_list

	return p
}

func (s *Opt_reference_option_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_reference_option_listContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Opt_reference_option_listContext) Opt_reference_option_list() IOpt_reference_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_reference_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_reference_option_listContext)
}

func (s *Opt_reference_option_listContext) Reference_option() IReference_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReference_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReference_optionContext)
}

func (s *Opt_reference_option_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_reference_option_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_reference_option_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_reference_option_list(s)
	}
}

func (s *Opt_reference_option_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_reference_option_list(s)
	}
}

func (s *Opt_reference_option_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_reference_option_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_reference_option_list() (localctx IOpt_reference_option_listContext) {
	return p.opt_reference_option_list(0)
}

func (p *OBParser) opt_reference_option_list(_p int) (localctx IOpt_reference_option_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewOpt_reference_option_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IOpt_reference_option_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 212
	p.EnterRecursionRule(localctx, 212, OBParserRULE_opt_reference_option_list, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3358)
		p.Empty()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 256, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewOpt_reference_option_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, OBParserRULE_opt_reference_option_list)
			p.SetState(3360)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(3361)
				p.Reference_option()
			}

		}
		p.SetState(3366)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 256, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReference_optionContext is an interface to support dynamic dispatch.
type IReference_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	Reference_action() IReference_actionContext
	DELETE() antlr.TerminalNode

	// IsReference_optionContext differentiates from other interfaces.
	IsReference_optionContext()
}

type Reference_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReference_optionContext() *Reference_optionContext {
	var p = new(Reference_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_reference_option
	return p
}

func InitEmptyReference_optionContext(p *Reference_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_reference_option
}

func (*Reference_optionContext) IsReference_optionContext() {}

func NewReference_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reference_optionContext {
	var p = new(Reference_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_reference_option

	return p
}

func (s *Reference_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Reference_optionContext) ON() antlr.TerminalNode {
	return s.GetToken(OBParserON, 0)
}

func (s *Reference_optionContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(OBParserUPDATE, 0)
}

func (s *Reference_optionContext) Reference_action() IReference_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReference_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReference_actionContext)
}

func (s *Reference_optionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(OBParserDELETE, 0)
}

func (s *Reference_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reference_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reference_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterReference_option(s)
	}
}

func (s *Reference_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitReference_option(s)
	}
}

func (s *Reference_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitReference_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Reference_option() (localctx IReference_optionContext) {
	localctx = NewReference_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, OBParserRULE_reference_option)
	p.SetState(3373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 257, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3367)
			p.Match(OBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3368)
			p.Match(OBParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3369)
			p.Reference_action()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3370)
			p.Match(OBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3371)
			p.Match(OBParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3372)
			p.Reference_action()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReference_actionContext is an interface to support dynamic dispatch.
type IReference_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESTRICT() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	SET() antlr.TerminalNode
	NULLX() antlr.TerminalNode
	NO() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsReference_actionContext differentiates from other interfaces.
	IsReference_actionContext()
}

type Reference_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReference_actionContext() *Reference_actionContext {
	var p = new(Reference_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_reference_action
	return p
}

func InitEmptyReference_actionContext(p *Reference_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_reference_action
}

func (*Reference_actionContext) IsReference_actionContext() {}

func NewReference_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reference_actionContext {
	var p = new(Reference_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_reference_action

	return p
}

func (s *Reference_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Reference_actionContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(OBParserRESTRICT, 0)
}

func (s *Reference_actionContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(OBParserCASCADE, 0)
}

func (s *Reference_actionContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Reference_actionContext) NULLX() antlr.TerminalNode {
	return s.GetToken(OBParserNULLX, 0)
}

func (s *Reference_actionContext) NO() antlr.TerminalNode {
	return s.GetToken(OBParserNO, 0)
}

func (s *Reference_actionContext) ACTION() antlr.TerminalNode {
	return s.GetToken(OBParserACTION, 0)
}

func (s *Reference_actionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT, 0)
}

func (s *Reference_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reference_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reference_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterReference_action(s)
	}
}

func (s *Reference_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitReference_action(s)
	}
}

func (s *Reference_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitReference_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Reference_action() (localctx IReference_actionContext) {
	localctx = NewReference_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, OBParserRULE_reference_action)
	p.SetState(3383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 258, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3375)
			p.Match(OBParserRESTRICT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3376)
			p.Match(OBParserCASCADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3377)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3378)
			p.Match(OBParserNULLX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3379)
			p.Match(OBParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3380)
			p.Match(OBParserACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3381)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3382)
			p.Match(OBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatch_actionContext is an interface to support dynamic dispatch.
type IMatch_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SIMPLE() antlr.TerminalNode
	FULL() antlr.TerminalNode
	PARTIAL() antlr.TerminalNode

	// IsMatch_actionContext differentiates from other interfaces.
	IsMatch_actionContext()
}

type Match_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatch_actionContext() *Match_actionContext {
	var p = new(Match_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_match_action
	return p
}

func InitEmptyMatch_actionContext(p *Match_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_match_action
}

func (*Match_actionContext) IsMatch_actionContext() {}

func NewMatch_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Match_actionContext {
	var p = new(Match_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_match_action

	return p
}

func (s *Match_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Match_actionContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(OBParserSIMPLE, 0)
}

func (s *Match_actionContext) FULL() antlr.TerminalNode {
	return s.GetToken(OBParserFULL, 0)
}

func (s *Match_actionContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(OBParserPARTIAL, 0)
}

func (s *Match_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Match_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Match_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterMatch_action(s)
	}
}

func (s *Match_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitMatch_action(s)
	}
}

func (s *Match_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitMatch_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Match_action() (localctx IMatch_actionContext) {
	localctx = NewMatch_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, OBParserRULE_match_action)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3385)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserFULL || _la == OBParserSIMPLE || _la == OBParserPARTIAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_definitionContext is an interface to support dynamic dispatch.
type IColumn_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_definition_ref() IColumn_definition_refContext
	Data_type() IData_typeContext
	Opt_column_attribute_list() IOpt_column_attribute_listContext
	Column_attribute() IColumn_attributeContext
	FIRST() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	Column_name() IColumn_nameContext
	AFTER() antlr.TerminalNode
	AS() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Expr() IExprContext
	RightParen() antlr.TerminalNode
	GENERATED() antlr.TerminalNode
	ALWAYS() antlr.TerminalNode
	Opt_generated_column_attribute_list() IOpt_generated_column_attribute_listContext
	Generated_column_attribute() IGenerated_column_attributeContext
	VIRTUAL() antlr.TerminalNode
	STORED() antlr.TerminalNode

	// IsColumn_definitionContext differentiates from other interfaces.
	IsColumn_definitionContext()
}

type Column_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_definitionContext() *Column_definitionContext {
	var p = new(Column_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_definition
	return p
}

func InitEmptyColumn_definitionContext(p *Column_definitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_definition
}

func (*Column_definitionContext) IsColumn_definitionContext() {}

func NewColumn_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_definitionContext {
	var p = new(Column_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_column_definition

	return p
}

func (s *Column_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_definitionContext) Column_definition_ref() IColumn_definition_refContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_definition_refContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_definition_refContext)
}

func (s *Column_definitionContext) Data_type() IData_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IData_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Column_definitionContext) Opt_column_attribute_list() IOpt_column_attribute_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_column_attribute_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_column_attribute_listContext)
}

func (s *Column_definitionContext) Column_attribute() IColumn_attributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_attributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_attributeContext)
}

func (s *Column_definitionContext) FIRST() antlr.TerminalNode {
	return s.GetToken(OBParserFIRST, 0)
}

func (s *Column_definitionContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(OBParserBEFORE, 0)
}

func (s *Column_definitionContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Column_definitionContext) AFTER() antlr.TerminalNode {
	return s.GetToken(OBParserAFTER, 0)
}

func (s *Column_definitionContext) AS() antlr.TerminalNode {
	return s.GetToken(OBParserAS, 0)
}

func (s *Column_definitionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Column_definitionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Column_definitionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Column_definitionContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(OBParserGENERATED, 0)
}

func (s *Column_definitionContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(OBParserALWAYS, 0)
}

func (s *Column_definitionContext) Opt_generated_column_attribute_list() IOpt_generated_column_attribute_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_generated_column_attribute_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_generated_column_attribute_listContext)
}

func (s *Column_definitionContext) Generated_column_attribute() IGenerated_column_attributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenerated_column_attributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenerated_column_attributeContext)
}

func (s *Column_definitionContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(OBParserVIRTUAL, 0)
}

func (s *Column_definitionContext) STORED() antlr.TerminalNode {
	return s.GetToken(OBParserSTORED, 0)
}

func (s *Column_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterColumn_definition(s)
	}
}

func (s *Column_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitColumn_definition(s)
	}
}

func (s *Column_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitColumn_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Column_definition() (localctx IColumn_definitionContext) {
	localctx = NewColumn_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, OBParserRULE_column_definition)
	var _la int

	p.SetState(3426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 265, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3387)
			p.Column_definition_ref()
		}
		{
			p.SetState(3388)
			p.Data_type()
		}
		p.SetState(3392)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 259, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3389)
				p.opt_column_attribute_list(0)
			}
			{
				p.SetState(3390)
				p.Column_attribute()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3399)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3394)
				p.Match(OBParserFIRST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3395)
				p.Match(OBParserBEFORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3396)
				p.Column_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(3397)
				p.Match(OBParserAFTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3398)
				p.Column_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3401)
			p.Column_definition_ref()
		}
		{
			p.SetState(3402)
			p.Data_type()
		}
		p.SetState(3405)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserGENERATED {
			{
				p.SetState(3403)
				p.Match(OBParserGENERATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3404)
				p.Match(OBParserALWAYS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3407)
			p.Match(OBParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3408)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3409)
			p.expr(0)
		}
		{
			p.SetState(3410)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3412)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3411)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserSTORED || _la == OBParserVIRTUAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3417)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3414)
				p.opt_generated_column_attribute_list(0)
			}
			{
				p.SetState(3415)
				p.Generated_column_attribute()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3424)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3419)
				p.Match(OBParserFIRST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3420)
				p.Match(OBParserBEFORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3421)
				p.Column_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(3422)
				p.Match(OBParserAFTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3423)
				p.Column_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_generated_column_attribute_listContext is an interface to support dynamic dispatch.
type IOpt_generated_column_attribute_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Empty() IEmptyContext
	Opt_generated_column_attribute_list() IOpt_generated_column_attribute_listContext
	Generated_column_attribute() IGenerated_column_attributeContext

	// IsOpt_generated_column_attribute_listContext differentiates from other interfaces.
	IsOpt_generated_column_attribute_listContext()
}

type Opt_generated_column_attribute_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_generated_column_attribute_listContext() *Opt_generated_column_attribute_listContext {
	var p = new(Opt_generated_column_attribute_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_generated_column_attribute_list
	return p
}

func InitEmptyOpt_generated_column_attribute_listContext(p *Opt_generated_column_attribute_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_generated_column_attribute_list
}

func (*Opt_generated_column_attribute_listContext) IsOpt_generated_column_attribute_listContext() {}

func NewOpt_generated_column_attribute_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_generated_column_attribute_listContext {
	var p = new(Opt_generated_column_attribute_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_generated_column_attribute_list

	return p
}

func (s *Opt_generated_column_attribute_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_generated_column_attribute_listContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Opt_generated_column_attribute_listContext) Opt_generated_column_attribute_list() IOpt_generated_column_attribute_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_generated_column_attribute_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_generated_column_attribute_listContext)
}

func (s *Opt_generated_column_attribute_listContext) Generated_column_attribute() IGenerated_column_attributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenerated_column_attributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenerated_column_attributeContext)
}

func (s *Opt_generated_column_attribute_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_generated_column_attribute_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_generated_column_attribute_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_generated_column_attribute_list(s)
	}
}

func (s *Opt_generated_column_attribute_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_generated_column_attribute_list(s)
	}
}

func (s *Opt_generated_column_attribute_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_generated_column_attribute_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_generated_column_attribute_list() (localctx IOpt_generated_column_attribute_listContext) {
	return p.opt_generated_column_attribute_list(0)
}

func (p *OBParser) opt_generated_column_attribute_list(_p int) (localctx IOpt_generated_column_attribute_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewOpt_generated_column_attribute_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IOpt_generated_column_attribute_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 222
	p.EnterRecursionRule(localctx, 222, OBParserRULE_opt_generated_column_attribute_list, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3429)
		p.Empty()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 266, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewOpt_generated_column_attribute_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, OBParserRULE_opt_generated_column_attribute_list)
			p.SetState(3431)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(3432)
				p.Generated_column_attribute()
			}

		}
		p.SetState(3437)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 266, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenerated_column_attributeContext is an interface to support dynamic dispatch.
type IGenerated_column_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT() antlr.TerminalNode
	NULLX() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	ID() antlr.TerminalNode
	INTNUM() antlr.TerminalNode

	// IsGenerated_column_attributeContext differentiates from other interfaces.
	IsGenerated_column_attributeContext()
}

type Generated_column_attributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerated_column_attributeContext() *Generated_column_attributeContext {
	var p = new(Generated_column_attributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_generated_column_attribute
	return p
}

func InitEmptyGenerated_column_attributeContext(p *Generated_column_attributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_generated_column_attribute
}

func (*Generated_column_attributeContext) IsGenerated_column_attributeContext() {}

func NewGenerated_column_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generated_column_attributeContext {
	var p = new(Generated_column_attributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_generated_column_attribute

	return p
}

func (s *Generated_column_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Generated_column_attributeContext) NOT() antlr.TerminalNode {
	return s.GetToken(OBParserNOT, 0)
}

func (s *Generated_column_attributeContext) NULLX() antlr.TerminalNode {
	return s.GetToken(OBParserNULLX, 0)
}

func (s *Generated_column_attributeContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(OBParserUNIQUE, 0)
}

func (s *Generated_column_attributeContext) KEY() antlr.TerminalNode {
	return s.GetToken(OBParserKEY, 0)
}

func (s *Generated_column_attributeContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(OBParserPRIMARY, 0)
}

func (s *Generated_column_attributeContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(OBParserCOMMENT, 0)
}

func (s *Generated_column_attributeContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Generated_column_attributeContext) ID() antlr.TerminalNode {
	return s.GetToken(OBParserID, 0)
}

func (s *Generated_column_attributeContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Generated_column_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generated_column_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generated_column_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterGenerated_column_attribute(s)
	}
}

func (s *Generated_column_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitGenerated_column_attribute(s)
	}
}

func (s *Generated_column_attributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitGenerated_column_attribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Generated_column_attribute() (localctx IGenerated_column_attributeContext) {
	localctx = NewGenerated_column_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, OBParserRULE_generated_column_attribute)
	var _la int

	p.SetState(3452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 268, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3438)
			p.Match(OBParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3439)
			p.Match(OBParserNULLX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3440)
			p.Match(OBParserNULLX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3441)
			p.Match(OBParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3442)
			p.Match(OBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(3444)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPRIMARY {
			{
				p.SetState(3443)
				p.Match(OBParserPRIMARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3446)
			p.Match(OBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3447)
			p.Match(OBParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3448)
			p.Match(OBParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3449)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3450)
			p.Match(OBParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3451)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_definition_refContext is an interface to support dynamic dispatch.
type IColumn_definition_refContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_name() IColumn_nameContext
	AllRelation_name() []IRelation_nameContext
	Relation_name(i int) IRelation_nameContext
	AllDot() []antlr.TerminalNode
	Dot(i int) antlr.TerminalNode

	// IsColumn_definition_refContext differentiates from other interfaces.
	IsColumn_definition_refContext()
}

type Column_definition_refContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_definition_refContext() *Column_definition_refContext {
	var p = new(Column_definition_refContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_definition_ref
	return p
}

func InitEmptyColumn_definition_refContext(p *Column_definition_refContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_definition_ref
}

func (*Column_definition_refContext) IsColumn_definition_refContext() {}

func NewColumn_definition_refContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_definition_refContext {
	var p = new(Column_definition_refContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_column_definition_ref

	return p
}

func (s *Column_definition_refContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_definition_refContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Column_definition_refContext) AllRelation_name() []IRelation_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_nameContext); ok {
			len++
		}
	}

	tst := make([]IRelation_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_nameContext); ok {
			tst[i] = t.(IRelation_nameContext)
			i++
		}
	}

	return tst
}

func (s *Column_definition_refContext) Relation_name(i int) IRelation_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Column_definition_refContext) AllDot() []antlr.TerminalNode {
	return s.GetTokens(OBParserDot)
}

func (s *Column_definition_refContext) Dot(i int) antlr.TerminalNode {
	return s.GetToken(OBParserDot, i)
}

func (s *Column_definition_refContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_definition_refContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_definition_refContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterColumn_definition_ref(s)
	}
}

func (s *Column_definition_refContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitColumn_definition_ref(s)
	}
}

func (s *Column_definition_refContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitColumn_definition_ref(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Column_definition_ref() (localctx IColumn_definition_refContext) {
	localctx = NewColumn_definition_refContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, OBParserRULE_column_definition_ref)
	p.SetState(3465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 269, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3454)
			p.Column_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3455)
			p.Relation_name()
		}
		{
			p.SetState(3456)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3457)
			p.Column_name()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3459)
			p.Relation_name()
		}
		{
			p.SetState(3460)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3461)
			p.Relation_name()
		}
		{
			p.SetState(3462)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3463)
			p.Column_name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_definition_listContext is an interface to support dynamic dispatch.
type IColumn_definition_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumn_definition() []IColumn_definitionContext
	Column_definition(i int) IColumn_definitionContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsColumn_definition_listContext differentiates from other interfaces.
	IsColumn_definition_listContext()
}

type Column_definition_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_definition_listContext() *Column_definition_listContext {
	var p = new(Column_definition_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_definition_list
	return p
}

func InitEmptyColumn_definition_listContext(p *Column_definition_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_definition_list
}

func (*Column_definition_listContext) IsColumn_definition_listContext() {}

func NewColumn_definition_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_definition_listContext {
	var p = new(Column_definition_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_column_definition_list

	return p
}

func (s *Column_definition_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_definition_listContext) AllColumn_definition() []IColumn_definitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_definitionContext); ok {
			len++
		}
	}

	tst := make([]IColumn_definitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_definitionContext); ok {
			tst[i] = t.(IColumn_definitionContext)
			i++
		}
	}

	return tst
}

func (s *Column_definition_listContext) Column_definition(i int) IColumn_definitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_definitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_definitionContext)
}

func (s *Column_definition_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Column_definition_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Column_definition_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_definition_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_definition_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterColumn_definition_list(s)
	}
}

func (s *Column_definition_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitColumn_definition_list(s)
	}
}

func (s *Column_definition_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitColumn_definition_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Column_definition_list() (localctx IColumn_definition_listContext) {
	localctx = NewColumn_definition_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, OBParserRULE_column_definition_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3467)
		p.Column_definition()
	}
	p.SetState(3472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(3468)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3469)
			p.Column_definition()
		}

		p.SetState(3474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICast_data_typeContext is an interface to support dynamic dispatch.
type ICast_data_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINARY() antlr.TerminalNode
	String_length_i() IString_length_iContext
	CHARACTER() antlr.TerminalNode
	Cast_datetime_type_i() ICast_datetime_type_iContext
	LeftParen() antlr.TerminalNode
	AllINTNUM() []antlr.TerminalNode
	INTNUM(i int) antlr.TerminalNode
	RightParen() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	Comma() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	UNSIGNED() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode

	// IsCast_data_typeContext differentiates from other interfaces.
	IsCast_data_typeContext()
}

type Cast_data_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCast_data_typeContext() *Cast_data_typeContext {
	var p = new(Cast_data_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cast_data_type
	return p
}

func InitEmptyCast_data_typeContext(p *Cast_data_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cast_data_type
}

func (*Cast_data_typeContext) IsCast_data_typeContext() {}

func NewCast_data_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cast_data_typeContext {
	var p = new(Cast_data_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_cast_data_type

	return p
}

func (s *Cast_data_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Cast_data_typeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(OBParserBINARY, 0)
}

func (s *Cast_data_typeContext) String_length_i() IString_length_iContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_length_iContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_length_iContext)
}

func (s *Cast_data_typeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(OBParserCHARACTER, 0)
}

func (s *Cast_data_typeContext) Cast_datetime_type_i() ICast_datetime_type_iContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICast_datetime_type_iContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICast_datetime_type_iContext)
}

func (s *Cast_data_typeContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Cast_data_typeContext) AllINTNUM() []antlr.TerminalNode {
	return s.GetTokens(OBParserINTNUM)
}

func (s *Cast_data_typeContext) INTNUM(i int) antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, i)
}

func (s *Cast_data_typeContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Cast_data_typeContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(OBParserNUMBER, 0)
}

func (s *Cast_data_typeContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Cast_data_typeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(OBParserDECIMAL, 0)
}

func (s *Cast_data_typeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(OBParserSIGNED, 0)
}

func (s *Cast_data_typeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(OBParserINTEGER, 0)
}

func (s *Cast_data_typeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(OBParserUNSIGNED, 0)
}

func (s *Cast_data_typeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(OBParserDOUBLE, 0)
}

func (s *Cast_data_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cast_data_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cast_data_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCast_data_type(s)
	}
}

func (s *Cast_data_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCast_data_type(s)
	}
}

func (s *Cast_data_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCast_data_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Cast_data_type() (localctx ICast_data_typeContext) {
	localctx = NewCast_data_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, OBParserRULE_cast_data_type)
	var _la int

	p.SetState(3523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserBINARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3475)
			p.Match(OBParserBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3477)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserLeftParen {
			{
				p.SetState(3476)
				p.String_length_i()
			}

		}

	case OBParserCHARACTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3479)
			p.Match(OBParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3481)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserLeftParen {
			{
				p.SetState(3480)
				p.String_length_i()
			}

		}
		p.SetState(3484)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserBINARY {
			{
				p.SetState(3483)
				p.Match(OBParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case OBParserTIME, OBParserDATETIME, OBParserDATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3486)
			p.Cast_datetime_type_i()
		}
		p.SetState(3490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserLeftParen {
			{
				p.SetState(3487)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3488)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3489)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case OBParserNUMBER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3492)
			p.Match(OBParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3501)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 275, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3493)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3494)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3495)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3496)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3497)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 275, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3498)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3499)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3500)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case OBParserDECIMAL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3503)
			p.Match(OBParserDECIMAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3512)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 276, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3504)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3505)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3506)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3507)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3508)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 276, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3509)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3510)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3511)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case OBParserSIGNED:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3514)
			p.Match(OBParserSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3516)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserINTEGER {
			{
				p.SetState(3515)
				p.Match(OBParserINTEGER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case OBParserUNSIGNED:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3518)
			p.Match(OBParserUNSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3520)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserINTEGER {
			{
				p.SetState(3519)
				p.Match(OBParserINTEGER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case OBParserDOUBLE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3522)
			p.Match(OBParserDOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICast_datetime_type_iContext is an interface to support dynamic dispatch.
type ICast_datetime_type_iContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATETIME() antlr.TerminalNode
	DATE() antlr.TerminalNode
	TIME() antlr.TerminalNode

	// IsCast_datetime_type_iContext differentiates from other interfaces.
	IsCast_datetime_type_iContext()
}

type Cast_datetime_type_iContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCast_datetime_type_iContext() *Cast_datetime_type_iContext {
	var p = new(Cast_datetime_type_iContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cast_datetime_type_i
	return p
}

func InitEmptyCast_datetime_type_iContext(p *Cast_datetime_type_iContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cast_datetime_type_i
}

func (*Cast_datetime_type_iContext) IsCast_datetime_type_iContext() {}

func NewCast_datetime_type_iContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cast_datetime_type_iContext {
	var p = new(Cast_datetime_type_iContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_cast_datetime_type_i

	return p
}

func (s *Cast_datetime_type_iContext) GetParser() antlr.Parser { return s.parser }

func (s *Cast_datetime_type_iContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(OBParserDATETIME, 0)
}

func (s *Cast_datetime_type_iContext) DATE() antlr.TerminalNode {
	return s.GetToken(OBParserDATE, 0)
}

func (s *Cast_datetime_type_iContext) TIME() antlr.TerminalNode {
	return s.GetToken(OBParserTIME, 0)
}

func (s *Cast_datetime_type_iContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cast_datetime_type_iContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cast_datetime_type_iContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCast_datetime_type_i(s)
	}
}

func (s *Cast_datetime_type_iContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCast_datetime_type_i(s)
	}
}

func (s *Cast_datetime_type_iContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCast_datetime_type_i(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Cast_datetime_type_i() (localctx ICast_datetime_type_iContext) {
	localctx = NewCast_datetime_type_iContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, OBParserRULE_cast_datetime_type_i)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3525)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserTIME || _la == OBParserDATETIME || _la == OBParserDATE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IData_typeContext is an interface to support dynamic dispatch.
type IData_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Int_type_i() IInt_type_iContext
	LeftParen() antlr.TerminalNode
	AllINTNUM() []antlr.TerminalNode
	INTNUM(i int) antlr.TerminalNode
	RightParen() antlr.TerminalNode
	ZEROFILL() antlr.TerminalNode
	UNSIGNED() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	Float_type_i() IFloat_type_iContext
	Comma() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	Datetime_type_i() IDatetime_type_iContext
	Date_year_type_i() IDate_year_type_iContext
	CHARACTER() antlr.TerminalNode
	String_length_i() IString_length_iContext
	BINARY() antlr.TerminalNode
	Charset_key() ICharset_keyContext
	Charset_name() ICharset_nameContext
	Collation() ICollationContext
	VARCHAR() antlr.TerminalNode
	Blob_type_i() IBlob_type_iContext
	Text_type_i() IText_type_iContext
	VARBINARY() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	BIT() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	String_list() IString_listContext
	SET() antlr.TerminalNode

	// IsData_typeContext differentiates from other interfaces.
	IsData_typeContext()
}

type Data_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyData_typeContext() *Data_typeContext {
	var p = new(Data_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_data_type
	return p
}

func InitEmptyData_typeContext(p *Data_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_data_type
}

func (*Data_typeContext) IsData_typeContext() {}

func NewData_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Data_typeContext {
	var p = new(Data_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_data_type

	return p
}

func (s *Data_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Data_typeContext) Int_type_i() IInt_type_iContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_type_iContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_type_iContext)
}

func (s *Data_typeContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Data_typeContext) AllINTNUM() []antlr.TerminalNode {
	return s.GetTokens(OBParserINTNUM)
}

func (s *Data_typeContext) INTNUM(i int) antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, i)
}

func (s *Data_typeContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Data_typeContext) ZEROFILL() antlr.TerminalNode {
	return s.GetToken(OBParserZEROFILL, 0)
}

func (s *Data_typeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(OBParserUNSIGNED, 0)
}

func (s *Data_typeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(OBParserSIGNED, 0)
}

func (s *Data_typeContext) Float_type_i() IFloat_type_iContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloat_type_iContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloat_type_iContext)
}

func (s *Data_typeContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Data_typeContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(OBParserNUMBER, 0)
}

func (s *Data_typeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(OBParserDECIMAL, 0)
}

func (s *Data_typeContext) BOOL() antlr.TerminalNode {
	return s.GetToken(OBParserBOOL, 0)
}

func (s *Data_typeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(OBParserBOOLEAN, 0)
}

func (s *Data_typeContext) Datetime_type_i() IDatetime_type_iContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetime_type_iContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetime_type_iContext)
}

func (s *Data_typeContext) Date_year_type_i() IDate_year_type_iContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDate_year_type_iContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDate_year_type_iContext)
}

func (s *Data_typeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(OBParserCHARACTER, 0)
}

func (s *Data_typeContext) String_length_i() IString_length_iContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_length_iContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_length_iContext)
}

func (s *Data_typeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(OBParserBINARY, 0)
}

func (s *Data_typeContext) Charset_key() ICharset_keyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_keyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_keyContext)
}

func (s *Data_typeContext) Charset_name() ICharset_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_nameContext)
}

func (s *Data_typeContext) Collation() ICollationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationContext)
}

func (s *Data_typeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(OBParserVARCHAR, 0)
}

func (s *Data_typeContext) Blob_type_i() IBlob_type_iContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlob_type_iContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlob_type_iContext)
}

func (s *Data_typeContext) Text_type_i() IText_type_iContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IText_type_iContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IText_type_iContext)
}

func (s *Data_typeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(OBParserVARBINARY, 0)
}

func (s *Data_typeContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Data_typeContext) BIT() antlr.TerminalNode {
	return s.GetToken(OBParserBIT, 0)
}

func (s *Data_typeContext) ENUM() antlr.TerminalNode {
	return s.GetToken(OBParserENUM, 0)
}

func (s *Data_typeContext) String_list() IString_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IString_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IString_listContext)
}

func (s *Data_typeContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Data_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Data_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Data_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterData_type(s)
	}
}

func (s *Data_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitData_type(s)
	}
}

func (s *Data_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitData_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Data_type() (localctx IData_typeContext) {
	localctx = NewData_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, OBParserRULE_data_type)
	var _la int

	p.SetState(3689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserBIGINT, OBParserINTEGER, OBParserMEDIUMINT, OBParserSMALLINT, OBParserTINYINT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3527)
			p.Int_type_i()
		}
		p.SetState(3531)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 280, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3528)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3529)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3530)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3534)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 281, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3533)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserUNSIGNED || _la == OBParserSIGNED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3537)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3536)
				p.Match(OBParserZEROFILL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case OBParserDOUBLE, OBParserFLOAT, OBParserREAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3539)
			p.Float_type_i()
		}
		p.SetState(3548)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 283, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3540)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3541)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3542)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3543)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3544)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 283, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3545)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3546)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3547)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3551)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 284, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3550)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserUNSIGNED || _la == OBParserSIGNED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3554)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 285, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3553)
				p.Match(OBParserZEROFILL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case OBParserNUMBER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3556)
			p.Match(OBParserNUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3565)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3557)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3558)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3559)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3560)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3561)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3562)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3563)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3564)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3568)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3567)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserUNSIGNED || _la == OBParserSIGNED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3571)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 288, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3570)
				p.Match(OBParserZEROFILL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case OBParserDECIMAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3573)
			p.Match(OBParserDECIMAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3582)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 289, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3574)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3575)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3576)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3577)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3578)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 289, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3579)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3580)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3581)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3585)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 290, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3584)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserUNSIGNED || _la == OBParserSIGNED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3588)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 291, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3587)
				p.Match(OBParserZEROFILL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case OBParserBOOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3590)
			p.Match(OBParserBOOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserBOOLEAN:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3591)
			p.Match(OBParserBOOLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserTIMESTAMP, OBParserTIME, OBParserDATETIME:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3592)
			p.Datetime_type_i()
		}
		p.SetState(3596)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 292, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3593)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3594)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3595)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case OBParserYEAR, OBParserDATE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3598)
			p.Date_year_type_i()
		}

	case OBParserCHARACTER:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3599)
			p.Match(OBParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3601)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 293, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3600)
				p.String_length_i()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3604)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3603)
				p.Match(OBParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3609)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 295, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3606)
				p.Charset_key()
			}
			{
				p.SetState(3607)
				p.Charset_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3612)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 296, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3611)
				p.Collation()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case OBParserVARCHAR:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3614)
			p.Match(OBParserVARCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3615)
			p.String_length_i()
		}
		p.SetState(3617)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 297, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3616)
				p.Match(OBParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3622)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 298, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3619)
				p.Charset_key()
			}
			{
				p.SetState(3620)
				p.Charset_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3625)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 299, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3624)
				p.Collation()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case OBParserBLOB, OBParserLONGBLOB, OBParserMEDIUMBLOB, OBParserTINYBLOB:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3627)
			p.Blob_type_i()
		}
		p.SetState(3629)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 300, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3628)
				p.String_length_i()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case OBParserLONGTEXT, OBParserMEDIUMTEXT, OBParserTEXT, OBParserTINYTEXT:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3631)
			p.Text_type_i()
		}
		p.SetState(3633)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 301, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3632)
				p.String_length_i()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3636)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 302, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3635)
				p.Match(OBParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3641)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 303, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3638)
				p.Charset_key()
			}
			{
				p.SetState(3639)
				p.Charset_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3644)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 304, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3643)
				p.Collation()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case OBParserBINARY:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3646)
			p.Match(OBParserBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3648)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 305, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3647)
				p.String_length_i()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case OBParserVARBINARY:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3650)
			p.Match(OBParserVARBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3651)
			p.String_length_i()
		}

	case OBParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3652)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserBIT:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3653)
			p.Match(OBParserBIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3657)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 306, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3654)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3655)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3656)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case OBParserENUM:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3659)
			p.Match(OBParserENUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3660)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3661)
			p.String_list()
		}
		{
			p.SetState(3662)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3664)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 307, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3663)
				p.Match(OBParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3669)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 308, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3666)
				p.Charset_key()
			}
			{
				p.SetState(3667)
				p.Charset_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3672)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 309, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3671)
				p.Collation()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case OBParserSET:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(3674)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3675)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3676)
			p.String_list()
		}
		{
			p.SetState(3677)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3679)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 310, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3678)
				p.Match(OBParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3684)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 311, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3681)
				p.Charset_key()
			}
			{
				p.SetState(3682)
				p.Charset_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3687)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 312, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3686)
				p.Collation()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IString_listContext is an interface to support dynamic dispatch.
type IString_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllText_string() []IText_stringContext
	Text_string(i int) IText_stringContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsString_listContext differentiates from other interfaces.
	IsString_listContext()
}

type String_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_listContext() *String_listContext {
	var p = new(String_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_string_list
	return p
}

func InitEmptyString_listContext(p *String_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_string_list
}

func (*String_listContext) IsString_listContext() {}

func NewString_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_listContext {
	var p = new(String_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_string_list

	return p
}

func (s *String_listContext) GetParser() antlr.Parser { return s.parser }

func (s *String_listContext) AllText_string() []IText_stringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IText_stringContext); ok {
			len++
		}
	}

	tst := make([]IText_stringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IText_stringContext); ok {
			tst[i] = t.(IText_stringContext)
			i++
		}
	}

	return tst
}

func (s *String_listContext) Text_string(i int) IText_stringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IText_stringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IText_stringContext)
}

func (s *String_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *String_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *String_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterString_list(s)
	}
}

func (s *String_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitString_list(s)
	}
}

func (s *String_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitString_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) String_list() (localctx IString_listContext) {
	localctx = NewString_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, OBParserRULE_string_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3691)
		p.Text_string()
	}
	p.SetState(3696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(3692)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3693)
			p.Text_string()
		}

		p.SetState(3698)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IText_stringContext is an interface to support dynamic dispatch.
type IText_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_VALUE() antlr.TerminalNode
	HEX_STRING_VALUE() antlr.TerminalNode

	// IsText_stringContext differentiates from other interfaces.
	IsText_stringContext()
}

type Text_stringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_stringContext() *Text_stringContext {
	var p = new(Text_stringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_text_string
	return p
}

func InitEmptyText_stringContext(p *Text_stringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_text_string
}

func (*Text_stringContext) IsText_stringContext() {}

func NewText_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_stringContext {
	var p = new(Text_stringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_text_string

	return p
}

func (s *Text_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_stringContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Text_stringContext) HEX_STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserHEX_STRING_VALUE, 0)
}

func (s *Text_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterText_string(s)
	}
}

func (s *Text_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitText_string(s)
	}
}

func (s *Text_stringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitText_string(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Text_string() (localctx IText_stringContext) {
	localctx = NewText_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, OBParserRULE_text_string)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3699)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserHEX_STRING_VALUE || _la == OBParserSTRING_VALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInt_type_iContext is an interface to support dynamic dispatch.
type IInt_type_iContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TINYINT() antlr.TerminalNode
	SMALLINT() antlr.TerminalNode
	MEDIUMINT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	BIGINT() antlr.TerminalNode

	// IsInt_type_iContext differentiates from other interfaces.
	IsInt_type_iContext()
}

type Int_type_iContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInt_type_iContext() *Int_type_iContext {
	var p = new(Int_type_iContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_int_type_i
	return p
}

func InitEmptyInt_type_iContext(p *Int_type_iContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_int_type_i
}

func (*Int_type_iContext) IsInt_type_iContext() {}

func NewInt_type_iContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int_type_iContext {
	var p = new(Int_type_iContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_int_type_i

	return p
}

func (s *Int_type_iContext) GetParser() antlr.Parser { return s.parser }

func (s *Int_type_iContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(OBParserTINYINT, 0)
}

func (s *Int_type_iContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(OBParserSMALLINT, 0)
}

func (s *Int_type_iContext) MEDIUMINT() antlr.TerminalNode {
	return s.GetToken(OBParserMEDIUMINT, 0)
}

func (s *Int_type_iContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(OBParserINTEGER, 0)
}

func (s *Int_type_iContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(OBParserBIGINT, 0)
}

func (s *Int_type_iContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int_type_iContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Int_type_iContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterInt_type_i(s)
	}
}

func (s *Int_type_iContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitInt_type_i(s)
	}
}

func (s *Int_type_iContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitInt_type_i(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Int_type_i() (localctx IInt_type_iContext) {
	localctx = NewInt_type_iContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, OBParserRULE_int_type_i)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3701)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserBIGINT || _la == OBParserINTEGER || _la == OBParserMEDIUMINT || _la == OBParserSMALLINT || _la == OBParserTINYINT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFloat_type_iContext is an interface to support dynamic dispatch.
type IFloat_type_iContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOAT() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	REAL() antlr.TerminalNode
	PRECISION() antlr.TerminalNode

	// IsFloat_type_iContext differentiates from other interfaces.
	IsFloat_type_iContext()
}

type Float_type_iContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloat_type_iContext() *Float_type_iContext {
	var p = new(Float_type_iContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_float_type_i
	return p
}

func InitEmptyFloat_type_iContext(p *Float_type_iContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_float_type_i
}

func (*Float_type_iContext) IsFloat_type_iContext() {}

func NewFloat_type_iContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Float_type_iContext {
	var p = new(Float_type_iContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_float_type_i

	return p
}

func (s *Float_type_iContext) GetParser() antlr.Parser { return s.parser }

func (s *Float_type_iContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(OBParserFLOAT, 0)
}

func (s *Float_type_iContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(OBParserDOUBLE, 0)
}

func (s *Float_type_iContext) REAL() antlr.TerminalNode {
	return s.GetToken(OBParserREAL, 0)
}

func (s *Float_type_iContext) PRECISION() antlr.TerminalNode {
	return s.GetToken(OBParserPRECISION, 0)
}

func (s *Float_type_iContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Float_type_iContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Float_type_iContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterFloat_type_i(s)
	}
}

func (s *Float_type_iContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitFloat_type_i(s)
	}
}

func (s *Float_type_iContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitFloat_type_i(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Float_type_i() (localctx IFloat_type_iContext) {
	localctx = NewFloat_type_iContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, OBParserRULE_float_type_i)
	p.SetState(3710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 315, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3703)
			p.Match(OBParserFLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3704)
			p.Match(OBParserDOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3705)
			p.Match(OBParserREAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3706)
			p.Match(OBParserDOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3707)
			p.Match(OBParserPRECISION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3708)
			p.Match(OBParserREAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3709)
			p.Match(OBParserPRECISION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatetime_type_iContext is an interface to support dynamic dispatch.
type IDatetime_type_iContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATETIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TIME() antlr.TerminalNode

	// IsDatetime_type_iContext differentiates from other interfaces.
	IsDatetime_type_iContext()
}

type Datetime_type_iContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatetime_type_iContext() *Datetime_type_iContext {
	var p = new(Datetime_type_iContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_datetime_type_i
	return p
}

func InitEmptyDatetime_type_iContext(p *Datetime_type_iContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_datetime_type_i
}

func (*Datetime_type_iContext) IsDatetime_type_iContext() {}

func NewDatetime_type_iContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Datetime_type_iContext {
	var p = new(Datetime_type_iContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_datetime_type_i

	return p
}

func (s *Datetime_type_iContext) GetParser() antlr.Parser { return s.parser }

func (s *Datetime_type_iContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(OBParserDATETIME, 0)
}

func (s *Datetime_type_iContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(OBParserTIMESTAMP, 0)
}

func (s *Datetime_type_iContext) TIME() antlr.TerminalNode {
	return s.GetToken(OBParserTIME, 0)
}

func (s *Datetime_type_iContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Datetime_type_iContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Datetime_type_iContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDatetime_type_i(s)
	}
}

func (s *Datetime_type_iContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDatetime_type_i(s)
	}
}

func (s *Datetime_type_iContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDatetime_type_i(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Datetime_type_i() (localctx IDatetime_type_iContext) {
	localctx = NewDatetime_type_iContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, OBParserRULE_datetime_type_i)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3712)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserTIMESTAMP || _la == OBParserTIME || _la == OBParserDATETIME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDate_year_type_iContext is an interface to support dynamic dispatch.
type IDate_year_type_iContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATE() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	RightParen() antlr.TerminalNode

	// IsDate_year_type_iContext differentiates from other interfaces.
	IsDate_year_type_iContext()
}

type Date_year_type_iContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDate_year_type_iContext() *Date_year_type_iContext {
	var p = new(Date_year_type_iContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_date_year_type_i
	return p
}

func InitEmptyDate_year_type_iContext(p *Date_year_type_iContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_date_year_type_i
}

func (*Date_year_type_iContext) IsDate_year_type_iContext() {}

func NewDate_year_type_iContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Date_year_type_iContext {
	var p = new(Date_year_type_iContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_date_year_type_i

	return p
}

func (s *Date_year_type_iContext) GetParser() antlr.Parser { return s.parser }

func (s *Date_year_type_iContext) DATE() antlr.TerminalNode {
	return s.GetToken(OBParserDATE, 0)
}

func (s *Date_year_type_iContext) YEAR() antlr.TerminalNode {
	return s.GetToken(OBParserYEAR, 0)
}

func (s *Date_year_type_iContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Date_year_type_iContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Date_year_type_iContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Date_year_type_iContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Date_year_type_iContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Date_year_type_iContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDate_year_type_i(s)
	}
}

func (s *Date_year_type_iContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDate_year_type_i(s)
	}
}

func (s *Date_year_type_iContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDate_year_type_i(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Date_year_type_i() (localctx IDate_year_type_iContext) {
	localctx = NewDate_year_type_iContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, OBParserRULE_date_year_type_i)
	p.SetState(3721)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserDATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3714)
			p.Match(OBParserDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserYEAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3715)
			p.Match(OBParserYEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3719)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 316, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3716)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3717)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3718)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IText_type_iContext is an interface to support dynamic dispatch.
type IText_type_iContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TINYTEXT() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	MEDIUMTEXT() antlr.TerminalNode
	LONGTEXT() antlr.TerminalNode

	// IsText_type_iContext differentiates from other interfaces.
	IsText_type_iContext()
}

type Text_type_iContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_type_iContext() *Text_type_iContext {
	var p = new(Text_type_iContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_text_type_i
	return p
}

func InitEmptyText_type_iContext(p *Text_type_iContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_text_type_i
}

func (*Text_type_iContext) IsText_type_iContext() {}

func NewText_type_iContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_type_iContext {
	var p = new(Text_type_iContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_text_type_i

	return p
}

func (s *Text_type_iContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_type_iContext) TINYTEXT() antlr.TerminalNode {
	return s.GetToken(OBParserTINYTEXT, 0)
}

func (s *Text_type_iContext) TEXT() antlr.TerminalNode {
	return s.GetToken(OBParserTEXT, 0)
}

func (s *Text_type_iContext) MEDIUMTEXT() antlr.TerminalNode {
	return s.GetToken(OBParserMEDIUMTEXT, 0)
}

func (s *Text_type_iContext) LONGTEXT() antlr.TerminalNode {
	return s.GetToken(OBParserLONGTEXT, 0)
}

func (s *Text_type_iContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_type_iContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_type_iContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterText_type_i(s)
	}
}

func (s *Text_type_iContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitText_type_i(s)
	}
}

func (s *Text_type_iContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitText_type_i(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Text_type_i() (localctx IText_type_iContext) {
	localctx = NewText_type_iContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, OBParserRULE_text_type_i)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3723)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserLONGTEXT || _la == OBParserMEDIUMTEXT || _la == OBParserTEXT || _la == OBParserTINYTEXT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlob_type_iContext is an interface to support dynamic dispatch.
type IBlob_type_iContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TINYBLOB() antlr.TerminalNode
	BLOB() antlr.TerminalNode
	MEDIUMBLOB() antlr.TerminalNode
	LONGBLOB() antlr.TerminalNode

	// IsBlob_type_iContext differentiates from other interfaces.
	IsBlob_type_iContext()
}

type Blob_type_iContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlob_type_iContext() *Blob_type_iContext {
	var p = new(Blob_type_iContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_blob_type_i
	return p
}

func InitEmptyBlob_type_iContext(p *Blob_type_iContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_blob_type_i
}

func (*Blob_type_iContext) IsBlob_type_iContext() {}

func NewBlob_type_iContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Blob_type_iContext {
	var p = new(Blob_type_iContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_blob_type_i

	return p
}

func (s *Blob_type_iContext) GetParser() antlr.Parser { return s.parser }

func (s *Blob_type_iContext) TINYBLOB() antlr.TerminalNode {
	return s.GetToken(OBParserTINYBLOB, 0)
}

func (s *Blob_type_iContext) BLOB() antlr.TerminalNode {
	return s.GetToken(OBParserBLOB, 0)
}

func (s *Blob_type_iContext) MEDIUMBLOB() antlr.TerminalNode {
	return s.GetToken(OBParserMEDIUMBLOB, 0)
}

func (s *Blob_type_iContext) LONGBLOB() antlr.TerminalNode {
	return s.GetToken(OBParserLONGBLOB, 0)
}

func (s *Blob_type_iContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Blob_type_iContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Blob_type_iContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterBlob_type_i(s)
	}
}

func (s *Blob_type_iContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitBlob_type_i(s)
	}
}

func (s *Blob_type_iContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitBlob_type_i(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Blob_type_i() (localctx IBlob_type_iContext) {
	localctx = NewBlob_type_iContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, OBParserRULE_blob_type_i)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3725)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserBLOB || _la == OBParserLONGBLOB || _la == OBParserMEDIUMBLOB || _la == OBParserTINYBLOB) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IString_length_iContext is an interface to support dynamic dispatch.
type IString_length_iContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	Number_literal() INumber_literalContext
	RightParen() antlr.TerminalNode

	// IsString_length_iContext differentiates from other interfaces.
	IsString_length_iContext()
}

type String_length_iContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_length_iContext() *String_length_iContext {
	var p = new(String_length_iContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_string_length_i
	return p
}

func InitEmptyString_length_iContext(p *String_length_iContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_string_length_i
}

func (*String_length_iContext) IsString_length_iContext() {}

func NewString_length_iContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_length_iContext {
	var p = new(String_length_iContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_string_length_i

	return p
}

func (s *String_length_iContext) GetParser() antlr.Parser { return s.parser }

func (s *String_length_iContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *String_length_iContext) Number_literal() INumber_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumber_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumber_literalContext)
}

func (s *String_length_iContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *String_length_iContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_length_iContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_length_iContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterString_length_i(s)
	}
}

func (s *String_length_iContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitString_length_i(s)
	}
}

func (s *String_length_iContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitString_length_i(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) String_length_i() (localctx IString_length_iContext) {
	localctx = NewString_length_iContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, OBParserRULE_string_length_i)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3727)
		p.Match(OBParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3728)
		p.Number_literal()
	}
	{
		p.SetState(3729)
		p.Match(OBParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollation_nameContext is an interface to support dynamic dispatch.
type ICollation_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME_OB() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode

	// IsCollation_nameContext differentiates from other interfaces.
	IsCollation_nameContext()
}

type Collation_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollation_nameContext() *Collation_nameContext {
	var p = new(Collation_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_collation_name
	return p
}

func InitEmptyCollation_nameContext(p *Collation_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_collation_name
}

func (*Collation_nameContext) IsCollation_nameContext() {}

func NewCollation_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collation_nameContext {
	var p = new(Collation_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_collation_name

	return p
}

func (s *Collation_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Collation_nameContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Collation_nameContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Collation_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collation_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collation_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCollation_name(s)
	}
}

func (s *Collation_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCollation_name(s)
	}
}

func (s *Collation_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCollation_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Collation_name() (localctx ICollation_nameContext) {
	localctx = NewCollation_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, OBParserRULE_collation_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3731)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserNAME_OB || _la == OBParserSTRING_VALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrans_param_nameContext is an interface to support dynamic dispatch.
type ITrans_param_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQuote() []antlr.TerminalNode
	Quote(i int) antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode

	// IsTrans_param_nameContext differentiates from other interfaces.
	IsTrans_param_nameContext()
}

type Trans_param_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrans_param_nameContext() *Trans_param_nameContext {
	var p = new(Trans_param_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_trans_param_name
	return p
}

func InitEmptyTrans_param_nameContext(p *Trans_param_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_trans_param_name
}

func (*Trans_param_nameContext) IsTrans_param_nameContext() {}

func NewTrans_param_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trans_param_nameContext {
	var p = new(Trans_param_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_trans_param_name

	return p
}

func (s *Trans_param_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Trans_param_nameContext) AllQuote() []antlr.TerminalNode {
	return s.GetTokens(OBParserQuote)
}

func (s *Trans_param_nameContext) Quote(i int) antlr.TerminalNode {
	return s.GetToken(OBParserQuote, i)
}

func (s *Trans_param_nameContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Trans_param_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trans_param_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trans_param_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTrans_param_name(s)
	}
}

func (s *Trans_param_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTrans_param_name(s)
	}
}

func (s *Trans_param_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTrans_param_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Trans_param_name() (localctx ITrans_param_nameContext) {
	localctx = NewTrans_param_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, OBParserRULE_trans_param_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3733)
		p.Match(OBParserQuote)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3734)
		p.Match(OBParserSTRING_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3735)
		p.Match(OBParserQuote)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrans_param_valueContext is an interface to support dynamic dispatch.
type ITrans_param_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQuote() []antlr.TerminalNode
	Quote(i int) antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	INTNUM() antlr.TerminalNode

	// IsTrans_param_valueContext differentiates from other interfaces.
	IsTrans_param_valueContext()
}

type Trans_param_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrans_param_valueContext() *Trans_param_valueContext {
	var p = new(Trans_param_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_trans_param_value
	return p
}

func InitEmptyTrans_param_valueContext(p *Trans_param_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_trans_param_value
}

func (*Trans_param_valueContext) IsTrans_param_valueContext() {}

func NewTrans_param_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trans_param_valueContext {
	var p = new(Trans_param_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_trans_param_value

	return p
}

func (s *Trans_param_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Trans_param_valueContext) AllQuote() []antlr.TerminalNode {
	return s.GetTokens(OBParserQuote)
}

func (s *Trans_param_valueContext) Quote(i int) antlr.TerminalNode {
	return s.GetToken(OBParserQuote, i)
}

func (s *Trans_param_valueContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Trans_param_valueContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Trans_param_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trans_param_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trans_param_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTrans_param_value(s)
	}
}

func (s *Trans_param_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTrans_param_value(s)
	}
}

func (s *Trans_param_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTrans_param_value(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Trans_param_value() (localctx ITrans_param_valueContext) {
	localctx = NewTrans_param_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, OBParserRULE_trans_param_value)
	p.SetState(3741)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserQuote:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3737)
			p.Match(OBParserQuote)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3738)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3739)
			p.Match(OBParserQuote)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserINTNUM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3740)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharset_nameContext is an interface to support dynamic dispatch.
type ICharset_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME_OB() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	BINARY() antlr.TerminalNode

	// IsCharset_nameContext differentiates from other interfaces.
	IsCharset_nameContext()
}

type Charset_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharset_nameContext() *Charset_nameContext {
	var p = new(Charset_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_charset_name
	return p
}

func InitEmptyCharset_nameContext(p *Charset_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_charset_name
}

func (*Charset_nameContext) IsCharset_nameContext() {}

func NewCharset_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Charset_nameContext {
	var p = new(Charset_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_charset_name

	return p
}

func (s *Charset_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Charset_nameContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Charset_nameContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Charset_nameContext) BINARY() antlr.TerminalNode {
	return s.GetToken(OBParserBINARY, 0)
}

func (s *Charset_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Charset_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Charset_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCharset_name(s)
	}
}

func (s *Charset_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCharset_name(s)
	}
}

func (s *Charset_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCharset_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Charset_name() (localctx ICharset_nameContext) {
	localctx = NewCharset_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, OBParserRULE_charset_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3743)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserBINARY || _la == OBParserNAME_OB || _la == OBParserSTRING_VALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharset_name_or_defaultContext is an interface to support dynamic dispatch.
type ICharset_name_or_defaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Charset_name() ICharset_nameContext
	DEFAULT() antlr.TerminalNode

	// IsCharset_name_or_defaultContext differentiates from other interfaces.
	IsCharset_name_or_defaultContext()
}

type Charset_name_or_defaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharset_name_or_defaultContext() *Charset_name_or_defaultContext {
	var p = new(Charset_name_or_defaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_charset_name_or_default
	return p
}

func InitEmptyCharset_name_or_defaultContext(p *Charset_name_or_defaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_charset_name_or_default
}

func (*Charset_name_or_defaultContext) IsCharset_name_or_defaultContext() {}

func NewCharset_name_or_defaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Charset_name_or_defaultContext {
	var p = new(Charset_name_or_defaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_charset_name_or_default

	return p
}

func (s *Charset_name_or_defaultContext) GetParser() antlr.Parser { return s.parser }

func (s *Charset_name_or_defaultContext) Charset_name() ICharset_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_nameContext)
}

func (s *Charset_name_or_defaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT, 0)
}

func (s *Charset_name_or_defaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Charset_name_or_defaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Charset_name_or_defaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCharset_name_or_default(s)
	}
}

func (s *Charset_name_or_defaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCharset_name_or_default(s)
	}
}

func (s *Charset_name_or_defaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCharset_name_or_default(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Charset_name_or_default() (localctx ICharset_name_or_defaultContext) {
	localctx = NewCharset_name_or_defaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, OBParserRULE_charset_name_or_default)
	p.SetState(3747)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserBINARY, OBParserNAME_OB, OBParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3745)
			p.Charset_name()
		}

	case OBParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3746)
			p.Match(OBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollationContext is an interface to support dynamic dispatch.
type ICollationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLLATE() antlr.TerminalNode
	Collation_name() ICollation_nameContext

	// IsCollationContext differentiates from other interfaces.
	IsCollationContext()
}

type CollationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollationContext() *CollationContext {
	var p = new(CollationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_collation
	return p
}

func InitEmptyCollationContext(p *CollationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_collation
}

func (*CollationContext) IsCollationContext() {}

func NewCollationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollationContext {
	var p = new(CollationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_collation

	return p
}

func (s *CollationContext) GetParser() antlr.Parser { return s.parser }

func (s *CollationContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(OBParserCOLLATE, 0)
}

func (s *CollationContext) Collation_name() ICollation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollation_nameContext)
}

func (s *CollationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCollation(s)
	}
}

func (s *CollationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCollation(s)
	}
}

func (s *CollationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCollation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Collation() (localctx ICollationContext) {
	localctx = NewCollationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, OBParserRULE_collation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3749)
		p.Match(OBParserCOLLATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3750)
		p.Collation_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_column_attribute_listContext is an interface to support dynamic dispatch.
type IOpt_column_attribute_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Empty() IEmptyContext
	Opt_column_attribute_list() IOpt_column_attribute_listContext
	Column_attribute() IColumn_attributeContext

	// IsOpt_column_attribute_listContext differentiates from other interfaces.
	IsOpt_column_attribute_listContext()
}

type Opt_column_attribute_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_column_attribute_listContext() *Opt_column_attribute_listContext {
	var p = new(Opt_column_attribute_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_column_attribute_list
	return p
}

func InitEmptyOpt_column_attribute_listContext(p *Opt_column_attribute_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_column_attribute_list
}

func (*Opt_column_attribute_listContext) IsOpt_column_attribute_listContext() {}

func NewOpt_column_attribute_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_column_attribute_listContext {
	var p = new(Opt_column_attribute_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_column_attribute_list

	return p
}

func (s *Opt_column_attribute_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_column_attribute_listContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Opt_column_attribute_listContext) Opt_column_attribute_list() IOpt_column_attribute_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_column_attribute_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_column_attribute_listContext)
}

func (s *Opt_column_attribute_listContext) Column_attribute() IColumn_attributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_attributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_attributeContext)
}

func (s *Opt_column_attribute_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_column_attribute_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_column_attribute_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_column_attribute_list(s)
	}
}

func (s *Opt_column_attribute_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_column_attribute_list(s)
	}
}

func (s *Opt_column_attribute_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_column_attribute_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_column_attribute_list() (localctx IOpt_column_attribute_listContext) {
	return p.opt_column_attribute_list(0)
}

func (p *OBParser) opt_column_attribute_list(_p int) (localctx IOpt_column_attribute_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewOpt_column_attribute_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IOpt_column_attribute_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 266
	p.EnterRecursionRule(localctx, 266, OBParserRULE_opt_column_attribute_list, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3753)
		p.Empty()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3759)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 320, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewOpt_column_attribute_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, OBParserRULE_opt_column_attribute_list)
			p.SetState(3755)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(3756)
				p.Column_attribute()
			}

		}
		p.SetState(3761)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 320, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_attributeContext is an interface to support dynamic dispatch.
type IColumn_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Not() INotContext
	NULLX() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	Now_or_signed_literal() INow_or_signed_literalContext
	ORIG_DEFAULT() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	ON() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	Cur_timestamp_func() ICur_timestamp_funcContext
	ID() antlr.TerminalNode
	INTNUM() antlr.TerminalNode

	// IsColumn_attributeContext differentiates from other interfaces.
	IsColumn_attributeContext()
}

type Column_attributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_attributeContext() *Column_attributeContext {
	var p = new(Column_attributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_attribute
	return p
}

func InitEmptyColumn_attributeContext(p *Column_attributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_attribute
}

func (*Column_attributeContext) IsColumn_attributeContext() {}

func NewColumn_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_attributeContext {
	var p = new(Column_attributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_column_attribute

	return p
}

func (s *Column_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_attributeContext) Not() INotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotContext)
}

func (s *Column_attributeContext) NULLX() antlr.TerminalNode {
	return s.GetToken(OBParserNULLX, 0)
}

func (s *Column_attributeContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT, 0)
}

func (s *Column_attributeContext) Now_or_signed_literal() INow_or_signed_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INow_or_signed_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INow_or_signed_literalContext)
}

func (s *Column_attributeContext) ORIG_DEFAULT() antlr.TerminalNode {
	return s.GetToken(OBParserORIG_DEFAULT, 0)
}

func (s *Column_attributeContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(OBParserAUTO_INCREMENT, 0)
}

func (s *Column_attributeContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(OBParserUNIQUE, 0)
}

func (s *Column_attributeContext) KEY() antlr.TerminalNode {
	return s.GetToken(OBParserKEY, 0)
}

func (s *Column_attributeContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(OBParserPRIMARY, 0)
}

func (s *Column_attributeContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(OBParserCOMMENT, 0)
}

func (s *Column_attributeContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Column_attributeContext) ON() antlr.TerminalNode {
	return s.GetToken(OBParserON, 0)
}

func (s *Column_attributeContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(OBParserUPDATE, 0)
}

func (s *Column_attributeContext) Cur_timestamp_func() ICur_timestamp_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICur_timestamp_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICur_timestamp_funcContext)
}

func (s *Column_attributeContext) ID() antlr.TerminalNode {
	return s.GetToken(OBParserID, 0)
}

func (s *Column_attributeContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Column_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterColumn_attribute(s)
	}
}

func (s *Column_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitColumn_attribute(s)
	}
}

func (s *Column_attributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitColumn_attribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Column_attribute() (localctx IColumn_attributeContext) {
	localctx = NewColumn_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, OBParserRULE_column_attribute)
	var _la int

	p.SetState(3785)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 322, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3762)
			p.Not()
		}
		{
			p.SetState(3763)
			p.Match(OBParserNULLX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3765)
			p.Match(OBParserNULLX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3766)
			p.Match(OBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3767)
			p.Now_or_signed_literal()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3768)
			p.Match(OBParserORIG_DEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3769)
			p.Now_or_signed_literal()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3770)
			p.Match(OBParserAUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3771)
			p.Match(OBParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3772)
			p.Match(OBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(3774)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPRIMARY {
			{
				p.SetState(3773)
				p.Match(OBParserPRIMARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3776)
			p.Match(OBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3777)
			p.Match(OBParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3778)
			p.Match(OBParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3779)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3780)
			p.Match(OBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3781)
			p.Match(OBParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3782)
			p.Cur_timestamp_func()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3783)
			p.Match(OBParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3784)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INow_or_signed_literalContext is an interface to support dynamic dispatch.
type INow_or_signed_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Cur_timestamp_func() ICur_timestamp_funcContext
	Signed_literal() ISigned_literalContext

	// IsNow_or_signed_literalContext differentiates from other interfaces.
	IsNow_or_signed_literalContext()
}

type Now_or_signed_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNow_or_signed_literalContext() *Now_or_signed_literalContext {
	var p = new(Now_or_signed_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_now_or_signed_literal
	return p
}

func InitEmptyNow_or_signed_literalContext(p *Now_or_signed_literalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_now_or_signed_literal
}

func (*Now_or_signed_literalContext) IsNow_or_signed_literalContext() {}

func NewNow_or_signed_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Now_or_signed_literalContext {
	var p = new(Now_or_signed_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_now_or_signed_literal

	return p
}

func (s *Now_or_signed_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Now_or_signed_literalContext) Cur_timestamp_func() ICur_timestamp_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICur_timestamp_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICur_timestamp_funcContext)
}

func (s *Now_or_signed_literalContext) Signed_literal() ISigned_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISigned_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISigned_literalContext)
}

func (s *Now_or_signed_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Now_or_signed_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Now_or_signed_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterNow_or_signed_literal(s)
	}
}

func (s *Now_or_signed_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitNow_or_signed_literal(s)
	}
}

func (s *Now_or_signed_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitNow_or_signed_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Now_or_signed_literal() (localctx INow_or_signed_literalContext) {
	localctx = NewNow_or_signed_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, OBParserRULE_now_or_signed_literal)
	p.SetState(3789)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserCURRENT_TIMESTAMP, OBParserLOCALTIME, OBParserLOCALTIMESTAMP, OBParserNOW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3787)
			p.Cur_timestamp_func()
		}

	case OBParserUnderlineUTF8, OBParserUnderlineUTF8MB4, OBParserUnderlineGBK, OBParserUnderlineGB18030, OBParserUnderlineBINARY, OBParserUnderlineUTF16, OBParserNULLX, OBParserINTNUM, OBParserTIMESTAMP_VALUE, OBParserAPPROXNUM, OBParserDECIMAL_VAL, OBParserBOOL_VALUE, OBParserHEX_STRING_VALUE, OBParserDATE_VALUE, OBParserPlus, OBParserMinus, OBParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3788)
			p.Signed_literal()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISigned_literalContext is an interface to support dynamic dispatch.
type ISigned_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	Plus() antlr.TerminalNode
	Number_literal() INumber_literalContext
	Minus() antlr.TerminalNode

	// IsSigned_literalContext differentiates from other interfaces.
	IsSigned_literalContext()
}

type Signed_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySigned_literalContext() *Signed_literalContext {
	var p = new(Signed_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_signed_literal
	return p
}

func InitEmptySigned_literalContext(p *Signed_literalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_signed_literal
}

func (*Signed_literalContext) IsSigned_literalContext() {}

func NewSigned_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signed_literalContext {
	var p = new(Signed_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_signed_literal

	return p
}

func (s *Signed_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Signed_literalContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *Signed_literalContext) Plus() antlr.TerminalNode {
	return s.GetToken(OBParserPlus, 0)
}

func (s *Signed_literalContext) Number_literal() INumber_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumber_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumber_literalContext)
}

func (s *Signed_literalContext) Minus() antlr.TerminalNode {
	return s.GetToken(OBParserMinus, 0)
}

func (s *Signed_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signed_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signed_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSigned_literal(s)
	}
}

func (s *Signed_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSigned_literal(s)
	}
}

func (s *Signed_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSigned_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Signed_literal() (localctx ISigned_literalContext) {
	localctx = NewSigned_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, OBParserRULE_signed_literal)
	p.SetState(3796)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserUnderlineUTF8, OBParserUnderlineUTF8MB4, OBParserUnderlineGBK, OBParserUnderlineGB18030, OBParserUnderlineBINARY, OBParserUnderlineUTF16, OBParserNULLX, OBParserINTNUM, OBParserTIMESTAMP_VALUE, OBParserAPPROXNUM, OBParserDECIMAL_VAL, OBParserBOOL_VALUE, OBParserHEX_STRING_VALUE, OBParserDATE_VALUE, OBParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3791)
			p.Literal()
		}

	case OBParserPlus:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3792)
			p.Match(OBParserPlus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3793)
			p.Number_literal()
		}

	case OBParserMinus:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3794)
			p.Match(OBParserMinus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3795)
			p.Number_literal()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_commaContext is an interface to support dynamic dispatch.
type IOpt_commaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Comma() antlr.TerminalNode

	// IsOpt_commaContext differentiates from other interfaces.
	IsOpt_commaContext()
}

type Opt_commaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_commaContext() *Opt_commaContext {
	var p = new(Opt_commaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_comma
	return p
}

func InitEmptyOpt_commaContext(p *Opt_commaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_comma
}

func (*Opt_commaContext) IsOpt_commaContext() {}

func NewOpt_commaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_commaContext {
	var p = new(Opt_commaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_comma

	return p
}

func (s *Opt_commaContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_commaContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Opt_commaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_commaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_commaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_comma(s)
	}
}

func (s *Opt_commaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_comma(s)
	}
}

func (s *Opt_commaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_comma(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_comma() (localctx IOpt_commaContext) {
	localctx = NewOpt_commaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, OBParserRULE_opt_comma)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserComma {
		{
			p.SetState(3798)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_option_list_space_seperatedContext is an interface to support dynamic dispatch.
type ITable_option_list_space_seperatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_option() ITable_optionContext
	Table_option_list_space_seperated() ITable_option_list_space_seperatedContext

	// IsTable_option_list_space_seperatedContext differentiates from other interfaces.
	IsTable_option_list_space_seperatedContext()
}

type Table_option_list_space_seperatedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_option_list_space_seperatedContext() *Table_option_list_space_seperatedContext {
	var p = new(Table_option_list_space_seperatedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_option_list_space_seperated
	return p
}

func InitEmptyTable_option_list_space_seperatedContext(p *Table_option_list_space_seperatedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_option_list_space_seperated
}

func (*Table_option_list_space_seperatedContext) IsTable_option_list_space_seperatedContext() {}

func NewTable_option_list_space_seperatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_option_list_space_seperatedContext {
	var p = new(Table_option_list_space_seperatedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_table_option_list_space_seperated

	return p
}

func (s *Table_option_list_space_seperatedContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_option_list_space_seperatedContext) Table_option() ITable_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_optionContext)
}

func (s *Table_option_list_space_seperatedContext) Table_option_list_space_seperated() ITable_option_list_space_seperatedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_option_list_space_seperatedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_option_list_space_seperatedContext)
}

func (s *Table_option_list_space_seperatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_option_list_space_seperatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_option_list_space_seperatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTable_option_list_space_seperated(s)
	}
}

func (s *Table_option_list_space_seperatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTable_option_list_space_seperated(s)
	}
}

func (s *Table_option_list_space_seperatedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTable_option_list_space_seperated(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Table_option_list_space_seperated() (localctx ITable_option_list_space_seperatedContext) {
	localctx = NewTable_option_list_space_seperatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, OBParserRULE_table_option_list_space_seperated)
	p.SetState(3805)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 326, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3801)
			p.Table_option()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3802)
			p.Table_option()
		}
		{
			p.SetState(3803)
			p.Table_option_list_space_seperated()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_option_listContext is an interface to support dynamic dispatch.
type ITable_option_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_option_list_space_seperated() ITable_option_list_space_seperatedContext
	Table_option() ITable_optionContext
	Comma() antlr.TerminalNode
	Table_option_list() ITable_option_listContext

	// IsTable_option_listContext differentiates from other interfaces.
	IsTable_option_listContext()
}

type Table_option_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_option_listContext() *Table_option_listContext {
	var p = new(Table_option_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_option_list
	return p
}

func InitEmptyTable_option_listContext(p *Table_option_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_option_list
}

func (*Table_option_listContext) IsTable_option_listContext() {}

func NewTable_option_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_option_listContext {
	var p = new(Table_option_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_table_option_list

	return p
}

func (s *Table_option_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_option_listContext) Table_option_list_space_seperated() ITable_option_list_space_seperatedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_option_list_space_seperatedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_option_list_space_seperatedContext)
}

func (s *Table_option_listContext) Table_option() ITable_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_optionContext)
}

func (s *Table_option_listContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Table_option_listContext) Table_option_list() ITable_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_option_listContext)
}

func (s *Table_option_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_option_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_option_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTable_option_list(s)
	}
}

func (s *Table_option_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTable_option_list(s)
	}
}

func (s *Table_option_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTable_option_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Table_option_list() (localctx ITable_option_listContext) {
	localctx = NewTable_option_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, OBParserRULE_table_option_list)
	p.SetState(3812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 327, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3807)
			p.Table_option_list_space_seperated()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3808)
			p.Table_option()
		}
		{
			p.SetState(3809)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3810)
			p.Table_option_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimary_zone_nameContext is an interface to support dynamic dispatch.
type IPrimary_zone_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	RANDOM() antlr.TerminalNode
	Relation_name_or_string() IRelation_name_or_stringContext

	// IsPrimary_zone_nameContext differentiates from other interfaces.
	IsPrimary_zone_nameContext()
}

type Primary_zone_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_zone_nameContext() *Primary_zone_nameContext {
	var p = new(Primary_zone_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_primary_zone_name
	return p
}

func InitEmptyPrimary_zone_nameContext(p *Primary_zone_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_primary_zone_name
}

func (*Primary_zone_nameContext) IsPrimary_zone_nameContext() {}

func NewPrimary_zone_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_zone_nameContext {
	var p = new(Primary_zone_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_primary_zone_name

	return p
}

func (s *Primary_zone_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_zone_nameContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT, 0)
}

func (s *Primary_zone_nameContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(OBParserRANDOM, 0)
}

func (s *Primary_zone_nameContext) Relation_name_or_string() IRelation_name_or_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_name_or_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_name_or_stringContext)
}

func (s *Primary_zone_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_zone_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Primary_zone_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterPrimary_zone_name(s)
	}
}

func (s *Primary_zone_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitPrimary_zone_name(s)
	}
}

func (s *Primary_zone_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitPrimary_zone_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Primary_zone_name() (localctx IPrimary_zone_nameContext) {
	localctx = NewPrimary_zone_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, OBParserRULE_primary_zone_name)
	p.SetState(3817)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserDEFAULT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3814)
			p.Match(OBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserRANDOM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3815)
			p.Match(OBParserRANDOM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserALL, OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserNAME_OB, OBParserSTRING_VALUE, OBParserSTAT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3816)
			p.Relation_name_or_string()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablespaceContext is an interface to support dynamic dispatch.
type ITablespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME_OB() antlr.TerminalNode

	// IsTablespaceContext differentiates from other interfaces.
	IsTablespaceContext()
}

type TablespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablespaceContext() *TablespaceContext {
	var p = new(TablespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tablespace
	return p
}

func InitEmptyTablespaceContext(p *TablespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tablespace
}

func (*TablespaceContext) IsTablespaceContext() {}

func NewTablespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablespaceContext {
	var p = new(TablespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tablespace

	return p
}

func (s *TablespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *TablespaceContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *TablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTablespace(s)
	}
}

func (s *TablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTablespace(s)
	}
}

func (s *TablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tablespace() (localctx ITablespaceContext) {
	localctx = NewTablespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, OBParserRULE_tablespace)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3819)
		p.Match(OBParserNAME_OB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocality_nameContext is an interface to support dynamic dispatch.
type ILocality_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_VALUE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsLocality_nameContext differentiates from other interfaces.
	IsLocality_nameContext()
}

type Locality_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocality_nameContext() *Locality_nameContext {
	var p = new(Locality_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_locality_name
	return p
}

func InitEmptyLocality_nameContext(p *Locality_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_locality_name
}

func (*Locality_nameContext) IsLocality_nameContext() {}

func NewLocality_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Locality_nameContext {
	var p = new(Locality_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_locality_name

	return p
}

func (s *Locality_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Locality_nameContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Locality_nameContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT, 0)
}

func (s *Locality_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Locality_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Locality_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLocality_name(s)
	}
}

func (s *Locality_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLocality_name(s)
	}
}

func (s *Locality_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLocality_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Locality_name() (localctx ILocality_nameContext) {
	localctx = NewLocality_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, OBParserRULE_locality_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3821)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserDEFAULT || _la == OBParserSTRING_VALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_optionContext is an interface to support dynamic dispatch.
type ITable_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE_MODE() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode
	DUPLICATE_SCOPE() antlr.TerminalNode
	LOCALITY() antlr.TerminalNode
	Locality_name() ILocality_nameContext
	FORCE() antlr.TerminalNode
	EXPIRE_INFO() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Expr() IExprContext
	RightParen() antlr.TerminalNode
	PROGRESSIVE_MERGE_NUM() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	BLOCK_SIZE() antlr.TerminalNode
	TABLE_ID() antlr.TerminalNode
	REPLICA_NUM() antlr.TerminalNode
	COMPRESSION() antlr.TerminalNode
	ROW_FORMAT() antlr.TerminalNode
	Row_format_option() IRow_format_optionContext
	STORAGE_FORMAT_VERSION() antlr.TerminalNode
	USE_BLOOM_FILTER() antlr.TerminalNode
	BOOL_VALUE() antlr.TerminalNode
	Charset_key() ICharset_keyContext
	Charset_name() ICharset_nameContext
	DEFAULT() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	Collation_name() ICollation_nameContext
	COMMENT() antlr.TerminalNode
	PRIMARY_ZONE() antlr.TerminalNode
	Primary_zone_name() IPrimary_zone_nameContext
	TABLEGROUP() antlr.TerminalNode
	Relation_name_or_string() IRelation_name_or_stringContext
	AUTO_INCREMENT() antlr.TerminalNode
	Int_or_decimal() IInt_or_decimalContext
	Read_only_or_write() IRead_only_or_writeContext
	ENGINE_() antlr.TerminalNode
	TABLET_SIZE() antlr.TerminalNode
	PCTFREE() antlr.TerminalNode
	MAX_USED_PART_ID() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	Tablespace() ITablespaceContext

	// IsTable_optionContext differentiates from other interfaces.
	IsTable_optionContext()
}

type Table_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_optionContext() *Table_optionContext {
	var p = new(Table_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_option
	return p
}

func InitEmptyTable_optionContext(p *Table_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_option
}

func (*Table_optionContext) IsTable_optionContext() {}

func NewTable_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_optionContext {
	var p = new(Table_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_table_option

	return p
}

func (s *Table_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_optionContext) TABLE_MODE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE_MODE, 0)
}

func (s *Table_optionContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Table_optionContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Table_optionContext) DUPLICATE_SCOPE() antlr.TerminalNode {
	return s.GetToken(OBParserDUPLICATE_SCOPE, 0)
}

func (s *Table_optionContext) LOCALITY() antlr.TerminalNode {
	return s.GetToken(OBParserLOCALITY, 0)
}

func (s *Table_optionContext) Locality_name() ILocality_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocality_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocality_nameContext)
}

func (s *Table_optionContext) FORCE() antlr.TerminalNode {
	return s.GetToken(OBParserFORCE, 0)
}

func (s *Table_optionContext) EXPIRE_INFO() antlr.TerminalNode {
	return s.GetToken(OBParserEXPIRE_INFO, 0)
}

func (s *Table_optionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Table_optionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Table_optionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Table_optionContext) PROGRESSIVE_MERGE_NUM() antlr.TerminalNode {
	return s.GetToken(OBParserPROGRESSIVE_MERGE_NUM, 0)
}

func (s *Table_optionContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Table_optionContext) BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserBLOCK_SIZE, 0)
}

func (s *Table_optionContext) TABLE_ID() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE_ID, 0)
}

func (s *Table_optionContext) REPLICA_NUM() antlr.TerminalNode {
	return s.GetToken(OBParserREPLICA_NUM, 0)
}

func (s *Table_optionContext) COMPRESSION() antlr.TerminalNode {
	return s.GetToken(OBParserCOMPRESSION, 0)
}

func (s *Table_optionContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(OBParserROW_FORMAT, 0)
}

func (s *Table_optionContext) Row_format_option() IRow_format_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRow_format_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRow_format_optionContext)
}

func (s *Table_optionContext) STORAGE_FORMAT_VERSION() antlr.TerminalNode {
	return s.GetToken(OBParserSTORAGE_FORMAT_VERSION, 0)
}

func (s *Table_optionContext) USE_BLOOM_FILTER() antlr.TerminalNode {
	return s.GetToken(OBParserUSE_BLOOM_FILTER, 0)
}

func (s *Table_optionContext) BOOL_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserBOOL_VALUE, 0)
}

func (s *Table_optionContext) Charset_key() ICharset_keyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_keyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_keyContext)
}

func (s *Table_optionContext) Charset_name() ICharset_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_nameContext)
}

func (s *Table_optionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT, 0)
}

func (s *Table_optionContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(OBParserCOLLATE, 0)
}

func (s *Table_optionContext) Collation_name() ICollation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollation_nameContext)
}

func (s *Table_optionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(OBParserCOMMENT, 0)
}

func (s *Table_optionContext) PRIMARY_ZONE() antlr.TerminalNode {
	return s.GetToken(OBParserPRIMARY_ZONE, 0)
}

func (s *Table_optionContext) Primary_zone_name() IPrimary_zone_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimary_zone_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimary_zone_nameContext)
}

func (s *Table_optionContext) TABLEGROUP() antlr.TerminalNode {
	return s.GetToken(OBParserTABLEGROUP, 0)
}

func (s *Table_optionContext) Relation_name_or_string() IRelation_name_or_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_name_or_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_name_or_stringContext)
}

func (s *Table_optionContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(OBParserAUTO_INCREMENT, 0)
}

func (s *Table_optionContext) Int_or_decimal() IInt_or_decimalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_or_decimalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_or_decimalContext)
}

func (s *Table_optionContext) Read_only_or_write() IRead_only_or_writeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRead_only_or_writeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRead_only_or_writeContext)
}

func (s *Table_optionContext) ENGINE_() antlr.TerminalNode {
	return s.GetToken(OBParserENGINE_, 0)
}

func (s *Table_optionContext) TABLET_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLET_SIZE, 0)
}

func (s *Table_optionContext) PCTFREE() antlr.TerminalNode {
	return s.GetToken(OBParserPCTFREE, 0)
}

func (s *Table_optionContext) MAX_USED_PART_ID() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_USED_PART_ID, 0)
}

func (s *Table_optionContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLESPACE, 0)
}

func (s *Table_optionContext) Tablespace() ITablespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceContext)
}

func (s *Table_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTable_option(s)
	}
}

func (s *Table_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTable_option(s)
	}
}

func (s *Table_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTable_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Table_option() (localctx ITable_optionContext) {
	localctx = NewTable_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, OBParserRULE_table_option)
	var _la int

	p.SetState(3949)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 354, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3823)
			p.Match(OBParserTABLE_MODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3824)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3827)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3828)
			p.Match(OBParserDUPLICATE_SCOPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3829)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3832)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3833)
			p.Match(OBParserLOCALITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3834)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3837)
			p.Locality_name()
		}
		p.SetState(3839)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3838)
				p.Match(OBParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3841)
			p.Match(OBParserEXPIRE_INFO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3843)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3842)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3845)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3846)
			p.expr(0)
		}
		{
			p.SetState(3847)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3849)
			p.Match(OBParserPROGRESSIVE_MERGE_NUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3851)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3850)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3853)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3854)
			p.Match(OBParserBLOCK_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3856)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3855)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3858)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3859)
			p.Match(OBParserTABLE_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3861)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3860)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3863)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3864)
			p.Match(OBParserREPLICA_NUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3865)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3868)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3869)
			p.Match(OBParserCOMPRESSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3871)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3870)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3873)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3874)
			p.Match(OBParserROW_FORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3875)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3878)
			p.Row_format_option()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3879)
			p.Match(OBParserSTORAGE_FORMAT_VERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3880)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3883)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3884)
			p.Match(OBParserUSE_BLOOM_FILTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3886)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3885)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3888)
			p.Match(OBParserBOOL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		p.SetState(3890)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserDEFAULT {
			{
				p.SetState(3889)
				p.Match(OBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3892)
			p.Charset_key()
		}
		p.SetState(3894)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3893)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3896)
			p.Charset_name()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		p.SetState(3899)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserDEFAULT {
			{
				p.SetState(3898)
				p.Match(OBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3901)
			p.Match(OBParserCOLLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3903)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3902)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3905)
			p.Collation_name()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3906)
			p.Match(OBParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3907)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3910)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3911)
			p.Match(OBParserPRIMARY_ZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3912)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3915)
			p.Primary_zone_name()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3916)
			p.Match(OBParserTABLEGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3918)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3917)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3920)
			p.Relation_name_or_string()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(3921)
			p.Match(OBParserAUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3923)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3922)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3925)
			p.Int_or_decimal()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(3926)
			p.Read_only_or_write()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(3927)
			p.Match(OBParserENGINE_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3929)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3928)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3931)
			p.Relation_name_or_string()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(3932)
			p.Match(OBParserTABLET_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3934)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3933)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3936)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(3937)
			p.Match(OBParserPCTFREE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3938)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3941)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(3942)
			p.Match(OBParserMAX_USED_PART_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3944)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(3943)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3946)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(3947)
			p.Match(OBParserTABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3948)
			p.Tablespace()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelation_name_or_stringContext is an interface to support dynamic dispatch.
type IRelation_name_or_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Relation_name() IRelation_nameContext
	STRING_VALUE() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsRelation_name_or_stringContext differentiates from other interfaces.
	IsRelation_name_or_stringContext()
}

type Relation_name_or_stringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelation_name_or_stringContext() *Relation_name_or_stringContext {
	var p = new(Relation_name_or_stringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_name_or_string
	return p
}

func InitEmptyRelation_name_or_stringContext(p *Relation_name_or_stringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_name_or_string
}

func (*Relation_name_or_stringContext) IsRelation_name_or_stringContext() {}

func NewRelation_name_or_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relation_name_or_stringContext {
	var p = new(Relation_name_or_stringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_relation_name_or_string

	return p
}

func (s *Relation_name_or_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Relation_name_or_stringContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Relation_name_or_stringContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Relation_name_or_stringContext) ALL() antlr.TerminalNode {
	return s.GetToken(OBParserALL, 0)
}

func (s *Relation_name_or_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relation_name_or_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relation_name_or_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRelation_name_or_string(s)
	}
}

func (s *Relation_name_or_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRelation_name_or_string(s)
	}
}

func (s *Relation_name_or_stringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRelation_name_or_string(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Relation_name_or_string() (localctx IRelation_name_or_stringContext) {
	localctx = NewRelation_name_or_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, OBParserRULE_relation_name_or_string)
	p.SetState(3954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserNAME_OB, OBParserSTAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3951)
			p.Relation_name()
		}

	case OBParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3952)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3953)
			p.Match(OBParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_equal_markContext is an interface to support dynamic dispatch.
type IOpt_equal_markContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMP_EQ() antlr.TerminalNode

	// IsOpt_equal_markContext differentiates from other interfaces.
	IsOpt_equal_markContext()
}

type Opt_equal_markContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_equal_markContext() *Opt_equal_markContext {
	var p = new(Opt_equal_markContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_equal_mark
	return p
}

func InitEmptyOpt_equal_markContext(p *Opt_equal_markContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_equal_mark
}

func (*Opt_equal_markContext) IsOpt_equal_markContext() {}

func NewOpt_equal_markContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_equal_markContext {
	var p = new(Opt_equal_markContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_equal_mark

	return p
}

func (s *Opt_equal_markContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_equal_markContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Opt_equal_markContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_equal_markContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_equal_markContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_equal_mark(s)
	}
}

func (s *Opt_equal_markContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_equal_mark(s)
	}
}

func (s *Opt_equal_markContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_equal_mark(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_equal_mark() (localctx IOpt_equal_markContext) {
	localctx = NewOpt_equal_markContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, OBParserRULE_opt_equal_mark)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3957)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCOMP_EQ {
		{
			p.SetState(3956)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartition_optionContext is an interface to support dynamic dispatch.
type IPartition_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Hash_partition_option() IHash_partition_optionContext
	Key_partition_option() IKey_partition_optionContext
	Range_partition_option() IRange_partition_optionContext
	List_partition_option() IList_partition_optionContext

	// IsPartition_optionContext differentiates from other interfaces.
	IsPartition_optionContext()
}

type Partition_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartition_optionContext() *Partition_optionContext {
	var p = new(Partition_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_partition_option
	return p
}

func InitEmptyPartition_optionContext(p *Partition_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_partition_option
}

func (*Partition_optionContext) IsPartition_optionContext() {}

func NewPartition_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_optionContext {
	var p = new(Partition_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_partition_option

	return p
}

func (s *Partition_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_optionContext) Hash_partition_option() IHash_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHash_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHash_partition_optionContext)
}

func (s *Partition_optionContext) Key_partition_option() IKey_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKey_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKey_partition_optionContext)
}

func (s *Partition_optionContext) Range_partition_option() IRange_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRange_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRange_partition_optionContext)
}

func (s *Partition_optionContext) List_partition_option() IList_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_partition_optionContext)
}

func (s *Partition_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Partition_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterPartition_option(s)
	}
}

func (s *Partition_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitPartition_option(s)
	}
}

func (s *Partition_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitPartition_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Partition_option() (localctx IPartition_optionContext) {
	localctx = NewPartition_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, OBParserRULE_partition_option)
	p.SetState(3963)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 357, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3959)
			p.Hash_partition_option()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3960)
			p.Key_partition_option()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3961)
			p.Range_partition_option()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3962)
			p.List_partition_option()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_partition_optionContext is an interface to support dynamic dispatch.
type IOpt_partition_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Partition_option() IPartition_optionContext
	Opt_column_partition_option() IOpt_column_partition_optionContext

	// IsOpt_partition_optionContext differentiates from other interfaces.
	IsOpt_partition_optionContext()
}

type Opt_partition_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_partition_optionContext() *Opt_partition_optionContext {
	var p = new(Opt_partition_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_partition_option
	return p
}

func InitEmptyOpt_partition_optionContext(p *Opt_partition_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_partition_option
}

func (*Opt_partition_optionContext) IsOpt_partition_optionContext() {}

func NewOpt_partition_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_partition_optionContext {
	var p = new(Opt_partition_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_partition_option

	return p
}

func (s *Opt_partition_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_partition_optionContext) Partition_option() IPartition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartition_optionContext)
}

func (s *Opt_partition_optionContext) Opt_column_partition_option() IOpt_column_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_column_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_column_partition_optionContext)
}

func (s *Opt_partition_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_partition_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_partition_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_partition_option(s)
	}
}

func (s *Opt_partition_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_partition_option(s)
	}
}

func (s *Opt_partition_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_partition_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_partition_option() (localctx IOpt_partition_optionContext) {
	localctx = NewOpt_partition_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, OBParserRULE_opt_partition_option)
	p.SetState(3969)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 358, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3965)
			p.Partition_option()
		}
		{
			p.SetState(3966)
			p.Opt_column_partition_option()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3968)
			p.Opt_column_partition_option()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHash_partition_optionContext is an interface to support dynamic dispatch.
type IHash_partition_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	HASH() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Expr() IExprContext
	RightParen() antlr.TerminalNode
	Subpartition_option() ISubpartition_optionContext
	PARTITIONS() antlr.TerminalNode
	INTNUM() antlr.TerminalNode

	// IsHash_partition_optionContext differentiates from other interfaces.
	IsHash_partition_optionContext()
}

type Hash_partition_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHash_partition_optionContext() *Hash_partition_optionContext {
	var p = new(Hash_partition_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_hash_partition_option
	return p
}

func InitEmptyHash_partition_optionContext(p *Hash_partition_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_hash_partition_option
}

func (*Hash_partition_optionContext) IsHash_partition_optionContext() {}

func NewHash_partition_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hash_partition_optionContext {
	var p = new(Hash_partition_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_hash_partition_option

	return p
}

func (s *Hash_partition_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Hash_partition_optionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *Hash_partition_optionContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Hash_partition_optionContext) HASH() antlr.TerminalNode {
	return s.GetToken(OBParserHASH, 0)
}

func (s *Hash_partition_optionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Hash_partition_optionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Hash_partition_optionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Hash_partition_optionContext) Subpartition_option() ISubpartition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartition_optionContext)
}

func (s *Hash_partition_optionContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITIONS, 0)
}

func (s *Hash_partition_optionContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Hash_partition_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hash_partition_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hash_partition_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterHash_partition_option(s)
	}
}

func (s *Hash_partition_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitHash_partition_option(s)
	}
}

func (s *Hash_partition_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitHash_partition_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Hash_partition_option() (localctx IHash_partition_optionContext) {
	localctx = NewHash_partition_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, OBParserRULE_hash_partition_option)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3971)
		p.Match(OBParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3972)
		p.Match(OBParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3973)
		p.Match(OBParserHASH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3974)
		p.Match(OBParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3975)
		p.expr(0)
	}
	{
		p.SetState(3976)
		p.Match(OBParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3977)
		p.Subpartition_option()
	}
	p.SetState(3980)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 359, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3978)
			p.Match(OBParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3979)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IList_partition_optionContext is an interface to support dynamic dispatch.
type IList_partition_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	BISON_LIST() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Expr() IExprContext
	RightParen() antlr.TerminalNode
	Subpartition_option() ISubpartition_optionContext
	Opt_list_partition_list() IOpt_list_partition_listContext
	PARTITIONS() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	Column_name_list() IColumn_name_listContext

	// IsList_partition_optionContext differentiates from other interfaces.
	IsList_partition_optionContext()
}

type List_partition_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_partition_optionContext() *List_partition_optionContext {
	var p = new(List_partition_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_list_partition_option
	return p
}

func InitEmptyList_partition_optionContext(p *List_partition_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_list_partition_option
}

func (*List_partition_optionContext) IsList_partition_optionContext() {}

func NewList_partition_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_partition_optionContext {
	var p = new(List_partition_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_list_partition_option

	return p
}

func (s *List_partition_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *List_partition_optionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *List_partition_optionContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *List_partition_optionContext) BISON_LIST() antlr.TerminalNode {
	return s.GetToken(OBParserBISON_LIST, 0)
}

func (s *List_partition_optionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *List_partition_optionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *List_partition_optionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *List_partition_optionContext) Subpartition_option() ISubpartition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartition_optionContext)
}

func (s *List_partition_optionContext) Opt_list_partition_list() IOpt_list_partition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_list_partition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_list_partition_listContext)
}

func (s *List_partition_optionContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITIONS, 0)
}

func (s *List_partition_optionContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *List_partition_optionContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(OBParserCOLUMNS, 0)
}

func (s *List_partition_optionContext) Column_name_list() IColumn_name_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_name_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_name_listContext)
}

func (s *List_partition_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_partition_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_partition_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterList_partition_option(s)
	}
}

func (s *List_partition_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitList_partition_option(s)
	}
}

func (s *List_partition_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitList_partition_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) List_partition_option() (localctx IList_partition_optionContext) {
	localctx = NewList_partition_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, OBParserRULE_list_partition_option)
	var _la int

	p.SetState(4009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 362, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3982)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3983)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3984)
			p.Match(OBParserBISON_LIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3985)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3986)
			p.expr(0)
		}
		{
			p.SetState(3987)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3988)
			p.Subpartition_option()
		}
		p.SetState(3991)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPARTITIONS {
			{
				p.SetState(3989)
				p.Match(OBParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3990)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3993)
			p.Opt_list_partition_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3995)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3996)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3997)
			p.Match(OBParserBISON_LIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3998)
			p.Match(OBParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3999)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4000)
			p.Column_name_list()
		}
		{
			p.SetState(4001)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4002)
			p.Subpartition_option()
		}
		p.SetState(4005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPARTITIONS {
			{
				p.SetState(4003)
				p.Match(OBParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4004)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4007)
			p.Opt_list_partition_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKey_partition_optionContext is an interface to support dynamic dispatch.
type IKey_partition_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Column_name_list() IColumn_name_listContext
	RightParen() antlr.TerminalNode
	Subpartition_option() ISubpartition_optionContext
	PARTITIONS() antlr.TerminalNode
	INTNUM() antlr.TerminalNode

	// IsKey_partition_optionContext differentiates from other interfaces.
	IsKey_partition_optionContext()
}

type Key_partition_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKey_partition_optionContext() *Key_partition_optionContext {
	var p = new(Key_partition_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_key_partition_option
	return p
}

func InitEmptyKey_partition_optionContext(p *Key_partition_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_key_partition_option
}

func (*Key_partition_optionContext) IsKey_partition_optionContext() {}

func NewKey_partition_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Key_partition_optionContext {
	var p = new(Key_partition_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_key_partition_option

	return p
}

func (s *Key_partition_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Key_partition_optionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *Key_partition_optionContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Key_partition_optionContext) KEY() antlr.TerminalNode {
	return s.GetToken(OBParserKEY, 0)
}

func (s *Key_partition_optionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Key_partition_optionContext) Column_name_list() IColumn_name_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_name_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_name_listContext)
}

func (s *Key_partition_optionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Key_partition_optionContext) Subpartition_option() ISubpartition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartition_optionContext)
}

func (s *Key_partition_optionContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITIONS, 0)
}

func (s *Key_partition_optionContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Key_partition_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Key_partition_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Key_partition_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterKey_partition_option(s)
	}
}

func (s *Key_partition_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitKey_partition_option(s)
	}
}

func (s *Key_partition_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitKey_partition_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Key_partition_option() (localctx IKey_partition_optionContext) {
	localctx = NewKey_partition_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, OBParserRULE_key_partition_option)
	p.SetState(4032)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 365, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4011)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4012)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4013)
			p.Match(OBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4014)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4015)
			p.Column_name_list()
		}
		{
			p.SetState(4016)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4017)
			p.Subpartition_option()
		}
		p.SetState(4020)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 363, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4018)
				p.Match(OBParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4019)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4022)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4023)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4024)
			p.Match(OBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4025)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4026)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4027)
			p.Subpartition_option()
		}
		p.SetState(4030)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 364, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4028)
				p.Match(OBParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4029)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRange_partition_optionContext is an interface to support dynamic dispatch.
type IRange_partition_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Expr() IExprContext
	RightParen() antlr.TerminalNode
	Subpartition_option() ISubpartition_optionContext
	Opt_range_partition_list() IOpt_range_partition_listContext
	PARTITIONS() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	Column_name_list() IColumn_name_listContext

	// IsRange_partition_optionContext differentiates from other interfaces.
	IsRange_partition_optionContext()
}

type Range_partition_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_partition_optionContext() *Range_partition_optionContext {
	var p = new(Range_partition_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_range_partition_option
	return p
}

func InitEmptyRange_partition_optionContext(p *Range_partition_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_range_partition_option
}

func (*Range_partition_optionContext) IsRange_partition_optionContext() {}

func NewRange_partition_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_partition_optionContext {
	var p = new(Range_partition_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_range_partition_option

	return p
}

func (s *Range_partition_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_partition_optionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *Range_partition_optionContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Range_partition_optionContext) RANGE() antlr.TerminalNode {
	return s.GetToken(OBParserRANGE, 0)
}

func (s *Range_partition_optionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Range_partition_optionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Range_partition_optionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Range_partition_optionContext) Subpartition_option() ISubpartition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartition_optionContext)
}

func (s *Range_partition_optionContext) Opt_range_partition_list() IOpt_range_partition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_range_partition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_range_partition_listContext)
}

func (s *Range_partition_optionContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITIONS, 0)
}

func (s *Range_partition_optionContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Range_partition_optionContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(OBParserCOLUMNS, 0)
}

func (s *Range_partition_optionContext) Column_name_list() IColumn_name_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_name_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_name_listContext)
}

func (s *Range_partition_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_partition_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_partition_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRange_partition_option(s)
	}
}

func (s *Range_partition_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRange_partition_option(s)
	}
}

func (s *Range_partition_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRange_partition_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Range_partition_option() (localctx IRange_partition_optionContext) {
	localctx = NewRange_partition_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, OBParserRULE_range_partition_option)
	var _la int

	p.SetState(4061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 368, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4034)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4035)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4036)
			p.Match(OBParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4037)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4038)
			p.expr(0)
		}
		{
			p.SetState(4039)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4040)
			p.Subpartition_option()
		}
		p.SetState(4043)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPARTITIONS {
			{
				p.SetState(4041)
				p.Match(OBParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4042)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4045)
			p.Opt_range_partition_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4047)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4048)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4049)
			p.Match(OBParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4050)
			p.Match(OBParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4051)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4052)
			p.Column_name_list()
		}
		{
			p.SetState(4053)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4054)
			p.Subpartition_option()
		}
		p.SetState(4057)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPARTITIONS {
			{
				p.SetState(4055)
				p.Match(OBParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4056)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4059)
			p.Opt_range_partition_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_column_partition_optionContext is an interface to support dynamic dispatch.
type IOpt_column_partition_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_partition_option() IColumn_partition_optionContext

	// IsOpt_column_partition_optionContext differentiates from other interfaces.
	IsOpt_column_partition_optionContext()
}

type Opt_column_partition_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_column_partition_optionContext() *Opt_column_partition_optionContext {
	var p = new(Opt_column_partition_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_column_partition_option
	return p
}

func InitEmptyOpt_column_partition_optionContext(p *Opt_column_partition_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_column_partition_option
}

func (*Opt_column_partition_optionContext) IsOpt_column_partition_optionContext() {}

func NewOpt_column_partition_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_column_partition_optionContext {
	var p = new(Opt_column_partition_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_column_partition_option

	return p
}

func (s *Opt_column_partition_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_column_partition_optionContext) Column_partition_option() IColumn_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_partition_optionContext)
}

func (s *Opt_column_partition_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_column_partition_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_column_partition_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_column_partition_option(s)
	}
}

func (s *Opt_column_partition_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_column_partition_option(s)
	}
}

func (s *Opt_column_partition_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_column_partition_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_column_partition_option() (localctx IOpt_column_partition_optionContext) {
	localctx = NewOpt_column_partition_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, OBParserRULE_opt_column_partition_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4064)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserPARTITION {
		{
			p.SetState(4063)
			p.Column_partition_option()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_partition_optionContext is an interface to support dynamic dispatch.
type IColumn_partition_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Vertical_column_name() IVertical_column_nameContext
	RightParen() antlr.TerminalNode
	Comma() antlr.TerminalNode
	Aux_column_list() IAux_column_listContext

	// IsColumn_partition_optionContext differentiates from other interfaces.
	IsColumn_partition_optionContext()
}

type Column_partition_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_partition_optionContext() *Column_partition_optionContext {
	var p = new(Column_partition_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_partition_option
	return p
}

func InitEmptyColumn_partition_optionContext(p *Column_partition_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_partition_option
}

func (*Column_partition_optionContext) IsColumn_partition_optionContext() {}

func NewColumn_partition_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_partition_optionContext {
	var p = new(Column_partition_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_column_partition_option

	return p
}

func (s *Column_partition_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_partition_optionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *Column_partition_optionContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Column_partition_optionContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(OBParserCOLUMN, 0)
}

func (s *Column_partition_optionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Column_partition_optionContext) Vertical_column_name() IVertical_column_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVertical_column_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVertical_column_nameContext)
}

func (s *Column_partition_optionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Column_partition_optionContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Column_partition_optionContext) Aux_column_list() IAux_column_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAux_column_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAux_column_listContext)
}

func (s *Column_partition_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_partition_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_partition_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterColumn_partition_option(s)
	}
}

func (s *Column_partition_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitColumn_partition_option(s)
	}
}

func (s *Column_partition_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitColumn_partition_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Column_partition_option() (localctx IColumn_partition_optionContext) {
	localctx = NewColumn_partition_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, OBParserRULE_column_partition_option)
	p.SetState(4082)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 370, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4066)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4067)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4068)
			p.Match(OBParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4069)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4070)
			p.Vertical_column_name()
		}
		{
			p.SetState(4071)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4073)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4074)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4075)
			p.Match(OBParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4076)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4077)
			p.Vertical_column_name()
		}
		{
			p.SetState(4078)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4079)
			p.Aux_column_list()
		}
		{
			p.SetState(4080)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAux_column_listContext is an interface to support dynamic dispatch.
type IAux_column_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVertical_column_name() []IVertical_column_nameContext
	Vertical_column_name(i int) IVertical_column_nameContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsAux_column_listContext differentiates from other interfaces.
	IsAux_column_listContext()
}

type Aux_column_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAux_column_listContext() *Aux_column_listContext {
	var p = new(Aux_column_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_aux_column_list
	return p
}

func InitEmptyAux_column_listContext(p *Aux_column_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_aux_column_list
}

func (*Aux_column_listContext) IsAux_column_listContext() {}

func NewAux_column_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Aux_column_listContext {
	var p = new(Aux_column_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_aux_column_list

	return p
}

func (s *Aux_column_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Aux_column_listContext) AllVertical_column_name() []IVertical_column_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVertical_column_nameContext); ok {
			len++
		}
	}

	tst := make([]IVertical_column_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVertical_column_nameContext); ok {
			tst[i] = t.(IVertical_column_nameContext)
			i++
		}
	}

	return tst
}

func (s *Aux_column_listContext) Vertical_column_name(i int) IVertical_column_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVertical_column_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVertical_column_nameContext)
}

func (s *Aux_column_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Aux_column_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Aux_column_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Aux_column_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Aux_column_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAux_column_list(s)
	}
}

func (s *Aux_column_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAux_column_list(s)
	}
}

func (s *Aux_column_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAux_column_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Aux_column_list() (localctx IAux_column_listContext) {
	localctx = NewAux_column_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, OBParserRULE_aux_column_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4084)
		p.Vertical_column_name()
	}
	p.SetState(4089)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(4085)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4086)
			p.Vertical_column_name()
		}

		p.SetState(4091)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVertical_column_nameContext is an interface to support dynamic dispatch.
type IVertical_column_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_name() IColumn_nameContext
	LeftParen() antlr.TerminalNode
	Column_name_list() IColumn_name_listContext
	RightParen() antlr.TerminalNode

	// IsVertical_column_nameContext differentiates from other interfaces.
	IsVertical_column_nameContext()
}

type Vertical_column_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVertical_column_nameContext() *Vertical_column_nameContext {
	var p = new(Vertical_column_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_vertical_column_name
	return p
}

func InitEmptyVertical_column_nameContext(p *Vertical_column_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_vertical_column_name
}

func (*Vertical_column_nameContext) IsVertical_column_nameContext() {}

func NewVertical_column_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Vertical_column_nameContext {
	var p = new(Vertical_column_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_vertical_column_name

	return p
}

func (s *Vertical_column_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Vertical_column_nameContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Vertical_column_nameContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Vertical_column_nameContext) Column_name_list() IColumn_name_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_name_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_name_listContext)
}

func (s *Vertical_column_nameContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Vertical_column_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Vertical_column_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Vertical_column_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterVertical_column_name(s)
	}
}

func (s *Vertical_column_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitVertical_column_name(s)
	}
}

func (s *Vertical_column_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitVertical_column_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Vertical_column_name() (localctx IVertical_column_nameContext) {
	localctx = NewVertical_column_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, OBParserRULE_vertical_column_name)
	p.SetState(4097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserNAME_OB, OBParserSTAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4092)
			p.Column_name()
		}

	case OBParserLeftParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4093)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4094)
			p.Column_name_list()
		}
		{
			p.SetState(4095)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_name_listContext is an interface to support dynamic dispatch.
type IColumn_name_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumn_name() []IColumn_nameContext
	Column_name(i int) IColumn_nameContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsColumn_name_listContext differentiates from other interfaces.
	IsColumn_name_listContext()
}

type Column_name_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_name_listContext() *Column_name_listContext {
	var p = new(Column_name_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_name_list
	return p
}

func InitEmptyColumn_name_listContext(p *Column_name_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_name_list
}

func (*Column_name_listContext) IsColumn_name_listContext() {}

func NewColumn_name_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_name_listContext {
	var p = new(Column_name_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_column_name_list

	return p
}

func (s *Column_name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_name_listContext) AllColumn_name() []IColumn_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_nameContext); ok {
			len++
		}
	}

	tst := make([]IColumn_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_nameContext); ok {
			tst[i] = t.(IColumn_nameContext)
			i++
		}
	}

	return tst
}

func (s *Column_name_listContext) Column_name(i int) IColumn_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Column_name_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Column_name_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Column_name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterColumn_name_list(s)
	}
}

func (s *Column_name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitColumn_name_list(s)
	}
}

func (s *Column_name_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitColumn_name_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Column_name_list() (localctx IColumn_name_listContext) {
	localctx = NewColumn_name_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, OBParserRULE_column_name_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4099)
		p.Column_name()
	}
	p.SetState(4104)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(4100)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4101)
			p.Column_name()
		}

		p.SetState(4106)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubpartition_optionContext is an interface to support dynamic dispatch.
type ISubpartition_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSUBPARTITION() []antlr.TerminalNode
	SUBPARTITION(i int) antlr.TerminalNode
	BY() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Expr() IExprContext
	RightParen() antlr.TerminalNode
	TEMPLATE() antlr.TerminalNode
	Opt_range_subpartition_list() IOpt_range_subpartition_listContext
	COLUMNS() antlr.TerminalNode
	Column_name_list() IColumn_name_listContext
	HASH() antlr.TerminalNode
	SUBPARTITIONS() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	BISON_LIST() antlr.TerminalNode
	Opt_list_subpartition_list() IOpt_list_subpartition_listContext
	KEY() antlr.TerminalNode
	Empty() IEmptyContext

	// IsSubpartition_optionContext differentiates from other interfaces.
	IsSubpartition_optionContext()
}

type Subpartition_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpartition_optionContext() *Subpartition_optionContext {
	var p = new(Subpartition_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_subpartition_option
	return p
}

func InitEmptySubpartition_optionContext(p *Subpartition_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_subpartition_option
}

func (*Subpartition_optionContext) IsSubpartition_optionContext() {}

func NewSubpartition_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subpartition_optionContext {
	var p = new(Subpartition_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_subpartition_option

	return p
}

func (s *Subpartition_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Subpartition_optionContext) AllSUBPARTITION() []antlr.TerminalNode {
	return s.GetTokens(OBParserSUBPARTITION)
}

func (s *Subpartition_optionContext) SUBPARTITION(i int) antlr.TerminalNode {
	return s.GetToken(OBParserSUBPARTITION, i)
}

func (s *Subpartition_optionContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Subpartition_optionContext) RANGE() antlr.TerminalNode {
	return s.GetToken(OBParserRANGE, 0)
}

func (s *Subpartition_optionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Subpartition_optionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Subpartition_optionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Subpartition_optionContext) TEMPLATE() antlr.TerminalNode {
	return s.GetToken(OBParserTEMPLATE, 0)
}

func (s *Subpartition_optionContext) Opt_range_subpartition_list() IOpt_range_subpartition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_range_subpartition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_range_subpartition_listContext)
}

func (s *Subpartition_optionContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(OBParserCOLUMNS, 0)
}

func (s *Subpartition_optionContext) Column_name_list() IColumn_name_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_name_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_name_listContext)
}

func (s *Subpartition_optionContext) HASH() antlr.TerminalNode {
	return s.GetToken(OBParserHASH, 0)
}

func (s *Subpartition_optionContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(OBParserSUBPARTITIONS, 0)
}

func (s *Subpartition_optionContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Subpartition_optionContext) BISON_LIST() antlr.TerminalNode {
	return s.GetToken(OBParserBISON_LIST, 0)
}

func (s *Subpartition_optionContext) Opt_list_subpartition_list() IOpt_list_subpartition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_list_subpartition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_list_subpartition_listContext)
}

func (s *Subpartition_optionContext) KEY() antlr.TerminalNode {
	return s.GetToken(OBParserKEY, 0)
}

func (s *Subpartition_optionContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Subpartition_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subpartition_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subpartition_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSubpartition_option(s)
	}
}

func (s *Subpartition_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSubpartition_option(s)
	}
}

func (s *Subpartition_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSubpartition_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Subpartition_option() (localctx ISubpartition_optionContext) {
	localctx = NewSubpartition_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, OBParserRULE_subpartition_option)
	p.SetState(4170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 376, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4107)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4108)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4109)
			p.Match(OBParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4110)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4111)
			p.expr(0)
		}
		{
			p.SetState(4112)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4113)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4114)
			p.Match(OBParserTEMPLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4115)
			p.Opt_range_subpartition_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4117)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4118)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4119)
			p.Match(OBParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4120)
			p.Match(OBParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4121)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4122)
			p.Column_name_list()
		}
		{
			p.SetState(4123)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4124)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4125)
			p.Match(OBParserTEMPLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4126)
			p.Opt_range_subpartition_list()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4128)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4129)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4130)
			p.Match(OBParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4131)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4132)
			p.expr(0)
		}
		{
			p.SetState(4133)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4136)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 374, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4134)
				p.Match(OBParserSUBPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4135)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4138)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4139)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4140)
			p.Match(OBParserBISON_LIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4141)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4142)
			p.expr(0)
		}
		{
			p.SetState(4143)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4144)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4145)
			p.Match(OBParserTEMPLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4146)
			p.Opt_list_subpartition_list()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4148)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4149)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4150)
			p.Match(OBParserBISON_LIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4151)
			p.Match(OBParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4152)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4153)
			p.Column_name_list()
		}
		{
			p.SetState(4154)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4155)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4156)
			p.Match(OBParserTEMPLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4157)
			p.Opt_list_subpartition_list()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4159)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4160)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4161)
			p.Match(OBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4162)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4163)
			p.Column_name_list()
		}
		{
			p.SetState(4164)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4167)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 375, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4165)
				p.Match(OBParserSUBPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4166)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4169)
			p.Empty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_list_partition_listContext is an interface to support dynamic dispatch.
type IOpt_list_partition_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	List_partition_list() IList_partition_listContext
	RightParen() antlr.TerminalNode

	// IsOpt_list_partition_listContext differentiates from other interfaces.
	IsOpt_list_partition_listContext()
}

type Opt_list_partition_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_list_partition_listContext() *Opt_list_partition_listContext {
	var p = new(Opt_list_partition_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_list_partition_list
	return p
}

func InitEmptyOpt_list_partition_listContext(p *Opt_list_partition_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_list_partition_list
}

func (*Opt_list_partition_listContext) IsOpt_list_partition_listContext() {}

func NewOpt_list_partition_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_list_partition_listContext {
	var p = new(Opt_list_partition_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_list_partition_list

	return p
}

func (s *Opt_list_partition_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_list_partition_listContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Opt_list_partition_listContext) List_partition_list() IList_partition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_partition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_partition_listContext)
}

func (s *Opt_list_partition_listContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Opt_list_partition_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_list_partition_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_list_partition_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_list_partition_list(s)
	}
}

func (s *Opt_list_partition_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_list_partition_list(s)
	}
}

func (s *Opt_list_partition_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_list_partition_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_list_partition_list() (localctx IOpt_list_partition_listContext) {
	localctx = NewOpt_list_partition_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, OBParserRULE_opt_list_partition_list)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4172)
		p.Match(OBParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4173)
		p.List_partition_list()
	}
	{
		p.SetState(4174)
		p.Match(OBParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_list_subpartition_listContext is an interface to support dynamic dispatch.
type IOpt_list_subpartition_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	List_subpartition_list() IList_subpartition_listContext
	RightParen() antlr.TerminalNode

	// IsOpt_list_subpartition_listContext differentiates from other interfaces.
	IsOpt_list_subpartition_listContext()
}

type Opt_list_subpartition_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_list_subpartition_listContext() *Opt_list_subpartition_listContext {
	var p = new(Opt_list_subpartition_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_list_subpartition_list
	return p
}

func InitEmptyOpt_list_subpartition_listContext(p *Opt_list_subpartition_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_list_subpartition_list
}

func (*Opt_list_subpartition_listContext) IsOpt_list_subpartition_listContext() {}

func NewOpt_list_subpartition_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_list_subpartition_listContext {
	var p = new(Opt_list_subpartition_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_list_subpartition_list

	return p
}

func (s *Opt_list_subpartition_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_list_subpartition_listContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Opt_list_subpartition_listContext) List_subpartition_list() IList_subpartition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_subpartition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_subpartition_listContext)
}

func (s *Opt_list_subpartition_listContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Opt_list_subpartition_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_list_subpartition_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_list_subpartition_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_list_subpartition_list(s)
	}
}

func (s *Opt_list_subpartition_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_list_subpartition_list(s)
	}
}

func (s *Opt_list_subpartition_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_list_subpartition_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_list_subpartition_list() (localctx IOpt_list_subpartition_listContext) {
	localctx = NewOpt_list_subpartition_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, OBParserRULE_opt_list_subpartition_list)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4176)
		p.Match(OBParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4177)
		p.List_subpartition_list()
	}
	{
		p.SetState(4178)
		p.Match(OBParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_range_partition_listContext is an interface to support dynamic dispatch.
type IOpt_range_partition_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	Range_partition_list() IRange_partition_listContext
	RightParen() antlr.TerminalNode

	// IsOpt_range_partition_listContext differentiates from other interfaces.
	IsOpt_range_partition_listContext()
}

type Opt_range_partition_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_range_partition_listContext() *Opt_range_partition_listContext {
	var p = new(Opt_range_partition_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_range_partition_list
	return p
}

func InitEmptyOpt_range_partition_listContext(p *Opt_range_partition_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_range_partition_list
}

func (*Opt_range_partition_listContext) IsOpt_range_partition_listContext() {}

func NewOpt_range_partition_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_range_partition_listContext {
	var p = new(Opt_range_partition_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_range_partition_list

	return p
}

func (s *Opt_range_partition_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_range_partition_listContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Opt_range_partition_listContext) Range_partition_list() IRange_partition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRange_partition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRange_partition_listContext)
}

func (s *Opt_range_partition_listContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Opt_range_partition_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_range_partition_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_range_partition_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_range_partition_list(s)
	}
}

func (s *Opt_range_partition_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_range_partition_list(s)
	}
}

func (s *Opt_range_partition_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_range_partition_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_range_partition_list() (localctx IOpt_range_partition_listContext) {
	localctx = NewOpt_range_partition_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, OBParserRULE_opt_range_partition_list)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4180)
		p.Match(OBParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4181)
		p.Range_partition_list()
	}
	{
		p.SetState(4182)
		p.Match(OBParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_range_subpartition_listContext is an interface to support dynamic dispatch.
type IOpt_range_subpartition_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	Range_subpartition_list() IRange_subpartition_listContext
	RightParen() antlr.TerminalNode

	// IsOpt_range_subpartition_listContext differentiates from other interfaces.
	IsOpt_range_subpartition_listContext()
}

type Opt_range_subpartition_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_range_subpartition_listContext() *Opt_range_subpartition_listContext {
	var p = new(Opt_range_subpartition_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_range_subpartition_list
	return p
}

func InitEmptyOpt_range_subpartition_listContext(p *Opt_range_subpartition_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_range_subpartition_list
}

func (*Opt_range_subpartition_listContext) IsOpt_range_subpartition_listContext() {}

func NewOpt_range_subpartition_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_range_subpartition_listContext {
	var p = new(Opt_range_subpartition_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_range_subpartition_list

	return p
}

func (s *Opt_range_subpartition_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_range_subpartition_listContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Opt_range_subpartition_listContext) Range_subpartition_list() IRange_subpartition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRange_subpartition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRange_subpartition_listContext)
}

func (s *Opt_range_subpartition_listContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Opt_range_subpartition_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_range_subpartition_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_range_subpartition_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_range_subpartition_list(s)
	}
}

func (s *Opt_range_subpartition_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_range_subpartition_list(s)
	}
}

func (s *Opt_range_subpartition_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_range_subpartition_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_range_subpartition_list() (localctx IOpt_range_subpartition_listContext) {
	localctx = NewOpt_range_subpartition_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, OBParserRULE_opt_range_subpartition_list)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4184)
		p.Match(OBParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4185)
		p.Range_subpartition_list()
	}
	{
		p.SetState(4186)
		p.Match(OBParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IList_partition_listContext is an interface to support dynamic dispatch.
type IList_partition_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllList_partition_element() []IList_partition_elementContext
	List_partition_element(i int) IList_partition_elementContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsList_partition_listContext differentiates from other interfaces.
	IsList_partition_listContext()
}

type List_partition_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_partition_listContext() *List_partition_listContext {
	var p = new(List_partition_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_list_partition_list
	return p
}

func InitEmptyList_partition_listContext(p *List_partition_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_list_partition_list
}

func (*List_partition_listContext) IsList_partition_listContext() {}

func NewList_partition_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_partition_listContext {
	var p = new(List_partition_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_list_partition_list

	return p
}

func (s *List_partition_listContext) GetParser() antlr.Parser { return s.parser }

func (s *List_partition_listContext) AllList_partition_element() []IList_partition_elementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IList_partition_elementContext); ok {
			len++
		}
	}

	tst := make([]IList_partition_elementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IList_partition_elementContext); ok {
			tst[i] = t.(IList_partition_elementContext)
			i++
		}
	}

	return tst
}

func (s *List_partition_listContext) List_partition_element(i int) IList_partition_elementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_partition_elementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_partition_elementContext)
}

func (s *List_partition_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *List_partition_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *List_partition_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_partition_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_partition_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterList_partition_list(s)
	}
}

func (s *List_partition_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitList_partition_list(s)
	}
}

func (s *List_partition_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitList_partition_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) List_partition_list() (localctx IList_partition_listContext) {
	localctx = NewList_partition_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, OBParserRULE_list_partition_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4188)
		p.List_partition_element()
	}
	p.SetState(4193)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(4189)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4190)
			p.List_partition_element()
		}

		p.SetState(4195)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IList_subpartition_listContext is an interface to support dynamic dispatch.
type IList_subpartition_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllList_subpartition_element() []IList_subpartition_elementContext
	List_subpartition_element(i int) IList_subpartition_elementContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsList_subpartition_listContext differentiates from other interfaces.
	IsList_subpartition_listContext()
}

type List_subpartition_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_subpartition_listContext() *List_subpartition_listContext {
	var p = new(List_subpartition_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_list_subpartition_list
	return p
}

func InitEmptyList_subpartition_listContext(p *List_subpartition_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_list_subpartition_list
}

func (*List_subpartition_listContext) IsList_subpartition_listContext() {}

func NewList_subpartition_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_subpartition_listContext {
	var p = new(List_subpartition_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_list_subpartition_list

	return p
}

func (s *List_subpartition_listContext) GetParser() antlr.Parser { return s.parser }

func (s *List_subpartition_listContext) AllList_subpartition_element() []IList_subpartition_elementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IList_subpartition_elementContext); ok {
			len++
		}
	}

	tst := make([]IList_subpartition_elementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IList_subpartition_elementContext); ok {
			tst[i] = t.(IList_subpartition_elementContext)
			i++
		}
	}

	return tst
}

func (s *List_subpartition_listContext) List_subpartition_element(i int) IList_subpartition_elementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_subpartition_elementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_subpartition_elementContext)
}

func (s *List_subpartition_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *List_subpartition_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *List_subpartition_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_subpartition_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_subpartition_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterList_subpartition_list(s)
	}
}

func (s *List_subpartition_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitList_subpartition_list(s)
	}
}

func (s *List_subpartition_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitList_subpartition_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) List_subpartition_list() (localctx IList_subpartition_listContext) {
	localctx = NewList_subpartition_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, OBParserRULE_list_subpartition_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4196)
		p.List_subpartition_element()
	}
	p.SetState(4201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(4197)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4198)
			p.List_subpartition_element()
		}

		p.SetState(4203)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IList_subpartition_elementContext is an interface to support dynamic dispatch.
type IList_subpartition_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBPARTITION() antlr.TerminalNode
	Relation_factor() IRelation_factorContext
	VALUES() antlr.TerminalNode
	IN() antlr.TerminalNode
	List_partition_expr() IList_partition_exprContext

	// IsList_subpartition_elementContext differentiates from other interfaces.
	IsList_subpartition_elementContext()
}

type List_subpartition_elementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_subpartition_elementContext() *List_subpartition_elementContext {
	var p = new(List_subpartition_elementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_list_subpartition_element
	return p
}

func InitEmptyList_subpartition_elementContext(p *List_subpartition_elementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_list_subpartition_element
}

func (*List_subpartition_elementContext) IsList_subpartition_elementContext() {}

func NewList_subpartition_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_subpartition_elementContext {
	var p = new(List_subpartition_elementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_list_subpartition_element

	return p
}

func (s *List_subpartition_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *List_subpartition_elementContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserSUBPARTITION, 0)
}

func (s *List_subpartition_elementContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *List_subpartition_elementContext) VALUES() antlr.TerminalNode {
	return s.GetToken(OBParserVALUES, 0)
}

func (s *List_subpartition_elementContext) IN() antlr.TerminalNode {
	return s.GetToken(OBParserIN, 0)
}

func (s *List_subpartition_elementContext) List_partition_expr() IList_partition_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_partition_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_partition_exprContext)
}

func (s *List_subpartition_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_subpartition_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_subpartition_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterList_subpartition_element(s)
	}
}

func (s *List_subpartition_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitList_subpartition_element(s)
	}
}

func (s *List_subpartition_elementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitList_subpartition_element(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) List_subpartition_element() (localctx IList_subpartition_elementContext) {
	localctx = NewList_subpartition_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, OBParserRULE_list_subpartition_element)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4204)
		p.Match(OBParserSUBPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4205)
		p.Relation_factor()
	}
	{
		p.SetState(4206)
		p.Match(OBParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4207)
		p.Match(OBParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4208)
		p.List_partition_expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IList_partition_elementContext is an interface to support dynamic dispatch.
type IList_partition_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Relation_factor() IRelation_factorContext
	VALUES() antlr.TerminalNode
	IN() antlr.TerminalNode
	List_partition_expr() IList_partition_exprContext
	ID() antlr.TerminalNode
	INTNUM() antlr.TerminalNode

	// IsList_partition_elementContext differentiates from other interfaces.
	IsList_partition_elementContext()
}

type List_partition_elementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_partition_elementContext() *List_partition_elementContext {
	var p = new(List_partition_elementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_list_partition_element
	return p
}

func InitEmptyList_partition_elementContext(p *List_partition_elementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_list_partition_element
}

func (*List_partition_elementContext) IsList_partition_elementContext() {}

func NewList_partition_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_partition_elementContext {
	var p = new(List_partition_elementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_list_partition_element

	return p
}

func (s *List_partition_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *List_partition_elementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *List_partition_elementContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *List_partition_elementContext) VALUES() antlr.TerminalNode {
	return s.GetToken(OBParserVALUES, 0)
}

func (s *List_partition_elementContext) IN() antlr.TerminalNode {
	return s.GetToken(OBParserIN, 0)
}

func (s *List_partition_elementContext) List_partition_expr() IList_partition_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_partition_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_partition_exprContext)
}

func (s *List_partition_elementContext) ID() antlr.TerminalNode {
	return s.GetToken(OBParserID, 0)
}

func (s *List_partition_elementContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *List_partition_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_partition_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_partition_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterList_partition_element(s)
	}
}

func (s *List_partition_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitList_partition_element(s)
	}
}

func (s *List_partition_elementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitList_partition_element(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) List_partition_element() (localctx IList_partition_elementContext) {
	localctx = NewList_partition_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, OBParserRULE_list_partition_element)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4210)
		p.Match(OBParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4211)
		p.Relation_factor()
	}
	{
		p.SetState(4212)
		p.Match(OBParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4213)
		p.Match(OBParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4214)
		p.List_partition_expr()
	}
	p.SetState(4217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserID {
		{
			p.SetState(4215)
			p.Match(OBParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4216)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IList_partition_exprContext is an interface to support dynamic dispatch.
type IList_partition_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	List_expr() IList_exprContext
	RightParen() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsList_partition_exprContext differentiates from other interfaces.
	IsList_partition_exprContext()
}

type List_partition_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_partition_exprContext() *List_partition_exprContext {
	var p = new(List_partition_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_list_partition_expr
	return p
}

func InitEmptyList_partition_exprContext(p *List_partition_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_list_partition_expr
}

func (*List_partition_exprContext) IsList_partition_exprContext() {}

func NewList_partition_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_partition_exprContext {
	var p = new(List_partition_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_list_partition_expr

	return p
}

func (s *List_partition_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *List_partition_exprContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *List_partition_exprContext) List_expr() IList_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_exprContext)
}

func (s *List_partition_exprContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *List_partition_exprContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT, 0)
}

func (s *List_partition_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_partition_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_partition_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterList_partition_expr(s)
	}
}

func (s *List_partition_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitList_partition_expr(s)
	}
}

func (s *List_partition_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitList_partition_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) List_partition_expr() (localctx IList_partition_exprContext) {
	localctx = NewList_partition_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, OBParserRULE_list_partition_expr)
	p.SetState(4226)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 380, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4219)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4220)
			p.List_expr()
		}
		{
			p.SetState(4221)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4223)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4224)
			p.Match(OBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4225)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IList_exprContext is an interface to support dynamic dispatch.
type IList_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsList_exprContext differentiates from other interfaces.
	IsList_exprContext()
}

type List_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_exprContext() *List_exprContext {
	var p = new(List_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_list_expr
	return p
}

func InitEmptyList_exprContext(p *List_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_list_expr
}

func (*List_exprContext) IsList_exprContext() {}

func NewList_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_exprContext {
	var p = new(List_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_list_expr

	return p
}

func (s *List_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *List_exprContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *List_exprContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *List_exprContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *List_exprContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *List_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterList_expr(s)
	}
}

func (s *List_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitList_expr(s)
	}
}

func (s *List_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitList_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) List_expr() (localctx IList_exprContext) {
	localctx = NewList_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, OBParserRULE_list_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4228)
		p.expr(0)
	}
	p.SetState(4233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(4229)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4230)
			p.expr(0)
		}

		p.SetState(4235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRange_partition_listContext is an interface to support dynamic dispatch.
type IRange_partition_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRange_partition_element() []IRange_partition_elementContext
	Range_partition_element(i int) IRange_partition_elementContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsRange_partition_listContext differentiates from other interfaces.
	IsRange_partition_listContext()
}

type Range_partition_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_partition_listContext() *Range_partition_listContext {
	var p = new(Range_partition_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_range_partition_list
	return p
}

func InitEmptyRange_partition_listContext(p *Range_partition_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_range_partition_list
}

func (*Range_partition_listContext) IsRange_partition_listContext() {}

func NewRange_partition_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_partition_listContext {
	var p = new(Range_partition_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_range_partition_list

	return p
}

func (s *Range_partition_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_partition_listContext) AllRange_partition_element() []IRange_partition_elementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRange_partition_elementContext); ok {
			len++
		}
	}

	tst := make([]IRange_partition_elementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRange_partition_elementContext); ok {
			tst[i] = t.(IRange_partition_elementContext)
			i++
		}
	}

	return tst
}

func (s *Range_partition_listContext) Range_partition_element(i int) IRange_partition_elementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRange_partition_elementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRange_partition_elementContext)
}

func (s *Range_partition_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Range_partition_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Range_partition_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_partition_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_partition_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRange_partition_list(s)
	}
}

func (s *Range_partition_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRange_partition_list(s)
	}
}

func (s *Range_partition_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRange_partition_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Range_partition_list() (localctx IRange_partition_listContext) {
	localctx = NewRange_partition_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, OBParserRULE_range_partition_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4236)
		p.Range_partition_element()
	}
	p.SetState(4241)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(4237)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4238)
			p.Range_partition_element()
		}

		p.SetState(4243)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRange_partition_elementContext is an interface to support dynamic dispatch.
type IRange_partition_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Relation_factor() IRelation_factorContext
	VALUES() antlr.TerminalNode
	LESS() antlr.TerminalNode
	THAN() antlr.TerminalNode
	Range_partition_expr() IRange_partition_exprContext
	ID() antlr.TerminalNode
	INTNUM() antlr.TerminalNode

	// IsRange_partition_elementContext differentiates from other interfaces.
	IsRange_partition_elementContext()
}

type Range_partition_elementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_partition_elementContext() *Range_partition_elementContext {
	var p = new(Range_partition_elementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_range_partition_element
	return p
}

func InitEmptyRange_partition_elementContext(p *Range_partition_elementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_range_partition_element
}

func (*Range_partition_elementContext) IsRange_partition_elementContext() {}

func NewRange_partition_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_partition_elementContext {
	var p = new(Range_partition_elementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_range_partition_element

	return p
}

func (s *Range_partition_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_partition_elementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *Range_partition_elementContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Range_partition_elementContext) VALUES() antlr.TerminalNode {
	return s.GetToken(OBParserVALUES, 0)
}

func (s *Range_partition_elementContext) LESS() antlr.TerminalNode {
	return s.GetToken(OBParserLESS, 0)
}

func (s *Range_partition_elementContext) THAN() antlr.TerminalNode {
	return s.GetToken(OBParserTHAN, 0)
}

func (s *Range_partition_elementContext) Range_partition_expr() IRange_partition_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRange_partition_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRange_partition_exprContext)
}

func (s *Range_partition_elementContext) ID() antlr.TerminalNode {
	return s.GetToken(OBParserID, 0)
}

func (s *Range_partition_elementContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Range_partition_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_partition_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_partition_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRange_partition_element(s)
	}
}

func (s *Range_partition_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRange_partition_element(s)
	}
}

func (s *Range_partition_elementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRange_partition_element(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Range_partition_element() (localctx IRange_partition_elementContext) {
	localctx = NewRange_partition_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, OBParserRULE_range_partition_element)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4244)
		p.Match(OBParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4245)
		p.Relation_factor()
	}
	{
		p.SetState(4246)
		p.Match(OBParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4247)
		p.Match(OBParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4248)
		p.Match(OBParserTHAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4249)
		p.Range_partition_expr()
	}
	p.SetState(4252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserID {
		{
			p.SetState(4250)
			p.Match(OBParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4251)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRange_subpartition_elementContext is an interface to support dynamic dispatch.
type IRange_subpartition_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBPARTITION() antlr.TerminalNode
	Relation_factor() IRelation_factorContext
	VALUES() antlr.TerminalNode
	LESS() antlr.TerminalNode
	THAN() antlr.TerminalNode
	Range_partition_expr() IRange_partition_exprContext

	// IsRange_subpartition_elementContext differentiates from other interfaces.
	IsRange_subpartition_elementContext()
}

type Range_subpartition_elementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_subpartition_elementContext() *Range_subpartition_elementContext {
	var p = new(Range_subpartition_elementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_range_subpartition_element
	return p
}

func InitEmptyRange_subpartition_elementContext(p *Range_subpartition_elementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_range_subpartition_element
}

func (*Range_subpartition_elementContext) IsRange_subpartition_elementContext() {}

func NewRange_subpartition_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_subpartition_elementContext {
	var p = new(Range_subpartition_elementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_range_subpartition_element

	return p
}

func (s *Range_subpartition_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_subpartition_elementContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserSUBPARTITION, 0)
}

func (s *Range_subpartition_elementContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Range_subpartition_elementContext) VALUES() antlr.TerminalNode {
	return s.GetToken(OBParserVALUES, 0)
}

func (s *Range_subpartition_elementContext) LESS() antlr.TerminalNode {
	return s.GetToken(OBParserLESS, 0)
}

func (s *Range_subpartition_elementContext) THAN() antlr.TerminalNode {
	return s.GetToken(OBParserTHAN, 0)
}

func (s *Range_subpartition_elementContext) Range_partition_expr() IRange_partition_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRange_partition_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRange_partition_exprContext)
}

func (s *Range_subpartition_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_subpartition_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_subpartition_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRange_subpartition_element(s)
	}
}

func (s *Range_subpartition_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRange_subpartition_element(s)
	}
}

func (s *Range_subpartition_elementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRange_subpartition_element(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Range_subpartition_element() (localctx IRange_subpartition_elementContext) {
	localctx = NewRange_subpartition_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, OBParserRULE_range_subpartition_element)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4254)
		p.Match(OBParserSUBPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4255)
		p.Relation_factor()
	}
	{
		p.SetState(4256)
		p.Match(OBParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4257)
		p.Match(OBParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4258)
		p.Match(OBParserTHAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4259)
		p.Range_partition_expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRange_subpartition_listContext is an interface to support dynamic dispatch.
type IRange_subpartition_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRange_subpartition_element() []IRange_subpartition_elementContext
	Range_subpartition_element(i int) IRange_subpartition_elementContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsRange_subpartition_listContext differentiates from other interfaces.
	IsRange_subpartition_listContext()
}

type Range_subpartition_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_subpartition_listContext() *Range_subpartition_listContext {
	var p = new(Range_subpartition_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_range_subpartition_list
	return p
}

func InitEmptyRange_subpartition_listContext(p *Range_subpartition_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_range_subpartition_list
}

func (*Range_subpartition_listContext) IsRange_subpartition_listContext() {}

func NewRange_subpartition_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_subpartition_listContext {
	var p = new(Range_subpartition_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_range_subpartition_list

	return p
}

func (s *Range_subpartition_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_subpartition_listContext) AllRange_subpartition_element() []IRange_subpartition_elementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRange_subpartition_elementContext); ok {
			len++
		}
	}

	tst := make([]IRange_subpartition_elementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRange_subpartition_elementContext); ok {
			tst[i] = t.(IRange_subpartition_elementContext)
			i++
		}
	}

	return tst
}

func (s *Range_subpartition_listContext) Range_subpartition_element(i int) IRange_subpartition_elementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRange_subpartition_elementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRange_subpartition_elementContext)
}

func (s *Range_subpartition_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Range_subpartition_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Range_subpartition_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_subpartition_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_subpartition_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRange_subpartition_list(s)
	}
}

func (s *Range_subpartition_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRange_subpartition_list(s)
	}
}

func (s *Range_subpartition_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRange_subpartition_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Range_subpartition_list() (localctx IRange_subpartition_listContext) {
	localctx = NewRange_subpartition_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, OBParserRULE_range_subpartition_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4261)
		p.Range_subpartition_element()
	}
	p.SetState(4266)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(4262)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4263)
			p.Range_subpartition_element()
		}

		p.SetState(4268)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRange_partition_exprContext is an interface to support dynamic dispatch.
type IRange_partition_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	Range_expr_list() IRange_expr_listContext
	RightParen() antlr.TerminalNode
	MAXVALUE() antlr.TerminalNode

	// IsRange_partition_exprContext differentiates from other interfaces.
	IsRange_partition_exprContext()
}

type Range_partition_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_partition_exprContext() *Range_partition_exprContext {
	var p = new(Range_partition_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_range_partition_expr
	return p
}

func InitEmptyRange_partition_exprContext(p *Range_partition_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_range_partition_expr
}

func (*Range_partition_exprContext) IsRange_partition_exprContext() {}

func NewRange_partition_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_partition_exprContext {
	var p = new(Range_partition_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_range_partition_expr

	return p
}

func (s *Range_partition_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_partition_exprContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Range_partition_exprContext) Range_expr_list() IRange_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRange_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRange_expr_listContext)
}

func (s *Range_partition_exprContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Range_partition_exprContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(OBParserMAXVALUE, 0)
}

func (s *Range_partition_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_partition_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_partition_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRange_partition_expr(s)
	}
}

func (s *Range_partition_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRange_partition_expr(s)
	}
}

func (s *Range_partition_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRange_partition_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Range_partition_expr() (localctx IRange_partition_exprContext) {
	localctx = NewRange_partition_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, OBParserRULE_range_partition_expr)
	p.SetState(4274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserLeftParen:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4269)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4270)
			p.Range_expr_list()
		}
		{
			p.SetState(4271)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserMAXVALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4273)
			p.Match(OBParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRange_expr_listContext is an interface to support dynamic dispatch.
type IRange_expr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRange_expr() []IRange_exprContext
	Range_expr(i int) IRange_exprContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsRange_expr_listContext differentiates from other interfaces.
	IsRange_expr_listContext()
}

type Range_expr_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_expr_listContext() *Range_expr_listContext {
	var p = new(Range_expr_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_range_expr_list
	return p
}

func InitEmptyRange_expr_listContext(p *Range_expr_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_range_expr_list
}

func (*Range_expr_listContext) IsRange_expr_listContext() {}

func NewRange_expr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_expr_listContext {
	var p = new(Range_expr_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_range_expr_list

	return p
}

func (s *Range_expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_expr_listContext) AllRange_expr() []IRange_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRange_exprContext); ok {
			len++
		}
	}

	tst := make([]IRange_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRange_exprContext); ok {
			tst[i] = t.(IRange_exprContext)
			i++
		}
	}

	return tst
}

func (s *Range_expr_listContext) Range_expr(i int) IRange_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRange_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRange_exprContext)
}

func (s *Range_expr_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Range_expr_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Range_expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRange_expr_list(s)
	}
}

func (s *Range_expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRange_expr_list(s)
	}
}

func (s *Range_expr_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRange_expr_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Range_expr_list() (localctx IRange_expr_listContext) {
	localctx = NewRange_expr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, OBParserRULE_range_expr_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4276)
		p.Range_expr()
	}
	p.SetState(4281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(4277)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4278)
			p.Range_expr()
		}

		p.SetState(4283)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRange_exprContext is an interface to support dynamic dispatch.
type IRange_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	MAXVALUE() antlr.TerminalNode

	// IsRange_exprContext differentiates from other interfaces.
	IsRange_exprContext()
}

type Range_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_exprContext() *Range_exprContext {
	var p = new(Range_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_range_expr
	return p
}

func InitEmptyRange_exprContext(p *Range_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_range_expr
}

func (*Range_exprContext) IsRange_exprContext() {}

func NewRange_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_exprContext {
	var p = new(Range_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_range_expr

	return p
}

func (s *Range_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_exprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Range_exprContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(OBParserMAXVALUE, 0)
}

func (s *Range_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRange_expr(s)
	}
}

func (s *Range_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRange_expr(s)
	}
}

func (s *Range_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRange_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Range_expr() (localctx IRange_exprContext) {
	localctx = NewRange_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, OBParserRULE_range_expr)
	p.SetState(4286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserBINARY, OBParserCASE, OBParserCHARACTER, OBParserCIPHER, OBParserCONVERT, OBParserCOLUMNS, OBParserCURRENT_DATE, OBParserCURRENT_TIME, OBParserCURRENT_TIMESTAMP, OBParserCURRENT_USER, OBParserDATABASE, OBParserNUMBER, OBParserDEFAULT, OBParserEXISTS, OBParserFIELDS, OBParserID, OBParserIF, OBParserINTERVAL, OBParserINSERT, OBParserISSUER, OBParserLANGUAGE, OBParserLEFT, OBParserLOCAL, OBParserLOCALTIME, OBParserLOCALTIMESTAMP, OBParserMATCH, OBParserMOD, OBParserMODE, OBParserPARSER, OBParserREPLACE, OBParserREPEAT, OBParserRIGHT, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserUTC_TIMESTAMP, OBParserVALUES, OBParserX509, OBParserGLOBAL_ALIAS, OBParserSESSION_ALIAS, OBParserUnderlineUTF8, OBParserUnderlineUTF8MB4, OBParserUnderlineGBK, OBParserUnderlineGB18030, OBParserUnderlineBINARY, OBParserUnderlineUTF16, OBParserISNULL, OBParserNOT, OBParserNULLX, OBParserINTNUM, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserTIMESTAMP_VALUE, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserAPPROXNUM, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserDECIMAL_VAL, OBParserBOOL_VALUE, OBParserHEX_STRING_VALUE, OBParserDATE_VALUE, OBParserPlus, OBParserNot, OBParserLeftParen, OBParserMinus, OBParserDot, OBParserTilde, OBParserQUESTIONMARK, OBParserSYSTEM_VARIABLE, OBParserUSER_VARIABLE, OBParserNAME_OB, OBParserSTRING_VALUE, OBParserSTAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4284)
			p.expr(0)
		}

	case OBParserMAXVALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4285)
			p.Match(OBParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInt_or_decimalContext is an interface to support dynamic dispatch.
type IInt_or_decimalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTNUM() antlr.TerminalNode
	DECIMAL_VAL() antlr.TerminalNode

	// IsInt_or_decimalContext differentiates from other interfaces.
	IsInt_or_decimalContext()
}

type Int_or_decimalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInt_or_decimalContext() *Int_or_decimalContext {
	var p = new(Int_or_decimalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_int_or_decimal
	return p
}

func InitEmptyInt_or_decimalContext(p *Int_or_decimalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_int_or_decimal
}

func (*Int_or_decimalContext) IsInt_or_decimalContext() {}

func NewInt_or_decimalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int_or_decimalContext {
	var p = new(Int_or_decimalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_int_or_decimal

	return p
}

func (s *Int_or_decimalContext) GetParser() antlr.Parser { return s.parser }

func (s *Int_or_decimalContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Int_or_decimalContext) DECIMAL_VAL() antlr.TerminalNode {
	return s.GetToken(OBParserDECIMAL_VAL, 0)
}

func (s *Int_or_decimalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int_or_decimalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Int_or_decimalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterInt_or_decimal(s)
	}
}

func (s *Int_or_decimalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitInt_or_decimal(s)
	}
}

func (s *Int_or_decimalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitInt_or_decimal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Int_or_decimal() (localctx IInt_or_decimalContext) {
	localctx = NewInt_or_decimalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, OBParserRULE_int_or_decimal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4288)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserINTNUM || _la == OBParserDECIMAL_VAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITg_hash_partition_optionContext is an interface to support dynamic dispatch.
type ITg_hash_partition_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	HASH() antlr.TerminalNode
	Tg_subpartition_option() ITg_subpartition_optionContext
	PARTITIONS() antlr.TerminalNode
	INTNUM() antlr.TerminalNode

	// IsTg_hash_partition_optionContext differentiates from other interfaces.
	IsTg_hash_partition_optionContext()
}

type Tg_hash_partition_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTg_hash_partition_optionContext() *Tg_hash_partition_optionContext {
	var p = new(Tg_hash_partition_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tg_hash_partition_option
	return p
}

func InitEmptyTg_hash_partition_optionContext(p *Tg_hash_partition_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tg_hash_partition_option
}

func (*Tg_hash_partition_optionContext) IsTg_hash_partition_optionContext() {}

func NewTg_hash_partition_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tg_hash_partition_optionContext {
	var p = new(Tg_hash_partition_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tg_hash_partition_option

	return p
}

func (s *Tg_hash_partition_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tg_hash_partition_optionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *Tg_hash_partition_optionContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Tg_hash_partition_optionContext) HASH() antlr.TerminalNode {
	return s.GetToken(OBParserHASH, 0)
}

func (s *Tg_hash_partition_optionContext) Tg_subpartition_option() ITg_subpartition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITg_subpartition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITg_subpartition_optionContext)
}

func (s *Tg_hash_partition_optionContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITIONS, 0)
}

func (s *Tg_hash_partition_optionContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Tg_hash_partition_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tg_hash_partition_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tg_hash_partition_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTg_hash_partition_option(s)
	}
}

func (s *Tg_hash_partition_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTg_hash_partition_option(s)
	}
}

func (s *Tg_hash_partition_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTg_hash_partition_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tg_hash_partition_option() (localctx ITg_hash_partition_optionContext) {
	localctx = NewTg_hash_partition_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, OBParserRULE_tg_hash_partition_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4290)
		p.Match(OBParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4291)
		p.Match(OBParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4292)
		p.Match(OBParserHASH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4293)
		p.Tg_subpartition_option()
	}
	p.SetState(4296)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserPARTITIONS {
		{
			p.SetState(4294)
			p.Match(OBParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4295)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITg_key_partition_optionContext is an interface to support dynamic dispatch.
type ITg_key_partition_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	AllINTNUM() []antlr.TerminalNode
	INTNUM(i int) antlr.TerminalNode
	Tg_subpartition_option() ITg_subpartition_optionContext
	PARTITIONS() antlr.TerminalNode

	// IsTg_key_partition_optionContext differentiates from other interfaces.
	IsTg_key_partition_optionContext()
}

type Tg_key_partition_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTg_key_partition_optionContext() *Tg_key_partition_optionContext {
	var p = new(Tg_key_partition_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tg_key_partition_option
	return p
}

func InitEmptyTg_key_partition_optionContext(p *Tg_key_partition_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tg_key_partition_option
}

func (*Tg_key_partition_optionContext) IsTg_key_partition_optionContext() {}

func NewTg_key_partition_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tg_key_partition_optionContext {
	var p = new(Tg_key_partition_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tg_key_partition_option

	return p
}

func (s *Tg_key_partition_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tg_key_partition_optionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *Tg_key_partition_optionContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Tg_key_partition_optionContext) KEY() antlr.TerminalNode {
	return s.GetToken(OBParserKEY, 0)
}

func (s *Tg_key_partition_optionContext) AllINTNUM() []antlr.TerminalNode {
	return s.GetTokens(OBParserINTNUM)
}

func (s *Tg_key_partition_optionContext) INTNUM(i int) antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, i)
}

func (s *Tg_key_partition_optionContext) Tg_subpartition_option() ITg_subpartition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITg_subpartition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITg_subpartition_optionContext)
}

func (s *Tg_key_partition_optionContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITIONS, 0)
}

func (s *Tg_key_partition_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tg_key_partition_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tg_key_partition_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTg_key_partition_option(s)
	}
}

func (s *Tg_key_partition_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTg_key_partition_option(s)
	}
}

func (s *Tg_key_partition_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTg_key_partition_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tg_key_partition_option() (localctx ITg_key_partition_optionContext) {
	localctx = NewTg_key_partition_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, OBParserRULE_tg_key_partition_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4298)
		p.Match(OBParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4299)
		p.Match(OBParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4300)
		p.Match(OBParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4301)
		p.Match(OBParserINTNUM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4302)
		p.Tg_subpartition_option()
	}
	p.SetState(4305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserPARTITIONS {
		{
			p.SetState(4303)
			p.Match(OBParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4304)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITg_range_partition_optionContext is an interface to support dynamic dispatch.
type ITg_range_partition_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	Tg_subpartition_option() ITg_subpartition_optionContext
	Opt_range_partition_list() IOpt_range_partition_listContext
	PARTITIONS() antlr.TerminalNode
	AllINTNUM() []antlr.TerminalNode
	INTNUM(i int) antlr.TerminalNode
	COLUMNS() antlr.TerminalNode

	// IsTg_range_partition_optionContext differentiates from other interfaces.
	IsTg_range_partition_optionContext()
}

type Tg_range_partition_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTg_range_partition_optionContext() *Tg_range_partition_optionContext {
	var p = new(Tg_range_partition_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tg_range_partition_option
	return p
}

func InitEmptyTg_range_partition_optionContext(p *Tg_range_partition_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tg_range_partition_option
}

func (*Tg_range_partition_optionContext) IsTg_range_partition_optionContext() {}

func NewTg_range_partition_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tg_range_partition_optionContext {
	var p = new(Tg_range_partition_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tg_range_partition_option

	return p
}

func (s *Tg_range_partition_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tg_range_partition_optionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *Tg_range_partition_optionContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Tg_range_partition_optionContext) RANGE() antlr.TerminalNode {
	return s.GetToken(OBParserRANGE, 0)
}

func (s *Tg_range_partition_optionContext) Tg_subpartition_option() ITg_subpartition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITg_subpartition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITg_subpartition_optionContext)
}

func (s *Tg_range_partition_optionContext) Opt_range_partition_list() IOpt_range_partition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_range_partition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_range_partition_listContext)
}

func (s *Tg_range_partition_optionContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITIONS, 0)
}

func (s *Tg_range_partition_optionContext) AllINTNUM() []antlr.TerminalNode {
	return s.GetTokens(OBParserINTNUM)
}

func (s *Tg_range_partition_optionContext) INTNUM(i int) antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, i)
}

func (s *Tg_range_partition_optionContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(OBParserCOLUMNS, 0)
}

func (s *Tg_range_partition_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tg_range_partition_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tg_range_partition_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTg_range_partition_option(s)
	}
}

func (s *Tg_range_partition_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTg_range_partition_option(s)
	}
}

func (s *Tg_range_partition_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTg_range_partition_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tg_range_partition_option() (localctx ITg_range_partition_optionContext) {
	localctx = NewTg_range_partition_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, OBParserRULE_tg_range_partition_option)
	var _la int

	p.SetState(4329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 392, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4307)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4308)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4309)
			p.Match(OBParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4310)
			p.Tg_subpartition_option()
		}
		p.SetState(4313)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPARTITIONS {
			{
				p.SetState(4311)
				p.Match(OBParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4312)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4315)
			p.Opt_range_partition_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4317)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4318)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4319)
			p.Match(OBParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4320)
			p.Match(OBParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4321)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4322)
			p.Tg_subpartition_option()
		}
		p.SetState(4325)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPARTITIONS {
			{
				p.SetState(4323)
				p.Match(OBParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4324)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4327)
			p.Opt_range_partition_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITg_list_partition_optionContext is an interface to support dynamic dispatch.
type ITg_list_partition_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	BISON_LIST() antlr.TerminalNode
	Tg_subpartition_option() ITg_subpartition_optionContext
	Opt_list_partition_list() IOpt_list_partition_listContext
	PARTITIONS() antlr.TerminalNode
	AllINTNUM() []antlr.TerminalNode
	INTNUM(i int) antlr.TerminalNode
	COLUMNS() antlr.TerminalNode

	// IsTg_list_partition_optionContext differentiates from other interfaces.
	IsTg_list_partition_optionContext()
}

type Tg_list_partition_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTg_list_partition_optionContext() *Tg_list_partition_optionContext {
	var p = new(Tg_list_partition_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tg_list_partition_option
	return p
}

func InitEmptyTg_list_partition_optionContext(p *Tg_list_partition_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tg_list_partition_option
}

func (*Tg_list_partition_optionContext) IsTg_list_partition_optionContext() {}

func NewTg_list_partition_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tg_list_partition_optionContext {
	var p = new(Tg_list_partition_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tg_list_partition_option

	return p
}

func (s *Tg_list_partition_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tg_list_partition_optionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *Tg_list_partition_optionContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Tg_list_partition_optionContext) BISON_LIST() antlr.TerminalNode {
	return s.GetToken(OBParserBISON_LIST, 0)
}

func (s *Tg_list_partition_optionContext) Tg_subpartition_option() ITg_subpartition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITg_subpartition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITg_subpartition_optionContext)
}

func (s *Tg_list_partition_optionContext) Opt_list_partition_list() IOpt_list_partition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_list_partition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_list_partition_listContext)
}

func (s *Tg_list_partition_optionContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITIONS, 0)
}

func (s *Tg_list_partition_optionContext) AllINTNUM() []antlr.TerminalNode {
	return s.GetTokens(OBParserINTNUM)
}

func (s *Tg_list_partition_optionContext) INTNUM(i int) antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, i)
}

func (s *Tg_list_partition_optionContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(OBParserCOLUMNS, 0)
}

func (s *Tg_list_partition_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tg_list_partition_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tg_list_partition_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTg_list_partition_option(s)
	}
}

func (s *Tg_list_partition_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTg_list_partition_option(s)
	}
}

func (s *Tg_list_partition_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTg_list_partition_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tg_list_partition_option() (localctx ITg_list_partition_optionContext) {
	localctx = NewTg_list_partition_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, OBParserRULE_tg_list_partition_option)
	var _la int

	p.SetState(4353)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 395, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4331)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4332)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4333)
			p.Match(OBParserBISON_LIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4334)
			p.Tg_subpartition_option()
		}
		p.SetState(4337)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPARTITIONS {
			{
				p.SetState(4335)
				p.Match(OBParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4336)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4339)
			p.Opt_list_partition_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4341)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4342)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4343)
			p.Match(OBParserBISON_LIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4344)
			p.Match(OBParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4345)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4346)
			p.Tg_subpartition_option()
		}
		p.SetState(4349)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPARTITIONS {
			{
				p.SetState(4347)
				p.Match(OBParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4348)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4351)
			p.Opt_list_partition_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITg_subpartition_optionContext is an interface to support dynamic dispatch.
type ITg_subpartition_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSUBPARTITION() []antlr.TerminalNode
	SUBPARTITION(i int) antlr.TerminalNode
	BY() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	TEMPLATE() antlr.TerminalNode
	Opt_range_subpartition_list() IOpt_range_subpartition_listContext
	COLUMNS() antlr.TerminalNode
	AllINTNUM() []antlr.TerminalNode
	INTNUM(i int) antlr.TerminalNode
	HASH() antlr.TerminalNode
	SUBPARTITIONS() antlr.TerminalNode
	KEY() antlr.TerminalNode
	BISON_LIST() antlr.TerminalNode
	Opt_list_subpartition_list() IOpt_list_subpartition_listContext
	Empty() IEmptyContext

	// IsTg_subpartition_optionContext differentiates from other interfaces.
	IsTg_subpartition_optionContext()
}

type Tg_subpartition_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTg_subpartition_optionContext() *Tg_subpartition_optionContext {
	var p = new(Tg_subpartition_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tg_subpartition_option
	return p
}

func InitEmptyTg_subpartition_optionContext(p *Tg_subpartition_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tg_subpartition_option
}

func (*Tg_subpartition_optionContext) IsTg_subpartition_optionContext() {}

func NewTg_subpartition_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tg_subpartition_optionContext {
	var p = new(Tg_subpartition_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tg_subpartition_option

	return p
}

func (s *Tg_subpartition_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tg_subpartition_optionContext) AllSUBPARTITION() []antlr.TerminalNode {
	return s.GetTokens(OBParserSUBPARTITION)
}

func (s *Tg_subpartition_optionContext) SUBPARTITION(i int) antlr.TerminalNode {
	return s.GetToken(OBParserSUBPARTITION, i)
}

func (s *Tg_subpartition_optionContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Tg_subpartition_optionContext) RANGE() antlr.TerminalNode {
	return s.GetToken(OBParserRANGE, 0)
}

func (s *Tg_subpartition_optionContext) TEMPLATE() antlr.TerminalNode {
	return s.GetToken(OBParserTEMPLATE, 0)
}

func (s *Tg_subpartition_optionContext) Opt_range_subpartition_list() IOpt_range_subpartition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_range_subpartition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_range_subpartition_listContext)
}

func (s *Tg_subpartition_optionContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(OBParserCOLUMNS, 0)
}

func (s *Tg_subpartition_optionContext) AllINTNUM() []antlr.TerminalNode {
	return s.GetTokens(OBParserINTNUM)
}

func (s *Tg_subpartition_optionContext) INTNUM(i int) antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, i)
}

func (s *Tg_subpartition_optionContext) HASH() antlr.TerminalNode {
	return s.GetToken(OBParserHASH, 0)
}

func (s *Tg_subpartition_optionContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(OBParserSUBPARTITIONS, 0)
}

func (s *Tg_subpartition_optionContext) KEY() antlr.TerminalNode {
	return s.GetToken(OBParserKEY, 0)
}

func (s *Tg_subpartition_optionContext) BISON_LIST() antlr.TerminalNode {
	return s.GetToken(OBParserBISON_LIST, 0)
}

func (s *Tg_subpartition_optionContext) Opt_list_subpartition_list() IOpt_list_subpartition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_list_subpartition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_list_subpartition_listContext)
}

func (s *Tg_subpartition_optionContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Tg_subpartition_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tg_subpartition_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tg_subpartition_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTg_subpartition_option(s)
	}
}

func (s *Tg_subpartition_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTg_subpartition_option(s)
	}
}

func (s *Tg_subpartition_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTg_subpartition_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tg_subpartition_option() (localctx ITg_subpartition_optionContext) {
	localctx = NewTg_subpartition_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, OBParserRULE_tg_subpartition_option)
	var _la int

	p.SetState(4399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 398, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4355)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4356)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4357)
			p.Match(OBParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4358)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4359)
			p.Match(OBParserTEMPLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4360)
			p.Opt_range_subpartition_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4361)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4362)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4363)
			p.Match(OBParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4364)
			p.Match(OBParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4365)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4366)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4367)
			p.Match(OBParserTEMPLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4368)
			p.Opt_range_subpartition_list()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4369)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4370)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4371)
			p.Match(OBParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSUBPARTITIONS {
			{
				p.SetState(4372)
				p.Match(OBParserSUBPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4373)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4376)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4377)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4378)
			p.Match(OBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4379)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4382)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSUBPARTITIONS {
			{
				p.SetState(4380)
				p.Match(OBParserSUBPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4381)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4384)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4385)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4386)
			p.Match(OBParserBISON_LIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4387)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4388)
			p.Match(OBParserTEMPLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4389)
			p.Opt_list_subpartition_list()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4390)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4391)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4392)
			p.Match(OBParserBISON_LIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4393)
			p.Match(OBParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4394)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4395)
			p.Match(OBParserSUBPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4396)
			p.Match(OBParserTEMPLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4397)
			p.Opt_list_subpartition_list()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4398)
			p.Empty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRow_format_optionContext is an interface to support dynamic dispatch.
type IRow_format_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REDUNDANT() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	COMPRESSED() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsRow_format_optionContext differentiates from other interfaces.
	IsRow_format_optionContext()
}

type Row_format_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRow_format_optionContext() *Row_format_optionContext {
	var p = new(Row_format_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_row_format_option
	return p
}

func InitEmptyRow_format_optionContext(p *Row_format_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_row_format_option
}

func (*Row_format_optionContext) IsRow_format_optionContext() {}

func NewRow_format_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Row_format_optionContext {
	var p = new(Row_format_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_row_format_option

	return p
}

func (s *Row_format_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Row_format_optionContext) REDUNDANT() antlr.TerminalNode {
	return s.GetToken(OBParserREDUNDANT, 0)
}

func (s *Row_format_optionContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(OBParserCOMPACT, 0)
}

func (s *Row_format_optionContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(OBParserDYNAMIC, 0)
}

func (s *Row_format_optionContext) COMPRESSED() antlr.TerminalNode {
	return s.GetToken(OBParserCOMPRESSED, 0)
}

func (s *Row_format_optionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT, 0)
}

func (s *Row_format_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Row_format_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Row_format_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRow_format_option(s)
	}
}

func (s *Row_format_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRow_format_option(s)
	}
}

func (s *Row_format_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRow_format_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Row_format_option() (localctx IRow_format_optionContext) {
	localctx = NewRow_format_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, OBParserRULE_row_format_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4401)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserDEFAULT || _la == OBParserREDUNDANT || _la == OBParserCOMPACT || _la == OBParserCOMPRESSED || _la == OBParserDYNAMIC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_tablegroup_stmtContext is an interface to support dynamic dispatch.
type ICreate_tablegroup_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLEGROUP() antlr.TerminalNode
	Relation_name() IRelation_nameContext
	IF() antlr.TerminalNode
	Not() INotContext
	EXISTS() antlr.TerminalNode
	Tablegroup_option_list() ITablegroup_option_listContext
	Tg_hash_partition_option() ITg_hash_partition_optionContext
	Tg_key_partition_option() ITg_key_partition_optionContext
	Tg_range_partition_option() ITg_range_partition_optionContext
	Tg_list_partition_option() ITg_list_partition_optionContext

	// IsCreate_tablegroup_stmtContext differentiates from other interfaces.
	IsCreate_tablegroup_stmtContext()
}

type Create_tablegroup_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_tablegroup_stmtContext() *Create_tablegroup_stmtContext {
	var p = new(Create_tablegroup_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_tablegroup_stmt
	return p
}

func InitEmptyCreate_tablegroup_stmtContext(p *Create_tablegroup_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_tablegroup_stmt
}

func (*Create_tablegroup_stmtContext) IsCreate_tablegroup_stmtContext() {}

func NewCreate_tablegroup_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_tablegroup_stmtContext {
	var p = new(Create_tablegroup_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_create_tablegroup_stmt

	return p
}

func (s *Create_tablegroup_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_tablegroup_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE, 0)
}

func (s *Create_tablegroup_stmtContext) TABLEGROUP() antlr.TerminalNode {
	return s.GetToken(OBParserTABLEGROUP, 0)
}

func (s *Create_tablegroup_stmtContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Create_tablegroup_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Create_tablegroup_stmtContext) Not() INotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotContext)
}

func (s *Create_tablegroup_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Create_tablegroup_stmtContext) Tablegroup_option_list() ITablegroup_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablegroup_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablegroup_option_listContext)
}

func (s *Create_tablegroup_stmtContext) Tg_hash_partition_option() ITg_hash_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITg_hash_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITg_hash_partition_optionContext)
}

func (s *Create_tablegroup_stmtContext) Tg_key_partition_option() ITg_key_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITg_key_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITg_key_partition_optionContext)
}

func (s *Create_tablegroup_stmtContext) Tg_range_partition_option() ITg_range_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITg_range_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITg_range_partition_optionContext)
}

func (s *Create_tablegroup_stmtContext) Tg_list_partition_option() ITg_list_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITg_list_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITg_list_partition_optionContext)
}

func (s *Create_tablegroup_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_tablegroup_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_tablegroup_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCreate_tablegroup_stmt(s)
	}
}

func (s *Create_tablegroup_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCreate_tablegroup_stmt(s)
	}
}

func (s *Create_tablegroup_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCreate_tablegroup_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Create_tablegroup_stmt() (localctx ICreate_tablegroup_stmtContext) {
	localctx = NewCreate_tablegroup_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, OBParserRULE_create_tablegroup_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4403)
		p.Match(OBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4404)
		p.Match(OBParserTABLEGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserIF {
		{
			p.SetState(4405)
			p.Match(OBParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4406)
			p.Not()
		}
		{
			p.SetState(4407)
			p.Match(OBParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4411)
		p.Relation_name()
	}
	p.SetState(4413)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserLOCALITY || _la == OBParserMAX_USED_PART_ID || _la == OBParserBINDING || _la == OBParserPRIMARY_ZONE || _la == OBParserTABLEGROUP_ID {
		{
			p.SetState(4412)
			p.Tablegroup_option_list()
		}

	}
	p.SetState(4419)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 401, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4415)
			p.Tg_hash_partition_option()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 401, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(4416)
			p.Tg_key_partition_option()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 401, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(4417)
			p.Tg_range_partition_option()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 401, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(4418)
			p.Tg_list_partition_option()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_tablegroup_stmtContext is an interface to support dynamic dispatch.
type IDrop_tablegroup_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TABLEGROUP() antlr.TerminalNode
	Relation_name() IRelation_nameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDrop_tablegroup_stmtContext differentiates from other interfaces.
	IsDrop_tablegroup_stmtContext()
}

type Drop_tablegroup_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_tablegroup_stmtContext() *Drop_tablegroup_stmtContext {
	var p = new(Drop_tablegroup_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_tablegroup_stmt
	return p
}

func InitEmptyDrop_tablegroup_stmtContext(p *Drop_tablegroup_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_tablegroup_stmt
}

func (*Drop_tablegroup_stmtContext) IsDrop_tablegroup_stmtContext() {}

func NewDrop_tablegroup_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_tablegroup_stmtContext {
	var p = new(Drop_tablegroup_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_drop_tablegroup_stmt

	return p
}

func (s *Drop_tablegroup_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_tablegroup_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Drop_tablegroup_stmtContext) TABLEGROUP() antlr.TerminalNode {
	return s.GetToken(OBParserTABLEGROUP, 0)
}

func (s *Drop_tablegroup_stmtContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Drop_tablegroup_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Drop_tablegroup_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Drop_tablegroup_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_tablegroup_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_tablegroup_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDrop_tablegroup_stmt(s)
	}
}

func (s *Drop_tablegroup_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDrop_tablegroup_stmt(s)
	}
}

func (s *Drop_tablegroup_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDrop_tablegroup_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Drop_tablegroup_stmt() (localctx IDrop_tablegroup_stmtContext) {
	localctx = NewDrop_tablegroup_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, OBParserRULE_drop_tablegroup_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4421)
		p.Match(OBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4422)
		p.Match(OBParserTABLEGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4425)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserIF {
		{
			p.SetState(4423)
			p.Match(OBParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4424)
			p.Match(OBParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4427)
		p.Relation_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_tablegroup_stmtContext is an interface to support dynamic dispatch.
type IAlter_tablegroup_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLEGROUP() antlr.TerminalNode
	Relation_name() IRelation_nameContext
	ADD() antlr.TerminalNode
	Table_list() ITable_listContext
	TABLE() antlr.TerminalNode
	Alter_tablegroup_actions() IAlter_tablegroup_actionsContext
	Alter_tg_partition_option() IAlter_tg_partition_optionContext

	// IsAlter_tablegroup_stmtContext differentiates from other interfaces.
	IsAlter_tablegroup_stmtContext()
}

type Alter_tablegroup_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_tablegroup_stmtContext() *Alter_tablegroup_stmtContext {
	var p = new(Alter_tablegroup_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tablegroup_stmt
	return p
}

func InitEmptyAlter_tablegroup_stmtContext(p *Alter_tablegroup_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tablegroup_stmt
}

func (*Alter_tablegroup_stmtContext) IsAlter_tablegroup_stmtContext() {}

func NewAlter_tablegroup_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_tablegroup_stmtContext {
	var p = new(Alter_tablegroup_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_tablegroup_stmt

	return p
}

func (s *Alter_tablegroup_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_tablegroup_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(OBParserALTER, 0)
}

func (s *Alter_tablegroup_stmtContext) TABLEGROUP() antlr.TerminalNode {
	return s.GetToken(OBParserTABLEGROUP, 0)
}

func (s *Alter_tablegroup_stmtContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Alter_tablegroup_stmtContext) ADD() antlr.TerminalNode {
	return s.GetToken(OBParserADD, 0)
}

func (s *Alter_tablegroup_stmtContext) Table_list() ITable_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_listContext)
}

func (s *Alter_tablegroup_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE, 0)
}

func (s *Alter_tablegroup_stmtContext) Alter_tablegroup_actions() IAlter_tablegroup_actionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_tablegroup_actionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_tablegroup_actionsContext)
}

func (s *Alter_tablegroup_stmtContext) Alter_tg_partition_option() IAlter_tg_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_tg_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_tg_partition_optionContext)
}

func (s *Alter_tablegroup_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_tablegroup_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_tablegroup_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_tablegroup_stmt(s)
	}
}

func (s *Alter_tablegroup_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_tablegroup_stmt(s)
	}
}

func (s *Alter_tablegroup_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_tablegroup_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_tablegroup_stmt() (localctx IAlter_tablegroup_stmtContext) {
	localctx = NewAlter_tablegroup_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, OBParserRULE_alter_tablegroup_stmt)
	var _la int

	p.SetState(4448)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 404, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4429)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4430)
			p.Match(OBParserTABLEGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4431)
			p.Relation_name()
		}
		{
			p.SetState(4432)
			p.Match(OBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4434)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTABLE {
			{
				p.SetState(4433)
				p.Match(OBParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4436)
			p.Table_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4438)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4439)
			p.Match(OBParserTABLEGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4440)
			p.Relation_name()
		}
		{
			p.SetState(4441)
			p.Alter_tablegroup_actions()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4443)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4444)
			p.Match(OBParserTABLEGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4445)
			p.Relation_name()
		}
		{
			p.SetState(4446)
			p.Alter_tg_partition_option()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablegroup_option_list_space_seperatedContext is an interface to support dynamic dispatch.
type ITablegroup_option_list_space_seperatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Tablegroup_option() ITablegroup_optionContext
	Tablegroup_option_list_space_seperated() ITablegroup_option_list_space_seperatedContext

	// IsTablegroup_option_list_space_seperatedContext differentiates from other interfaces.
	IsTablegroup_option_list_space_seperatedContext()
}

type Tablegroup_option_list_space_seperatedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablegroup_option_list_space_seperatedContext() *Tablegroup_option_list_space_seperatedContext {
	var p = new(Tablegroup_option_list_space_seperatedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tablegroup_option_list_space_seperated
	return p
}

func InitEmptyTablegroup_option_list_space_seperatedContext(p *Tablegroup_option_list_space_seperatedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tablegroup_option_list_space_seperated
}

func (*Tablegroup_option_list_space_seperatedContext) IsTablegroup_option_list_space_seperatedContext() {
}

func NewTablegroup_option_list_space_seperatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tablegroup_option_list_space_seperatedContext {
	var p = new(Tablegroup_option_list_space_seperatedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tablegroup_option_list_space_seperated

	return p
}

func (s *Tablegroup_option_list_space_seperatedContext) GetParser() antlr.Parser { return s.parser }

func (s *Tablegroup_option_list_space_seperatedContext) Tablegroup_option() ITablegroup_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablegroup_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablegroup_optionContext)
}

func (s *Tablegroup_option_list_space_seperatedContext) Tablegroup_option_list_space_seperated() ITablegroup_option_list_space_seperatedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablegroup_option_list_space_seperatedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablegroup_option_list_space_seperatedContext)
}

func (s *Tablegroup_option_list_space_seperatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tablegroup_option_list_space_seperatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tablegroup_option_list_space_seperatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTablegroup_option_list_space_seperated(s)
	}
}

func (s *Tablegroup_option_list_space_seperatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTablegroup_option_list_space_seperated(s)
	}
}

func (s *Tablegroup_option_list_space_seperatedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTablegroup_option_list_space_seperated(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tablegroup_option_list_space_seperated() (localctx ITablegroup_option_list_space_seperatedContext) {
	localctx = NewTablegroup_option_list_space_seperatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, OBParserRULE_tablegroup_option_list_space_seperated)
	p.SetState(4454)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 405, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4450)
			p.Tablegroup_option()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4451)
			p.Tablegroup_option()
		}
		{
			p.SetState(4452)
			p.Tablegroup_option_list_space_seperated()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablegroup_option_listContext is an interface to support dynamic dispatch.
type ITablegroup_option_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Tablegroup_option_list_space_seperated() ITablegroup_option_list_space_seperatedContext
	Tablegroup_option() ITablegroup_optionContext
	Comma() antlr.TerminalNode
	Tablegroup_option_list() ITablegroup_option_listContext

	// IsTablegroup_option_listContext differentiates from other interfaces.
	IsTablegroup_option_listContext()
}

type Tablegroup_option_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablegroup_option_listContext() *Tablegroup_option_listContext {
	var p = new(Tablegroup_option_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tablegroup_option_list
	return p
}

func InitEmptyTablegroup_option_listContext(p *Tablegroup_option_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tablegroup_option_list
}

func (*Tablegroup_option_listContext) IsTablegroup_option_listContext() {}

func NewTablegroup_option_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tablegroup_option_listContext {
	var p = new(Tablegroup_option_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tablegroup_option_list

	return p
}

func (s *Tablegroup_option_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Tablegroup_option_listContext) Tablegroup_option_list_space_seperated() ITablegroup_option_list_space_seperatedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablegroup_option_list_space_seperatedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablegroup_option_list_space_seperatedContext)
}

func (s *Tablegroup_option_listContext) Tablegroup_option() ITablegroup_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablegroup_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablegroup_optionContext)
}

func (s *Tablegroup_option_listContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Tablegroup_option_listContext) Tablegroup_option_list() ITablegroup_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablegroup_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablegroup_option_listContext)
}

func (s *Tablegroup_option_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tablegroup_option_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tablegroup_option_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTablegroup_option_list(s)
	}
}

func (s *Tablegroup_option_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTablegroup_option_list(s)
	}
}

func (s *Tablegroup_option_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTablegroup_option_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tablegroup_option_list() (localctx ITablegroup_option_listContext) {
	localctx = NewTablegroup_option_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, OBParserRULE_tablegroup_option_list)
	p.SetState(4461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 406, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4456)
			p.Tablegroup_option_list_space_seperated()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4457)
			p.Tablegroup_option()
		}
		{
			p.SetState(4458)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4459)
			p.Tablegroup_option_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablegroup_optionContext is an interface to support dynamic dispatch.
type ITablegroup_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCALITY() antlr.TerminalNode
	Locality_name() ILocality_nameContext
	COMP_EQ() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	PRIMARY_ZONE() antlr.TerminalNode
	Primary_zone_name() IPrimary_zone_nameContext
	TABLEGROUP_ID() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	BINDING() antlr.TerminalNode
	BOOL_VALUE() antlr.TerminalNode
	MAX_USED_PART_ID() antlr.TerminalNode

	// IsTablegroup_optionContext differentiates from other interfaces.
	IsTablegroup_optionContext()
}

type Tablegroup_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablegroup_optionContext() *Tablegroup_optionContext {
	var p = new(Tablegroup_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tablegroup_option
	return p
}

func InitEmptyTablegroup_optionContext(p *Tablegroup_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tablegroup_option
}

func (*Tablegroup_optionContext) IsTablegroup_optionContext() {}

func NewTablegroup_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tablegroup_optionContext {
	var p = new(Tablegroup_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tablegroup_option

	return p
}

func (s *Tablegroup_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tablegroup_optionContext) LOCALITY() antlr.TerminalNode {
	return s.GetToken(OBParserLOCALITY, 0)
}

func (s *Tablegroup_optionContext) Locality_name() ILocality_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocality_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocality_nameContext)
}

func (s *Tablegroup_optionContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Tablegroup_optionContext) FORCE() antlr.TerminalNode {
	return s.GetToken(OBParserFORCE, 0)
}

func (s *Tablegroup_optionContext) PRIMARY_ZONE() antlr.TerminalNode {
	return s.GetToken(OBParserPRIMARY_ZONE, 0)
}

func (s *Tablegroup_optionContext) Primary_zone_name() IPrimary_zone_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimary_zone_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimary_zone_nameContext)
}

func (s *Tablegroup_optionContext) TABLEGROUP_ID() antlr.TerminalNode {
	return s.GetToken(OBParserTABLEGROUP_ID, 0)
}

func (s *Tablegroup_optionContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Tablegroup_optionContext) BINDING() antlr.TerminalNode {
	return s.GetToken(OBParserBINDING, 0)
}

func (s *Tablegroup_optionContext) BOOL_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserBOOL_VALUE, 0)
}

func (s *Tablegroup_optionContext) MAX_USED_PART_ID() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_USED_PART_ID, 0)
}

func (s *Tablegroup_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tablegroup_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tablegroup_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTablegroup_option(s)
	}
}

func (s *Tablegroup_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTablegroup_option(s)
	}
}

func (s *Tablegroup_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTablegroup_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tablegroup_option() (localctx ITablegroup_optionContext) {
	localctx = NewTablegroup_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, OBParserRULE_tablegroup_option)
	var _la int

	p.SetState(4491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserLOCALITY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4463)
			p.Match(OBParserLOCALITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4465)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(4464)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4467)
			p.Locality_name()
		}
		p.SetState(4469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFORCE {
			{
				p.SetState(4468)
				p.Match(OBParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case OBParserPRIMARY_ZONE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4471)
			p.Match(OBParserPRIMARY_ZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(4472)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4475)
			p.Primary_zone_name()
		}

	case OBParserTABLEGROUP_ID:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4476)
			p.Match(OBParserTABLEGROUP_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4478)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(4477)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4480)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserBINDING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4481)
			p.Match(OBParserBINDING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4483)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(4482)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4485)
			p.Match(OBParserBOOL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserMAX_USED_PART_ID:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4486)
			p.Match(OBParserMAX_USED_PART_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4488)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(4487)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4490)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_tablegroup_actionsContext is an interface to support dynamic dispatch.
type IAlter_tablegroup_actionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlter_tablegroup_action() []IAlter_tablegroup_actionContext
	Alter_tablegroup_action(i int) IAlter_tablegroup_actionContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsAlter_tablegroup_actionsContext differentiates from other interfaces.
	IsAlter_tablegroup_actionsContext()
}

type Alter_tablegroup_actionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_tablegroup_actionsContext() *Alter_tablegroup_actionsContext {
	var p = new(Alter_tablegroup_actionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tablegroup_actions
	return p
}

func InitEmptyAlter_tablegroup_actionsContext(p *Alter_tablegroup_actionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tablegroup_actions
}

func (*Alter_tablegroup_actionsContext) IsAlter_tablegroup_actionsContext() {}

func NewAlter_tablegroup_actionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_tablegroup_actionsContext {
	var p = new(Alter_tablegroup_actionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_tablegroup_actions

	return p
}

func (s *Alter_tablegroup_actionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_tablegroup_actionsContext) AllAlter_tablegroup_action() []IAlter_tablegroup_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_tablegroup_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_tablegroup_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_tablegroup_actionContext); ok {
			tst[i] = t.(IAlter_tablegroup_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_tablegroup_actionsContext) Alter_tablegroup_action(i int) IAlter_tablegroup_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_tablegroup_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_tablegroup_actionContext)
}

func (s *Alter_tablegroup_actionsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Alter_tablegroup_actionsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Alter_tablegroup_actionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_tablegroup_actionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_tablegroup_actionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_tablegroup_actions(s)
	}
}

func (s *Alter_tablegroup_actionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_tablegroup_actions(s)
	}
}

func (s *Alter_tablegroup_actionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_tablegroup_actions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_tablegroup_actions() (localctx IAlter_tablegroup_actionsContext) {
	localctx = NewAlter_tablegroup_actionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, OBParserRULE_alter_tablegroup_actions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4493)
		p.Alter_tablegroup_action()
	}
	p.SetState(4498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(4494)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4495)
			p.Alter_tablegroup_action()
		}

		p.SetState(4500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_tablegroup_actionContext is an interface to support dynamic dispatch.
type IAlter_tablegroup_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Tablegroup_option_list_space_seperated() ITablegroup_option_list_space_seperatedContext
	SET() antlr.TerminalNode

	// IsAlter_tablegroup_actionContext differentiates from other interfaces.
	IsAlter_tablegroup_actionContext()
}

type Alter_tablegroup_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_tablegroup_actionContext() *Alter_tablegroup_actionContext {
	var p = new(Alter_tablegroup_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tablegroup_action
	return p
}

func InitEmptyAlter_tablegroup_actionContext(p *Alter_tablegroup_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tablegroup_action
}

func (*Alter_tablegroup_actionContext) IsAlter_tablegroup_actionContext() {}

func NewAlter_tablegroup_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_tablegroup_actionContext {
	var p = new(Alter_tablegroup_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_tablegroup_action

	return p
}

func (s *Alter_tablegroup_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_tablegroup_actionContext) Tablegroup_option_list_space_seperated() ITablegroup_option_list_space_seperatedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablegroup_option_list_space_seperatedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablegroup_option_list_space_seperatedContext)
}

func (s *Alter_tablegroup_actionContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Alter_tablegroup_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_tablegroup_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_tablegroup_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_tablegroup_action(s)
	}
}

func (s *Alter_tablegroup_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_tablegroup_action(s)
	}
}

func (s *Alter_tablegroup_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_tablegroup_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_tablegroup_action() (localctx IAlter_tablegroup_actionContext) {
	localctx = NewAlter_tablegroup_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, OBParserRULE_alter_tablegroup_action)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4502)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserSET {
		{
			p.SetState(4501)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4504)
		p.Tablegroup_option_list_space_seperated()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefault_tablegroupContext is an interface to support dynamic dispatch.
type IDefault_tablegroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLEGROUP() antlr.TerminalNode
	Relation_name() IRelation_nameContext
	DEFAULT() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode
	NULLX() antlr.TerminalNode

	// IsDefault_tablegroupContext differentiates from other interfaces.
	IsDefault_tablegroupContext()
}

type Default_tablegroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefault_tablegroupContext() *Default_tablegroupContext {
	var p = new(Default_tablegroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_default_tablegroup
	return p
}

func InitEmptyDefault_tablegroupContext(p *Default_tablegroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_default_tablegroup
}

func (*Default_tablegroupContext) IsDefault_tablegroupContext() {}

func NewDefault_tablegroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Default_tablegroupContext {
	var p = new(Default_tablegroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_default_tablegroup

	return p
}

func (s *Default_tablegroupContext) GetParser() antlr.Parser { return s.parser }

func (s *Default_tablegroupContext) TABLEGROUP() antlr.TerminalNode {
	return s.GetToken(OBParserTABLEGROUP, 0)
}

func (s *Default_tablegroupContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Default_tablegroupContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT, 0)
}

func (s *Default_tablegroupContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Default_tablegroupContext) NULLX() antlr.TerminalNode {
	return s.GetToken(OBParserNULLX, 0)
}

func (s *Default_tablegroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Default_tablegroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Default_tablegroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDefault_tablegroup(s)
	}
}

func (s *Default_tablegroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDefault_tablegroup(s)
	}
}

func (s *Default_tablegroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDefault_tablegroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Default_tablegroup() (localctx IDefault_tablegroupContext) {
	localctx = NewDefault_tablegroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, OBParserRULE_default_tablegroup)
	var _la int

	p.SetState(4522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 420, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4507)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserDEFAULT {
			{
				p.SetState(4506)
				p.Match(OBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4509)
			p.Match(OBParserTABLEGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4511)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(4510)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4513)
			p.Relation_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4515)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserDEFAULT {
			{
				p.SetState(4514)
				p.Match(OBParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4517)
			p.Match(OBParserTABLEGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(4518)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4521)
			p.Match(OBParserNULLX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_view_stmtContext is an interface to support dynamic dispatch.
type ICreate_view_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	View_name() IView_nameContext
	AS() antlr.TerminalNode
	View_select_stmt() IView_select_stmtContext
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Column_list() IColumn_listContext
	RightParen() antlr.TerminalNode
	TABLE_ID() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode
	INTNUM() antlr.TerminalNode

	// IsCreate_view_stmtContext differentiates from other interfaces.
	IsCreate_view_stmtContext()
}

type Create_view_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_view_stmtContext() *Create_view_stmtContext {
	var p = new(Create_view_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_view_stmt
	return p
}

func InitEmptyCreate_view_stmtContext(p *Create_view_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_view_stmt
}

func (*Create_view_stmtContext) IsCreate_view_stmtContext() {}

func NewCreate_view_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_view_stmtContext {
	var p = new(Create_view_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_create_view_stmt

	return p
}

func (s *Create_view_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_view_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE, 0)
}

func (s *Create_view_stmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(OBParserVIEW, 0)
}

func (s *Create_view_stmtContext) View_name() IView_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IView_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IView_nameContext)
}

func (s *Create_view_stmtContext) AS() antlr.TerminalNode {
	return s.GetToken(OBParserAS, 0)
}

func (s *Create_view_stmtContext) View_select_stmt() IView_select_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IView_select_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IView_select_stmtContext)
}

func (s *Create_view_stmtContext) OR() antlr.TerminalNode {
	return s.GetToken(OBParserOR, 0)
}

func (s *Create_view_stmtContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(OBParserREPLACE, 0)
}

func (s *Create_view_stmtContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(OBParserMATERIALIZED, 0)
}

func (s *Create_view_stmtContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Create_view_stmtContext) Column_list() IColumn_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_listContext)
}

func (s *Create_view_stmtContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Create_view_stmtContext) TABLE_ID() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE_ID, 0)
}

func (s *Create_view_stmtContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Create_view_stmtContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Create_view_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_view_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_view_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCreate_view_stmt(s)
	}
}

func (s *Create_view_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCreate_view_stmt(s)
	}
}

func (s *Create_view_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCreate_view_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Create_view_stmt() (localctx ICreate_view_stmtContext) {
	localctx = NewCreate_view_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, OBParserRULE_create_view_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4524)
		p.Match(OBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4527)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserOR {
		{
			p.SetState(4525)
			p.Match(OBParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4526)
			p.Match(OBParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserMATERIALIZED {
		{
			p.SetState(4529)
			p.Match(OBParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4532)
		p.Match(OBParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4533)
		p.View_name()
	}
	p.SetState(4538)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserLeftParen {
		{
			p.SetState(4534)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4535)
			p.Column_list()
		}
		{
			p.SetState(4536)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4543)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserTABLE_ID {
		{
			p.SetState(4540)
			p.Match(OBParserTABLE_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4541)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4542)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4545)
		p.Match(OBParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4546)
		p.View_select_stmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IView_select_stmtContext is an interface to support dynamic dispatch.
type IView_select_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_stmt() ISelect_stmtContext

	// IsView_select_stmtContext differentiates from other interfaces.
	IsView_select_stmtContext()
}

type View_select_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_select_stmtContext() *View_select_stmtContext {
	var p = new(View_select_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_view_select_stmt
	return p
}

func InitEmptyView_select_stmtContext(p *View_select_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_view_select_stmt
}

func (*View_select_stmtContext) IsView_select_stmtContext() {}

func NewView_select_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_select_stmtContext {
	var p = new(View_select_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_view_select_stmt

	return p
}

func (s *View_select_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *View_select_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *View_select_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_select_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_select_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterView_select_stmt(s)
	}
}

func (s *View_select_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitView_select_stmt(s)
	}
}

func (s *View_select_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitView_select_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) View_select_stmt() (localctx IView_select_stmtContext) {
	localctx = NewView_select_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, OBParserRULE_view_select_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4548)
		p.Select_stmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IView_nameContext is an interface to support dynamic dispatch.
type IView_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Relation_factor() IRelation_factorContext

	// IsView_nameContext differentiates from other interfaces.
	IsView_nameContext()
}

type View_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyView_nameContext() *View_nameContext {
	var p = new(View_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_view_name
	return p
}

func InitEmptyView_nameContext(p *View_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_view_name
}

func (*View_nameContext) IsView_nameContext() {}

func NewView_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *View_nameContext {
	var p = new(View_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_view_name

	return p
}

func (s *View_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *View_nameContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *View_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *View_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *View_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterView_name(s)
	}
}

func (s *View_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitView_name(s)
	}
}

func (s *View_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitView_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) View_name() (localctx IView_nameContext) {
	localctx = NewView_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, OBParserRULE_view_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4550)
		p.Relation_factor()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_index_stmtContext is an interface to support dynamic dispatch.
type ICreate_index_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Normal_relation_factor() INormal_relation_factorContext
	ON() antlr.TerminalNode
	Relation_factor() IRelation_factorContext
	LeftParen() antlr.TerminalNode
	Sort_column_list() ISort_column_listContext
	RightParen() antlr.TerminalNode
	Opt_partition_option() IOpt_partition_optionContext
	IF() antlr.TerminalNode
	Not() INotContext
	EXISTS() antlr.TerminalNode
	Index_using_algorithm() IIndex_using_algorithmContext
	Opt_index_options() IOpt_index_optionsContext
	FULLTEXT() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode

	// IsCreate_index_stmtContext differentiates from other interfaces.
	IsCreate_index_stmtContext()
}

type Create_index_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_index_stmtContext() *Create_index_stmtContext {
	var p = new(Create_index_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_index_stmt
	return p
}

func InitEmptyCreate_index_stmtContext(p *Create_index_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_index_stmt
}

func (*Create_index_stmtContext) IsCreate_index_stmtContext() {}

func NewCreate_index_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_index_stmtContext {
	var p = new(Create_index_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_create_index_stmt

	return p
}

func (s *Create_index_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_index_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE, 0)
}

func (s *Create_index_stmtContext) INDEX() antlr.TerminalNode {
	return s.GetToken(OBParserINDEX, 0)
}

func (s *Create_index_stmtContext) Normal_relation_factor() INormal_relation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INormal_relation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INormal_relation_factorContext)
}

func (s *Create_index_stmtContext) ON() antlr.TerminalNode {
	return s.GetToken(OBParserON, 0)
}

func (s *Create_index_stmtContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Create_index_stmtContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Create_index_stmtContext) Sort_column_list() ISort_column_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISort_column_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISort_column_listContext)
}

func (s *Create_index_stmtContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Create_index_stmtContext) Opt_partition_option() IOpt_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_partition_optionContext)
}

func (s *Create_index_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Create_index_stmtContext) Not() INotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotContext)
}

func (s *Create_index_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Create_index_stmtContext) Index_using_algorithm() IIndex_using_algorithmContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_using_algorithmContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_using_algorithmContext)
}

func (s *Create_index_stmtContext) Opt_index_options() IOpt_index_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_index_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_index_optionsContext)
}

func (s *Create_index_stmtContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(OBParserFULLTEXT, 0)
}

func (s *Create_index_stmtContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(OBParserUNIQUE, 0)
}

func (s *Create_index_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_index_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_index_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCreate_index_stmt(s)
	}
}

func (s *Create_index_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCreate_index_stmt(s)
	}
}

func (s *Create_index_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCreate_index_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Create_index_stmt() (localctx ICreate_index_stmtContext) {
	localctx = NewCreate_index_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, OBParserRULE_create_index_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4552)
		p.Match(OBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserFULLTEXT || _la == OBParserUNIQUE {
		{
			p.SetState(4553)
			_la = p.GetTokenStream().LA(1)

			if !(_la == OBParserFULLTEXT || _la == OBParserUNIQUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4556)
		p.Match(OBParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserIF {
		{
			p.SetState(4557)
			p.Match(OBParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4558)
			p.Not()
		}
		{
			p.SetState(4559)
			p.Match(OBParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4563)
		p.Normal_relation_factor()
	}
	p.SetState(4565)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserUSING {
		{
			p.SetState(4564)
			p.Index_using_algorithm()
		}

	}
	{
		p.SetState(4567)
		p.Match(OBParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4568)
		p.Relation_factor()
	}
	{
		p.SetState(4569)
		p.Match(OBParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4570)
		p.Sort_column_list()
	}
	{
		p.SetState(4571)
		p.Match(OBParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserWITH_ROWID || _la == OBParserLOCAL || _la == OBParserUSING || _la == OBParserWITH || _la == OBParserCOMMENT || ((int64((_la-492)) & ^0x3f) == 0 && ((int64(1)<<(_la-492))&70514773196833) != 0) || _la == OBParserBLOCK_SIZE || _la == OBParserINDEX_TABLE_ID || _la == OBParserVIRTUAL_COLUMN_ID || _la == OBParserSTORING {
		{
			p.SetState(4572)
			p.Opt_index_options()
		}

	}
	{
		p.SetState(4575)
		p.Opt_partition_option()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_nameContext is an interface to support dynamic dispatch.
type IIndex_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Relation_name() IRelation_nameContext

	// IsIndex_nameContext differentiates from other interfaces.
	IsIndex_nameContext()
}

type Index_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_nameContext() *Index_nameContext {
	var p = new(Index_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_name
	return p
}

func InitEmptyIndex_nameContext(p *Index_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_name
}

func (*Index_nameContext) IsIndex_nameContext() {}

func NewIndex_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_nameContext {
	var p = new(Index_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_index_name

	return p
}

func (s *Index_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_nameContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Index_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterIndex_name(s)
	}
}

func (s *Index_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitIndex_name(s)
	}
}

func (s *Index_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitIndex_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Index_name() (localctx IIndex_nameContext) {
	localctx = NewIndex_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, OBParserRULE_index_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4577)
		p.Relation_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_constraint_nameContext is an interface to support dynamic dispatch.
type IOpt_constraint_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constraint_name() IConstraint_nameContext

	// IsOpt_constraint_nameContext differentiates from other interfaces.
	IsOpt_constraint_nameContext()
}

type Opt_constraint_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_constraint_nameContext() *Opt_constraint_nameContext {
	var p = new(Opt_constraint_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_constraint_name
	return p
}

func InitEmptyOpt_constraint_nameContext(p *Opt_constraint_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_constraint_name
}

func (*Opt_constraint_nameContext) IsOpt_constraint_nameContext() {}

func NewOpt_constraint_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_constraint_nameContext {
	var p = new(Opt_constraint_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_constraint_name

	return p
}

func (s *Opt_constraint_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_constraint_nameContext) Constraint_name() IConstraint_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraint_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraint_nameContext)
}

func (s *Opt_constraint_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_constraint_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_constraint_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_constraint_name(s)
	}
}

func (s *Opt_constraint_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_constraint_name(s)
	}
}

func (s *Opt_constraint_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_constraint_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_constraint_name() (localctx IOpt_constraint_nameContext) {
	localctx = NewOpt_constraint_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, OBParserRULE_opt_constraint_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&140737496744065) != 0) || ((int64((_la-92)) & ^0x3f) == 0 && ((int64(1)<<(_la-92))&288230513726980097) != 0) || ((int64((_la-163)) & ^0x3f) == 0 && ((int64(1)<<(_la-163))&11821949038624769) != 0) || ((int64((_la-250)) & ^0x3f) == 0 && ((int64(1)<<(_la-250))&-4629700416945258495) != 0) || ((int64((_la-314)) & ^0x3f) == 0 && ((int64(1)<<(_la-314))&-587737344112594961) != 0) || ((int64((_la-378)) & ^0x3f) == 0 && ((int64(1)<<(_la-378))&-603552873430712321) != 0) || ((int64((_la-442)) & ^0x3f) == 0 && ((int64(1)<<(_la-442))&-2305913515397021697) != 0) || ((int64((_la-506)) & ^0x3f) == 0 && ((int64(1)<<(_la-506))&8070450531845275647) != 0) || ((int64((_la-570)) & ^0x3f) == 0 && ((int64(1)<<(_la-570))&-18159534061387777) != 0) || ((int64((_la-634)) & ^0x3f) == 0 && ((int64(1)<<(_la-634))&-18146237874177) != 0) || ((int64((_la-698)) & ^0x3f) == 0 && ((int64(1)<<(_la-698))&-2533274790395907) != 0) || ((int64((_la-762)) & ^0x3f) == 0 && ((int64(1)<<(_la-762))&-1157425104234217473) != 0) || ((int64((_la-826)) & ^0x3f) == 0 && ((int64(1)<<(_la-826))&137342196111112175) != 0) || _la == OBParserNAME_OB || _la == OBParserSTAT {
		{
			p.SetState(4579)
			p.Constraint_name()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraint_nameContext is an interface to support dynamic dispatch.
type IConstraint_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Relation_name() IRelation_nameContext

	// IsConstraint_nameContext differentiates from other interfaces.
	IsConstraint_nameContext()
}

type Constraint_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraint_nameContext() *Constraint_nameContext {
	var p = new(Constraint_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_constraint_name
	return p
}

func InitEmptyConstraint_nameContext(p *Constraint_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_constraint_name
}

func (*Constraint_nameContext) IsConstraint_nameContext() {}

func NewConstraint_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constraint_nameContext {
	var p = new(Constraint_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_constraint_name

	return p
}

func (s *Constraint_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Constraint_nameContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Constraint_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constraint_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constraint_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterConstraint_name(s)
	}
}

func (s *Constraint_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitConstraint_name(s)
	}
}

func (s *Constraint_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitConstraint_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Constraint_name() (localctx IConstraint_nameContext) {
	localctx = NewConstraint_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, OBParserRULE_constraint_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4582)
		p.Relation_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISort_column_listContext is an interface to support dynamic dispatch.
type ISort_column_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSort_column_key() []ISort_column_keyContext
	Sort_column_key(i int) ISort_column_keyContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsSort_column_listContext differentiates from other interfaces.
	IsSort_column_listContext()
}

type Sort_column_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySort_column_listContext() *Sort_column_listContext {
	var p = new(Sort_column_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sort_column_list
	return p
}

func InitEmptySort_column_listContext(p *Sort_column_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sort_column_list
}

func (*Sort_column_listContext) IsSort_column_listContext() {}

func NewSort_column_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sort_column_listContext {
	var p = new(Sort_column_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_sort_column_list

	return p
}

func (s *Sort_column_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Sort_column_listContext) AllSort_column_key() []ISort_column_keyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISort_column_keyContext); ok {
			len++
		}
	}

	tst := make([]ISort_column_keyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISort_column_keyContext); ok {
			tst[i] = t.(ISort_column_keyContext)
			i++
		}
	}

	return tst
}

func (s *Sort_column_listContext) Sort_column_key(i int) ISort_column_keyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISort_column_keyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISort_column_keyContext)
}

func (s *Sort_column_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Sort_column_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Sort_column_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sort_column_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sort_column_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSort_column_list(s)
	}
}

func (s *Sort_column_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSort_column_list(s)
	}
}

func (s *Sort_column_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSort_column_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Sort_column_list() (localctx ISort_column_listContext) {
	localctx = NewSort_column_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, OBParserRULE_sort_column_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4584)
		p.Sort_column_key()
	}
	p.SetState(4589)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(4585)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4586)
			p.Sort_column_key()
		}

		p.SetState(4591)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISort_column_keyContext is an interface to support dynamic dispatch.
type ISort_column_keyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_name() IColumn_nameContext
	LeftParen() antlr.TerminalNode
	AllINTNUM() []antlr.TerminalNode
	INTNUM(i int) antlr.TerminalNode
	RightParen() antlr.TerminalNode
	ID() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsSort_column_keyContext differentiates from other interfaces.
	IsSort_column_keyContext()
}

type Sort_column_keyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySort_column_keyContext() *Sort_column_keyContext {
	var p = new(Sort_column_keyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sort_column_key
	return p
}

func InitEmptySort_column_keyContext(p *Sort_column_keyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sort_column_key
}

func (*Sort_column_keyContext) IsSort_column_keyContext() {}

func NewSort_column_keyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sort_column_keyContext {
	var p = new(Sort_column_keyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_sort_column_key

	return p
}

func (s *Sort_column_keyContext) GetParser() antlr.Parser { return s.parser }

func (s *Sort_column_keyContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Sort_column_keyContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Sort_column_keyContext) AllINTNUM() []antlr.TerminalNode {
	return s.GetTokens(OBParserINTNUM)
}

func (s *Sort_column_keyContext) INTNUM(i int) antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, i)
}

func (s *Sort_column_keyContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Sort_column_keyContext) ID() antlr.TerminalNode {
	return s.GetToken(OBParserID, 0)
}

func (s *Sort_column_keyContext) ASC() antlr.TerminalNode {
	return s.GetToken(OBParserASC, 0)
}

func (s *Sort_column_keyContext) DESC() antlr.TerminalNode {
	return s.GetToken(OBParserDESC, 0)
}

func (s *Sort_column_keyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sort_column_keyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sort_column_keyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSort_column_key(s)
	}
}

func (s *Sort_column_keyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSort_column_key(s)
	}
}

func (s *Sort_column_keyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSort_column_key(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Sort_column_key() (localctx ISort_column_keyContext) {
	localctx = NewSort_column_keyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, OBParserRULE_sort_column_key)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4592)
		p.Column_name()
	}
	p.SetState(4596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserLeftParen {
		{
			p.SetState(4593)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4594)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4595)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4599)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserASC || _la == OBParserDESC {
		{
			p.SetState(4598)
			_la = p.GetTokenStream().LA(1)

			if !(_la == OBParserASC || _la == OBParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(4603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserID {
		{
			p.SetState(4601)
			p.Match(OBParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4602)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_index_optionsContext is an interface to support dynamic dispatch.
type IOpt_index_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIndex_option() []IIndex_optionContext
	Index_option(i int) IIndex_optionContext

	// IsOpt_index_optionsContext differentiates from other interfaces.
	IsOpt_index_optionsContext()
}

type Opt_index_optionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_index_optionsContext() *Opt_index_optionsContext {
	var p = new(Opt_index_optionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_index_options
	return p
}

func InitEmptyOpt_index_optionsContext(p *Opt_index_optionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_index_options
}

func (*Opt_index_optionsContext) IsOpt_index_optionsContext() {}

func NewOpt_index_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_index_optionsContext {
	var p = new(Opt_index_optionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_index_options

	return p
}

func (s *Opt_index_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_index_optionsContext) AllIndex_option() []IIndex_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndex_optionContext); ok {
			len++
		}
	}

	tst := make([]IIndex_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndex_optionContext); ok {
			tst[i] = t.(IIndex_optionContext)
			i++
		}
	}

	return tst
}

func (s *Opt_index_optionsContext) Index_option(i int) IIndex_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_optionContext)
}

func (s *Opt_index_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_index_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_index_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_index_options(s)
	}
}

func (s *Opt_index_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_index_options(s)
	}
}

func (s *Opt_index_optionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_index_options(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_index_options() (localctx IOpt_index_optionsContext) {
	localctx = NewOpt_index_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, OBParserRULE_opt_index_options)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4605)
				p.Index_option()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4608)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 434, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_optionContext is an interface to support dynamic dispatch.
type IIndex_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	BLOCK_SIZE() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	STORING() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Column_name_list() IColumn_name_listContext
	RightParen() antlr.TerminalNode
	CTXCAT() antlr.TerminalNode
	WITH_ROWID() antlr.TerminalNode
	WITH() antlr.TerminalNode
	PARSER() antlr.TerminalNode
	Index_using_algorithm() IIndex_using_algorithmContext
	Visibility_option() IVisibility_optionContext
	DATA_TABLE_ID() antlr.TerminalNode
	INDEX_TABLE_ID() antlr.TerminalNode
	VIRTUAL_COLUMN_ID() antlr.TerminalNode
	MAX_USED_PART_ID() antlr.TerminalNode

	// IsIndex_optionContext differentiates from other interfaces.
	IsIndex_optionContext()
}

type Index_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_optionContext() *Index_optionContext {
	var p = new(Index_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_option
	return p
}

func InitEmptyIndex_optionContext(p *Index_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_option
}

func (*Index_optionContext) IsIndex_optionContext() {}

func NewIndex_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_optionContext {
	var p = new(Index_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_index_option

	return p
}

func (s *Index_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_optionContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(OBParserGLOBAL, 0)
}

func (s *Index_optionContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(OBParserLOCAL, 0)
}

func (s *Index_optionContext) BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserBLOCK_SIZE, 0)
}

func (s *Index_optionContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Index_optionContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Index_optionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(OBParserCOMMENT, 0)
}

func (s *Index_optionContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Index_optionContext) STORING() antlr.TerminalNode {
	return s.GetToken(OBParserSTORING, 0)
}

func (s *Index_optionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Index_optionContext) Column_name_list() IColumn_name_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_name_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_name_listContext)
}

func (s *Index_optionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Index_optionContext) CTXCAT() antlr.TerminalNode {
	return s.GetToken(OBParserCTXCAT, 0)
}

func (s *Index_optionContext) WITH_ROWID() antlr.TerminalNode {
	return s.GetToken(OBParserWITH_ROWID, 0)
}

func (s *Index_optionContext) WITH() antlr.TerminalNode {
	return s.GetToken(OBParserWITH, 0)
}

func (s *Index_optionContext) PARSER() antlr.TerminalNode {
	return s.GetToken(OBParserPARSER, 0)
}

func (s *Index_optionContext) Index_using_algorithm() IIndex_using_algorithmContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_using_algorithmContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_using_algorithmContext)
}

func (s *Index_optionContext) Visibility_option() IVisibility_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibility_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibility_optionContext)
}

func (s *Index_optionContext) DATA_TABLE_ID() antlr.TerminalNode {
	return s.GetToken(OBParserDATA_TABLE_ID, 0)
}

func (s *Index_optionContext) INDEX_TABLE_ID() antlr.TerminalNode {
	return s.GetToken(OBParserINDEX_TABLE_ID, 0)
}

func (s *Index_optionContext) VIRTUAL_COLUMN_ID() antlr.TerminalNode {
	return s.GetToken(OBParserVIRTUAL_COLUMN_ID, 0)
}

func (s *Index_optionContext) MAX_USED_PART_ID() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_USED_PART_ID, 0)
}

func (s *Index_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterIndex_option(s)
	}
}

func (s *Index_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitIndex_option(s)
	}
}

func (s *Index_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitIndex_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Index_option() (localctx IIndex_optionContext) {
	localctx = NewIndex_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, OBParserRULE_index_option)
	var _la int

	p.SetState(4655)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserGLOBAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4610)
			p.Match(OBParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserLOCAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4611)
			p.Match(OBParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserBLOCK_SIZE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4612)
			p.Match(OBParserBLOCK_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4614)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(4613)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4616)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserCOMMENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4617)
			p.Match(OBParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4618)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserSTORING:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4619)
			p.Match(OBParserSTORING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4620)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4621)
			p.Column_name_list()
		}
		{
			p.SetState(4622)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserCTXCAT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4624)
			p.Match(OBParserCTXCAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4625)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4626)
			p.Column_name_list()
		}
		{
			p.SetState(4627)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserWITH_ROWID:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4629)
			p.Match(OBParserWITH_ROWID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserWITH:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4630)
			p.Match(OBParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4631)
			p.Match(OBParserPARSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4632)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserUSING:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4633)
			p.Index_using_algorithm()
		}

	case OBParserVISIBLE, OBParserINVISIBLE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4634)
			p.Visibility_option()
		}

	case OBParserDATA_TABLE_ID:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4635)
			p.Match(OBParserDATA_TABLE_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4637)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(4636)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4639)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserINDEX_TABLE_ID:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4640)
			p.Match(OBParserINDEX_TABLE_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(4641)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4644)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserVIRTUAL_COLUMN_ID:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(4645)
			p.Match(OBParserVIRTUAL_COLUMN_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4647)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(4646)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4649)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserMAX_USED_PART_ID:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(4650)
			p.Match(OBParserMAX_USED_PART_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4652)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(4651)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4654)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_using_algorithmContext is an interface to support dynamic dispatch.
type IIndex_using_algorithmContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING() antlr.TerminalNode
	BTREE() antlr.TerminalNode
	HASH() antlr.TerminalNode

	// IsIndex_using_algorithmContext differentiates from other interfaces.
	IsIndex_using_algorithmContext()
}

type Index_using_algorithmContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_using_algorithmContext() *Index_using_algorithmContext {
	var p = new(Index_using_algorithmContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_using_algorithm
	return p
}

func InitEmptyIndex_using_algorithmContext(p *Index_using_algorithmContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_using_algorithm
}

func (*Index_using_algorithmContext) IsIndex_using_algorithmContext() {}

func NewIndex_using_algorithmContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_using_algorithmContext {
	var p = new(Index_using_algorithmContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_index_using_algorithm

	return p
}

func (s *Index_using_algorithmContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_using_algorithmContext) USING() antlr.TerminalNode {
	return s.GetToken(OBParserUSING, 0)
}

func (s *Index_using_algorithmContext) BTREE() antlr.TerminalNode {
	return s.GetToken(OBParserBTREE, 0)
}

func (s *Index_using_algorithmContext) HASH() antlr.TerminalNode {
	return s.GetToken(OBParserHASH, 0)
}

func (s *Index_using_algorithmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_using_algorithmContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_using_algorithmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterIndex_using_algorithm(s)
	}
}

func (s *Index_using_algorithmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitIndex_using_algorithm(s)
	}
}

func (s *Index_using_algorithmContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitIndex_using_algorithm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Index_using_algorithm() (localctx IIndex_using_algorithmContext) {
	localctx = NewIndex_using_algorithmContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, OBParserRULE_index_using_algorithm)
	p.SetState(4661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 441, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4657)
			p.Match(OBParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4658)
			p.Match(OBParserBTREE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4659)
			p.Match(OBParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4660)
			p.Match(OBParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_table_stmtContext is an interface to support dynamic dispatch.
type IDrop_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	Table_or_tables() ITable_or_tablesContext
	Table_list() ITable_listContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	RESTRICT() antlr.TerminalNode

	// IsDrop_table_stmtContext differentiates from other interfaces.
	IsDrop_table_stmtContext()
}

type Drop_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_table_stmtContext() *Drop_table_stmtContext {
	var p = new(Drop_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_table_stmt
	return p
}

func InitEmptyDrop_table_stmtContext(p *Drop_table_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_table_stmt
}

func (*Drop_table_stmtContext) IsDrop_table_stmtContext() {}

func NewDrop_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_table_stmtContext {
	var p = new(Drop_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_drop_table_stmt

	return p
}

func (s *Drop_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_table_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Drop_table_stmtContext) Table_or_tables() ITable_or_tablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_or_tablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_or_tablesContext)
}

func (s *Drop_table_stmtContext) Table_list() ITable_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_listContext)
}

func (s *Drop_table_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Drop_table_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Drop_table_stmtContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(OBParserTEMPORARY, 0)
}

func (s *Drop_table_stmtContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(OBParserMATERIALIZED, 0)
}

func (s *Drop_table_stmtContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(OBParserCASCADE, 0)
}

func (s *Drop_table_stmtContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(OBParserRESTRICT, 0)
}

func (s *Drop_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDrop_table_stmt(s)
	}
}

func (s *Drop_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDrop_table_stmt(s)
	}
}

func (s *Drop_table_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDrop_table_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Drop_table_stmt() (localctx IDrop_table_stmtContext) {
	localctx = NewDrop_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, OBParserRULE_drop_table_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4663)
		p.Match(OBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4665)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserTEMPORARY || _la == OBParserMATERIALIZED {
		{
			p.SetState(4664)
			_la = p.GetTokenStream().LA(1)

			if !(_la == OBParserTEMPORARY || _la == OBParserMATERIALIZED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4667)
		p.Table_or_tables()
	}
	p.SetState(4670)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserIF {
		{
			p.SetState(4668)
			p.Match(OBParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4669)
			p.Match(OBParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4672)
		p.Table_list()
	}
	p.SetState(4674)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCASCADE || _la == OBParserRESTRICT {
		{
			p.SetState(4673)
			_la = p.GetTokenStream().LA(1)

			if !(_la == OBParserCASCADE || _la == OBParserRESTRICT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_or_tablesContext is an interface to support dynamic dispatch.
type ITable_or_tablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode

	// IsTable_or_tablesContext differentiates from other interfaces.
	IsTable_or_tablesContext()
}

type Table_or_tablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_or_tablesContext() *Table_or_tablesContext {
	var p = new(Table_or_tablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_or_tables
	return p
}

func InitEmptyTable_or_tablesContext(p *Table_or_tablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_or_tables
}

func (*Table_or_tablesContext) IsTable_or_tablesContext() {}

func NewTable_or_tablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_or_tablesContext {
	var p = new(Table_or_tablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_table_or_tables

	return p
}

func (s *Table_or_tablesContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_or_tablesContext) TABLE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE, 0)
}

func (s *Table_or_tablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(OBParserTABLES, 0)
}

func (s *Table_or_tablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_or_tablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_or_tablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTable_or_tables(s)
	}
}

func (s *Table_or_tablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTable_or_tables(s)
	}
}

func (s *Table_or_tablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTable_or_tables(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Table_or_tables() (localctx ITable_or_tablesContext) {
	localctx = NewTable_or_tablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, OBParserRULE_table_or_tables)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4676)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserTABLE || _la == OBParserTABLES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_view_stmtContext is an interface to support dynamic dispatch.
type IDrop_view_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	Table_list() ITable_listContext
	MATERIALIZED() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	RESTRICT() antlr.TerminalNode

	// IsDrop_view_stmtContext differentiates from other interfaces.
	IsDrop_view_stmtContext()
}

type Drop_view_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_view_stmtContext() *Drop_view_stmtContext {
	var p = new(Drop_view_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_view_stmt
	return p
}

func InitEmptyDrop_view_stmtContext(p *Drop_view_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_view_stmt
}

func (*Drop_view_stmtContext) IsDrop_view_stmtContext() {}

func NewDrop_view_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_view_stmtContext {
	var p = new(Drop_view_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_drop_view_stmt

	return p
}

func (s *Drop_view_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_view_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Drop_view_stmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(OBParserVIEW, 0)
}

func (s *Drop_view_stmtContext) Table_list() ITable_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_listContext)
}

func (s *Drop_view_stmtContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(OBParserMATERIALIZED, 0)
}

func (s *Drop_view_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Drop_view_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Drop_view_stmtContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(OBParserCASCADE, 0)
}

func (s *Drop_view_stmtContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(OBParserRESTRICT, 0)
}

func (s *Drop_view_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_view_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_view_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDrop_view_stmt(s)
	}
}

func (s *Drop_view_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDrop_view_stmt(s)
	}
}

func (s *Drop_view_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDrop_view_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Drop_view_stmt() (localctx IDrop_view_stmtContext) {
	localctx = NewDrop_view_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, OBParserRULE_drop_view_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4678)
		p.Match(OBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserMATERIALIZED {
		{
			p.SetState(4679)
			p.Match(OBParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4682)
		p.Match(OBParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserIF {
		{
			p.SetState(4683)
			p.Match(OBParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4684)
			p.Match(OBParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4687)
		p.Table_list()
	}
	p.SetState(4689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCASCADE || _la == OBParserRESTRICT {
		{
			p.SetState(4688)
			_la = p.GetTokenStream().LA(1)

			if !(_la == OBParserCASCADE || _la == OBParserRESTRICT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_listContext is an interface to support dynamic dispatch.
type ITable_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelation_factor() []IRelation_factorContext
	Relation_factor(i int) IRelation_factorContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsTable_listContext differentiates from other interfaces.
	IsTable_listContext()
}

type Table_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_listContext() *Table_listContext {
	var p = new(Table_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_list
	return p
}

func InitEmptyTable_listContext(p *Table_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_list
}

func (*Table_listContext) IsTable_listContext() {}

func NewTable_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_listContext {
	var p = new(Table_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_table_list

	return p
}

func (s *Table_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_listContext) AllRelation_factor() []IRelation_factorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_factorContext); ok {
			len++
		}
	}

	tst := make([]IRelation_factorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_factorContext); ok {
			tst[i] = t.(IRelation_factorContext)
			i++
		}
	}

	return tst
}

func (s *Table_listContext) Relation_factor(i int) IRelation_factorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Table_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Table_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Table_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTable_list(s)
	}
}

func (s *Table_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTable_list(s)
	}
}

func (s *Table_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTable_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Table_list() (localctx ITable_listContext) {
	localctx = NewTable_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, OBParserRULE_table_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4691)
		p.Relation_factor()
	}
	p.SetState(4696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(4692)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4693)
			p.Relation_factor()
		}

		p.SetState(4698)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_index_stmtContext is an interface to support dynamic dispatch.
type IDrop_index_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Relation_name() IRelation_nameContext
	ON() antlr.TerminalNode
	Relation_factor() IRelation_factorContext

	// IsDrop_index_stmtContext differentiates from other interfaces.
	IsDrop_index_stmtContext()
}

type Drop_index_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_index_stmtContext() *Drop_index_stmtContext {
	var p = new(Drop_index_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_index_stmt
	return p
}

func InitEmptyDrop_index_stmtContext(p *Drop_index_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_index_stmt
}

func (*Drop_index_stmtContext) IsDrop_index_stmtContext() {}

func NewDrop_index_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_index_stmtContext {
	var p = new(Drop_index_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_drop_index_stmt

	return p
}

func (s *Drop_index_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_index_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Drop_index_stmtContext) INDEX() antlr.TerminalNode {
	return s.GetToken(OBParserINDEX, 0)
}

func (s *Drop_index_stmtContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Drop_index_stmtContext) ON() antlr.TerminalNode {
	return s.GetToken(OBParserON, 0)
}

func (s *Drop_index_stmtContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Drop_index_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_index_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_index_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDrop_index_stmt(s)
	}
}

func (s *Drop_index_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDrop_index_stmt(s)
	}
}

func (s *Drop_index_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDrop_index_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Drop_index_stmt() (localctx IDrop_index_stmtContext) {
	localctx = NewDrop_index_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, OBParserRULE_drop_index_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4699)
		p.Match(OBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4700)
		p.Match(OBParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4701)
		p.Relation_name()
	}
	{
		p.SetState(4702)
		p.Match(OBParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4703)
		p.Relation_factor()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsert_stmtContext is an interface to support dynamic dispatch.
type IInsert_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Insert_with_opt_hint() IInsert_with_opt_hintContext
	Single_table_insert() ISingle_table_insertContext
	IGNORE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	ON() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	Update_asgn_list() IUpdate_asgn_listContext
	Replace_with_opt_hint() IReplace_with_opt_hintContext

	// IsInsert_stmtContext differentiates from other interfaces.
	IsInsert_stmtContext()
}

type Insert_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_stmtContext() *Insert_stmtContext {
	var p = new(Insert_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_insert_stmt
	return p
}

func InitEmptyInsert_stmtContext(p *Insert_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_insert_stmt
}

func (*Insert_stmtContext) IsInsert_stmtContext() {}

func NewInsert_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_stmtContext {
	var p = new(Insert_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_insert_stmt

	return p
}

func (s *Insert_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_stmtContext) Insert_with_opt_hint() IInsert_with_opt_hintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_with_opt_hintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_with_opt_hintContext)
}

func (s *Insert_stmtContext) Single_table_insert() ISingle_table_insertContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_table_insertContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_table_insertContext)
}

func (s *Insert_stmtContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(OBParserIGNORE, 0)
}

func (s *Insert_stmtContext) INTO() antlr.TerminalNode {
	return s.GetToken(OBParserINTO, 0)
}

func (s *Insert_stmtContext) ON() antlr.TerminalNode {
	return s.GetToken(OBParserON, 0)
}

func (s *Insert_stmtContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(OBParserDUPLICATE, 0)
}

func (s *Insert_stmtContext) KEY() antlr.TerminalNode {
	return s.GetToken(OBParserKEY, 0)
}

func (s *Insert_stmtContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(OBParserUPDATE, 0)
}

func (s *Insert_stmtContext) Update_asgn_list() IUpdate_asgn_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_asgn_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_asgn_listContext)
}

func (s *Insert_stmtContext) Replace_with_opt_hint() IReplace_with_opt_hintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplace_with_opt_hintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplace_with_opt_hintContext)
}

func (s *Insert_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterInsert_stmt(s)
	}
}

func (s *Insert_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitInsert_stmt(s)
	}
}

func (s *Insert_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitInsert_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Insert_stmt() (localctx IInsert_stmtContext) {
	localctx = NewInsert_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, OBParserRULE_insert_stmt)
	var _la int

	p.SetState(4729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserINSERT, OBParserINSERT_HINT_BEGIN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4705)
			p.Insert_with_opt_hint()
		}
		p.SetState(4707)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIGNORE {
			{
				p.SetState(4706)
				p.Match(OBParserIGNORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(4710)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserINTO {
			{
				p.SetState(4709)
				p.Match(OBParserINTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4712)
			p.Single_table_insert()
		}
		p.SetState(4718)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserON {
			{
				p.SetState(4713)
				p.Match(OBParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4714)
				p.Match(OBParserDUPLICATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4715)
				p.Match(OBParserKEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4716)
				p.Match(OBParserUPDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4717)
				p.Update_asgn_list()
			}

		}

	case OBParserREPLACE, OBParserREPLACE_HINT_BEGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4720)
			p.Replace_with_opt_hint()
		}
		p.SetState(4722)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIGNORE {
			{
				p.SetState(4721)
				p.Match(OBParserIGNORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(4725)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserINTO {
			{
				p.SetState(4724)
				p.Match(OBParserINTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4727)
			p.Single_table_insert()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingle_table_insertContext is an interface to support dynamic dispatch.
type ISingle_table_insertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Dml_table_name() IDml_table_nameContext
	Values_clause() IValues_clauseContext
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	Column_list() IColumn_listContext
	SET() antlr.TerminalNode
	Update_asgn_list() IUpdate_asgn_listContext

	// IsSingle_table_insertContext differentiates from other interfaces.
	IsSingle_table_insertContext()
}

type Single_table_insertContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_table_insertContext() *Single_table_insertContext {
	var p = new(Single_table_insertContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_single_table_insert
	return p
}

func InitEmptySingle_table_insertContext(p *Single_table_insertContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_single_table_insert
}

func (*Single_table_insertContext) IsSingle_table_insertContext() {}

func NewSingle_table_insertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_table_insertContext {
	var p = new(Single_table_insertContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_single_table_insert

	return p
}

func (s *Single_table_insertContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_table_insertContext) Dml_table_name() IDml_table_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDml_table_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDml_table_nameContext)
}

func (s *Single_table_insertContext) Values_clause() IValues_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_clauseContext)
}

func (s *Single_table_insertContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Single_table_insertContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Single_table_insertContext) Column_list() IColumn_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_listContext)
}

func (s *Single_table_insertContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Single_table_insertContext) Update_asgn_list() IUpdate_asgn_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_asgn_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_asgn_listContext)
}

func (s *Single_table_insertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_table_insertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_table_insertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSingle_table_insert(s)
	}
}

func (s *Single_table_insertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSingle_table_insert(s)
	}
}

func (s *Single_table_insertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSingle_table_insert(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Single_table_insert() (localctx ISingle_table_insertContext) {
	localctx = NewSingle_table_insertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, OBParserRULE_single_table_insert)
	p.SetState(4749)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 455, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4731)
			p.Dml_table_name()
		}
		{
			p.SetState(4732)
			p.Values_clause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4734)
			p.Dml_table_name()
		}
		{
			p.SetState(4735)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4736)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4737)
			p.Values_clause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4739)
			p.Dml_table_name()
		}
		{
			p.SetState(4740)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4741)
			p.Column_list()
		}
		{
			p.SetState(4742)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4743)
			p.Values_clause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4745)
			p.Dml_table_name()
		}
		{
			p.SetState(4746)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4747)
			p.Update_asgn_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValues_clauseContext is an interface to support dynamic dispatch.
type IValues_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Value_or_values() IValue_or_valuesContext
	Insert_vals_list() IInsert_vals_listContext
	Select_stmt() ISelect_stmtContext

	// IsValues_clauseContext differentiates from other interfaces.
	IsValues_clauseContext()
}

type Values_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValues_clauseContext() *Values_clauseContext {
	var p = new(Values_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_values_clause
	return p
}

func InitEmptyValues_clauseContext(p *Values_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_values_clause
}

func (*Values_clauseContext) IsValues_clauseContext() {}

func NewValues_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Values_clauseContext {
	var p = new(Values_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_values_clause

	return p
}

func (s *Values_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Values_clauseContext) Value_or_values() IValue_or_valuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValue_or_valuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValue_or_valuesContext)
}

func (s *Values_clauseContext) Insert_vals_list() IInsert_vals_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_vals_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_vals_listContext)
}

func (s *Values_clauseContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Values_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Values_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Values_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterValues_clause(s)
	}
}

func (s *Values_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitValues_clause(s)
	}
}

func (s *Values_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitValues_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Values_clause() (localctx IValues_clauseContext) {
	localctx = NewValues_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, OBParserRULE_values_clause)
	p.SetState(4755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserVALUES, OBParserVALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4751)
			p.Value_or_values()
		}
		{
			p.SetState(4752)
			p.insert_vals_list(0)
		}

	case OBParserSELECT, OBParserLeftParen, OBParserSELECT_HINT_BEGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4754)
			p.Select_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValue_or_valuesContext is an interface to support dynamic dispatch.
type IValue_or_valuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUE() antlr.TerminalNode
	VALUES() antlr.TerminalNode

	// IsValue_or_valuesContext differentiates from other interfaces.
	IsValue_or_valuesContext()
}

type Value_or_valuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_or_valuesContext() *Value_or_valuesContext {
	var p = new(Value_or_valuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_value_or_values
	return p
}

func InitEmptyValue_or_valuesContext(p *Value_or_valuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_value_or_values
}

func (*Value_or_valuesContext) IsValue_or_valuesContext() {}

func NewValue_or_valuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_or_valuesContext {
	var p = new(Value_or_valuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_value_or_values

	return p
}

func (s *Value_or_valuesContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_or_valuesContext) VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserVALUE, 0)
}

func (s *Value_or_valuesContext) VALUES() antlr.TerminalNode {
	return s.GetToken(OBParserVALUES, 0)
}

func (s *Value_or_valuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_or_valuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_or_valuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterValue_or_values(s)
	}
}

func (s *Value_or_valuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitValue_or_values(s)
	}
}

func (s *Value_or_valuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitValue_or_values(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Value_or_values() (localctx IValue_or_valuesContext) {
	localctx = NewValue_or_valuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, OBParserRULE_value_or_values)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4757)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserVALUES || _la == OBParserVALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplace_with_opt_hintContext is an interface to support dynamic dispatch.
type IReplace_with_opt_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE() antlr.TerminalNode
	REPLACE_HINT_BEGIN() antlr.TerminalNode
	Hint_list_with_end() IHint_list_with_endContext

	// IsReplace_with_opt_hintContext differentiates from other interfaces.
	IsReplace_with_opt_hintContext()
}

type Replace_with_opt_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplace_with_opt_hintContext() *Replace_with_opt_hintContext {
	var p = new(Replace_with_opt_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_replace_with_opt_hint
	return p
}

func InitEmptyReplace_with_opt_hintContext(p *Replace_with_opt_hintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_replace_with_opt_hint
}

func (*Replace_with_opt_hintContext) IsReplace_with_opt_hintContext() {}

func NewReplace_with_opt_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Replace_with_opt_hintContext {
	var p = new(Replace_with_opt_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_replace_with_opt_hint

	return p
}

func (s *Replace_with_opt_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *Replace_with_opt_hintContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(OBParserREPLACE, 0)
}

func (s *Replace_with_opt_hintContext) REPLACE_HINT_BEGIN() antlr.TerminalNode {
	return s.GetToken(OBParserREPLACE_HINT_BEGIN, 0)
}

func (s *Replace_with_opt_hintContext) Hint_list_with_end() IHint_list_with_endContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHint_list_with_endContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHint_list_with_endContext)
}

func (s *Replace_with_opt_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Replace_with_opt_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Replace_with_opt_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterReplace_with_opt_hint(s)
	}
}

func (s *Replace_with_opt_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitReplace_with_opt_hint(s)
	}
}

func (s *Replace_with_opt_hintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitReplace_with_opt_hint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Replace_with_opt_hint() (localctx IReplace_with_opt_hintContext) {
	localctx = NewReplace_with_opt_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, OBParserRULE_replace_with_opt_hint)
	p.SetState(4762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserREPLACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4759)
			p.Match(OBParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserREPLACE_HINT_BEGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4760)
			p.Match(OBParserREPLACE_HINT_BEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4761)
			p.Hint_list_with_end()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsert_with_opt_hintContext is an interface to support dynamic dispatch.
type IInsert_with_opt_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSERT() antlr.TerminalNode
	INSERT_HINT_BEGIN() antlr.TerminalNode
	Hint_list_with_end() IHint_list_with_endContext

	// IsInsert_with_opt_hintContext differentiates from other interfaces.
	IsInsert_with_opt_hintContext()
}

type Insert_with_opt_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_with_opt_hintContext() *Insert_with_opt_hintContext {
	var p = new(Insert_with_opt_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_insert_with_opt_hint
	return p
}

func InitEmptyInsert_with_opt_hintContext(p *Insert_with_opt_hintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_insert_with_opt_hint
}

func (*Insert_with_opt_hintContext) IsInsert_with_opt_hintContext() {}

func NewInsert_with_opt_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_with_opt_hintContext {
	var p = new(Insert_with_opt_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_insert_with_opt_hint

	return p
}

func (s *Insert_with_opt_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_with_opt_hintContext) INSERT() antlr.TerminalNode {
	return s.GetToken(OBParserINSERT, 0)
}

func (s *Insert_with_opt_hintContext) INSERT_HINT_BEGIN() antlr.TerminalNode {
	return s.GetToken(OBParserINSERT_HINT_BEGIN, 0)
}

func (s *Insert_with_opt_hintContext) Hint_list_with_end() IHint_list_with_endContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHint_list_with_endContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHint_list_with_endContext)
}

func (s *Insert_with_opt_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_with_opt_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_with_opt_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterInsert_with_opt_hint(s)
	}
}

func (s *Insert_with_opt_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitInsert_with_opt_hint(s)
	}
}

func (s *Insert_with_opt_hintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitInsert_with_opt_hint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Insert_with_opt_hint() (localctx IInsert_with_opt_hintContext) {
	localctx = NewInsert_with_opt_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, OBParserRULE_insert_with_opt_hint)
	p.SetState(4767)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserINSERT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4764)
			p.Match(OBParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserINSERT_HINT_BEGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4765)
			p.Match(OBParserINSERT_HINT_BEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4766)
			p.Hint_list_with_end()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_listContext is an interface to support dynamic dispatch.
type IColumn_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumn_definition_ref() []IColumn_definition_refContext
	Column_definition_ref(i int) IColumn_definition_refContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsColumn_listContext differentiates from other interfaces.
	IsColumn_listContext()
}

type Column_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_listContext() *Column_listContext {
	var p = new(Column_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_list
	return p
}

func InitEmptyColumn_listContext(p *Column_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_list
}

func (*Column_listContext) IsColumn_listContext() {}

func NewColumn_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_listContext {
	var p = new(Column_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_column_list

	return p
}

func (s *Column_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_listContext) AllColumn_definition_ref() []IColumn_definition_refContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_definition_refContext); ok {
			len++
		}
	}

	tst := make([]IColumn_definition_refContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_definition_refContext); ok {
			tst[i] = t.(IColumn_definition_refContext)
			i++
		}
	}

	return tst
}

func (s *Column_listContext) Column_definition_ref(i int) IColumn_definition_refContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_definition_refContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_definition_refContext)
}

func (s *Column_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Column_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Column_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterColumn_list(s)
	}
}

func (s *Column_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitColumn_list(s)
	}
}

func (s *Column_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitColumn_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Column_list() (localctx IColumn_listContext) {
	localctx = NewColumn_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, OBParserRULE_column_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4769)
		p.Column_definition_ref()
	}
	p.SetState(4774)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(4770)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4771)
			p.Column_definition_ref()
		}

		p.SetState(4776)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsert_vals_listContext is an interface to support dynamic dispatch.
type IInsert_vals_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	Insert_vals() IInsert_valsContext
	RightParen() antlr.TerminalNode
	Insert_vals_list() IInsert_vals_listContext
	Comma() antlr.TerminalNode

	// IsInsert_vals_listContext differentiates from other interfaces.
	IsInsert_vals_listContext()
}

type Insert_vals_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_vals_listContext() *Insert_vals_listContext {
	var p = new(Insert_vals_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_insert_vals_list
	return p
}

func InitEmptyInsert_vals_listContext(p *Insert_vals_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_insert_vals_list
}

func (*Insert_vals_listContext) IsInsert_vals_listContext() {}

func NewInsert_vals_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_vals_listContext {
	var p = new(Insert_vals_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_insert_vals_list

	return p
}

func (s *Insert_vals_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_vals_listContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Insert_vals_listContext) Insert_vals() IInsert_valsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_valsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_valsContext)
}

func (s *Insert_vals_listContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Insert_vals_listContext) Insert_vals_list() IInsert_vals_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_vals_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_vals_listContext)
}

func (s *Insert_vals_listContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Insert_vals_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_vals_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_vals_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterInsert_vals_list(s)
	}
}

func (s *Insert_vals_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitInsert_vals_list(s)
	}
}

func (s *Insert_vals_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitInsert_vals_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Insert_vals_list() (localctx IInsert_vals_listContext) {
	return p.insert_vals_list(0)
}

func (p *OBParser) insert_vals_list(_p int) (localctx IInsert_vals_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewInsert_vals_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IInsert_vals_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 430
	p.EnterRecursionRule(localctx, 430, OBParserRULE_insert_vals_list, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4778)
		p.Match(OBParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4779)
		p.insert_vals(0)
	}
	{
		p.SetState(4780)
		p.Match(OBParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4790)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 460, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewInsert_vals_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, OBParserRULE_insert_vals_list)
			p.SetState(4782)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(4783)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4784)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4785)
				p.insert_vals(0)
			}
			{
				p.SetState(4786)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(4792)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 460, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsert_valsContext is an interface to support dynamic dispatch.
type IInsert_valsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr_or_default() IExpr_or_defaultContext
	Empty() IEmptyContext
	Insert_vals() IInsert_valsContext
	Comma() antlr.TerminalNode

	// IsInsert_valsContext differentiates from other interfaces.
	IsInsert_valsContext()
}

type Insert_valsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_valsContext() *Insert_valsContext {
	var p = new(Insert_valsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_insert_vals
	return p
}

func InitEmptyInsert_valsContext(p *Insert_valsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_insert_vals
}

func (*Insert_valsContext) IsInsert_valsContext() {}

func NewInsert_valsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_valsContext {
	var p = new(Insert_valsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_insert_vals

	return p
}

func (s *Insert_valsContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_valsContext) Expr_or_default() IExpr_or_defaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_or_defaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_or_defaultContext)
}

func (s *Insert_valsContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Insert_valsContext) Insert_vals() IInsert_valsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_valsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_valsContext)
}

func (s *Insert_valsContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Insert_valsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_valsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_valsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterInsert_vals(s)
	}
}

func (s *Insert_valsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitInsert_vals(s)
	}
}

func (s *Insert_valsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitInsert_vals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Insert_vals() (localctx IInsert_valsContext) {
	return p.insert_vals(0)
}

func (p *OBParser) insert_vals(_p int) (localctx IInsert_valsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewInsert_valsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IInsert_valsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 432
	p.EnterRecursionRule(localctx, 432, OBParserRULE_insert_vals, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4796)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 461, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4794)
			p.Expr_or_default()
		}

	case 2:
		{
			p.SetState(4795)
			p.Empty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4803)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 462, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewInsert_valsContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, OBParserRULE_insert_vals)
			p.SetState(4798)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(4799)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4800)
				p.Expr_or_default()
			}

		}
		p.SetState(4805)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 462, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_or_defaultContext is an interface to support dynamic dispatch.
type IExpr_or_defaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	DEFAULT() antlr.TerminalNode

	// IsExpr_or_defaultContext differentiates from other interfaces.
	IsExpr_or_defaultContext()
}

type Expr_or_defaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_or_defaultContext() *Expr_or_defaultContext {
	var p = new(Expr_or_defaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_expr_or_default
	return p
}

func InitEmptyExpr_or_defaultContext(p *Expr_or_defaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_expr_or_default
}

func (*Expr_or_defaultContext) IsExpr_or_defaultContext() {}

func NewExpr_or_defaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_or_defaultContext {
	var p = new(Expr_or_defaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_expr_or_default

	return p
}

func (s *Expr_or_defaultContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_or_defaultContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_or_defaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT, 0)
}

func (s *Expr_or_defaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_or_defaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_or_defaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterExpr_or_default(s)
	}
}

func (s *Expr_or_defaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitExpr_or_default(s)
	}
}

func (s *Expr_or_defaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitExpr_or_default(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Expr_or_default() (localctx IExpr_or_defaultContext) {
	localctx = NewExpr_or_defaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, OBParserRULE_expr_or_default)
	p.SetState(4808)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 463, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4806)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4807)
			p.Match(OBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_stmtContext is an interface to support dynamic dispatch.
type ISelect_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_no_parens() ISelect_no_parensContext
	Select_with_parens() ISelect_with_parensContext
	Select_into() ISelect_intoContext

	// IsSelect_stmtContext differentiates from other interfaces.
	IsSelect_stmtContext()
}

type Select_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_stmtContext() *Select_stmtContext {
	var p = new(Select_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_stmt
	return p
}

func InitEmptySelect_stmtContext(p *Select_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_stmt
}

func (*Select_stmtContext) IsSelect_stmtContext() {}

func NewSelect_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_stmtContext {
	var p = new(Select_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_select_stmt

	return p
}

func (s *Select_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_stmtContext) Select_no_parens() ISelect_no_parensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_no_parensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_no_parensContext)
}

func (s *Select_stmtContext) Select_with_parens() ISelect_with_parensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_with_parensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_with_parensContext)
}

func (s *Select_stmtContext) Select_into() ISelect_intoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_intoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_intoContext)
}

func (s *Select_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSelect_stmt(s)
	}
}

func (s *Select_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSelect_stmt(s)
	}
}

func (s *Select_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSelect_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Select_stmt() (localctx ISelect_stmtContext) {
	localctx = NewSelect_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, OBParserRULE_select_stmt)
	p.SetState(4813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 464, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4810)
			p.Select_no_parens()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4811)
			p.Select_with_parens()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4812)
			p.Select_into()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_intoContext is an interface to support dynamic dispatch.
type ISelect_intoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_no_parens() ISelect_no_parensContext
	Into_clause() IInto_clauseContext

	// IsSelect_intoContext differentiates from other interfaces.
	IsSelect_intoContext()
}

type Select_intoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_intoContext() *Select_intoContext {
	var p = new(Select_intoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_into
	return p
}

func InitEmptySelect_intoContext(p *Select_intoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_into
}

func (*Select_intoContext) IsSelect_intoContext() {}

func NewSelect_intoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_intoContext {
	var p = new(Select_intoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_select_into

	return p
}

func (s *Select_intoContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_intoContext) Select_no_parens() ISelect_no_parensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_no_parensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_no_parensContext)
}

func (s *Select_intoContext) Into_clause() IInto_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_clauseContext)
}

func (s *Select_intoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_intoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_intoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSelect_into(s)
	}
}

func (s *Select_intoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSelect_into(s)
	}
}

func (s *Select_intoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSelect_into(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Select_into() (localctx ISelect_intoContext) {
	localctx = NewSelect_intoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, OBParserRULE_select_into)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4815)
		p.Select_no_parens()
	}
	{
		p.SetState(4816)
		p.Into_clause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_with_parensContext is an interface to support dynamic dispatch.
type ISelect_with_parensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	Select_no_parens() ISelect_no_parensContext
	RightParen() antlr.TerminalNode
	Select_with_parens() ISelect_with_parensContext

	// IsSelect_with_parensContext differentiates from other interfaces.
	IsSelect_with_parensContext()
}

type Select_with_parensContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_with_parensContext() *Select_with_parensContext {
	var p = new(Select_with_parensContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_with_parens
	return p
}

func InitEmptySelect_with_parensContext(p *Select_with_parensContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_with_parens
}

func (*Select_with_parensContext) IsSelect_with_parensContext() {}

func NewSelect_with_parensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_with_parensContext {
	var p = new(Select_with_parensContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_select_with_parens

	return p
}

func (s *Select_with_parensContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_with_parensContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Select_with_parensContext) Select_no_parens() ISelect_no_parensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_no_parensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_no_parensContext)
}

func (s *Select_with_parensContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Select_with_parensContext) Select_with_parens() ISelect_with_parensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_with_parensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_with_parensContext)
}

func (s *Select_with_parensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_with_parensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_with_parensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSelect_with_parens(s)
	}
}

func (s *Select_with_parensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSelect_with_parens(s)
	}
}

func (s *Select_with_parensContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSelect_with_parens(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Select_with_parens() (localctx ISelect_with_parensContext) {
	localctx = NewSelect_with_parensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, OBParserRULE_select_with_parens)
	p.SetState(4826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 465, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4818)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4819)
			p.Select_no_parens()
		}
		{
			p.SetState(4820)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4822)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4823)
			p.Select_with_parens()
		}
		{
			p.SetState(4824)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_no_parensContext is an interface to support dynamic dispatch.
type ISelect_no_parensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_clause() ISelect_clauseContext
	FOR() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	Opt_for_update_wait() IOpt_for_update_waitContext
	Select_clause_set() ISelect_clause_setContext
	Select_clause_set_with_order_and_limit() ISelect_clause_set_with_order_and_limitContext

	// IsSelect_no_parensContext differentiates from other interfaces.
	IsSelect_no_parensContext()
}

type Select_no_parensContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_no_parensContext() *Select_no_parensContext {
	var p = new(Select_no_parensContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_no_parens
	return p
}

func InitEmptySelect_no_parensContext(p *Select_no_parensContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_no_parens
}

func (*Select_no_parensContext) IsSelect_no_parensContext() {}

func NewSelect_no_parensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_no_parensContext {
	var p = new(Select_no_parensContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_select_no_parens

	return p
}

func (s *Select_no_parensContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_no_parensContext) Select_clause() ISelect_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_clauseContext)
}

func (s *Select_no_parensContext) FOR() antlr.TerminalNode {
	return s.GetToken(OBParserFOR, 0)
}

func (s *Select_no_parensContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(OBParserUPDATE, 0)
}

func (s *Select_no_parensContext) Opt_for_update_wait() IOpt_for_update_waitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_for_update_waitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_for_update_waitContext)
}

func (s *Select_no_parensContext) Select_clause_set() ISelect_clause_setContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_clause_setContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_clause_setContext)
}

func (s *Select_no_parensContext) Select_clause_set_with_order_and_limit() ISelect_clause_set_with_order_and_limitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_clause_set_with_order_and_limitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_clause_set_with_order_and_limitContext)
}

func (s *Select_no_parensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_no_parensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_no_parensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSelect_no_parens(s)
	}
}

func (s *Select_no_parensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSelect_no_parens(s)
	}
}

func (s *Select_no_parensContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSelect_no_parens(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Select_no_parens() (localctx ISelect_no_parensContext) {
	localctx = NewSelect_no_parensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, OBParserRULE_select_no_parens)
	var _la int

	p.SetState(4846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 469, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4828)
			p.Select_clause()
		}
		p.SetState(4832)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFOR {
			{
				p.SetState(4829)
				p.Match(OBParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4830)
				p.Match(OBParserUPDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4831)
				p.Opt_for_update_wait()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4834)
			p.select_clause_set(0)
		}
		p.SetState(4838)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFOR {
			{
				p.SetState(4835)
				p.Match(OBParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4836)
				p.Match(OBParserUPDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4837)
				p.Opt_for_update_wait()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4840)
			p.Select_clause_set_with_order_and_limit()
		}
		p.SetState(4844)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFOR {
			{
				p.SetState(4841)
				p.Match(OBParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4842)
				p.Match(OBParserUPDATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4843)
				p.Opt_for_update_wait()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INo_table_selectContext is an interface to support dynamic dispatch.
type INo_table_selectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_with_opt_hint() ISelect_with_opt_hintContext
	Select_expr_list() ISelect_expr_listContext
	Into_opt() IInto_optContext
	Query_expression_option_list() IQuery_expression_option_listContext
	FROM() antlr.TerminalNode
	DUAL() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Opt_hint_value() IOpt_hint_valueContext
	Expr() IExprContext
	WINDOW() antlr.TerminalNode
	Named_windows() INamed_windowsContext

	// IsNo_table_selectContext differentiates from other interfaces.
	IsNo_table_selectContext()
}

type No_table_selectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNo_table_selectContext() *No_table_selectContext {
	var p = new(No_table_selectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_no_table_select
	return p
}

func InitEmptyNo_table_selectContext(p *No_table_selectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_no_table_select
}

func (*No_table_selectContext) IsNo_table_selectContext() {}

func NewNo_table_selectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *No_table_selectContext {
	var p = new(No_table_selectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_no_table_select

	return p
}

func (s *No_table_selectContext) GetParser() antlr.Parser { return s.parser }

func (s *No_table_selectContext) Select_with_opt_hint() ISelect_with_opt_hintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_with_opt_hintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_with_opt_hintContext)
}

func (s *No_table_selectContext) Select_expr_list() ISelect_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_expr_listContext)
}

func (s *No_table_selectContext) Into_opt() IInto_optContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_optContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_optContext)
}

func (s *No_table_selectContext) Query_expression_option_list() IQuery_expression_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_expression_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_expression_option_listContext)
}

func (s *No_table_selectContext) FROM() antlr.TerminalNode {
	return s.GetToken(OBParserFROM, 0)
}

func (s *No_table_selectContext) DUAL() antlr.TerminalNode {
	return s.GetToken(OBParserDUAL, 0)
}

func (s *No_table_selectContext) WHERE() antlr.TerminalNode {
	return s.GetToken(OBParserWHERE, 0)
}

func (s *No_table_selectContext) Opt_hint_value() IOpt_hint_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_hint_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_hint_valueContext)
}

func (s *No_table_selectContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *No_table_selectContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(OBParserWINDOW, 0)
}

func (s *No_table_selectContext) Named_windows() INamed_windowsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_windowsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_windowsContext)
}

func (s *No_table_selectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *No_table_selectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *No_table_selectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterNo_table_select(s)
	}
}

func (s *No_table_selectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitNo_table_select(s)
	}
}

func (s *No_table_selectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitNo_table_select(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) No_table_select() (localctx INo_table_selectContext) {
	localctx = NewNo_table_selectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, OBParserRULE_no_table_select)
	var _la int

	p.SetState(4873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 474, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4848)
			p.Select_with_opt_hint()
		}
		p.SetState(4850)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserSQL_CALC_FOUND_ROWS || _la == OBParserUNIQUE {
			{
				p.SetState(4849)
				p.Query_expression_option_list()
			}

		}
		{
			p.SetState(4852)
			p.Select_expr_list()
		}
		{
			p.SetState(4853)
			p.Into_opt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4855)
			p.Select_with_opt_hint()
		}
		p.SetState(4857)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserSQL_CALC_FOUND_ROWS || _la == OBParserUNIQUE {
			{
				p.SetState(4856)
				p.Query_expression_option_list()
			}

		}
		{
			p.SetState(4859)
			p.Select_expr_list()
		}
		{
			p.SetState(4860)
			p.Into_opt()
		}
		{
			p.SetState(4861)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4862)
			p.Match(OBParserDUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4867)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 472, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4863)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4864)
				p.Opt_hint_value()
			}
			{
				p.SetState(4865)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4871)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 473, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4869)
				p.Match(OBParserWINDOW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4870)
				p.Named_windows()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_clauseContext is an interface to support dynamic dispatch.
type ISelect_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	No_table_select() INo_table_selectContext
	No_table_select_with_order_and_limit() INo_table_select_with_order_and_limitContext
	Simple_select() ISimple_selectContext
	Simple_select_with_order_and_limit() ISimple_select_with_order_and_limitContext
	Select_with_parens_with_order_and_limit() ISelect_with_parens_with_order_and_limitContext

	// IsSelect_clauseContext differentiates from other interfaces.
	IsSelect_clauseContext()
}

type Select_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_clauseContext() *Select_clauseContext {
	var p = new(Select_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_clause
	return p
}

func InitEmptySelect_clauseContext(p *Select_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_clause
}

func (*Select_clauseContext) IsSelect_clauseContext() {}

func NewSelect_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_clauseContext {
	var p = new(Select_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_select_clause

	return p
}

func (s *Select_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_clauseContext) No_table_select() INo_table_selectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INo_table_selectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INo_table_selectContext)
}

func (s *Select_clauseContext) No_table_select_with_order_and_limit() INo_table_select_with_order_and_limitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INo_table_select_with_order_and_limitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INo_table_select_with_order_and_limitContext)
}

func (s *Select_clauseContext) Simple_select() ISimple_selectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_selectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_selectContext)
}

func (s *Select_clauseContext) Simple_select_with_order_and_limit() ISimple_select_with_order_and_limitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_select_with_order_and_limitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_select_with_order_and_limitContext)
}

func (s *Select_clauseContext) Select_with_parens_with_order_and_limit() ISelect_with_parens_with_order_and_limitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_with_parens_with_order_and_limitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_with_parens_with_order_and_limitContext)
}

func (s *Select_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSelect_clause(s)
	}
}

func (s *Select_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSelect_clause(s)
	}
}

func (s *Select_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSelect_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Select_clause() (localctx ISelect_clauseContext) {
	localctx = NewSelect_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, OBParserRULE_select_clause)
	p.SetState(4880)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 475, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4875)
			p.No_table_select()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4876)
			p.No_table_select_with_order_and_limit()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4877)
			p.Simple_select()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4878)
			p.Simple_select_with_order_and_limit()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4879)
			p.Select_with_parens_with_order_and_limit()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_clause_set_with_order_and_limitContext is an interface to support dynamic dispatch.
type ISelect_clause_set_with_order_and_limitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_clause_set() ISelect_clause_setContext
	Order_by() IOrder_byContext
	Limit_clause() ILimit_clauseContext

	// IsSelect_clause_set_with_order_and_limitContext differentiates from other interfaces.
	IsSelect_clause_set_with_order_and_limitContext()
}

type Select_clause_set_with_order_and_limitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_clause_set_with_order_and_limitContext() *Select_clause_set_with_order_and_limitContext {
	var p = new(Select_clause_set_with_order_and_limitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_clause_set_with_order_and_limit
	return p
}

func InitEmptySelect_clause_set_with_order_and_limitContext(p *Select_clause_set_with_order_and_limitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_clause_set_with_order_and_limit
}

func (*Select_clause_set_with_order_and_limitContext) IsSelect_clause_set_with_order_and_limitContext() {
}

func NewSelect_clause_set_with_order_and_limitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_clause_set_with_order_and_limitContext {
	var p = new(Select_clause_set_with_order_and_limitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_select_clause_set_with_order_and_limit

	return p
}

func (s *Select_clause_set_with_order_and_limitContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_clause_set_with_order_and_limitContext) Select_clause_set() ISelect_clause_setContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_clause_setContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_clause_setContext)
}

func (s *Select_clause_set_with_order_and_limitContext) Order_by() IOrder_byContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_byContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_byContext)
}

func (s *Select_clause_set_with_order_and_limitContext) Limit_clause() ILimit_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimit_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimit_clauseContext)
}

func (s *Select_clause_set_with_order_and_limitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_clause_set_with_order_and_limitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_clause_set_with_order_and_limitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSelect_clause_set_with_order_and_limit(s)
	}
}

func (s *Select_clause_set_with_order_and_limitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSelect_clause_set_with_order_and_limit(s)
	}
}

func (s *Select_clause_set_with_order_and_limitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSelect_clause_set_with_order_and_limit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Select_clause_set_with_order_and_limit() (localctx ISelect_clause_set_with_order_and_limitContext) {
	localctx = NewSelect_clause_set_with_order_and_limitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, OBParserRULE_select_clause_set_with_order_and_limit)
	var _la int

	p.SetState(4891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 477, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4882)
			p.select_clause_set(0)
		}
		{
			p.SetState(4883)
			p.Order_by()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4885)
			p.select_clause_set(0)
		}
		p.SetState(4887)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserORDER {
			{
				p.SetState(4886)
				p.Order_by()
			}

		}
		{
			p.SetState(4889)
			p.Limit_clause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_clause_setContext is an interface to support dynamic dispatch.
type ISelect_clause_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_clause_set_left() ISelect_clause_set_leftContext
	Set_type() ISet_typeContext
	Select_clause_set_right() ISelect_clause_set_rightContext
	Select_clause_set() ISelect_clause_setContext
	Order_by() IOrder_byContext
	Limit_clause() ILimit_clauseContext

	// IsSelect_clause_setContext differentiates from other interfaces.
	IsSelect_clause_setContext()
}

type Select_clause_setContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_clause_setContext() *Select_clause_setContext {
	var p = new(Select_clause_setContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_clause_set
	return p
}

func InitEmptySelect_clause_setContext(p *Select_clause_setContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_clause_set
}

func (*Select_clause_setContext) IsSelect_clause_setContext() {}

func NewSelect_clause_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_clause_setContext {
	var p = new(Select_clause_setContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_select_clause_set

	return p
}

func (s *Select_clause_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_clause_setContext) Select_clause_set_left() ISelect_clause_set_leftContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_clause_set_leftContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_clause_set_leftContext)
}

func (s *Select_clause_setContext) Set_type() ISet_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_typeContext)
}

func (s *Select_clause_setContext) Select_clause_set_right() ISelect_clause_set_rightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_clause_set_rightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_clause_set_rightContext)
}

func (s *Select_clause_setContext) Select_clause_set() ISelect_clause_setContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_clause_setContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_clause_setContext)
}

func (s *Select_clause_setContext) Order_by() IOrder_byContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_byContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_byContext)
}

func (s *Select_clause_setContext) Limit_clause() ILimit_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimit_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimit_clauseContext)
}

func (s *Select_clause_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_clause_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_clause_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSelect_clause_set(s)
	}
}

func (s *Select_clause_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSelect_clause_set(s)
	}
}

func (s *Select_clause_setContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSelect_clause_set(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Select_clause_set() (localctx ISelect_clause_setContext) {
	return p.select_clause_set(0)
}

func (p *OBParser) select_clause_set(_p int) (localctx ISelect_clause_setContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewSelect_clause_setContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISelect_clause_setContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 450
	p.EnterRecursionRule(localctx, 450, OBParserRULE_select_clause_set, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4894)
		p.Select_clause_set_left()
	}
	{
		p.SetState(4895)
		p.Set_type()
	}
	{
		p.SetState(4896)
		p.Select_clause_set_right()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 480, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(4915)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 479, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSelect_clause_setContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_select_clause_set)
				p.SetState(4898)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(4899)
					p.Set_type()
				}
				{
					p.SetState(4900)
					p.Select_clause_set_right()
				}

			case 2:
				localctx = NewSelect_clause_setContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_select_clause_set)
				p.SetState(4902)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(4903)
					p.Order_by()
				}
				{
					p.SetState(4904)
					p.Set_type()
				}
				{
					p.SetState(4905)
					p.Select_clause_set_right()
				}

			case 3:
				localctx = NewSelect_clause_setContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_select_clause_set)
				p.SetState(4907)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				p.SetState(4909)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == OBParserORDER {
					{
						p.SetState(4908)
						p.Order_by()
					}

				}
				{
					p.SetState(4911)
					p.Limit_clause()
				}
				{
					p.SetState(4912)
					p.Set_type()
				}
				{
					p.SetState(4913)
					p.Select_clause_set_right()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(4919)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 480, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_clause_set_rightContext is an interface to support dynamic dispatch.
type ISelect_clause_set_rightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	No_table_select() INo_table_selectContext
	Simple_select() ISimple_selectContext
	Select_with_parens() ISelect_with_parensContext

	// IsSelect_clause_set_rightContext differentiates from other interfaces.
	IsSelect_clause_set_rightContext()
}

type Select_clause_set_rightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_clause_set_rightContext() *Select_clause_set_rightContext {
	var p = new(Select_clause_set_rightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_clause_set_right
	return p
}

func InitEmptySelect_clause_set_rightContext(p *Select_clause_set_rightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_clause_set_right
}

func (*Select_clause_set_rightContext) IsSelect_clause_set_rightContext() {}

func NewSelect_clause_set_rightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_clause_set_rightContext {
	var p = new(Select_clause_set_rightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_select_clause_set_right

	return p
}

func (s *Select_clause_set_rightContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_clause_set_rightContext) No_table_select() INo_table_selectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INo_table_selectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INo_table_selectContext)
}

func (s *Select_clause_set_rightContext) Simple_select() ISimple_selectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_selectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_selectContext)
}

func (s *Select_clause_set_rightContext) Select_with_parens() ISelect_with_parensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_with_parensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_with_parensContext)
}

func (s *Select_clause_set_rightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_clause_set_rightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_clause_set_rightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSelect_clause_set_right(s)
	}
}

func (s *Select_clause_set_rightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSelect_clause_set_right(s)
	}
}

func (s *Select_clause_set_rightContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSelect_clause_set_right(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Select_clause_set_right() (localctx ISelect_clause_set_rightContext) {
	localctx = NewSelect_clause_set_rightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, OBParserRULE_select_clause_set_right)
	p.SetState(4923)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 481, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4920)
			p.No_table_select()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4921)
			p.Simple_select()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4922)
			p.Select_with_parens()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_clause_set_leftContext is an interface to support dynamic dispatch.
type ISelect_clause_set_leftContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	No_table_select_with_order_and_limit() INo_table_select_with_order_and_limitContext
	Simple_select_with_order_and_limit() ISimple_select_with_order_and_limitContext
	Select_clause_set_right() ISelect_clause_set_rightContext

	// IsSelect_clause_set_leftContext differentiates from other interfaces.
	IsSelect_clause_set_leftContext()
}

type Select_clause_set_leftContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_clause_set_leftContext() *Select_clause_set_leftContext {
	var p = new(Select_clause_set_leftContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_clause_set_left
	return p
}

func InitEmptySelect_clause_set_leftContext(p *Select_clause_set_leftContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_clause_set_left
}

func (*Select_clause_set_leftContext) IsSelect_clause_set_leftContext() {}

func NewSelect_clause_set_leftContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_clause_set_leftContext {
	var p = new(Select_clause_set_leftContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_select_clause_set_left

	return p
}

func (s *Select_clause_set_leftContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_clause_set_leftContext) No_table_select_with_order_and_limit() INo_table_select_with_order_and_limitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INo_table_select_with_order_and_limitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INo_table_select_with_order_and_limitContext)
}

func (s *Select_clause_set_leftContext) Simple_select_with_order_and_limit() ISimple_select_with_order_and_limitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_select_with_order_and_limitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_select_with_order_and_limitContext)
}

func (s *Select_clause_set_leftContext) Select_clause_set_right() ISelect_clause_set_rightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_clause_set_rightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_clause_set_rightContext)
}

func (s *Select_clause_set_leftContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_clause_set_leftContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_clause_set_leftContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSelect_clause_set_left(s)
	}
}

func (s *Select_clause_set_leftContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSelect_clause_set_left(s)
	}
}

func (s *Select_clause_set_leftContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSelect_clause_set_left(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Select_clause_set_left() (localctx ISelect_clause_set_leftContext) {
	localctx = NewSelect_clause_set_leftContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, OBParserRULE_select_clause_set_left)
	p.SetState(4928)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 482, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4925)
			p.No_table_select_with_order_and_limit()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4926)
			p.Simple_select_with_order_and_limit()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4927)
			p.Select_clause_set_right()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INo_table_select_with_order_and_limitContext is an interface to support dynamic dispatch.
type INo_table_select_with_order_and_limitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	No_table_select() INo_table_selectContext
	Order_by() IOrder_byContext
	Limit_clause() ILimit_clauseContext

	// IsNo_table_select_with_order_and_limitContext differentiates from other interfaces.
	IsNo_table_select_with_order_and_limitContext()
}

type No_table_select_with_order_and_limitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNo_table_select_with_order_and_limitContext() *No_table_select_with_order_and_limitContext {
	var p = new(No_table_select_with_order_and_limitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_no_table_select_with_order_and_limit
	return p
}

func InitEmptyNo_table_select_with_order_and_limitContext(p *No_table_select_with_order_and_limitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_no_table_select_with_order_and_limit
}

func (*No_table_select_with_order_and_limitContext) IsNo_table_select_with_order_and_limitContext() {}

func NewNo_table_select_with_order_and_limitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *No_table_select_with_order_and_limitContext {
	var p = new(No_table_select_with_order_and_limitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_no_table_select_with_order_and_limit

	return p
}

func (s *No_table_select_with_order_and_limitContext) GetParser() antlr.Parser { return s.parser }

func (s *No_table_select_with_order_and_limitContext) No_table_select() INo_table_selectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INo_table_selectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INo_table_selectContext)
}

func (s *No_table_select_with_order_and_limitContext) Order_by() IOrder_byContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_byContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_byContext)
}

func (s *No_table_select_with_order_and_limitContext) Limit_clause() ILimit_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimit_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimit_clauseContext)
}

func (s *No_table_select_with_order_and_limitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *No_table_select_with_order_and_limitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *No_table_select_with_order_and_limitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterNo_table_select_with_order_and_limit(s)
	}
}

func (s *No_table_select_with_order_and_limitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitNo_table_select_with_order_and_limit(s)
	}
}

func (s *No_table_select_with_order_and_limitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitNo_table_select_with_order_and_limit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) No_table_select_with_order_and_limit() (localctx INo_table_select_with_order_and_limitContext) {
	localctx = NewNo_table_select_with_order_and_limitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, OBParserRULE_no_table_select_with_order_and_limit)
	var _la int

	p.SetState(4939)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 484, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4930)
			p.No_table_select()
		}
		{
			p.SetState(4931)
			p.Order_by()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4933)
			p.No_table_select()
		}
		p.SetState(4935)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserORDER {
			{
				p.SetState(4934)
				p.Order_by()
			}

		}
		{
			p.SetState(4937)
			p.Limit_clause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimple_select_with_order_and_limitContext is an interface to support dynamic dispatch.
type ISimple_select_with_order_and_limitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Simple_select() ISimple_selectContext
	Order_by() IOrder_byContext
	Limit_clause() ILimit_clauseContext

	// IsSimple_select_with_order_and_limitContext differentiates from other interfaces.
	IsSimple_select_with_order_and_limitContext()
}

type Simple_select_with_order_and_limitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_select_with_order_and_limitContext() *Simple_select_with_order_and_limitContext {
	var p = new(Simple_select_with_order_and_limitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_simple_select_with_order_and_limit
	return p
}

func InitEmptySimple_select_with_order_and_limitContext(p *Simple_select_with_order_and_limitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_simple_select_with_order_and_limit
}

func (*Simple_select_with_order_and_limitContext) IsSimple_select_with_order_and_limitContext() {}

func NewSimple_select_with_order_and_limitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_select_with_order_and_limitContext {
	var p = new(Simple_select_with_order_and_limitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_simple_select_with_order_and_limit

	return p
}

func (s *Simple_select_with_order_and_limitContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_select_with_order_and_limitContext) Simple_select() ISimple_selectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimple_selectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimple_selectContext)
}

func (s *Simple_select_with_order_and_limitContext) Order_by() IOrder_byContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_byContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_byContext)
}

func (s *Simple_select_with_order_and_limitContext) Limit_clause() ILimit_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimit_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimit_clauseContext)
}

func (s *Simple_select_with_order_and_limitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_select_with_order_and_limitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_select_with_order_and_limitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSimple_select_with_order_and_limit(s)
	}
}

func (s *Simple_select_with_order_and_limitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSimple_select_with_order_and_limit(s)
	}
}

func (s *Simple_select_with_order_and_limitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSimple_select_with_order_and_limit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Simple_select_with_order_and_limit() (localctx ISimple_select_with_order_and_limitContext) {
	localctx = NewSimple_select_with_order_and_limitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, OBParserRULE_simple_select_with_order_and_limit)
	var _la int

	p.SetState(4950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 486, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4941)
			p.Simple_select()
		}
		{
			p.SetState(4942)
			p.Order_by()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4944)
			p.Simple_select()
		}
		p.SetState(4946)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserORDER {
			{
				p.SetState(4945)
				p.Order_by()
			}

		}
		{
			p.SetState(4948)
			p.Limit_clause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_with_parens_with_order_and_limitContext is an interface to support dynamic dispatch.
type ISelect_with_parens_with_order_and_limitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_with_parens() ISelect_with_parensContext
	Order_by() IOrder_byContext
	Limit_clause() ILimit_clauseContext

	// IsSelect_with_parens_with_order_and_limitContext differentiates from other interfaces.
	IsSelect_with_parens_with_order_and_limitContext()
}

type Select_with_parens_with_order_and_limitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_with_parens_with_order_and_limitContext() *Select_with_parens_with_order_and_limitContext {
	var p = new(Select_with_parens_with_order_and_limitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_with_parens_with_order_and_limit
	return p
}

func InitEmptySelect_with_parens_with_order_and_limitContext(p *Select_with_parens_with_order_and_limitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_with_parens_with_order_and_limit
}

func (*Select_with_parens_with_order_and_limitContext) IsSelect_with_parens_with_order_and_limitContext() {
}

func NewSelect_with_parens_with_order_and_limitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_with_parens_with_order_and_limitContext {
	var p = new(Select_with_parens_with_order_and_limitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_select_with_parens_with_order_and_limit

	return p
}

func (s *Select_with_parens_with_order_and_limitContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_with_parens_with_order_and_limitContext) Select_with_parens() ISelect_with_parensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_with_parensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_with_parensContext)
}

func (s *Select_with_parens_with_order_and_limitContext) Order_by() IOrder_byContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_byContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_byContext)
}

func (s *Select_with_parens_with_order_and_limitContext) Limit_clause() ILimit_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimit_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimit_clauseContext)
}

func (s *Select_with_parens_with_order_and_limitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_with_parens_with_order_and_limitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_with_parens_with_order_and_limitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSelect_with_parens_with_order_and_limit(s)
	}
}

func (s *Select_with_parens_with_order_and_limitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSelect_with_parens_with_order_and_limit(s)
	}
}

func (s *Select_with_parens_with_order_and_limitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSelect_with_parens_with_order_and_limit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Select_with_parens_with_order_and_limit() (localctx ISelect_with_parens_with_order_and_limitContext) {
	localctx = NewSelect_with_parens_with_order_and_limitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, OBParserRULE_select_with_parens_with_order_and_limit)
	var _la int

	p.SetState(4961)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 488, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4952)
			p.Select_with_parens()
		}
		{
			p.SetState(4953)
			p.Order_by()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4955)
			p.Select_with_parens()
		}
		p.SetState(4957)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserORDER {
			{
				p.SetState(4956)
				p.Order_by()
			}

		}
		{
			p.SetState(4959)
			p.Limit_clause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_with_opt_hintContext is an interface to support dynamic dispatch.
type ISelect_with_opt_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SELECT_HINT_BEGIN() antlr.TerminalNode
	Hint_list_with_end() IHint_list_with_endContext

	// IsSelect_with_opt_hintContext differentiates from other interfaces.
	IsSelect_with_opt_hintContext()
}

type Select_with_opt_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_with_opt_hintContext() *Select_with_opt_hintContext {
	var p = new(Select_with_opt_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_with_opt_hint
	return p
}

func InitEmptySelect_with_opt_hintContext(p *Select_with_opt_hintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_with_opt_hint
}

func (*Select_with_opt_hintContext) IsSelect_with_opt_hintContext() {}

func NewSelect_with_opt_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_with_opt_hintContext {
	var p = new(Select_with_opt_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_select_with_opt_hint

	return p
}

func (s *Select_with_opt_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_with_opt_hintContext) SELECT() antlr.TerminalNode {
	return s.GetToken(OBParserSELECT, 0)
}

func (s *Select_with_opt_hintContext) SELECT_HINT_BEGIN() antlr.TerminalNode {
	return s.GetToken(OBParserSELECT_HINT_BEGIN, 0)
}

func (s *Select_with_opt_hintContext) Hint_list_with_end() IHint_list_with_endContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHint_list_with_endContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHint_list_with_endContext)
}

func (s *Select_with_opt_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_with_opt_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_with_opt_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSelect_with_opt_hint(s)
	}
}

func (s *Select_with_opt_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSelect_with_opt_hint(s)
	}
}

func (s *Select_with_opt_hintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSelect_with_opt_hint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Select_with_opt_hint() (localctx ISelect_with_opt_hintContext) {
	localctx = NewSelect_with_opt_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, OBParserRULE_select_with_opt_hint)
	p.SetState(4966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserSELECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4963)
			p.Match(OBParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserSELECT_HINT_BEGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4964)
			p.Match(OBParserSELECT_HINT_BEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4965)
			p.Hint_list_with_end()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_with_opt_hintContext is an interface to support dynamic dispatch.
type IUpdate_with_opt_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPDATE() antlr.TerminalNode
	UPDATE_HINT_BEGIN() antlr.TerminalNode
	Hint_list_with_end() IHint_list_with_endContext

	// IsUpdate_with_opt_hintContext differentiates from other interfaces.
	IsUpdate_with_opt_hintContext()
}

type Update_with_opt_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_with_opt_hintContext() *Update_with_opt_hintContext {
	var p = new(Update_with_opt_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_update_with_opt_hint
	return p
}

func InitEmptyUpdate_with_opt_hintContext(p *Update_with_opt_hintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_update_with_opt_hint
}

func (*Update_with_opt_hintContext) IsUpdate_with_opt_hintContext() {}

func NewUpdate_with_opt_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_with_opt_hintContext {
	var p = new(Update_with_opt_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_update_with_opt_hint

	return p
}

func (s *Update_with_opt_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_with_opt_hintContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(OBParserUPDATE, 0)
}

func (s *Update_with_opt_hintContext) UPDATE_HINT_BEGIN() antlr.TerminalNode {
	return s.GetToken(OBParserUPDATE_HINT_BEGIN, 0)
}

func (s *Update_with_opt_hintContext) Hint_list_with_end() IHint_list_with_endContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHint_list_with_endContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHint_list_with_endContext)
}

func (s *Update_with_opt_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_with_opt_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_with_opt_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUpdate_with_opt_hint(s)
	}
}

func (s *Update_with_opt_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUpdate_with_opt_hint(s)
	}
}

func (s *Update_with_opt_hintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUpdate_with_opt_hint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Update_with_opt_hint() (localctx IUpdate_with_opt_hintContext) {
	localctx = NewUpdate_with_opt_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, OBParserRULE_update_with_opt_hint)
	p.SetState(4971)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserUPDATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4968)
			p.Match(OBParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserUPDATE_HINT_BEGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4969)
			p.Match(OBParserUPDATE_HINT_BEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4970)
			p.Hint_list_with_end()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelete_with_opt_hintContext is an interface to support dynamic dispatch.
type IDelete_with_opt_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	DELETE_HINT_BEGIN() antlr.TerminalNode
	Hint_list_with_end() IHint_list_with_endContext

	// IsDelete_with_opt_hintContext differentiates from other interfaces.
	IsDelete_with_opt_hintContext()
}

type Delete_with_opt_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelete_with_opt_hintContext() *Delete_with_opt_hintContext {
	var p = new(Delete_with_opt_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_delete_with_opt_hint
	return p
}

func InitEmptyDelete_with_opt_hintContext(p *Delete_with_opt_hintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_delete_with_opt_hint
}

func (*Delete_with_opt_hintContext) IsDelete_with_opt_hintContext() {}

func NewDelete_with_opt_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_with_opt_hintContext {
	var p = new(Delete_with_opt_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_delete_with_opt_hint

	return p
}

func (s *Delete_with_opt_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *Delete_with_opt_hintContext) DELETE() antlr.TerminalNode {
	return s.GetToken(OBParserDELETE, 0)
}

func (s *Delete_with_opt_hintContext) DELETE_HINT_BEGIN() antlr.TerminalNode {
	return s.GetToken(OBParserDELETE_HINT_BEGIN, 0)
}

func (s *Delete_with_opt_hintContext) Hint_list_with_end() IHint_list_with_endContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHint_list_with_endContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHint_list_with_endContext)
}

func (s *Delete_with_opt_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_with_opt_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delete_with_opt_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDelete_with_opt_hint(s)
	}
}

func (s *Delete_with_opt_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDelete_with_opt_hint(s)
	}
}

func (s *Delete_with_opt_hintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDelete_with_opt_hint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Delete_with_opt_hint() (localctx IDelete_with_opt_hintContext) {
	localctx = NewDelete_with_opt_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, OBParserRULE_delete_with_opt_hint)
	p.SetState(4976)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserDELETE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4973)
			p.Match(OBParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserDELETE_HINT_BEGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4974)
			p.Match(OBParserDELETE_HINT_BEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4975)
			p.Hint_list_with_end()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimple_selectContext is an interface to support dynamic dispatch.
type ISimple_selectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_with_opt_hint() ISelect_with_opt_hintContext
	Select_expr_list() ISelect_expr_listContext
	Into_opt() IInto_optContext
	FROM() antlr.TerminalNode
	From_list() IFrom_listContext
	Query_expression_option_list() IQuery_expression_option_listContext
	WHERE() antlr.TerminalNode
	Opt_hint_value() IOpt_hint_valueContext
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	Groupby_clause() IGroupby_clauseContext
	HAVING() antlr.TerminalNode
	WINDOW() antlr.TerminalNode
	Named_windows() INamed_windowsContext

	// IsSimple_selectContext differentiates from other interfaces.
	IsSimple_selectContext()
}

type Simple_selectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_selectContext() *Simple_selectContext {
	var p = new(Simple_selectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_simple_select
	return p
}

func InitEmptySimple_selectContext(p *Simple_selectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_simple_select
}

func (*Simple_selectContext) IsSimple_selectContext() {}

func NewSimple_selectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_selectContext {
	var p = new(Simple_selectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_simple_select

	return p
}

func (s *Simple_selectContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_selectContext) Select_with_opt_hint() ISelect_with_opt_hintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_with_opt_hintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_with_opt_hintContext)
}

func (s *Simple_selectContext) Select_expr_list() ISelect_expr_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_expr_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_expr_listContext)
}

func (s *Simple_selectContext) Into_opt() IInto_optContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_optContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_optContext)
}

func (s *Simple_selectContext) FROM() antlr.TerminalNode {
	return s.GetToken(OBParserFROM, 0)
}

func (s *Simple_selectContext) From_list() IFrom_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_listContext)
}

func (s *Simple_selectContext) Query_expression_option_list() IQuery_expression_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_expression_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_expression_option_listContext)
}

func (s *Simple_selectContext) WHERE() antlr.TerminalNode {
	return s.GetToken(OBParserWHERE, 0)
}

func (s *Simple_selectContext) Opt_hint_value() IOpt_hint_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_hint_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_hint_valueContext)
}

func (s *Simple_selectContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Simple_selectContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Simple_selectContext) GROUP() antlr.TerminalNode {
	return s.GetToken(OBParserGROUP, 0)
}

func (s *Simple_selectContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Simple_selectContext) Groupby_clause() IGroupby_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupby_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupby_clauseContext)
}

func (s *Simple_selectContext) HAVING() antlr.TerminalNode {
	return s.GetToken(OBParserHAVING, 0)
}

func (s *Simple_selectContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(OBParserWINDOW, 0)
}

func (s *Simple_selectContext) Named_windows() INamed_windowsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_windowsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_windowsContext)
}

func (s *Simple_selectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_selectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_selectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSimple_select(s)
	}
}

func (s *Simple_selectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSimple_select(s)
	}
}

func (s *Simple_selectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSimple_select(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Simple_select() (localctx ISimple_selectContext) {
	localctx = NewSimple_selectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, OBParserRULE_simple_select)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4978)
		p.Select_with_opt_hint()
	}
	p.SetState(4980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserSQL_CALC_FOUND_ROWS || _la == OBParserUNIQUE {
		{
			p.SetState(4979)
			p.Query_expression_option_list()
		}

	}
	{
		p.SetState(4982)
		p.Select_expr_list()
	}
	{
		p.SetState(4983)
		p.Into_opt()
	}
	{
		p.SetState(4984)
		p.Match(OBParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4985)
		p.From_list()
	}
	p.SetState(4990)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 493, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4986)
			p.Match(OBParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4987)
			p.Opt_hint_value()
		}
		{
			p.SetState(4988)
			p.expr(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4995)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 494, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4992)
			p.Match(OBParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4993)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4994)
			p.Groupby_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4999)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 495, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4997)
			p.Match(OBParserHAVING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4998)
			p.expr(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(5003)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 496, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5001)
			p.Match(OBParserWINDOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5002)
			p.Named_windows()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_type_unionContext is an interface to support dynamic dispatch.
type ISet_type_unionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNION() antlr.TerminalNode

	// IsSet_type_unionContext differentiates from other interfaces.
	IsSet_type_unionContext()
}

type Set_type_unionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_type_unionContext() *Set_type_unionContext {
	var p = new(Set_type_unionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_type_union
	return p
}

func InitEmptySet_type_unionContext(p *Set_type_unionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_type_union
}

func (*Set_type_unionContext) IsSet_type_unionContext() {}

func NewSet_type_unionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_type_unionContext {
	var p = new(Set_type_unionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_set_type_union

	return p
}

func (s *Set_type_unionContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_type_unionContext) UNION() antlr.TerminalNode {
	return s.GetToken(OBParserUNION, 0)
}

func (s *Set_type_unionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_type_unionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_type_unionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSet_type_union(s)
	}
}

func (s *Set_type_unionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSet_type_union(s)
	}
}

func (s *Set_type_unionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSet_type_union(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Set_type_union() (localctx ISet_type_unionContext) {
	localctx = NewSet_type_unionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, OBParserRULE_set_type_union)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5005)
		p.Match(OBParserUNION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_type_otherContext is an interface to support dynamic dispatch.
type ISet_type_otherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERSECT() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsSet_type_otherContext differentiates from other interfaces.
	IsSet_type_otherContext()
}

type Set_type_otherContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_type_otherContext() *Set_type_otherContext {
	var p = new(Set_type_otherContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_type_other
	return p
}

func InitEmptySet_type_otherContext(p *Set_type_otherContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_type_other
}

func (*Set_type_otherContext) IsSet_type_otherContext() {}

func NewSet_type_otherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_type_otherContext {
	var p = new(Set_type_otherContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_set_type_other

	return p
}

func (s *Set_type_otherContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_type_otherContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(OBParserINTERSECT, 0)
}

func (s *Set_type_otherContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(OBParserEXCEPT, 0)
}

func (s *Set_type_otherContext) MINUS() antlr.TerminalNode {
	return s.GetToken(OBParserMINUS, 0)
}

func (s *Set_type_otherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_type_otherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_type_otherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSet_type_other(s)
	}
}

func (s *Set_type_otherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSet_type_other(s)
	}
}

func (s *Set_type_otherContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSet_type_other(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Set_type_other() (localctx ISet_type_otherContext) {
	localctx = NewSet_type_otherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, OBParserRULE_set_type_other)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5007)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-264)) & ^0x3f) == 0 && ((int64(1)<<(_la-264))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_typeContext is an interface to support dynamic dispatch.
type ISet_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Set_type_union() ISet_type_unionContext
	Set_expression_option() ISet_expression_optionContext
	Set_type_other() ISet_type_otherContext

	// IsSet_typeContext differentiates from other interfaces.
	IsSet_typeContext()
}

type Set_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_typeContext() *Set_typeContext {
	var p = new(Set_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_type
	return p
}

func InitEmptySet_typeContext(p *Set_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_type
}

func (*Set_typeContext) IsSet_typeContext() {}

func NewSet_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_typeContext {
	var p = new(Set_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_set_type

	return p
}

func (s *Set_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_typeContext) Set_type_union() ISet_type_unionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_type_unionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_type_unionContext)
}

func (s *Set_typeContext) Set_expression_option() ISet_expression_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_expression_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_expression_optionContext)
}

func (s *Set_typeContext) Set_type_other() ISet_type_otherContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_type_otherContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_type_otherContext)
}

func (s *Set_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSet_type(s)
	}
}

func (s *Set_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSet_type(s)
	}
}

func (s *Set_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSet_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Set_type() (localctx ISet_typeContext) {
	localctx = NewSet_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, OBParserRULE_set_type)
	p.SetState(5013)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserUNION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5009)
			p.Set_type_union()
		}
		{
			p.SetState(5010)
			p.Set_expression_option()
		}

	case OBParserEXCEPT, OBParserMINUS, OBParserINTERSECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5012)
			p.Set_type_other()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_expression_optionContext is an interface to support dynamic dispatch.
type ISet_expression_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode

	// IsSet_expression_optionContext differentiates from other interfaces.
	IsSet_expression_optionContext()
}

type Set_expression_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_expression_optionContext() *Set_expression_optionContext {
	var p = new(Set_expression_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_expression_option
	return p
}

func InitEmptySet_expression_optionContext(p *Set_expression_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_expression_option
}

func (*Set_expression_optionContext) IsSet_expression_optionContext() {}

func NewSet_expression_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_expression_optionContext {
	var p = new(Set_expression_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_set_expression_option

	return p
}

func (s *Set_expression_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_expression_optionContext) ALL() antlr.TerminalNode {
	return s.GetToken(OBParserALL, 0)
}

func (s *Set_expression_optionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(OBParserDISTINCT, 0)
}

func (s *Set_expression_optionContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(OBParserUNIQUE, 0)
}

func (s *Set_expression_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_expression_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_expression_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSet_expression_option(s)
	}
}

func (s *Set_expression_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSet_expression_option(s)
	}
}

func (s *Set_expression_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSet_expression_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Set_expression_option() (localctx ISet_expression_optionContext) {
	localctx = NewSet_expression_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, OBParserRULE_set_expression_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5016)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE {
		{
			p.SetState(5015)
			_la = p.GetTokenStream().LA(1)

			if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserUNIQUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_hint_valueContext is an interface to support dynamic dispatch.
type IOpt_hint_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HINT_VALUE() antlr.TerminalNode

	// IsOpt_hint_valueContext differentiates from other interfaces.
	IsOpt_hint_valueContext()
}

type Opt_hint_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_hint_valueContext() *Opt_hint_valueContext {
	var p = new(Opt_hint_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_hint_value
	return p
}

func InitEmptyOpt_hint_valueContext(p *Opt_hint_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_hint_value
}

func (*Opt_hint_valueContext) IsOpt_hint_valueContext() {}

func NewOpt_hint_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_hint_valueContext {
	var p = new(Opt_hint_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_hint_value

	return p
}

func (s *Opt_hint_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_hint_valueContext) HINT_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserHINT_VALUE, 0)
}

func (s *Opt_hint_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_hint_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_hint_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_hint_value(s)
	}
}

func (s *Opt_hint_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_hint_value(s)
	}
}

func (s *Opt_hint_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_hint_value(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_hint_value() (localctx IOpt_hint_valueContext) {
	localctx = NewOpt_hint_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, OBParserRULE_opt_hint_value)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserHINT_VALUE {
		{
			p.SetState(5018)
			p.Match(OBParserHINT_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimit_clauseContext is an interface to support dynamic dispatch.
type ILimit_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT() antlr.TerminalNode
	AllLimit_expr() []ILimit_exprContext
	Limit_expr(i int) ILimit_exprContext
	OFFSET() antlr.TerminalNode
	Comma() antlr.TerminalNode

	// IsLimit_clauseContext differentiates from other interfaces.
	IsLimit_clauseContext()
}

type Limit_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimit_clauseContext() *Limit_clauseContext {
	var p = new(Limit_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_limit_clause
	return p
}

func InitEmptyLimit_clauseContext(p *Limit_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_limit_clause
}

func (*Limit_clauseContext) IsLimit_clauseContext() {}

func NewLimit_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Limit_clauseContext {
	var p = new(Limit_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_limit_clause

	return p
}

func (s *Limit_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Limit_clauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(OBParserLIMIT, 0)
}

func (s *Limit_clauseContext) AllLimit_expr() []ILimit_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILimit_exprContext); ok {
			len++
		}
	}

	tst := make([]ILimit_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILimit_exprContext); ok {
			tst[i] = t.(ILimit_exprContext)
			i++
		}
	}

	return tst
}

func (s *Limit_clauseContext) Limit_expr(i int) ILimit_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimit_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimit_exprContext)
}

func (s *Limit_clauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(OBParserOFFSET, 0)
}

func (s *Limit_clauseContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Limit_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Limit_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Limit_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLimit_clause(s)
	}
}

func (s *Limit_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLimit_clause(s)
	}
}

func (s *Limit_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLimit_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Limit_clause() (localctx ILimit_clauseContext) {
	localctx = NewLimit_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, OBParserRULE_limit_clause)
	p.SetState(5033)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 500, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5021)
			p.Match(OBParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5022)
			p.Limit_expr()
		}
		{
			p.SetState(5023)
			p.Match(OBParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5024)
			p.Limit_expr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5026)
			p.Match(OBParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5027)
			p.Limit_expr()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5028)
			p.Match(OBParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5029)
			p.Limit_expr()
		}
		{
			p.SetState(5030)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5031)
			p.Limit_expr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInto_clauseContext is an interface to support dynamic dispatch.
type IInto_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTO() antlr.TerminalNode
	OUTFILE() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	Field_opt() IField_optContext
	Line_opt() ILine_optContext
	Charset_key() ICharset_keyContext
	Charset_name() ICharset_nameContext
	DUMPFILE() antlr.TerminalNode
	Into_var_list() IInto_var_listContext

	// IsInto_clauseContext differentiates from other interfaces.
	IsInto_clauseContext()
}

type Into_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInto_clauseContext() *Into_clauseContext {
	var p = new(Into_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_into_clause
	return p
}

func InitEmptyInto_clauseContext(p *Into_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_into_clause
}

func (*Into_clauseContext) IsInto_clauseContext() {}

func NewInto_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Into_clauseContext {
	var p = new(Into_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_into_clause

	return p
}

func (s *Into_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Into_clauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(OBParserINTO, 0)
}

func (s *Into_clauseContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(OBParserOUTFILE, 0)
}

func (s *Into_clauseContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Into_clauseContext) Field_opt() IField_optContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IField_optContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IField_optContext)
}

func (s *Into_clauseContext) Line_opt() ILine_optContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILine_optContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILine_optContext)
}

func (s *Into_clauseContext) Charset_key() ICharset_keyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_keyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_keyContext)
}

func (s *Into_clauseContext) Charset_name() ICharset_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_nameContext)
}

func (s *Into_clauseContext) DUMPFILE() antlr.TerminalNode {
	return s.GetToken(OBParserDUMPFILE, 0)
}

func (s *Into_clauseContext) Into_var_list() IInto_var_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_var_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_var_listContext)
}

func (s *Into_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Into_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Into_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterInto_clause(s)
	}
}

func (s *Into_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitInto_clause(s)
	}
}

func (s *Into_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitInto_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Into_clause() (localctx IInto_clauseContext) {
	localctx = NewInto_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, OBParserRULE_into_clause)
	p.SetState(5051)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 502, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5035)
			p.Match(OBParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5036)
			p.Match(OBParserOUTFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5037)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5041)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 501, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5038)
				p.Charset_key()
			}
			{
				p.SetState(5039)
				p.Charset_name()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5043)
			p.Field_opt()
		}
		{
			p.SetState(5044)
			p.Line_opt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5046)
			p.Match(OBParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5047)
			p.Match(OBParserDUMPFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5048)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5049)
			p.Match(OBParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5050)
			p.Into_var_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInto_optContext is an interface to support dynamic dispatch.
type IInto_optContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Into_clause() IInto_clauseContext

	// IsInto_optContext differentiates from other interfaces.
	IsInto_optContext()
}

type Into_optContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInto_optContext() *Into_optContext {
	var p = new(Into_optContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_into_opt
	return p
}

func InitEmptyInto_optContext(p *Into_optContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_into_opt
}

func (*Into_optContext) IsInto_optContext() {}

func NewInto_optContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Into_optContext {
	var p = new(Into_optContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_into_opt

	return p
}

func (s *Into_optContext) GetParser() antlr.Parser { return s.parser }

func (s *Into_optContext) Into_clause() IInto_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_clauseContext)
}

func (s *Into_optContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Into_optContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Into_optContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterInto_opt(s)
	}
}

func (s *Into_optContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitInto_opt(s)
	}
}

func (s *Into_optContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitInto_opt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Into_opt() (localctx IInto_optContext) {
	localctx = NewInto_optContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, OBParserRULE_into_opt)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(5054)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 503, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5053)
			p.Into_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInto_var_listContext is an interface to support dynamic dispatch.
type IInto_var_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInto_var() []IInto_varContext
	Into_var(i int) IInto_varContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsInto_var_listContext differentiates from other interfaces.
	IsInto_var_listContext()
}

type Into_var_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInto_var_listContext() *Into_var_listContext {
	var p = new(Into_var_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_into_var_list
	return p
}

func InitEmptyInto_var_listContext(p *Into_var_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_into_var_list
}

func (*Into_var_listContext) IsInto_var_listContext() {}

func NewInto_var_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Into_var_listContext {
	var p = new(Into_var_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_into_var_list

	return p
}

func (s *Into_var_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Into_var_listContext) AllInto_var() []IInto_varContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInto_varContext); ok {
			len++
		}
	}

	tst := make([]IInto_varContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInto_varContext); ok {
			tst[i] = t.(IInto_varContext)
			i++
		}
	}

	return tst
}

func (s *Into_var_listContext) Into_var(i int) IInto_varContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_varContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_varContext)
}

func (s *Into_var_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Into_var_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Into_var_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Into_var_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Into_var_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterInto_var_list(s)
	}
}

func (s *Into_var_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitInto_var_list(s)
	}
}

func (s *Into_var_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitInto_var_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Into_var_list() (localctx IInto_var_listContext) {
	localctx = NewInto_var_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, OBParserRULE_into_var_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5056)
		p.Into_var()
	}
	p.SetState(5061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 504, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5057)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5058)
				p.Into_var()
			}

		}
		p.SetState(5063)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 504, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInto_varContext is an interface to support dynamic dispatch.
type IInto_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USER_VARIABLE() antlr.TerminalNode
	Var_name() IVar_nameContext

	// IsInto_varContext differentiates from other interfaces.
	IsInto_varContext()
}

type Into_varContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInto_varContext() *Into_varContext {
	var p = new(Into_varContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_into_var
	return p
}

func InitEmptyInto_varContext(p *Into_varContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_into_var
}

func (*Into_varContext) IsInto_varContext() {}

func NewInto_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Into_varContext {
	var p = new(Into_varContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_into_var

	return p
}

func (s *Into_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Into_varContext) USER_VARIABLE() antlr.TerminalNode {
	return s.GetToken(OBParserUSER_VARIABLE, 0)
}

func (s *Into_varContext) Var_name() IVar_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVar_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVar_nameContext)
}

func (s *Into_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Into_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Into_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterInto_var(s)
	}
}

func (s *Into_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitInto_var(s)
	}
}

func (s *Into_varContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitInto_var(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Into_var() (localctx IInto_varContext) {
	localctx = NewInto_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, OBParserRULE_into_var)
	p.SetState(5066)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserUSER_VARIABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5064)
			p.Match(OBParserUSER_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserNAME_OB, OBParserSTAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5065)
			p.Var_name()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IField_optContext is an interface to support dynamic dispatch.
type IField_optContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Columns_or_fields() IColumns_or_fieldsContext
	Field_term_list() IField_term_listContext
	Empty() IEmptyContext

	// IsField_optContext differentiates from other interfaces.
	IsField_optContext()
}

type Field_optContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_optContext() *Field_optContext {
	var p = new(Field_optContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_field_opt
	return p
}

func InitEmptyField_optContext(p *Field_optContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_field_opt
}

func (*Field_optContext) IsField_optContext() {}

func NewField_optContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_optContext {
	var p = new(Field_optContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_field_opt

	return p
}

func (s *Field_optContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_optContext) Columns_or_fields() IColumns_or_fieldsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumns_or_fieldsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumns_or_fieldsContext)
}

func (s *Field_optContext) Field_term_list() IField_term_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IField_term_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IField_term_listContext)
}

func (s *Field_optContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Field_optContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_optContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_optContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterField_opt(s)
	}
}

func (s *Field_optContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitField_opt(s)
	}
}

func (s *Field_optContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitField_opt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Field_opt() (localctx IField_optContext) {
	localctx = NewField_optContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, OBParserRULE_field_opt)
	p.SetState(5072)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 506, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5068)
			p.Columns_or_fields()
		}
		{
			p.SetState(5069)
			p.Field_term_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5071)
			p.Empty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IField_term_listContext is an interface to support dynamic dispatch.
type IField_term_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllField_term() []IField_termContext
	Field_term(i int) IField_termContext

	// IsField_term_listContext differentiates from other interfaces.
	IsField_term_listContext()
}

type Field_term_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_term_listContext() *Field_term_listContext {
	var p = new(Field_term_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_field_term_list
	return p
}

func InitEmptyField_term_listContext(p *Field_term_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_field_term_list
}

func (*Field_term_listContext) IsField_term_listContext() {}

func NewField_term_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_term_listContext {
	var p = new(Field_term_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_field_term_list

	return p
}

func (s *Field_term_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_term_listContext) AllField_term() []IField_termContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IField_termContext); ok {
			len++
		}
	}

	tst := make([]IField_termContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IField_termContext); ok {
			tst[i] = t.(IField_termContext)
			i++
		}
	}

	return tst
}

func (s *Field_term_listContext) Field_term(i int) IField_termContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IField_termContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IField_termContext)
}

func (s *Field_term_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_term_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_term_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterField_term_list(s)
	}
}

func (s *Field_term_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitField_term_list(s)
	}
}

func (s *Field_term_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitField_term_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Field_term_list() (localctx IField_term_listContext) {
	localctx = NewField_term_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, OBParserRULE_field_term_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5075)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(5074)
				p.Field_term()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(5077)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 507, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IField_termContext is an interface to support dynamic dispatch.
type IField_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TERMINATED() antlr.TerminalNode
	BY() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	OPTIONALLY() antlr.TerminalNode
	ENCLOSED() antlr.TerminalNode
	ESCAPED() antlr.TerminalNode

	// IsField_termContext differentiates from other interfaces.
	IsField_termContext()
}

type Field_termContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_termContext() *Field_termContext {
	var p = new(Field_termContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_field_term
	return p
}

func InitEmptyField_termContext(p *Field_termContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_field_term
}

func (*Field_termContext) IsField_termContext() {}

func NewField_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_termContext {
	var p = new(Field_termContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_field_term

	return p
}

func (s *Field_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_termContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(OBParserTERMINATED, 0)
}

func (s *Field_termContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Field_termContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Field_termContext) OPTIONALLY() antlr.TerminalNode {
	return s.GetToken(OBParserOPTIONALLY, 0)
}

func (s *Field_termContext) ENCLOSED() antlr.TerminalNode {
	return s.GetToken(OBParserENCLOSED, 0)
}

func (s *Field_termContext) ESCAPED() antlr.TerminalNode {
	return s.GetToken(OBParserESCAPED, 0)
}

func (s *Field_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterField_term(s)
	}
}

func (s *Field_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitField_term(s)
	}
}

func (s *Field_termContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitField_term(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Field_term() (localctx IField_termContext) {
	localctx = NewField_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, OBParserRULE_field_term)
	p.SetState(5092)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserTERMINATED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5079)
			p.Match(OBParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5080)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5081)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserOPTIONALLY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5082)
			p.Match(OBParserOPTIONALLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5083)
			p.Match(OBParserENCLOSED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5084)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5085)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserENCLOSED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5086)
			p.Match(OBParserENCLOSED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5087)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5088)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserESCAPED:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5089)
			p.Match(OBParserESCAPED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5090)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5091)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILine_optContext is an interface to support dynamic dispatch.
type ILine_optContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LINES() antlr.TerminalNode
	Line_term_list() ILine_term_listContext
	Empty() IEmptyContext

	// IsLine_optContext differentiates from other interfaces.
	IsLine_optContext()
}

type Line_optContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLine_optContext() *Line_optContext {
	var p = new(Line_optContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_line_opt
	return p
}

func InitEmptyLine_optContext(p *Line_optContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_line_opt
}

func (*Line_optContext) IsLine_optContext() {}

func NewLine_optContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Line_optContext {
	var p = new(Line_optContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_line_opt

	return p
}

func (s *Line_optContext) GetParser() antlr.Parser { return s.parser }

func (s *Line_optContext) LINES() antlr.TerminalNode {
	return s.GetToken(OBParserLINES, 0)
}

func (s *Line_optContext) Line_term_list() ILine_term_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILine_term_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILine_term_listContext)
}

func (s *Line_optContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Line_optContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Line_optContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Line_optContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLine_opt(s)
	}
}

func (s *Line_optContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLine_opt(s)
	}
}

func (s *Line_optContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLine_opt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Line_opt() (localctx ILine_optContext) {
	localctx = NewLine_optContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, OBParserRULE_line_opt)
	p.SetState(5097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 509, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5094)
			p.Match(OBParserLINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5095)
			p.Line_term_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5096)
			p.Empty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILine_term_listContext is an interface to support dynamic dispatch.
type ILine_term_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLine_term() []ILine_termContext
	Line_term(i int) ILine_termContext

	// IsLine_term_listContext differentiates from other interfaces.
	IsLine_term_listContext()
}

type Line_term_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLine_term_listContext() *Line_term_listContext {
	var p = new(Line_term_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_line_term_list
	return p
}

func InitEmptyLine_term_listContext(p *Line_term_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_line_term_list
}

func (*Line_term_listContext) IsLine_term_listContext() {}

func NewLine_term_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Line_term_listContext {
	var p = new(Line_term_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_line_term_list

	return p
}

func (s *Line_term_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Line_term_listContext) AllLine_term() []ILine_termContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILine_termContext); ok {
			len++
		}
	}

	tst := make([]ILine_termContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILine_termContext); ok {
			tst[i] = t.(ILine_termContext)
			i++
		}
	}

	return tst
}

func (s *Line_term_listContext) Line_term(i int) ILine_termContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILine_termContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILine_termContext)
}

func (s *Line_term_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Line_term_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Line_term_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLine_term_list(s)
	}
}

func (s *Line_term_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLine_term_list(s)
	}
}

func (s *Line_term_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLine_term_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Line_term_list() (localctx ILine_term_listContext) {
	localctx = NewLine_term_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, OBParserRULE_line_term_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5100)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(5099)
				p.Line_term()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(5102)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 510, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILine_termContext is an interface to support dynamic dispatch.
type ILine_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TERMINATED() antlr.TerminalNode
	BY() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	STARTING() antlr.TerminalNode

	// IsLine_termContext differentiates from other interfaces.
	IsLine_termContext()
}

type Line_termContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLine_termContext() *Line_termContext {
	var p = new(Line_termContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_line_term
	return p
}

func InitEmptyLine_termContext(p *Line_termContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_line_term
}

func (*Line_termContext) IsLine_termContext() {}

func NewLine_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Line_termContext {
	var p = new(Line_termContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_line_term

	return p
}

func (s *Line_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Line_termContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(OBParserTERMINATED, 0)
}

func (s *Line_termContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Line_termContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Line_termContext) STARTING() antlr.TerminalNode {
	return s.GetToken(OBParserSTARTING, 0)
}

func (s *Line_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Line_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Line_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLine_term(s)
	}
}

func (s *Line_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLine_term(s)
	}
}

func (s *Line_termContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLine_term(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Line_term() (localctx ILine_termContext) {
	localctx = NewLine_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, OBParserRULE_line_term)
	p.SetState(5110)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserTERMINATED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5104)
			p.Match(OBParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5105)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5106)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserSTARTING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5107)
			p.Match(OBParserSTARTING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5108)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5109)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHint_list_with_endContext is an interface to support dynamic dispatch.
type IHint_list_with_endContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HINT_END() antlr.TerminalNode
	Hint_options() IHint_optionsContext
	Opt_hint_list() IOpt_hint_listContext
	Comma() antlr.TerminalNode

	// IsHint_list_with_endContext differentiates from other interfaces.
	IsHint_list_with_endContext()
}

type Hint_list_with_endContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHint_list_with_endContext() *Hint_list_with_endContext {
	var p = new(Hint_list_with_endContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_hint_list_with_end
	return p
}

func InitEmptyHint_list_with_endContext(p *Hint_list_with_endContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_hint_list_with_end
}

func (*Hint_list_with_endContext) IsHint_list_with_endContext() {}

func NewHint_list_with_endContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hint_list_with_endContext {
	var p = new(Hint_list_with_endContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_hint_list_with_end

	return p
}

func (s *Hint_list_with_endContext) GetParser() antlr.Parser { return s.parser }

func (s *Hint_list_with_endContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(OBParserHINT_END, 0)
}

func (s *Hint_list_with_endContext) Hint_options() IHint_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHint_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHint_optionsContext)
}

func (s *Hint_list_with_endContext) Opt_hint_list() IOpt_hint_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_hint_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_hint_listContext)
}

func (s *Hint_list_with_endContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Hint_list_with_endContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hint_list_with_endContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hint_list_with_endContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterHint_list_with_end(s)
	}
}

func (s *Hint_list_with_endContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitHint_list_with_end(s)
	}
}

func (s *Hint_list_with_endContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitHint_list_with_end(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Hint_list_with_end() (localctx IHint_list_with_endContext) {
	localctx = NewHint_list_with_endContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, OBParserRULE_hint_list_with_end)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(5117)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 512, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5112)
			p.Hint_options()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 512, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(5113)
			p.opt_hint_list(0)
		}
		{
			p.SetState(5114)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5115)
			p.Hint_options()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(5119)
		p.Match(OBParserHINT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_hint_listContext is an interface to support dynamic dispatch.
type IOpt_hint_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Hint_options() IHint_optionsContext
	Empty() IEmptyContext
	Opt_hint_list() IOpt_hint_listContext
	Comma() antlr.TerminalNode

	// IsOpt_hint_listContext differentiates from other interfaces.
	IsOpt_hint_listContext()
}

type Opt_hint_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_hint_listContext() *Opt_hint_listContext {
	var p = new(Opt_hint_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_hint_list
	return p
}

func InitEmptyOpt_hint_listContext(p *Opt_hint_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_hint_list
}

func (*Opt_hint_listContext) IsOpt_hint_listContext() {}

func NewOpt_hint_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_hint_listContext {
	var p = new(Opt_hint_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_hint_list

	return p
}

func (s *Opt_hint_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_hint_listContext) Hint_options() IHint_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHint_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHint_optionsContext)
}

func (s *Opt_hint_listContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Opt_hint_listContext) Opt_hint_list() IOpt_hint_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_hint_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_hint_listContext)
}

func (s *Opt_hint_listContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Opt_hint_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_hint_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_hint_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_hint_list(s)
	}
}

func (s *Opt_hint_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_hint_list(s)
	}
}

func (s *Opt_hint_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_hint_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_hint_list() (localctx IOpt_hint_listContext) {
	return p.opt_hint_list(0)
}

func (p *OBParser) opt_hint_list(_p int) (localctx IOpt_hint_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewOpt_hint_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IOpt_hint_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 504
	p.EnterRecursionRule(localctx, 504, OBParserRULE_opt_hint_list, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5124)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 513, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5122)
			p.Hint_options()
		}

	case 2:
		{
			p.SetState(5123)
			p.Empty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 514, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewOpt_hint_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, OBParserRULE_opt_hint_list)
			p.SetState(5126)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(5127)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5128)
				p.Hint_options()
			}

		}
		p.SetState(5133)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 514, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHint_optionsContext is an interface to support dynamic dispatch.
type IHint_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllHint_option() []IHint_optionContext
	Hint_option(i int) IHint_optionContext

	// IsHint_optionsContext differentiates from other interfaces.
	IsHint_optionsContext()
}

type Hint_optionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHint_optionsContext() *Hint_optionsContext {
	var p = new(Hint_optionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_hint_options
	return p
}

func InitEmptyHint_optionsContext(p *Hint_optionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_hint_options
}

func (*Hint_optionsContext) IsHint_optionsContext() {}

func NewHint_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hint_optionsContext {
	var p = new(Hint_optionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_hint_options

	return p
}

func (s *Hint_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Hint_optionsContext) AllHint_option() []IHint_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHint_optionContext); ok {
			len++
		}
	}

	tst := make([]IHint_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHint_optionContext); ok {
			tst[i] = t.(IHint_optionContext)
			i++
		}
	}

	return tst
}

func (s *Hint_optionsContext) Hint_option(i int) IHint_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHint_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHint_optionContext)
}

func (s *Hint_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hint_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hint_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterHint_options(s)
	}
}

func (s *Hint_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitHint_options(s)
	}
}

func (s *Hint_optionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitHint_options(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Hint_options() (localctx IHint_optionsContext) {
	localctx = NewHint_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, OBParserRULE_hint_options)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5135)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(5134)
				p.Hint_option()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(5137)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 515, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IName_listContext is an interface to support dynamic dispatch.
type IName_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME_OB() antlr.TerminalNode
	Name_list() IName_listContext
	Comma() antlr.TerminalNode

	// IsName_listContext differentiates from other interfaces.
	IsName_listContext()
}

type Name_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_listContext() *Name_listContext {
	var p = new(Name_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_name_list
	return p
}

func InitEmptyName_listContext(p *Name_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_name_list
}

func (*Name_listContext) IsName_listContext() {}

func NewName_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_listContext {
	var p = new(Name_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_name_list

	return p
}

func (s *Name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_listContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Name_listContext) Name_list() IName_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IName_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *Name_listContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterName_list(s)
	}
}

func (s *Name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitName_list(s)
	}
}

func (s *Name_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitName_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Name_list() (localctx IName_listContext) {
	return p.name_list(0)
}

func (p *OBParser) name_list(_p int) (localctx IName_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewName_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IName_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 508
	p.EnterRecursionRule(localctx, 508, OBParserRULE_name_list, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5140)
		p.Match(OBParserNAME_OB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5149)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 517, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5147)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 516, p.GetParserRuleContext()) {
			case 1:
				localctx = NewName_listContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_name_list)
				p.SetState(5142)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(5143)
					p.Match(OBParserNAME_OB)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewName_listContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_name_list)
				p.SetState(5144)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5145)
					p.Match(OBParserComma)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5146)
					p.Match(OBParserNAME_OB)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5151)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 517, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHint_optionContext is an interface to support dynamic dispatch.
type IHint_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NO_REWRITE() antlr.TerminalNode
	READ_CONSISTENCY() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Consistency_level() IConsistency_levelContext
	RightParen() antlr.TerminalNode
	INDEX_HINT() antlr.TerminalNode
	Qb_name_option() IQb_name_optionContext
	Relation_factor_in_hint() IRelation_factor_in_hintContext
	NAME_OB() antlr.TerminalNode
	QUERY_TIMEOUT() antlr.TerminalNode
	AllINTNUM() []antlr.TerminalNode
	INTNUM(i int) antlr.TerminalNode
	FROZEN_VERSION() antlr.TerminalNode
	TOPK() antlr.TerminalNode
	HOTSPOT() antlr.TerminalNode
	LOG_LEVEL() antlr.TerminalNode
	AllQuote() []antlr.TerminalNode
	Quote(i int) antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	LEADING_HINT() antlr.TerminalNode
	Relation_factor_in_leading_hint_list_entry() IRelation_factor_in_leading_hint_list_entryContext
	Relation_factor_in_hint_list() IRelation_factor_in_hint_listContext
	ORDERED() antlr.TerminalNode
	FULL_HINT() antlr.TerminalNode
	USE_PLAN_CACHE() antlr.TerminalNode
	Use_plan_cache_type() IUse_plan_cache_typeContext
	USE_MERGE() antlr.TerminalNode
	Relation_factor_in_use_join_hint_list() IRelation_factor_in_use_join_hint_listContext
	NO_USE_MERGE() antlr.TerminalNode
	USE_HASH() antlr.TerminalNode
	NO_USE_HASH() antlr.TerminalNode
	USE_NL() antlr.TerminalNode
	NO_USE_NL() antlr.TerminalNode
	USE_BNL() antlr.TerminalNode
	NO_USE_BNL() antlr.TerminalNode
	USE_NL_MATERIALIZATION() antlr.TerminalNode
	NO_USE_NL_MATERIALIZATION() antlr.TerminalNode
	USE_HASH_AGGREGATION() antlr.TerminalNode
	NO_USE_HASH_AGGREGATION() antlr.TerminalNode
	MERGE_HINT() antlr.TerminalNode
	NO_MERGE_HINT() antlr.TerminalNode
	NO_EXPAND() antlr.TerminalNode
	USE_CONCAT() antlr.TerminalNode
	UNNEST() antlr.TerminalNode
	NO_UNNEST() antlr.TerminalNode
	PLACE_GROUP_BY() antlr.TerminalNode
	NO_PLACE_GROUP_BY() antlr.TerminalNode
	NO_PRED_DEDUCE() antlr.TerminalNode
	USE_JIT() antlr.TerminalNode
	Use_jit_type() IUse_jit_typeContext
	NO_USE_JIT() antlr.TerminalNode
	USE_LATE_MATERIALIZATION() antlr.TerminalNode
	NO_USE_LATE_MATERIALIZATION() antlr.TerminalNode
	TRACE_LOG() antlr.TerminalNode
	STAT() antlr.TerminalNode
	Tracing_num_list() ITracing_num_listContext
	TRACING() antlr.TerminalNode
	USE_PX() antlr.TerminalNode
	NO_USE_PX() antlr.TerminalNode
	TRANS_PARAM() antlr.TerminalNode
	Trans_param_name() ITrans_param_nameContext
	Trans_param_value() ITrans_param_valueContext
	Comma() antlr.TerminalNode
	PX_JOIN_FILTER() antlr.TerminalNode
	FORCE_REFRESH_LOCATION_CACHE() antlr.TerminalNode
	QB_NAME() antlr.TerminalNode
	MAX_CONCURRENT() antlr.TerminalNode
	PARALLEL() antlr.TerminalNode
	PQ_DISTRIBUTE() antlr.TerminalNode
	Relation_factor_in_pq_hint() IRelation_factor_in_pq_hintContext
	AllDistribute_method() []IDistribute_methodContext
	Distribute_method(i int) IDistribute_methodContext
	Opt_comma() IOpt_commaContext
	LOAD_BATCH_SIZE() antlr.TerminalNode
	PARSER_SYNTAX_ERROR() antlr.TerminalNode

	// IsHint_optionContext differentiates from other interfaces.
	IsHint_optionContext()
}

type Hint_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHint_optionContext() *Hint_optionContext {
	var p = new(Hint_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_hint_option
	return p
}

func InitEmptyHint_optionContext(p *Hint_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_hint_option
}

func (*Hint_optionContext) IsHint_optionContext() {}

func NewHint_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hint_optionContext {
	var p = new(Hint_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_hint_option

	return p
}

func (s *Hint_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Hint_optionContext) NO_REWRITE() antlr.TerminalNode {
	return s.GetToken(OBParserNO_REWRITE, 0)
}

func (s *Hint_optionContext) READ_CONSISTENCY() antlr.TerminalNode {
	return s.GetToken(OBParserREAD_CONSISTENCY, 0)
}

func (s *Hint_optionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Hint_optionContext) Consistency_level() IConsistency_levelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConsistency_levelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConsistency_levelContext)
}

func (s *Hint_optionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Hint_optionContext) INDEX_HINT() antlr.TerminalNode {
	return s.GetToken(OBParserINDEX_HINT, 0)
}

func (s *Hint_optionContext) Qb_name_option() IQb_name_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQb_name_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQb_name_optionContext)
}

func (s *Hint_optionContext) Relation_factor_in_hint() IRelation_factor_in_hintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_hintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_hintContext)
}

func (s *Hint_optionContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Hint_optionContext) QUERY_TIMEOUT() antlr.TerminalNode {
	return s.GetToken(OBParserQUERY_TIMEOUT, 0)
}

func (s *Hint_optionContext) AllINTNUM() []antlr.TerminalNode {
	return s.GetTokens(OBParserINTNUM)
}

func (s *Hint_optionContext) INTNUM(i int) antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, i)
}

func (s *Hint_optionContext) FROZEN_VERSION() antlr.TerminalNode {
	return s.GetToken(OBParserFROZEN_VERSION, 0)
}

func (s *Hint_optionContext) TOPK() antlr.TerminalNode {
	return s.GetToken(OBParserTOPK, 0)
}

func (s *Hint_optionContext) HOTSPOT() antlr.TerminalNode {
	return s.GetToken(OBParserHOTSPOT, 0)
}

func (s *Hint_optionContext) LOG_LEVEL() antlr.TerminalNode {
	return s.GetToken(OBParserLOG_LEVEL, 0)
}

func (s *Hint_optionContext) AllQuote() []antlr.TerminalNode {
	return s.GetTokens(OBParserQuote)
}

func (s *Hint_optionContext) Quote(i int) antlr.TerminalNode {
	return s.GetToken(OBParserQuote, i)
}

func (s *Hint_optionContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Hint_optionContext) LEADING_HINT() antlr.TerminalNode {
	return s.GetToken(OBParserLEADING_HINT, 0)
}

func (s *Hint_optionContext) Relation_factor_in_leading_hint_list_entry() IRelation_factor_in_leading_hint_list_entryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_leading_hint_list_entryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_leading_hint_list_entryContext)
}

func (s *Hint_optionContext) Relation_factor_in_hint_list() IRelation_factor_in_hint_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_hint_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_hint_listContext)
}

func (s *Hint_optionContext) ORDERED() antlr.TerminalNode {
	return s.GetToken(OBParserORDERED, 0)
}

func (s *Hint_optionContext) FULL_HINT() antlr.TerminalNode {
	return s.GetToken(OBParserFULL_HINT, 0)
}

func (s *Hint_optionContext) USE_PLAN_CACHE() antlr.TerminalNode {
	return s.GetToken(OBParserUSE_PLAN_CACHE, 0)
}

func (s *Hint_optionContext) Use_plan_cache_type() IUse_plan_cache_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUse_plan_cache_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUse_plan_cache_typeContext)
}

func (s *Hint_optionContext) USE_MERGE() antlr.TerminalNode {
	return s.GetToken(OBParserUSE_MERGE, 0)
}

func (s *Hint_optionContext) Relation_factor_in_use_join_hint_list() IRelation_factor_in_use_join_hint_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_use_join_hint_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_use_join_hint_listContext)
}

func (s *Hint_optionContext) NO_USE_MERGE() antlr.TerminalNode {
	return s.GetToken(OBParserNO_USE_MERGE, 0)
}

func (s *Hint_optionContext) USE_HASH() antlr.TerminalNode {
	return s.GetToken(OBParserUSE_HASH, 0)
}

func (s *Hint_optionContext) NO_USE_HASH() antlr.TerminalNode {
	return s.GetToken(OBParserNO_USE_HASH, 0)
}

func (s *Hint_optionContext) USE_NL() antlr.TerminalNode {
	return s.GetToken(OBParserUSE_NL, 0)
}

func (s *Hint_optionContext) NO_USE_NL() antlr.TerminalNode {
	return s.GetToken(OBParserNO_USE_NL, 0)
}

func (s *Hint_optionContext) USE_BNL() antlr.TerminalNode {
	return s.GetToken(OBParserUSE_BNL, 0)
}

func (s *Hint_optionContext) NO_USE_BNL() antlr.TerminalNode {
	return s.GetToken(OBParserNO_USE_BNL, 0)
}

func (s *Hint_optionContext) USE_NL_MATERIALIZATION() antlr.TerminalNode {
	return s.GetToken(OBParserUSE_NL_MATERIALIZATION, 0)
}

func (s *Hint_optionContext) NO_USE_NL_MATERIALIZATION() antlr.TerminalNode {
	return s.GetToken(OBParserNO_USE_NL_MATERIALIZATION, 0)
}

func (s *Hint_optionContext) USE_HASH_AGGREGATION() antlr.TerminalNode {
	return s.GetToken(OBParserUSE_HASH_AGGREGATION, 0)
}

func (s *Hint_optionContext) NO_USE_HASH_AGGREGATION() antlr.TerminalNode {
	return s.GetToken(OBParserNO_USE_HASH_AGGREGATION, 0)
}

func (s *Hint_optionContext) MERGE_HINT() antlr.TerminalNode {
	return s.GetToken(OBParserMERGE_HINT, 0)
}

func (s *Hint_optionContext) NO_MERGE_HINT() antlr.TerminalNode {
	return s.GetToken(OBParserNO_MERGE_HINT, 0)
}

func (s *Hint_optionContext) NO_EXPAND() antlr.TerminalNode {
	return s.GetToken(OBParserNO_EXPAND, 0)
}

func (s *Hint_optionContext) USE_CONCAT() antlr.TerminalNode {
	return s.GetToken(OBParserUSE_CONCAT, 0)
}

func (s *Hint_optionContext) UNNEST() antlr.TerminalNode {
	return s.GetToken(OBParserUNNEST, 0)
}

func (s *Hint_optionContext) NO_UNNEST() antlr.TerminalNode {
	return s.GetToken(OBParserNO_UNNEST, 0)
}

func (s *Hint_optionContext) PLACE_GROUP_BY() antlr.TerminalNode {
	return s.GetToken(OBParserPLACE_GROUP_BY, 0)
}

func (s *Hint_optionContext) NO_PLACE_GROUP_BY() antlr.TerminalNode {
	return s.GetToken(OBParserNO_PLACE_GROUP_BY, 0)
}

func (s *Hint_optionContext) NO_PRED_DEDUCE() antlr.TerminalNode {
	return s.GetToken(OBParserNO_PRED_DEDUCE, 0)
}

func (s *Hint_optionContext) USE_JIT() antlr.TerminalNode {
	return s.GetToken(OBParserUSE_JIT, 0)
}

func (s *Hint_optionContext) Use_jit_type() IUse_jit_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUse_jit_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUse_jit_typeContext)
}

func (s *Hint_optionContext) NO_USE_JIT() antlr.TerminalNode {
	return s.GetToken(OBParserNO_USE_JIT, 0)
}

func (s *Hint_optionContext) USE_LATE_MATERIALIZATION() antlr.TerminalNode {
	return s.GetToken(OBParserUSE_LATE_MATERIALIZATION, 0)
}

func (s *Hint_optionContext) NO_USE_LATE_MATERIALIZATION() antlr.TerminalNode {
	return s.GetToken(OBParserNO_USE_LATE_MATERIALIZATION, 0)
}

func (s *Hint_optionContext) TRACE_LOG() antlr.TerminalNode {
	return s.GetToken(OBParserTRACE_LOG, 0)
}

func (s *Hint_optionContext) STAT() antlr.TerminalNode {
	return s.GetToken(OBParserSTAT, 0)
}

func (s *Hint_optionContext) Tracing_num_list() ITracing_num_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITracing_num_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITracing_num_listContext)
}

func (s *Hint_optionContext) TRACING() antlr.TerminalNode {
	return s.GetToken(OBParserTRACING, 0)
}

func (s *Hint_optionContext) USE_PX() antlr.TerminalNode {
	return s.GetToken(OBParserUSE_PX, 0)
}

func (s *Hint_optionContext) NO_USE_PX() antlr.TerminalNode {
	return s.GetToken(OBParserNO_USE_PX, 0)
}

func (s *Hint_optionContext) TRANS_PARAM() antlr.TerminalNode {
	return s.GetToken(OBParserTRANS_PARAM, 0)
}

func (s *Hint_optionContext) Trans_param_name() ITrans_param_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrans_param_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrans_param_nameContext)
}

func (s *Hint_optionContext) Trans_param_value() ITrans_param_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrans_param_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrans_param_valueContext)
}

func (s *Hint_optionContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Hint_optionContext) PX_JOIN_FILTER() antlr.TerminalNode {
	return s.GetToken(OBParserPX_JOIN_FILTER, 0)
}

func (s *Hint_optionContext) FORCE_REFRESH_LOCATION_CACHE() antlr.TerminalNode {
	return s.GetToken(OBParserFORCE_REFRESH_LOCATION_CACHE, 0)
}

func (s *Hint_optionContext) QB_NAME() antlr.TerminalNode {
	return s.GetToken(OBParserQB_NAME, 0)
}

func (s *Hint_optionContext) MAX_CONCURRENT() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_CONCURRENT, 0)
}

func (s *Hint_optionContext) PARALLEL() antlr.TerminalNode {
	return s.GetToken(OBParserPARALLEL, 0)
}

func (s *Hint_optionContext) PQ_DISTRIBUTE() antlr.TerminalNode {
	return s.GetToken(OBParserPQ_DISTRIBUTE, 0)
}

func (s *Hint_optionContext) Relation_factor_in_pq_hint() IRelation_factor_in_pq_hintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_pq_hintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_pq_hintContext)
}

func (s *Hint_optionContext) AllDistribute_method() []IDistribute_methodContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDistribute_methodContext); ok {
			len++
		}
	}

	tst := make([]IDistribute_methodContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDistribute_methodContext); ok {
			tst[i] = t.(IDistribute_methodContext)
			i++
		}
	}

	return tst
}

func (s *Hint_optionContext) Distribute_method(i int) IDistribute_methodContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistribute_methodContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistribute_methodContext)
}

func (s *Hint_optionContext) Opt_comma() IOpt_commaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_commaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_commaContext)
}

func (s *Hint_optionContext) LOAD_BATCH_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserLOAD_BATCH_SIZE, 0)
}

func (s *Hint_optionContext) PARSER_SYNTAX_ERROR() antlr.TerminalNode {
	return s.GetToken(OBParserPARSER_SYNTAX_ERROR, 0)
}

func (s *Hint_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hint_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hint_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterHint_option(s)
	}
}

func (s *Hint_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitHint_option(s)
	}
}

func (s *Hint_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitHint_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Hint_option() (localctx IHint_optionContext) {
	localctx = NewHint_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, OBParserRULE_hint_option)
	var _la int

	p.SetState(5403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 530, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5152)
			p.Match(OBParserNO_REWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5153)
			p.Match(OBParserREAD_CONSISTENCY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5154)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5155)
			p.Consistency_level()
		}
		{
			p.SetState(5156)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5158)
			p.Match(OBParserINDEX_HINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5159)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5160)
			p.Qb_name_option()
		}
		{
			p.SetState(5161)
			p.Relation_factor_in_hint()
		}
		{
			p.SetState(5162)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5163)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5165)
			p.Match(OBParserQUERY_TIMEOUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5166)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5167)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5168)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5169)
			p.Match(OBParserFROZEN_VERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5170)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5171)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5172)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5173)
			p.Match(OBParserTOPK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5174)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5175)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5176)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5177)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5178)
			p.Match(OBParserHOTSPOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5179)
			p.Match(OBParserLOG_LEVEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5180)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5181)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5182)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5183)
			p.Match(OBParserLOG_LEVEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5184)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5185)
			p.Match(OBParserQuote)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5186)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5187)
			p.Match(OBParserQuote)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5188)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5189)
			p.Match(OBParserLEADING_HINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5190)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5191)
			p.Qb_name_option()
		}
		{
			p.SetState(5192)
			p.Relation_factor_in_leading_hint_list_entry()
		}
		{
			p.SetState(5193)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5195)
			p.Match(OBParserLEADING_HINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5196)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5197)
			p.Qb_name_option()
		}
		{
			p.SetState(5198)
			p.Relation_factor_in_hint_list()
		}
		{
			p.SetState(5199)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5201)
			p.Match(OBParserORDERED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5202)
			p.Match(OBParserFULL_HINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5203)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5204)
			p.Qb_name_option()
		}
		{
			p.SetState(5205)
			p.Relation_factor_in_hint()
		}
		{
			p.SetState(5206)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5208)
			p.Match(OBParserUSE_PLAN_CACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5209)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5210)
			p.Use_plan_cache_type()
		}
		{
			p.SetState(5211)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5213)
			p.Match(OBParserUSE_MERGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5214)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5215)
			p.Qb_name_option()
		}
		{
			p.SetState(5216)
			p.relation_factor_in_use_join_hint_list(0)
		}
		{
			p.SetState(5217)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5219)
			p.Match(OBParserNO_USE_MERGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5220)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5221)
			p.Qb_name_option()
		}
		{
			p.SetState(5222)
			p.relation_factor_in_use_join_hint_list(0)
		}
		{
			p.SetState(5223)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(5225)
			p.Match(OBParserUSE_HASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5226)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5227)
			p.Qb_name_option()
		}
		{
			p.SetState(5228)
			p.relation_factor_in_use_join_hint_list(0)
		}
		{
			p.SetState(5229)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(5231)
			p.Match(OBParserNO_USE_HASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5232)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5233)
			p.Qb_name_option()
		}
		{
			p.SetState(5234)
			p.relation_factor_in_use_join_hint_list(0)
		}
		{
			p.SetState(5235)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(5237)
			p.Match(OBParserUSE_NL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5238)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5239)
			p.Qb_name_option()
		}
		{
			p.SetState(5240)
			p.relation_factor_in_use_join_hint_list(0)
		}
		{
			p.SetState(5241)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(5243)
			p.Match(OBParserNO_USE_NL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5244)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5245)
			p.Qb_name_option()
		}
		{
			p.SetState(5246)
			p.relation_factor_in_use_join_hint_list(0)
		}
		{
			p.SetState(5247)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(5249)
			p.Match(OBParserUSE_BNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5250)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5251)
			p.Qb_name_option()
		}
		{
			p.SetState(5252)
			p.relation_factor_in_use_join_hint_list(0)
		}
		{
			p.SetState(5253)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(5255)
			p.Match(OBParserNO_USE_BNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5256)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5257)
			p.Qb_name_option()
		}
		{
			p.SetState(5258)
			p.relation_factor_in_use_join_hint_list(0)
		}
		{
			p.SetState(5259)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(5261)
			p.Match(OBParserUSE_NL_MATERIALIZATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5262)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5263)
			p.Qb_name_option()
		}
		{
			p.SetState(5264)
			p.relation_factor_in_use_join_hint_list(0)
		}
		{
			p.SetState(5265)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(5267)
			p.Match(OBParserNO_USE_NL_MATERIALIZATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5268)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5269)
			p.Qb_name_option()
		}
		{
			p.SetState(5270)
			p.relation_factor_in_use_join_hint_list(0)
		}
		{
			p.SetState(5271)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(5273)
			p.Match(OBParserUSE_HASH_AGGREGATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(5274)
			p.Match(OBParserNO_USE_HASH_AGGREGATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(5275)
			p.Match(OBParserMERGE_HINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5280)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 518, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5276)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5277)
				p.Qb_name_option()
			}
			{
				p.SetState(5278)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(5282)
			p.Match(OBParserNO_MERGE_HINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5287)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 519, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5283)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5284)
				p.Qb_name_option()
			}
			{
				p.SetState(5285)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(5289)
			p.Match(OBParserNO_EXPAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5294)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 520, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5290)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5291)
				p.Qb_name_option()
			}
			{
				p.SetState(5292)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(5296)
			p.Match(OBParserUSE_CONCAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5301)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 521, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5297)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5298)
				p.Qb_name_option()
			}
			{
				p.SetState(5299)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(5303)
			p.Match(OBParserUNNEST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5308)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 522, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5304)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5305)
				p.Qb_name_option()
			}
			{
				p.SetState(5306)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(5310)
			p.Match(OBParserNO_UNNEST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5315)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 523, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5311)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5312)
				p.Qb_name_option()
			}
			{
				p.SetState(5313)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(5317)
			p.Match(OBParserPLACE_GROUP_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5322)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 524, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5318)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5319)
				p.Qb_name_option()
			}
			{
				p.SetState(5320)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(5324)
			p.Match(OBParserNO_PLACE_GROUP_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5329)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 525, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5325)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5326)
				p.Qb_name_option()
			}
			{
				p.SetState(5327)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(5331)
			p.Match(OBParserNO_PRED_DEDUCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5336)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 526, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5332)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5333)
				p.Qb_name_option()
			}
			{
				p.SetState(5334)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(5338)
			p.Match(OBParserUSE_JIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5339)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5340)
			p.Use_jit_type()
		}
		{
			p.SetState(5341)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(5343)
			p.Match(OBParserNO_USE_JIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(5344)
			p.Match(OBParserUSE_LATE_MATERIALIZATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(5345)
			p.Match(OBParserNO_USE_LATE_MATERIALIZATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(5346)
			p.Match(OBParserTRACE_LOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(5347)
			p.Match(OBParserSTAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5348)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5349)
			p.Tracing_num_list()
		}
		{
			p.SetState(5350)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(5352)
			p.Match(OBParserTRACING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5353)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5354)
			p.Tracing_num_list()
		}
		{
			p.SetState(5355)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(5357)
			p.Match(OBParserUSE_PX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(5358)
			p.Match(OBParserNO_USE_PX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(5359)
			p.Match(OBParserTRANS_PARAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5360)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5361)
			p.Trans_param_name()
		}
		p.SetState(5363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserComma {
			{
				p.SetState(5362)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5365)
			p.Trans_param_value()
		}
		{
			p.SetState(5366)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(5368)
			p.Match(OBParserPX_JOIN_FILTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(5369)
			p.Match(OBParserFORCE_REFRESH_LOCATION_CACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(5370)
			p.Match(OBParserQB_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5371)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5372)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5373)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(5374)
			p.Match(OBParserMAX_CONCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5375)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5376)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5377)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(5378)
			p.Match(OBParserPARALLEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5379)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5380)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5381)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(5382)
			p.Match(OBParserPQ_DISTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5383)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5384)
			p.Qb_name_option()
		}
		{
			p.SetState(5385)
			p.Relation_factor_in_pq_hint()
		}
		p.SetState(5387)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserComma {
			{
				p.SetState(5386)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5389)
			p.Distribute_method()
		}
		p.SetState(5393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPARTITION || _la == OBParserHASH || _la == OBParserNONE || _la == OBParserRANDOM || _la == OBParserComma || _la == OBParserRANDOM_LOCAL || _la == OBParserBROADCAST {
			{
				p.SetState(5390)
				p.Opt_comma()
			}
			{
				p.SetState(5391)
				p.Distribute_method()
			}

		}
		{
			p.SetState(5395)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(5397)
			p.Match(OBParserLOAD_BATCH_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5398)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5399)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5400)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(5401)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(5402)
			p.Match(OBParserPARSER_SYNTAX_ERROR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConsistency_levelContext is an interface to support dynamic dispatch.
type IConsistency_levelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WEAK() antlr.TerminalNode
	STRONG() antlr.TerminalNode
	FROZEN() antlr.TerminalNode

	// IsConsistency_levelContext differentiates from other interfaces.
	IsConsistency_levelContext()
}

type Consistency_levelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConsistency_levelContext() *Consistency_levelContext {
	var p = new(Consistency_levelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_consistency_level
	return p
}

func InitEmptyConsistency_levelContext(p *Consistency_levelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_consistency_level
}

func (*Consistency_levelContext) IsConsistency_levelContext() {}

func NewConsistency_levelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Consistency_levelContext {
	var p = new(Consistency_levelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_consistency_level

	return p
}

func (s *Consistency_levelContext) GetParser() antlr.Parser { return s.parser }

func (s *Consistency_levelContext) WEAK() antlr.TerminalNode {
	return s.GetToken(OBParserWEAK, 0)
}

func (s *Consistency_levelContext) STRONG() antlr.TerminalNode {
	return s.GetToken(OBParserSTRONG, 0)
}

func (s *Consistency_levelContext) FROZEN() antlr.TerminalNode {
	return s.GetToken(OBParserFROZEN, 0)
}

func (s *Consistency_levelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Consistency_levelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Consistency_levelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterConsistency_level(s)
	}
}

func (s *Consistency_levelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitConsistency_level(s)
	}
}

func (s *Consistency_levelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitConsistency_level(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Consistency_level() (localctx IConsistency_levelContext) {
	localctx = NewConsistency_levelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, OBParserRULE_consistency_level)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5405)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-261)) & ^0x3f) == 0 && ((int64(1)<<(_la-261))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUse_plan_cache_typeContext is an interface to support dynamic dispatch.
type IUse_plan_cache_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NONE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsUse_plan_cache_typeContext differentiates from other interfaces.
	IsUse_plan_cache_typeContext()
}

type Use_plan_cache_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_plan_cache_typeContext() *Use_plan_cache_typeContext {
	var p = new(Use_plan_cache_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_use_plan_cache_type
	return p
}

func InitEmptyUse_plan_cache_typeContext(p *Use_plan_cache_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_use_plan_cache_type
}

func (*Use_plan_cache_typeContext) IsUse_plan_cache_typeContext() {}

func NewUse_plan_cache_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_plan_cache_typeContext {
	var p = new(Use_plan_cache_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_use_plan_cache_type

	return p
}

func (s *Use_plan_cache_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_plan_cache_typeContext) NONE() antlr.TerminalNode {
	return s.GetToken(OBParserNONE, 0)
}

func (s *Use_plan_cache_typeContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT, 0)
}

func (s *Use_plan_cache_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_plan_cache_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_plan_cache_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUse_plan_cache_type(s)
	}
}

func (s *Use_plan_cache_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUse_plan_cache_type(s)
	}
}

func (s *Use_plan_cache_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUse_plan_cache_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Use_plan_cache_type() (localctx IUse_plan_cache_typeContext) {
	localctx = NewUse_plan_cache_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, OBParserRULE_use_plan_cache_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5407)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserDEFAULT || _la == OBParserNONE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUse_jit_typeContext is an interface to support dynamic dispatch.
type IUse_jit_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AUTO() antlr.TerminalNode
	FORCE() antlr.TerminalNode

	// IsUse_jit_typeContext differentiates from other interfaces.
	IsUse_jit_typeContext()
}

type Use_jit_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_jit_typeContext() *Use_jit_typeContext {
	var p = new(Use_jit_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_use_jit_type
	return p
}

func InitEmptyUse_jit_typeContext(p *Use_jit_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_use_jit_type
}

func (*Use_jit_typeContext) IsUse_jit_typeContext() {}

func NewUse_jit_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_jit_typeContext {
	var p = new(Use_jit_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_use_jit_type

	return p
}

func (s *Use_jit_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_jit_typeContext) AUTO() antlr.TerminalNode {
	return s.GetToken(OBParserAUTO, 0)
}

func (s *Use_jit_typeContext) FORCE() antlr.TerminalNode {
	return s.GetToken(OBParserFORCE, 0)
}

func (s *Use_jit_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_jit_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_jit_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUse_jit_type(s)
	}
}

func (s *Use_jit_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUse_jit_type(s)
	}
}

func (s *Use_jit_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUse_jit_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Use_jit_type() (localctx IUse_jit_typeContext) {
	localctx = NewUse_jit_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, OBParserRULE_use_jit_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5409)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserFORCE || _la == OBParserAUTO) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistribute_methodContext is an interface to support dynamic dispatch.
type IDistribute_methodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NONE() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	RANDOM() antlr.TerminalNode
	RANDOM_LOCAL() antlr.TerminalNode
	HASH() antlr.TerminalNode
	BROADCAST() antlr.TerminalNode

	// IsDistribute_methodContext differentiates from other interfaces.
	IsDistribute_methodContext()
}

type Distribute_methodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistribute_methodContext() *Distribute_methodContext {
	var p = new(Distribute_methodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_distribute_method
	return p
}

func InitEmptyDistribute_methodContext(p *Distribute_methodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_distribute_method
}

func (*Distribute_methodContext) IsDistribute_methodContext() {}

func NewDistribute_methodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Distribute_methodContext {
	var p = new(Distribute_methodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_distribute_method

	return p
}

func (s *Distribute_methodContext) GetParser() antlr.Parser { return s.parser }

func (s *Distribute_methodContext) NONE() antlr.TerminalNode {
	return s.GetToken(OBParserNONE, 0)
}

func (s *Distribute_methodContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *Distribute_methodContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(OBParserRANDOM, 0)
}

func (s *Distribute_methodContext) RANDOM_LOCAL() antlr.TerminalNode {
	return s.GetToken(OBParserRANDOM_LOCAL, 0)
}

func (s *Distribute_methodContext) HASH() antlr.TerminalNode {
	return s.GetToken(OBParserHASH, 0)
}

func (s *Distribute_methodContext) BROADCAST() antlr.TerminalNode {
	return s.GetToken(OBParserBROADCAST, 0)
}

func (s *Distribute_methodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Distribute_methodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Distribute_methodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDistribute_method(s)
	}
}

func (s *Distribute_methodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDistribute_method(s)
	}
}

func (s *Distribute_methodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDistribute_method(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Distribute_method() (localctx IDistribute_methodContext) {
	localctx = NewDistribute_methodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, OBParserRULE_distribute_method)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5411)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserPARTITION || _la == OBParserHASH || _la == OBParserNONE || _la == OBParserRANDOM || _la == OBParserRANDOM_LOCAL || _la == OBParserBROADCAST) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimit_exprContext is an interface to support dynamic dispatch.
type ILimit_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTNUM() antlr.TerminalNode
	QUESTIONMARK() antlr.TerminalNode

	// IsLimit_exprContext differentiates from other interfaces.
	IsLimit_exprContext()
}

type Limit_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimit_exprContext() *Limit_exprContext {
	var p = new(Limit_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_limit_expr
	return p
}

func InitEmptyLimit_exprContext(p *Limit_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_limit_expr
}

func (*Limit_exprContext) IsLimit_exprContext() {}

func NewLimit_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Limit_exprContext {
	var p = new(Limit_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_limit_expr

	return p
}

func (s *Limit_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Limit_exprContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Limit_exprContext) QUESTIONMARK() antlr.TerminalNode {
	return s.GetToken(OBParserQUESTIONMARK, 0)
}

func (s *Limit_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Limit_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Limit_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLimit_expr(s)
	}
}

func (s *Limit_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLimit_expr(s)
	}
}

func (s *Limit_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLimit_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Limit_expr() (localctx ILimit_exprContext) {
	localctx = NewLimit_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, OBParserRULE_limit_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5413)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserINTNUM || _la == OBParserQUESTIONMARK) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_for_update_waitContext is an interface to support dynamic dispatch.
type IOpt_for_update_waitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Empty() IEmptyContext
	WAIT() antlr.TerminalNode
	DECIMAL_VAL() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	NOWAIT() antlr.TerminalNode
	NO_WAIT() antlr.TerminalNode

	// IsOpt_for_update_waitContext differentiates from other interfaces.
	IsOpt_for_update_waitContext()
}

type Opt_for_update_waitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_for_update_waitContext() *Opt_for_update_waitContext {
	var p = new(Opt_for_update_waitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_for_update_wait
	return p
}

func InitEmptyOpt_for_update_waitContext(p *Opt_for_update_waitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_for_update_wait
}

func (*Opt_for_update_waitContext) IsOpt_for_update_waitContext() {}

func NewOpt_for_update_waitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_for_update_waitContext {
	var p = new(Opt_for_update_waitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_for_update_wait

	return p
}

func (s *Opt_for_update_waitContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_for_update_waitContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Opt_for_update_waitContext) WAIT() antlr.TerminalNode {
	return s.GetToken(OBParserWAIT, 0)
}

func (s *Opt_for_update_waitContext) DECIMAL_VAL() antlr.TerminalNode {
	return s.GetToken(OBParserDECIMAL_VAL, 0)
}

func (s *Opt_for_update_waitContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Opt_for_update_waitContext) NOWAIT() antlr.TerminalNode {
	return s.GetToken(OBParserNOWAIT, 0)
}

func (s *Opt_for_update_waitContext) NO_WAIT() antlr.TerminalNode {
	return s.GetToken(OBParserNO_WAIT, 0)
}

func (s *Opt_for_update_waitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_for_update_waitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_for_update_waitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_for_update_wait(s)
	}
}

func (s *Opt_for_update_waitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_for_update_wait(s)
	}
}

func (s *Opt_for_update_waitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_for_update_wait(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_for_update_wait() (localctx IOpt_for_update_waitContext) {
	localctx = NewOpt_for_update_waitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, OBParserRULE_opt_for_update_wait)
	p.SetState(5422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 531, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5415)
			p.Empty()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5416)
			p.Match(OBParserWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5417)
			p.Match(OBParserDECIMAL_VAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5418)
			p.Match(OBParserWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5419)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5420)
			p.Match(OBParserNOWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5421)
			p.Match(OBParserNO_WAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterized_trimContext is an interface to support dynamic dispatch.
type IParameterized_trimContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	FROM() antlr.TerminalNode
	BOTH() antlr.TerminalNode
	LEADING() antlr.TerminalNode
	TRAILING() antlr.TerminalNode

	// IsParameterized_trimContext differentiates from other interfaces.
	IsParameterized_trimContext()
}

type Parameterized_trimContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterized_trimContext() *Parameterized_trimContext {
	var p = new(Parameterized_trimContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_parameterized_trim
	return p
}

func InitEmptyParameterized_trimContext(p *Parameterized_trimContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_parameterized_trim
}

func (*Parameterized_trimContext) IsParameterized_trimContext() {}

func NewParameterized_trimContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameterized_trimContext {
	var p = new(Parameterized_trimContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_parameterized_trim

	return p
}

func (s *Parameterized_trimContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameterized_trimContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Parameterized_trimContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Parameterized_trimContext) FROM() antlr.TerminalNode {
	return s.GetToken(OBParserFROM, 0)
}

func (s *Parameterized_trimContext) BOTH() antlr.TerminalNode {
	return s.GetToken(OBParserBOTH, 0)
}

func (s *Parameterized_trimContext) LEADING() antlr.TerminalNode {
	return s.GetToken(OBParserLEADING, 0)
}

func (s *Parameterized_trimContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(OBParserTRAILING, 0)
}

func (s *Parameterized_trimContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameterized_trimContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameterized_trimContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterParameterized_trim(s)
	}
}

func (s *Parameterized_trimContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitParameterized_trim(s)
	}
}

func (s *Parameterized_trimContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitParameterized_trim(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Parameterized_trim() (localctx IParameterized_trimContext) {
	localctx = NewParameterized_trimContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, OBParserRULE_parameterized_trim)
	p.SetState(5453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 532, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5424)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5425)
			p.expr(0)
		}
		{
			p.SetState(5426)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5427)
			p.expr(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5429)
			p.Match(OBParserBOTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5430)
			p.expr(0)
		}
		{
			p.SetState(5431)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5432)
			p.expr(0)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5434)
			p.Match(OBParserLEADING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5435)
			p.expr(0)
		}
		{
			p.SetState(5436)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5437)
			p.expr(0)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5439)
			p.Match(OBParserTRAILING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5440)
			p.expr(0)
		}
		{
			p.SetState(5441)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5442)
			p.expr(0)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5444)
			p.Match(OBParserBOTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5445)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5446)
			p.expr(0)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5447)
			p.Match(OBParserLEADING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5448)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5449)
			p.expr(0)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5450)
			p.Match(OBParserTRAILING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5451)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5452)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupby_clauseContext is an interface to support dynamic dispatch.
type IGroupby_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Sort_list_for_group_by() ISort_list_for_group_byContext
	WITH() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode

	// IsGroupby_clauseContext differentiates from other interfaces.
	IsGroupby_clauseContext()
}

type Groupby_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupby_clauseContext() *Groupby_clauseContext {
	var p = new(Groupby_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_groupby_clause
	return p
}

func InitEmptyGroupby_clauseContext(p *Groupby_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_groupby_clause
}

func (*Groupby_clauseContext) IsGroupby_clauseContext() {}

func NewGroupby_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Groupby_clauseContext {
	var p = new(Groupby_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_groupby_clause

	return p
}

func (s *Groupby_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Groupby_clauseContext) Sort_list_for_group_by() ISort_list_for_group_byContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISort_list_for_group_byContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISort_list_for_group_byContext)
}

func (s *Groupby_clauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(OBParserWITH, 0)
}

func (s *Groupby_clauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(OBParserROLLUP, 0)
}

func (s *Groupby_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Groupby_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Groupby_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterGroupby_clause(s)
	}
}

func (s *Groupby_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitGroupby_clause(s)
	}
}

func (s *Groupby_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitGroupby_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Groupby_clause() (localctx IGroupby_clauseContext) {
	localctx = NewGroupby_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, OBParserRULE_groupby_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5455)
		p.Sort_list_for_group_by()
	}
	p.SetState(5458)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 533, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5456)
			p.Match(OBParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5457)
			p.Match(OBParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISort_list_for_group_byContext is an interface to support dynamic dispatch.
type ISort_list_for_group_byContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSort_key_for_group_by() []ISort_key_for_group_byContext
	Sort_key_for_group_by(i int) ISort_key_for_group_byContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsSort_list_for_group_byContext differentiates from other interfaces.
	IsSort_list_for_group_byContext()
}

type Sort_list_for_group_byContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySort_list_for_group_byContext() *Sort_list_for_group_byContext {
	var p = new(Sort_list_for_group_byContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sort_list_for_group_by
	return p
}

func InitEmptySort_list_for_group_byContext(p *Sort_list_for_group_byContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sort_list_for_group_by
}

func (*Sort_list_for_group_byContext) IsSort_list_for_group_byContext() {}

func NewSort_list_for_group_byContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sort_list_for_group_byContext {
	var p = new(Sort_list_for_group_byContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_sort_list_for_group_by

	return p
}

func (s *Sort_list_for_group_byContext) GetParser() antlr.Parser { return s.parser }

func (s *Sort_list_for_group_byContext) AllSort_key_for_group_by() []ISort_key_for_group_byContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISort_key_for_group_byContext); ok {
			len++
		}
	}

	tst := make([]ISort_key_for_group_byContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISort_key_for_group_byContext); ok {
			tst[i] = t.(ISort_key_for_group_byContext)
			i++
		}
	}

	return tst
}

func (s *Sort_list_for_group_byContext) Sort_key_for_group_by(i int) ISort_key_for_group_byContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISort_key_for_group_byContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISort_key_for_group_byContext)
}

func (s *Sort_list_for_group_byContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Sort_list_for_group_byContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Sort_list_for_group_byContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sort_list_for_group_byContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sort_list_for_group_byContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSort_list_for_group_by(s)
	}
}

func (s *Sort_list_for_group_byContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSort_list_for_group_by(s)
	}
}

func (s *Sort_list_for_group_byContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSort_list_for_group_by(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Sort_list_for_group_by() (localctx ISort_list_for_group_byContext) {
	localctx = NewSort_list_for_group_byContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, OBParserRULE_sort_list_for_group_by)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5460)
		p.Sort_key_for_group_by()
	}
	p.SetState(5465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 534, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5461)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5462)
				p.Sort_key_for_group_by()
			}

		}
		p.SetState(5467)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 534, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISort_key_for_group_byContext is an interface to support dynamic dispatch.
type ISort_key_for_group_byContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsSort_key_for_group_byContext differentiates from other interfaces.
	IsSort_key_for_group_byContext()
}

type Sort_key_for_group_byContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySort_key_for_group_byContext() *Sort_key_for_group_byContext {
	var p = new(Sort_key_for_group_byContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sort_key_for_group_by
	return p
}

func InitEmptySort_key_for_group_byContext(p *Sort_key_for_group_byContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sort_key_for_group_by
}

func (*Sort_key_for_group_byContext) IsSort_key_for_group_byContext() {}

func NewSort_key_for_group_byContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sort_key_for_group_byContext {
	var p = new(Sort_key_for_group_byContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_sort_key_for_group_by

	return p
}

func (s *Sort_key_for_group_byContext) GetParser() antlr.Parser { return s.parser }

func (s *Sort_key_for_group_byContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Sort_key_for_group_byContext) ASC() antlr.TerminalNode {
	return s.GetToken(OBParserASC, 0)
}

func (s *Sort_key_for_group_byContext) DESC() antlr.TerminalNode {
	return s.GetToken(OBParserDESC, 0)
}

func (s *Sort_key_for_group_byContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sort_key_for_group_byContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sort_key_for_group_byContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSort_key_for_group_by(s)
	}
}

func (s *Sort_key_for_group_byContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSort_key_for_group_by(s)
	}
}

func (s *Sort_key_for_group_byContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSort_key_for_group_by(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Sort_key_for_group_by() (localctx ISort_key_for_group_byContext) {
	localctx = NewSort_key_for_group_byContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, OBParserRULE_sort_key_for_group_by)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5468)
		p.expr(0)
	}
	p.SetState(5470)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 535, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5469)
			_la = p.GetTokenStream().LA(1)

			if !(_la == OBParserASC || _la == OBParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrder_byContext is an interface to support dynamic dispatch.
type IOrder_byContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	Sort_list() ISort_listContext

	// IsOrder_byContext differentiates from other interfaces.
	IsOrder_byContext()
}

type Order_byContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_byContext() *Order_byContext {
	var p = new(Order_byContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_order_by
	return p
}

func InitEmptyOrder_byContext(p *Order_byContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_order_by
}

func (*Order_byContext) IsOrder_byContext() {}

func NewOrder_byContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_byContext {
	var p = new(Order_byContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_order_by

	return p
}

func (s *Order_byContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_byContext) ORDER() antlr.TerminalNode {
	return s.GetToken(OBParserORDER, 0)
}

func (s *Order_byContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Order_byContext) Sort_list() ISort_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISort_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISort_listContext)
}

func (s *Order_byContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_byContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Order_byContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOrder_by(s)
	}
}

func (s *Order_byContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOrder_by(s)
	}
}

func (s *Order_byContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOrder_by(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Order_by() (localctx IOrder_byContext) {
	localctx = NewOrder_byContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, OBParserRULE_order_by)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5472)
		p.Match(OBParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5473)
		p.Match(OBParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5474)
		p.Sort_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISort_listContext is an interface to support dynamic dispatch.
type ISort_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSort_key() []ISort_keyContext
	Sort_key(i int) ISort_keyContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsSort_listContext differentiates from other interfaces.
	IsSort_listContext()
}

type Sort_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySort_listContext() *Sort_listContext {
	var p = new(Sort_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sort_list
	return p
}

func InitEmptySort_listContext(p *Sort_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sort_list
}

func (*Sort_listContext) IsSort_listContext() {}

func NewSort_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sort_listContext {
	var p = new(Sort_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_sort_list

	return p
}

func (s *Sort_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Sort_listContext) AllSort_key() []ISort_keyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISort_keyContext); ok {
			len++
		}
	}

	tst := make([]ISort_keyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISort_keyContext); ok {
			tst[i] = t.(ISort_keyContext)
			i++
		}
	}

	return tst
}

func (s *Sort_listContext) Sort_key(i int) ISort_keyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISort_keyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISort_keyContext)
}

func (s *Sort_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Sort_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Sort_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sort_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sort_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSort_list(s)
	}
}

func (s *Sort_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSort_list(s)
	}
}

func (s *Sort_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSort_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Sort_list() (localctx ISort_listContext) {
	localctx = NewSort_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, OBParserRULE_sort_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5476)
		p.Sort_key()
	}
	p.SetState(5481)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(5477)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5478)
			p.Sort_key()
		}

		p.SetState(5483)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISort_keyContext is an interface to support dynamic dispatch.
type ISort_keyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsSort_keyContext differentiates from other interfaces.
	IsSort_keyContext()
}

type Sort_keyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySort_keyContext() *Sort_keyContext {
	var p = new(Sort_keyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sort_key
	return p
}

func InitEmptySort_keyContext(p *Sort_keyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sort_key
}

func (*Sort_keyContext) IsSort_keyContext() {}

func NewSort_keyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sort_keyContext {
	var p = new(Sort_keyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_sort_key

	return p
}

func (s *Sort_keyContext) GetParser() antlr.Parser { return s.parser }

func (s *Sort_keyContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Sort_keyContext) ASC() antlr.TerminalNode {
	return s.GetToken(OBParserASC, 0)
}

func (s *Sort_keyContext) DESC() antlr.TerminalNode {
	return s.GetToken(OBParserDESC, 0)
}

func (s *Sort_keyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sort_keyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sort_keyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSort_key(s)
	}
}

func (s *Sort_keyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSort_key(s)
	}
}

func (s *Sort_keyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSort_key(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Sort_key() (localctx ISort_keyContext) {
	localctx = NewSort_keyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, OBParserRULE_sort_key)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5484)
		p.expr(0)
	}
	p.SetState(5486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserASC || _la == OBParserDESC {
		{
			p.SetState(5485)
			_la = p.GetTokenStream().LA(1)

			if !(_la == OBParserASC || _la == OBParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuery_expression_option_listContext is an interface to support dynamic dispatch.
type IQuery_expression_option_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQuery_expression_option() []IQuery_expression_optionContext
	Query_expression_option(i int) IQuery_expression_optionContext

	// IsQuery_expression_option_listContext differentiates from other interfaces.
	IsQuery_expression_option_listContext()
}

type Query_expression_option_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_expression_option_listContext() *Query_expression_option_listContext {
	var p = new(Query_expression_option_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_query_expression_option_list
	return p
}

func InitEmptyQuery_expression_option_listContext(p *Query_expression_option_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_query_expression_option_list
}

func (*Query_expression_option_listContext) IsQuery_expression_option_listContext() {}

func NewQuery_expression_option_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_expression_option_listContext {
	var p = new(Query_expression_option_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_query_expression_option_list

	return p
}

func (s *Query_expression_option_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_expression_option_listContext) AllQuery_expression_option() []IQuery_expression_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQuery_expression_optionContext); ok {
			len++
		}
	}

	tst := make([]IQuery_expression_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQuery_expression_optionContext); ok {
			tst[i] = t.(IQuery_expression_optionContext)
			i++
		}
	}

	return tst
}

func (s *Query_expression_option_listContext) Query_expression_option(i int) IQuery_expression_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuery_expression_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuery_expression_optionContext)
}

func (s *Query_expression_option_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_expression_option_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_expression_option_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterQuery_expression_option_list(s)
	}
}

func (s *Query_expression_option_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitQuery_expression_option_list(s)
	}
}

func (s *Query_expression_option_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitQuery_expression_option_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Query_expression_option_list() (localctx IQuery_expression_option_listContext) {
	localctx = NewQuery_expression_option_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, OBParserRULE_query_expression_option_list)
	p.SetState(5492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 538, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5488)
			p.Query_expression_option()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5489)
			p.Query_expression_option()
		}
		{
			p.SetState(5490)
			p.Query_expression_option()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuery_expression_optionContext is an interface to support dynamic dispatch.
type IQuery_expression_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	SQL_CALC_FOUND_ROWS() antlr.TerminalNode

	// IsQuery_expression_optionContext differentiates from other interfaces.
	IsQuery_expression_optionContext()
}

type Query_expression_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuery_expression_optionContext() *Query_expression_optionContext {
	var p = new(Query_expression_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_query_expression_option
	return p
}

func InitEmptyQuery_expression_optionContext(p *Query_expression_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_query_expression_option
}

func (*Query_expression_optionContext) IsQuery_expression_optionContext() {}

func NewQuery_expression_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Query_expression_optionContext {
	var p = new(Query_expression_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_query_expression_option

	return p
}

func (s *Query_expression_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Query_expression_optionContext) ALL() antlr.TerminalNode {
	return s.GetToken(OBParserALL, 0)
}

func (s *Query_expression_optionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(OBParserDISTINCT, 0)
}

func (s *Query_expression_optionContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(OBParserUNIQUE, 0)
}

func (s *Query_expression_optionContext) SQL_CALC_FOUND_ROWS() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_CALC_FOUND_ROWS, 0)
}

func (s *Query_expression_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Query_expression_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Query_expression_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterQuery_expression_option(s)
	}
}

func (s *Query_expression_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitQuery_expression_option(s)
	}
}

func (s *Query_expression_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitQuery_expression_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Query_expression_option() (localctx IQuery_expression_optionContext) {
	localctx = NewQuery_expression_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, OBParserRULE_query_expression_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5494)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserALL || _la == OBParserDISTINCT || _la == OBParserSQL_CALC_FOUND_ROWS || _la == OBParserUNIQUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProjectionContext is an interface to support dynamic dispatch.
type IProjectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	Column_label() IColumn_labelContext
	AS() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	Star() antlr.TerminalNode

	// IsProjectionContext differentiates from other interfaces.
	IsProjectionContext()
}

type ProjectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectionContext() *ProjectionContext {
	var p = new(ProjectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_projection
	return p
}

func InitEmptyProjectionContext(p *ProjectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_projection
}

func (*ProjectionContext) IsProjectionContext() {}

func NewProjectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectionContext {
	var p = new(ProjectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_projection

	return p
}

func (s *ProjectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ProjectionContext) Column_label() IColumn_labelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_labelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_labelContext)
}

func (s *ProjectionContext) AS() antlr.TerminalNode {
	return s.GetToken(OBParserAS, 0)
}

func (s *ProjectionContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *ProjectionContext) Star() antlr.TerminalNode {
	return s.GetToken(OBParserStar, 0)
}

func (s *ProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterProjection(s)
	}
}

func (s *ProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitProjection(s)
	}
}

func (s *ProjectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitProjection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Projection() (localctx IProjectionContext) {
	localctx = NewProjectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, OBParserRULE_projection)
	var _la int

	p.SetState(5510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 541, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5496)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5497)
			p.expr(0)
		}
		p.SetState(5499)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserAS {
			{
				p.SetState(5498)
				p.Match(OBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5501)
			p.Column_label()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5503)
			p.expr(0)
		}
		p.SetState(5505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserAS {
			{
				p.SetState(5504)
				p.Match(OBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5507)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5509)
			p.Match(OBParserStar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_expr_listContext is an interface to support dynamic dispatch.
type ISelect_expr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProjection() []IProjectionContext
	Projection(i int) IProjectionContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsSelect_expr_listContext differentiates from other interfaces.
	IsSelect_expr_listContext()
}

type Select_expr_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_expr_listContext() *Select_expr_listContext {
	var p = new(Select_expr_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_expr_list
	return p
}

func InitEmptySelect_expr_listContext(p *Select_expr_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_select_expr_list
}

func (*Select_expr_listContext) IsSelect_expr_listContext() {}

func NewSelect_expr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_expr_listContext {
	var p = new(Select_expr_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_select_expr_list

	return p
}

func (s *Select_expr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_expr_listContext) AllProjection() []IProjectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProjectionContext); ok {
			len++
		}
	}

	tst := make([]IProjectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProjectionContext); ok {
			tst[i] = t.(IProjectionContext)
			i++
		}
	}

	return tst
}

func (s *Select_expr_listContext) Projection(i int) IProjectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectionContext)
}

func (s *Select_expr_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Select_expr_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Select_expr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_expr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_expr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSelect_expr_list(s)
	}
}

func (s *Select_expr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSelect_expr_list(s)
	}
}

func (s *Select_expr_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSelect_expr_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Select_expr_list() (localctx ISelect_expr_listContext) {
	localctx = NewSelect_expr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, OBParserRULE_select_expr_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5512)
		p.Projection()
	}
	p.SetState(5517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 542, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5513)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5514)
				p.Projection()
			}

		}
		p.SetState(5519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 542, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_listContext is an interface to support dynamic dispatch.
type IFrom_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_references() ITable_referencesContext

	// IsFrom_listContext differentiates from other interfaces.
	IsFrom_listContext()
}

type From_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_listContext() *From_listContext {
	var p = new(From_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_from_list
	return p
}

func InitEmptyFrom_listContext(p *From_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_from_list
}

func (*From_listContext) IsFrom_listContext() {}

func NewFrom_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_listContext {
	var p = new(From_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_from_list

	return p
}

func (s *From_listContext) GetParser() antlr.Parser { return s.parser }

func (s *From_listContext) Table_references() ITable_referencesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_referencesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_referencesContext)
}

func (s *From_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterFrom_list(s)
	}
}

func (s *From_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitFrom_list(s)
	}
}

func (s *From_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitFrom_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) From_list() (localctx IFrom_listContext) {
	localctx = NewFrom_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, OBParserRULE_from_list)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5520)
		p.Table_references()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_referencesContext is an interface to support dynamic dispatch.
type ITable_referencesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTable_reference() []ITable_referenceContext
	Table_reference(i int) ITable_referenceContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsTable_referencesContext differentiates from other interfaces.
	IsTable_referencesContext()
}

type Table_referencesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_referencesContext() *Table_referencesContext {
	var p = new(Table_referencesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_references
	return p
}

func InitEmptyTable_referencesContext(p *Table_referencesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_references
}

func (*Table_referencesContext) IsTable_referencesContext() {}

func NewTable_referencesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_referencesContext {
	var p = new(Table_referencesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_table_references

	return p
}

func (s *Table_referencesContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_referencesContext) AllTable_reference() []ITable_referenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITable_referenceContext); ok {
			len++
		}
	}

	tst := make([]ITable_referenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITable_referenceContext); ok {
			tst[i] = t.(ITable_referenceContext)
			i++
		}
	}

	return tst
}

func (s *Table_referencesContext) Table_reference(i int) ITable_referenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_referenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_referenceContext)
}

func (s *Table_referencesContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Table_referencesContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Table_referencesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_referencesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_referencesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTable_references(s)
	}
}

func (s *Table_referencesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTable_references(s)
	}
}

func (s *Table_referencesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTable_references(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Table_references() (localctx ITable_referencesContext) {
	localctx = NewTable_referencesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, OBParserRULE_table_references)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5522)
		p.Table_reference()
	}
	p.SetState(5527)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 543, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5523)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5524)
				p.Table_reference()
			}

		}
		p.SetState(5529)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 543, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_referenceContext is an interface to support dynamic dispatch.
type ITable_referenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_factor() ITable_factorContext
	Joined_table() IJoined_tableContext

	// IsTable_referenceContext differentiates from other interfaces.
	IsTable_referenceContext()
}

type Table_referenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_referenceContext() *Table_referenceContext {
	var p = new(Table_referenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_reference
	return p
}

func InitEmptyTable_referenceContext(p *Table_referenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_reference
}

func (*Table_referenceContext) IsTable_referenceContext() {}

func NewTable_referenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_referenceContext {
	var p = new(Table_referenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_table_reference

	return p
}

func (s *Table_referenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_referenceContext) Table_factor() ITable_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_factorContext)
}

func (s *Table_referenceContext) Joined_table() IJoined_tableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoined_tableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoined_tableContext)
}

func (s *Table_referenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_referenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_referenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTable_reference(s)
	}
}

func (s *Table_referenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTable_reference(s)
	}
}

func (s *Table_referenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTable_reference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Table_reference() (localctx ITable_referenceContext) {
	localctx = NewTable_referenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, OBParserRULE_table_reference)
	p.SetState(5532)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 544, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5530)
			p.Table_factor()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5531)
			p.joined_table(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_factorContext is an interface to support dynamic dispatch.
type ITable_factorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Tbl_name() ITbl_nameContext
	Table_subquery() ITable_subqueryContext
	Select_with_parens() ISelect_with_parensContext
	LeftParen() antlr.TerminalNode
	Table_references() ITable_referencesContext
	RightParen() antlr.TerminalNode

	// IsTable_factorContext differentiates from other interfaces.
	IsTable_factorContext()
}

type Table_factorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_factorContext() *Table_factorContext {
	var p = new(Table_factorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_factor
	return p
}

func InitEmptyTable_factorContext(p *Table_factorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_factor
}

func (*Table_factorContext) IsTable_factorContext() {}

func NewTable_factorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_factorContext {
	var p = new(Table_factorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_table_factor

	return p
}

func (s *Table_factorContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_factorContext) Tbl_name() ITbl_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITbl_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITbl_nameContext)
}

func (s *Table_factorContext) Table_subquery() ITable_subqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_subqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_subqueryContext)
}

func (s *Table_factorContext) Select_with_parens() ISelect_with_parensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_with_parensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_with_parensContext)
}

func (s *Table_factorContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Table_factorContext) Table_references() ITable_referencesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_referencesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_referencesContext)
}

func (s *Table_factorContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Table_factorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_factorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_factorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTable_factor(s)
	}
}

func (s *Table_factorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTable_factor(s)
	}
}

func (s *Table_factorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTable_factor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Table_factor() (localctx ITable_factorContext) {
	localctx = NewTable_factorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, OBParserRULE_table_factor)
	p.SetState(5541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 545, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5534)
			p.Tbl_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5535)
			p.Table_subquery()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5536)
			p.Select_with_parens()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5537)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5538)
			p.Table_references()
		}
		{
			p.SetState(5539)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITbl_nameContext is an interface to support dynamic dispatch.
type ITbl_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Relation_factor() IRelation_factorContext
	Use_partition() IUse_partitionContext
	Sample_clause() ISample_clauseContext
	Opt_seed() IOpt_seedContext
	Index_hint_list() IIndex_hint_listContext
	AS() antlr.TerminalNode
	Relation_name() IRelation_nameContext
	Seed() ISeedContext

	// IsTbl_nameContext differentiates from other interfaces.
	IsTbl_nameContext()
}

type Tbl_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTbl_nameContext() *Tbl_nameContext {
	var p = new(Tbl_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tbl_name
	return p
}

func InitEmptyTbl_nameContext(p *Tbl_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tbl_name
}

func (*Tbl_nameContext) IsTbl_nameContext() {}

func NewTbl_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tbl_nameContext {
	var p = new(Tbl_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tbl_name

	return p
}

func (s *Tbl_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Tbl_nameContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Tbl_nameContext) Use_partition() IUse_partitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUse_partitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUse_partitionContext)
}

func (s *Tbl_nameContext) Sample_clause() ISample_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISample_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISample_clauseContext)
}

func (s *Tbl_nameContext) Opt_seed() IOpt_seedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_seedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_seedContext)
}

func (s *Tbl_nameContext) Index_hint_list() IIndex_hint_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_hint_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_hint_listContext)
}

func (s *Tbl_nameContext) AS() antlr.TerminalNode {
	return s.GetToken(OBParserAS, 0)
}

func (s *Tbl_nameContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Tbl_nameContext) Seed() ISeedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISeedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISeedContext)
}

func (s *Tbl_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tbl_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tbl_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTbl_name(s)
	}
}

func (s *Tbl_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTbl_name(s)
	}
}

func (s *Tbl_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTbl_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tbl_name() (localctx ITbl_nameContext) {
	localctx = NewTbl_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, OBParserRULE_tbl_name)
	var _la int

	p.SetState(5596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 558, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5543)
			p.Relation_factor()
		}
		p.SetState(5545)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 546, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5544)
				p.Use_partition()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5550)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 547, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5547)
				p.Sample_clause()
			}
			{
				p.SetState(5548)
				p.Opt_seed()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5553)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 548, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5552)
				p.Index_hint_list()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5555)
			p.Relation_factor()
		}
		p.SetState(5557)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPARTITION {
			{
				p.SetState(5556)
				p.Use_partition()
			}

		}
		p.SetState(5562)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSAMPLE {
			{
				p.SetState(5559)
				p.Sample_clause()
			}
			{
				p.SetState(5560)
				p.Opt_seed()
			}

		}
		{
			p.SetState(5564)
			p.Match(OBParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5565)
			p.Relation_name()
		}
		p.SetState(5567)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 551, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5566)
				p.Index_hint_list()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5569)
			p.Relation_factor()
		}
		p.SetState(5571)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPARTITION {
			{
				p.SetState(5570)
				p.Use_partition()
			}

		}
		{
			p.SetState(5573)
			p.Relation_name()
		}
		p.SetState(5575)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 553, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5574)
				p.Index_hint_list()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5577)
			p.Relation_factor()
		}
		p.SetState(5579)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPARTITION {
			{
				p.SetState(5578)
				p.Use_partition()
			}

		}
		{
			p.SetState(5581)
			p.Sample_clause()
		}
		{
			p.SetState(5582)
			p.Seed()
		}
		{
			p.SetState(5583)
			p.Relation_name()
		}
		p.SetState(5585)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 555, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5584)
				p.Index_hint_list()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5587)
			p.Relation_factor()
		}
		p.SetState(5589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPARTITION {
			{
				p.SetState(5588)
				p.Use_partition()
			}

		}
		{
			p.SetState(5591)
			p.Sample_clause()
		}
		{
			p.SetState(5592)
			p.Relation_name()
		}
		p.SetState(5594)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 557, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5593)
				p.Index_hint_list()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDml_table_nameContext is an interface to support dynamic dispatch.
type IDml_table_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Relation_factor() IRelation_factorContext
	Use_partition() IUse_partitionContext

	// IsDml_table_nameContext differentiates from other interfaces.
	IsDml_table_nameContext()
}

type Dml_table_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDml_table_nameContext() *Dml_table_nameContext {
	var p = new(Dml_table_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_dml_table_name
	return p
}

func InitEmptyDml_table_nameContext(p *Dml_table_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_dml_table_name
}

func (*Dml_table_nameContext) IsDml_table_nameContext() {}

func NewDml_table_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dml_table_nameContext {
	var p = new(Dml_table_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_dml_table_name

	return p
}

func (s *Dml_table_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dml_table_nameContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Dml_table_nameContext) Use_partition() IUse_partitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUse_partitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUse_partitionContext)
}

func (s *Dml_table_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dml_table_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dml_table_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDml_table_name(s)
	}
}

func (s *Dml_table_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDml_table_name(s)
	}
}

func (s *Dml_table_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDml_table_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Dml_table_name() (localctx IDml_table_nameContext) {
	localctx = NewDml_table_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, OBParserRULE_dml_table_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5598)
		p.Relation_factor()
	}
	p.SetState(5600)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserPARTITION {
		{
			p.SetState(5599)
			p.Use_partition()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISeedContext is an interface to support dynamic dispatch.
type ISeedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEED() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	RightParen() antlr.TerminalNode

	// IsSeedContext differentiates from other interfaces.
	IsSeedContext()
}

type SeedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeedContext() *SeedContext {
	var p = new(SeedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_seed
	return p
}

func InitEmptySeedContext(p *SeedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_seed
}

func (*SeedContext) IsSeedContext() {}

func NewSeedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SeedContext {
	var p = new(SeedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_seed

	return p
}

func (s *SeedContext) GetParser() antlr.Parser { return s.parser }

func (s *SeedContext) SEED() antlr.TerminalNode {
	return s.GetToken(OBParserSEED, 0)
}

func (s *SeedContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *SeedContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *SeedContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *SeedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SeedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SeedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSeed(s)
	}
}

func (s *SeedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSeed(s)
	}
}

func (s *SeedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSeed(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Seed() (localctx ISeedContext) {
	localctx = NewSeedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, OBParserRULE_seed)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5602)
		p.Match(OBParserSEED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5603)
		p.Match(OBParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5604)
		p.Match(OBParserINTNUM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5605)
		p.Match(OBParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_seedContext is an interface to support dynamic dispatch.
type IOpt_seedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Seed() ISeedContext

	// IsOpt_seedContext differentiates from other interfaces.
	IsOpt_seedContext()
}

type Opt_seedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_seedContext() *Opt_seedContext {
	var p = new(Opt_seedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_seed
	return p
}

func InitEmptyOpt_seedContext(p *Opt_seedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_seed
}

func (*Opt_seedContext) IsOpt_seedContext() {}

func NewOpt_seedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_seedContext {
	var p = new(Opt_seedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_seed

	return p
}

func (s *Opt_seedContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_seedContext) Seed() ISeedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISeedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISeedContext)
}

func (s *Opt_seedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_seedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_seedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_seed(s)
	}
}

func (s *Opt_seedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_seed(s)
	}
}

func (s *Opt_seedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_seed(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_seed() (localctx IOpt_seedContext) {
	localctx = NewOpt_seedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, OBParserRULE_opt_seed)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(5608)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 560, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5607)
			p.Seed()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISample_percentContext is an interface to support dynamic dispatch.
type ISample_percentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTNUM() antlr.TerminalNode
	DECIMAL_VAL() antlr.TerminalNode

	// IsSample_percentContext differentiates from other interfaces.
	IsSample_percentContext()
}

type Sample_percentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySample_percentContext() *Sample_percentContext {
	var p = new(Sample_percentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sample_percent
	return p
}

func InitEmptySample_percentContext(p *Sample_percentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sample_percent
}

func (*Sample_percentContext) IsSample_percentContext() {}

func NewSample_percentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sample_percentContext {
	var p = new(Sample_percentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_sample_percent

	return p
}

func (s *Sample_percentContext) GetParser() antlr.Parser { return s.parser }

func (s *Sample_percentContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Sample_percentContext) DECIMAL_VAL() antlr.TerminalNode {
	return s.GetToken(OBParserDECIMAL_VAL, 0)
}

func (s *Sample_percentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sample_percentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sample_percentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSample_percent(s)
	}
}

func (s *Sample_percentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSample_percent(s)
	}
}

func (s *Sample_percentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSample_percent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Sample_percent() (localctx ISample_percentContext) {
	localctx = NewSample_percentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, OBParserRULE_sample_percent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5610)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserINTNUM || _la == OBParserDECIMAL_VAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISample_clauseContext is an interface to support dynamic dispatch.
type ISample_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAMPLE() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Sample_percent() ISample_percentContext
	RightParen() antlr.TerminalNode
	BLOCK() antlr.TerminalNode
	ALL() antlr.TerminalNode
	BASE() antlr.TerminalNode
	INCR() antlr.TerminalNode

	// IsSample_clauseContext differentiates from other interfaces.
	IsSample_clauseContext()
}

type Sample_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySample_clauseContext() *Sample_clauseContext {
	var p = new(Sample_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sample_clause
	return p
}

func InitEmptySample_clauseContext(p *Sample_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sample_clause
}

func (*Sample_clauseContext) IsSample_clauseContext() {}

func NewSample_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sample_clauseContext {
	var p = new(Sample_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_sample_clause

	return p
}

func (s *Sample_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Sample_clauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(OBParserSAMPLE, 0)
}

func (s *Sample_clauseContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Sample_clauseContext) Sample_percent() ISample_percentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISample_percentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISample_percentContext)
}

func (s *Sample_clauseContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Sample_clauseContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(OBParserBLOCK, 0)
}

func (s *Sample_clauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(OBParserALL, 0)
}

func (s *Sample_clauseContext) BASE() antlr.TerminalNode {
	return s.GetToken(OBParserBASE, 0)
}

func (s *Sample_clauseContext) INCR() antlr.TerminalNode {
	return s.GetToken(OBParserINCR, 0)
}

func (s *Sample_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sample_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sample_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSample_clause(s)
	}
}

func (s *Sample_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSample_clause(s)
	}
}

func (s *Sample_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSample_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Sample_clause() (localctx ISample_clauseContext) {
	localctx = NewSample_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, OBParserRULE_sample_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5612)
		p.Match(OBParserSAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5614)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserBLOCK {
		{
			p.SetState(5613)
			p.Match(OBParserBLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5617)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserALL || _la == OBParserINCR || _la == OBParserBASE {
		{
			p.SetState(5616)
			_la = p.GetTokenStream().LA(1)

			if !(_la == OBParserALL || _la == OBParserINCR || _la == OBParserBASE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5619)
		p.Match(OBParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5620)
		p.Sample_percent()
	}
	{
		p.SetState(5621)
		p.Match(OBParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_subqueryContext is an interface to support dynamic dispatch.
type ITable_subqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_with_parens() ISelect_with_parensContext
	Relation_name() IRelation_nameContext
	AS() antlr.TerminalNode

	// IsTable_subqueryContext differentiates from other interfaces.
	IsTable_subqueryContext()
}

type Table_subqueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_subqueryContext() *Table_subqueryContext {
	var p = new(Table_subqueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_subquery
	return p
}

func InitEmptyTable_subqueryContext(p *Table_subqueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_table_subquery
}

func (*Table_subqueryContext) IsTable_subqueryContext() {}

func NewTable_subqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_subqueryContext {
	var p = new(Table_subqueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_table_subquery

	return p
}

func (s *Table_subqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_subqueryContext) Select_with_parens() ISelect_with_parensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_with_parensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_with_parensContext)
}

func (s *Table_subqueryContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Table_subqueryContext) AS() antlr.TerminalNode {
	return s.GetToken(OBParserAS, 0)
}

func (s *Table_subqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_subqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_subqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTable_subquery(s)
	}
}

func (s *Table_subqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTable_subquery(s)
	}
}

func (s *Table_subqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTable_subquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Table_subquery() (localctx ITable_subqueryContext) {
	localctx = NewTable_subqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, OBParserRULE_table_subquery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5623)
		p.Select_with_parens()
	}
	p.SetState(5625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserAS {
		{
			p.SetState(5624)
			p.Match(OBParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5627)
		p.Relation_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUse_partitionContext is an interface to support dynamic dispatch.
type IUse_partitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Name_list() IName_listContext
	RightParen() antlr.TerminalNode

	// IsUse_partitionContext differentiates from other interfaces.
	IsUse_partitionContext()
}

type Use_partitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_partitionContext() *Use_partitionContext {
	var p = new(Use_partitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_use_partition
	return p
}

func InitEmptyUse_partitionContext(p *Use_partitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_use_partition
}

func (*Use_partitionContext) IsUse_partitionContext() {}

func NewUse_partitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_partitionContext {
	var p = new(Use_partitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_use_partition

	return p
}

func (s *Use_partitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_partitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *Use_partitionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Use_partitionContext) Name_list() IName_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IName_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *Use_partitionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Use_partitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_partitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_partitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUse_partition(s)
	}
}

func (s *Use_partitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUse_partition(s)
	}
}

func (s *Use_partitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUse_partition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Use_partition() (localctx IUse_partitionContext) {
	localctx = NewUse_partitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, OBParserRULE_use_partition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5629)
		p.Match(OBParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5630)
		p.Match(OBParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5631)
		p.name_list(0)
	}
	{
		p.SetState(5632)
		p.Match(OBParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_hint_typeContext is an interface to support dynamic dispatch.
type IIndex_hint_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FORCE() antlr.TerminalNode
	IGNORE() antlr.TerminalNode

	// IsIndex_hint_typeContext differentiates from other interfaces.
	IsIndex_hint_typeContext()
}

type Index_hint_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_hint_typeContext() *Index_hint_typeContext {
	var p = new(Index_hint_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_hint_type
	return p
}

func InitEmptyIndex_hint_typeContext(p *Index_hint_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_hint_type
}

func (*Index_hint_typeContext) IsIndex_hint_typeContext() {}

func NewIndex_hint_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_hint_typeContext {
	var p = new(Index_hint_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_index_hint_type

	return p
}

func (s *Index_hint_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_hint_typeContext) FORCE() antlr.TerminalNode {
	return s.GetToken(OBParserFORCE, 0)
}

func (s *Index_hint_typeContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(OBParserIGNORE, 0)
}

func (s *Index_hint_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_hint_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_hint_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterIndex_hint_type(s)
	}
}

func (s *Index_hint_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitIndex_hint_type(s)
	}
}

func (s *Index_hint_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitIndex_hint_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Index_hint_type() (localctx IIndex_hint_typeContext) {
	localctx = NewIndex_hint_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, OBParserRULE_index_hint_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5634)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserFORCE || _la == OBParserIGNORE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKey_or_indexContext is an interface to support dynamic dispatch.
type IKey_or_indexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY() antlr.TerminalNode
	INDEX() antlr.TerminalNode

	// IsKey_or_indexContext differentiates from other interfaces.
	IsKey_or_indexContext()
}

type Key_or_indexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKey_or_indexContext() *Key_or_indexContext {
	var p = new(Key_or_indexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_key_or_index
	return p
}

func InitEmptyKey_or_indexContext(p *Key_or_indexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_key_or_index
}

func (*Key_or_indexContext) IsKey_or_indexContext() {}

func NewKey_or_indexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Key_or_indexContext {
	var p = new(Key_or_indexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_key_or_index

	return p
}

func (s *Key_or_indexContext) GetParser() antlr.Parser { return s.parser }

func (s *Key_or_indexContext) KEY() antlr.TerminalNode {
	return s.GetToken(OBParserKEY, 0)
}

func (s *Key_or_indexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(OBParserINDEX, 0)
}

func (s *Key_or_indexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Key_or_indexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Key_or_indexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterKey_or_index(s)
	}
}

func (s *Key_or_indexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitKey_or_index(s)
	}
}

func (s *Key_or_indexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitKey_or_index(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Key_or_index() (localctx IKey_or_indexContext) {
	localctx = NewKey_or_indexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, OBParserRULE_key_or_index)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5636)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserINDEX || _la == OBParserKEY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_hint_scopeContext is an interface to support dynamic dispatch.
type IIndex_hint_scopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Empty() IEmptyContext
	FOR() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	GROUP() antlr.TerminalNode

	// IsIndex_hint_scopeContext differentiates from other interfaces.
	IsIndex_hint_scopeContext()
}

type Index_hint_scopeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_hint_scopeContext() *Index_hint_scopeContext {
	var p = new(Index_hint_scopeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_hint_scope
	return p
}

func InitEmptyIndex_hint_scopeContext(p *Index_hint_scopeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_hint_scope
}

func (*Index_hint_scopeContext) IsIndex_hint_scopeContext() {}

func NewIndex_hint_scopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_hint_scopeContext {
	var p = new(Index_hint_scopeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_index_hint_scope

	return p
}

func (s *Index_hint_scopeContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_hint_scopeContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Index_hint_scopeContext) FOR() antlr.TerminalNode {
	return s.GetToken(OBParserFOR, 0)
}

func (s *Index_hint_scopeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(OBParserJOIN, 0)
}

func (s *Index_hint_scopeContext) ORDER() antlr.TerminalNode {
	return s.GetToken(OBParserORDER, 0)
}

func (s *Index_hint_scopeContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Index_hint_scopeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(OBParserGROUP, 0)
}

func (s *Index_hint_scopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_hint_scopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_hint_scopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterIndex_hint_scope(s)
	}
}

func (s *Index_hint_scopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitIndex_hint_scope(s)
	}
}

func (s *Index_hint_scopeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitIndex_hint_scope(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Index_hint_scope() (localctx IIndex_hint_scopeContext) {
	localctx = NewIndex_hint_scopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, OBParserRULE_index_hint_scope)
	p.SetState(5647)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 564, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5638)
			p.Empty()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5639)
			p.Match(OBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5640)
			p.Match(OBParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5641)
			p.Match(OBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5642)
			p.Match(OBParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5643)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5644)
			p.Match(OBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5645)
			p.Match(OBParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5646)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_elementContext is an interface to support dynamic dispatch.
type IIndex_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME_OB() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode

	// IsIndex_elementContext differentiates from other interfaces.
	IsIndex_elementContext()
}

type Index_elementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_elementContext() *Index_elementContext {
	var p = new(Index_elementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_element
	return p
}

func InitEmptyIndex_elementContext(p *Index_elementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_element
}

func (*Index_elementContext) IsIndex_elementContext() {}

func NewIndex_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_elementContext {
	var p = new(Index_elementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_index_element

	return p
}

func (s *Index_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_elementContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Index_elementContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(OBParserPRIMARY, 0)
}

func (s *Index_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterIndex_element(s)
	}
}

func (s *Index_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitIndex_element(s)
	}
}

func (s *Index_elementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitIndex_element(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Index_element() (localctx IIndex_elementContext) {
	localctx = NewIndex_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, OBParserRULE_index_element)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5649)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserPRIMARY || _la == OBParserNAME_OB) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_listContext is an interface to support dynamic dispatch.
type IIndex_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIndex_element() []IIndex_elementContext
	Index_element(i int) IIndex_elementContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsIndex_listContext differentiates from other interfaces.
	IsIndex_listContext()
}

type Index_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_listContext() *Index_listContext {
	var p = new(Index_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_list
	return p
}

func InitEmptyIndex_listContext(p *Index_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_list
}

func (*Index_listContext) IsIndex_listContext() {}

func NewIndex_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_listContext {
	var p = new(Index_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_index_list

	return p
}

func (s *Index_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_listContext) AllIndex_element() []IIndex_elementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndex_elementContext); ok {
			len++
		}
	}

	tst := make([]IIndex_elementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndex_elementContext); ok {
			tst[i] = t.(IIndex_elementContext)
			i++
		}
	}

	return tst
}

func (s *Index_listContext) Index_element(i int) IIndex_elementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_elementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_elementContext)
}

func (s *Index_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Index_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Index_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterIndex_list(s)
	}
}

func (s *Index_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitIndex_list(s)
	}
}

func (s *Index_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitIndex_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Index_list() (localctx IIndex_listContext) {
	localctx = NewIndex_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, OBParserRULE_index_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5651)
		p.Index_element()
	}
	p.SetState(5656)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(5652)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5653)
			p.Index_element()
		}

		p.SetState(5658)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_hint_definitionContext is an interface to support dynamic dispatch.
type IIndex_hint_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	Key_or_index() IKey_or_indexContext
	Index_hint_scope() IIndex_hint_scopeContext
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	Index_list() IIndex_listContext
	Index_hint_type() IIndex_hint_typeContext

	// IsIndex_hint_definitionContext differentiates from other interfaces.
	IsIndex_hint_definitionContext()
}

type Index_hint_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_hint_definitionContext() *Index_hint_definitionContext {
	var p = new(Index_hint_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_hint_definition
	return p
}

func InitEmptyIndex_hint_definitionContext(p *Index_hint_definitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_hint_definition
}

func (*Index_hint_definitionContext) IsIndex_hint_definitionContext() {}

func NewIndex_hint_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_hint_definitionContext {
	var p = new(Index_hint_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_index_hint_definition

	return p
}

func (s *Index_hint_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_hint_definitionContext) USE() antlr.TerminalNode {
	return s.GetToken(OBParserUSE, 0)
}

func (s *Index_hint_definitionContext) Key_or_index() IKey_or_indexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKey_or_indexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKey_or_indexContext)
}

func (s *Index_hint_definitionContext) Index_hint_scope() IIndex_hint_scopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_hint_scopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_hint_scopeContext)
}

func (s *Index_hint_definitionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Index_hint_definitionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Index_hint_definitionContext) Index_list() IIndex_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_listContext)
}

func (s *Index_hint_definitionContext) Index_hint_type() IIndex_hint_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_hint_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_hint_typeContext)
}

func (s *Index_hint_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_hint_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_hint_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterIndex_hint_definition(s)
	}
}

func (s *Index_hint_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitIndex_hint_definition(s)
	}
}

func (s *Index_hint_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitIndex_hint_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Index_hint_definition() (localctx IIndex_hint_definitionContext) {
	localctx = NewIndex_hint_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, OBParserRULE_index_hint_definition)
	var _la int

	p.SetState(5675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserUSE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5659)
			p.Match(OBParserUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5660)
			p.Key_or_index()
		}
		{
			p.SetState(5661)
			p.Index_hint_scope()
		}
		{
			p.SetState(5662)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5664)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPRIMARY || _la == OBParserNAME_OB {
			{
				p.SetState(5663)
				p.Index_list()
			}

		}
		{
			p.SetState(5666)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserFORCE, OBParserIGNORE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5668)
			p.Index_hint_type()
		}
		{
			p.SetState(5669)
			p.Key_or_index()
		}
		{
			p.SetState(5670)
			p.Index_hint_scope()
		}
		{
			p.SetState(5671)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5672)
			p.Index_list()
		}
		{
			p.SetState(5673)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_hint_listContext is an interface to support dynamic dispatch.
type IIndex_hint_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Index_hint_definition() IIndex_hint_definitionContext
	Index_hint_list() IIndex_hint_listContext

	// IsIndex_hint_listContext differentiates from other interfaces.
	IsIndex_hint_listContext()
}

type Index_hint_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_hint_listContext() *Index_hint_listContext {
	var p = new(Index_hint_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_hint_list
	return p
}

func InitEmptyIndex_hint_listContext(p *Index_hint_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_hint_list
}

func (*Index_hint_listContext) IsIndex_hint_listContext() {}

func NewIndex_hint_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_hint_listContext {
	var p = new(Index_hint_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_index_hint_list

	return p
}

func (s *Index_hint_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_hint_listContext) Index_hint_definition() IIndex_hint_definitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_hint_definitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_hint_definitionContext)
}

func (s *Index_hint_listContext) Index_hint_list() IIndex_hint_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_hint_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_hint_listContext)
}

func (s *Index_hint_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_hint_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_hint_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterIndex_hint_list(s)
	}
}

func (s *Index_hint_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitIndex_hint_list(s)
	}
}

func (s *Index_hint_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitIndex_hint_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Index_hint_list() (localctx IIndex_hint_listContext) {
	localctx = NewIndex_hint_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, OBParserRULE_index_hint_list)
	p.SetState(5681)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 568, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5677)
			p.Index_hint_definition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5678)
			p.Index_hint_definition()
		}
		{
			p.SetState(5679)
			p.Index_hint_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelation_factorContext is an interface to support dynamic dispatch.
type IRelation_factorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Normal_relation_factor() INormal_relation_factorContext
	Dot_relation_factor() IDot_relation_factorContext

	// IsRelation_factorContext differentiates from other interfaces.
	IsRelation_factorContext()
}

type Relation_factorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelation_factorContext() *Relation_factorContext {
	var p = new(Relation_factorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor
	return p
}

func InitEmptyRelation_factorContext(p *Relation_factorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor
}

func (*Relation_factorContext) IsRelation_factorContext() {}

func NewRelation_factorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relation_factorContext {
	var p = new(Relation_factorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_relation_factor

	return p
}

func (s *Relation_factorContext) GetParser() antlr.Parser { return s.parser }

func (s *Relation_factorContext) Normal_relation_factor() INormal_relation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INormal_relation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INormal_relation_factorContext)
}

func (s *Relation_factorContext) Dot_relation_factor() IDot_relation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDot_relation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDot_relation_factorContext)
}

func (s *Relation_factorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relation_factorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relation_factorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRelation_factor(s)
	}
}

func (s *Relation_factorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRelation_factor(s)
	}
}

func (s *Relation_factorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRelation_factor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Relation_factor() (localctx IRelation_factorContext) {
	localctx = NewRelation_factorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, OBParserRULE_relation_factor)
	p.SetState(5685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserNAME_OB, OBParserSTAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5683)
			p.Normal_relation_factor()
		}

	case OBParserDot:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5684)
			p.Dot_relation_factor()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelation_with_star_listContext is an interface to support dynamic dispatch.
type IRelation_with_star_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelation_factor_with_star() []IRelation_factor_with_starContext
	Relation_factor_with_star(i int) IRelation_factor_with_starContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsRelation_with_star_listContext differentiates from other interfaces.
	IsRelation_with_star_listContext()
}

type Relation_with_star_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelation_with_star_listContext() *Relation_with_star_listContext {
	var p = new(Relation_with_star_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_with_star_list
	return p
}

func InitEmptyRelation_with_star_listContext(p *Relation_with_star_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_with_star_list
}

func (*Relation_with_star_listContext) IsRelation_with_star_listContext() {}

func NewRelation_with_star_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relation_with_star_listContext {
	var p = new(Relation_with_star_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_relation_with_star_list

	return p
}

func (s *Relation_with_star_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Relation_with_star_listContext) AllRelation_factor_with_star() []IRelation_factor_with_starContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_factor_with_starContext); ok {
			len++
		}
	}

	tst := make([]IRelation_factor_with_starContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_factor_with_starContext); ok {
			tst[i] = t.(IRelation_factor_with_starContext)
			i++
		}
	}

	return tst
}

func (s *Relation_with_star_listContext) Relation_factor_with_star(i int) IRelation_factor_with_starContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_with_starContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_with_starContext)
}

func (s *Relation_with_star_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Relation_with_star_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Relation_with_star_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relation_with_star_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relation_with_star_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRelation_with_star_list(s)
	}
}

func (s *Relation_with_star_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRelation_with_star_list(s)
	}
}

func (s *Relation_with_star_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRelation_with_star_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Relation_with_star_list() (localctx IRelation_with_star_listContext) {
	localctx = NewRelation_with_star_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, OBParserRULE_relation_with_star_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5687)
		p.Relation_factor_with_star()
	}
	p.SetState(5692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(5688)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5689)
			p.Relation_factor_with_star()
		}

		p.SetState(5694)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelation_factor_with_starContext is an interface to support dynamic dispatch.
type IRelation_factor_with_starContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelation_name() []IRelation_nameContext
	Relation_name(i int) IRelation_nameContext
	AllDot() []antlr.TerminalNode
	Dot(i int) antlr.TerminalNode
	Star() antlr.TerminalNode

	// IsRelation_factor_with_starContext differentiates from other interfaces.
	IsRelation_factor_with_starContext()
}

type Relation_factor_with_starContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelation_factor_with_starContext() *Relation_factor_with_starContext {
	var p = new(Relation_factor_with_starContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor_with_star
	return p
}

func InitEmptyRelation_factor_with_starContext(p *Relation_factor_with_starContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor_with_star
}

func (*Relation_factor_with_starContext) IsRelation_factor_with_starContext() {}

func NewRelation_factor_with_starContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relation_factor_with_starContext {
	var p = new(Relation_factor_with_starContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_relation_factor_with_star

	return p
}

func (s *Relation_factor_with_starContext) GetParser() antlr.Parser { return s.parser }

func (s *Relation_factor_with_starContext) AllRelation_name() []IRelation_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_nameContext); ok {
			len++
		}
	}

	tst := make([]IRelation_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_nameContext); ok {
			tst[i] = t.(IRelation_nameContext)
			i++
		}
	}

	return tst
}

func (s *Relation_factor_with_starContext) Relation_name(i int) IRelation_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Relation_factor_with_starContext) AllDot() []antlr.TerminalNode {
	return s.GetTokens(OBParserDot)
}

func (s *Relation_factor_with_starContext) Dot(i int) antlr.TerminalNode {
	return s.GetToken(OBParserDot, i)
}

func (s *Relation_factor_with_starContext) Star() antlr.TerminalNode {
	return s.GetToken(OBParserStar, 0)
}

func (s *Relation_factor_with_starContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relation_factor_with_starContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relation_factor_with_starContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRelation_factor_with_star(s)
	}
}

func (s *Relation_factor_with_starContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRelation_factor_with_star(s)
	}
}

func (s *Relation_factor_with_starContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRelation_factor_with_star(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Relation_factor_with_star() (localctx IRelation_factor_with_starContext) {
	localctx = NewRelation_factor_with_starContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, OBParserRULE_relation_factor_with_star)
	var _la int

	p.SetState(5707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 573, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5695)
			p.Relation_name()
		}
		p.SetState(5698)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserDot {
			{
				p.SetState(5696)
				p.Match(OBParserDot)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5697)
				p.Match(OBParserStar)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5700)
			p.Relation_name()
		}
		{
			p.SetState(5701)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5702)
			p.Relation_name()
		}
		p.SetState(5705)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserDot {
			{
				p.SetState(5703)
				p.Match(OBParserDot)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5704)
				p.Match(OBParserStar)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INormal_relation_factorContext is an interface to support dynamic dispatch.
type INormal_relation_factorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelation_name() []IRelation_nameContext
	Relation_name(i int) IRelation_nameContext
	Dot() antlr.TerminalNode

	// IsNormal_relation_factorContext differentiates from other interfaces.
	IsNormal_relation_factorContext()
}

type Normal_relation_factorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormal_relation_factorContext() *Normal_relation_factorContext {
	var p = new(Normal_relation_factorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_normal_relation_factor
	return p
}

func InitEmptyNormal_relation_factorContext(p *Normal_relation_factorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_normal_relation_factor
}

func (*Normal_relation_factorContext) IsNormal_relation_factorContext() {}

func NewNormal_relation_factorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Normal_relation_factorContext {
	var p = new(Normal_relation_factorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_normal_relation_factor

	return p
}

func (s *Normal_relation_factorContext) GetParser() antlr.Parser { return s.parser }

func (s *Normal_relation_factorContext) AllRelation_name() []IRelation_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_nameContext); ok {
			len++
		}
	}

	tst := make([]IRelation_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_nameContext); ok {
			tst[i] = t.(IRelation_nameContext)
			i++
		}
	}

	return tst
}

func (s *Normal_relation_factorContext) Relation_name(i int) IRelation_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Normal_relation_factorContext) Dot() antlr.TerminalNode {
	return s.GetToken(OBParserDot, 0)
}

func (s *Normal_relation_factorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Normal_relation_factorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Normal_relation_factorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterNormal_relation_factor(s)
	}
}

func (s *Normal_relation_factorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitNormal_relation_factor(s)
	}
}

func (s *Normal_relation_factorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitNormal_relation_factor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Normal_relation_factor() (localctx INormal_relation_factorContext) {
	localctx = NewNormal_relation_factorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, OBParserRULE_normal_relation_factor)
	p.SetState(5714)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 574, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5709)
			p.Relation_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5710)
			p.Relation_name()
		}
		{
			p.SetState(5711)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5712)
			p.Relation_name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDot_relation_factorContext is an interface to support dynamic dispatch.
type IDot_relation_factorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Dot() antlr.TerminalNode
	Relation_name() IRelation_nameContext

	// IsDot_relation_factorContext differentiates from other interfaces.
	IsDot_relation_factorContext()
}

type Dot_relation_factorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDot_relation_factorContext() *Dot_relation_factorContext {
	var p = new(Dot_relation_factorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_dot_relation_factor
	return p
}

func InitEmptyDot_relation_factorContext(p *Dot_relation_factorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_dot_relation_factor
}

func (*Dot_relation_factorContext) IsDot_relation_factorContext() {}

func NewDot_relation_factorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dot_relation_factorContext {
	var p = new(Dot_relation_factorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_dot_relation_factor

	return p
}

func (s *Dot_relation_factorContext) GetParser() antlr.Parser { return s.parser }

func (s *Dot_relation_factorContext) Dot() antlr.TerminalNode {
	return s.GetToken(OBParserDot, 0)
}

func (s *Dot_relation_factorContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Dot_relation_factorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dot_relation_factorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dot_relation_factorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDot_relation_factor(s)
	}
}

func (s *Dot_relation_factorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDot_relation_factor(s)
	}
}

func (s *Dot_relation_factorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDot_relation_factor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Dot_relation_factor() (localctx IDot_relation_factorContext) {
	localctx = NewDot_relation_factorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, OBParserRULE_dot_relation_factor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5716)
		p.Match(OBParserDot)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5717)
		p.Relation_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelation_factor_in_hintContext is an interface to support dynamic dispatch.
type IRelation_factor_in_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Normal_relation_factor() INormal_relation_factorContext
	Qb_name_option() IQb_name_optionContext

	// IsRelation_factor_in_hintContext differentiates from other interfaces.
	IsRelation_factor_in_hintContext()
}

type Relation_factor_in_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelation_factor_in_hintContext() *Relation_factor_in_hintContext {
	var p = new(Relation_factor_in_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor_in_hint
	return p
}

func InitEmptyRelation_factor_in_hintContext(p *Relation_factor_in_hintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor_in_hint
}

func (*Relation_factor_in_hintContext) IsRelation_factor_in_hintContext() {}

func NewRelation_factor_in_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relation_factor_in_hintContext {
	var p = new(Relation_factor_in_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_relation_factor_in_hint

	return p
}

func (s *Relation_factor_in_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *Relation_factor_in_hintContext) Normal_relation_factor() INormal_relation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INormal_relation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INormal_relation_factorContext)
}

func (s *Relation_factor_in_hintContext) Qb_name_option() IQb_name_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQb_name_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQb_name_optionContext)
}

func (s *Relation_factor_in_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relation_factor_in_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relation_factor_in_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRelation_factor_in_hint(s)
	}
}

func (s *Relation_factor_in_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRelation_factor_in_hint(s)
	}
}

func (s *Relation_factor_in_hintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRelation_factor_in_hint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Relation_factor_in_hint() (localctx IRelation_factor_in_hintContext) {
	localctx = NewRelation_factor_in_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, OBParserRULE_relation_factor_in_hint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5719)
		p.Normal_relation_factor()
	}
	{
		p.SetState(5720)
		p.Qb_name_option()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQb_name_optionContext is an interface to support dynamic dispatch.
type IQb_name_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	At() antlr.TerminalNode
	NAME_OB() antlr.TerminalNode
	Empty() IEmptyContext

	// IsQb_name_optionContext differentiates from other interfaces.
	IsQb_name_optionContext()
}

type Qb_name_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQb_name_optionContext() *Qb_name_optionContext {
	var p = new(Qb_name_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_qb_name_option
	return p
}

func InitEmptyQb_name_optionContext(p *Qb_name_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_qb_name_option
}

func (*Qb_name_optionContext) IsQb_name_optionContext() {}

func NewQb_name_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Qb_name_optionContext {
	var p = new(Qb_name_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_qb_name_option

	return p
}

func (s *Qb_name_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Qb_name_optionContext) At() antlr.TerminalNode {
	return s.GetToken(OBParserAt, 0)
}

func (s *Qb_name_optionContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Qb_name_optionContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Qb_name_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Qb_name_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Qb_name_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterQb_name_option(s)
	}
}

func (s *Qb_name_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitQb_name_option(s)
	}
}

func (s *Qb_name_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitQb_name_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Qb_name_option() (localctx IQb_name_optionContext) {
	localctx = NewQb_name_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, OBParserRULE_qb_name_option)
	p.SetState(5725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 575, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5722)
			p.Match(OBParserAt)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5723)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5724)
			p.Empty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelation_factor_in_hint_listContext is an interface to support dynamic dispatch.
type IRelation_factor_in_hint_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelation_factor_in_hint() []IRelation_factor_in_hintContext
	Relation_factor_in_hint(i int) IRelation_factor_in_hintContext
	AllRelation_sep_option() []IRelation_sep_optionContext
	Relation_sep_option(i int) IRelation_sep_optionContext

	// IsRelation_factor_in_hint_listContext differentiates from other interfaces.
	IsRelation_factor_in_hint_listContext()
}

type Relation_factor_in_hint_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelation_factor_in_hint_listContext() *Relation_factor_in_hint_listContext {
	var p = new(Relation_factor_in_hint_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor_in_hint_list
	return p
}

func InitEmptyRelation_factor_in_hint_listContext(p *Relation_factor_in_hint_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor_in_hint_list
}

func (*Relation_factor_in_hint_listContext) IsRelation_factor_in_hint_listContext() {}

func NewRelation_factor_in_hint_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relation_factor_in_hint_listContext {
	var p = new(Relation_factor_in_hint_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_relation_factor_in_hint_list

	return p
}

func (s *Relation_factor_in_hint_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Relation_factor_in_hint_listContext) AllRelation_factor_in_hint() []IRelation_factor_in_hintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_factor_in_hintContext); ok {
			len++
		}
	}

	tst := make([]IRelation_factor_in_hintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_factor_in_hintContext); ok {
			tst[i] = t.(IRelation_factor_in_hintContext)
			i++
		}
	}

	return tst
}

func (s *Relation_factor_in_hint_listContext) Relation_factor_in_hint(i int) IRelation_factor_in_hintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_hintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_hintContext)
}

func (s *Relation_factor_in_hint_listContext) AllRelation_sep_option() []IRelation_sep_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_sep_optionContext); ok {
			len++
		}
	}

	tst := make([]IRelation_sep_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_sep_optionContext); ok {
			tst[i] = t.(IRelation_sep_optionContext)
			i++
		}
	}

	return tst
}

func (s *Relation_factor_in_hint_listContext) Relation_sep_option(i int) IRelation_sep_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_sep_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_sep_optionContext)
}

func (s *Relation_factor_in_hint_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relation_factor_in_hint_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relation_factor_in_hint_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRelation_factor_in_hint_list(s)
	}
}

func (s *Relation_factor_in_hint_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRelation_factor_in_hint_list(s)
	}
}

func (s *Relation_factor_in_hint_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRelation_factor_in_hint_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Relation_factor_in_hint_list() (localctx IRelation_factor_in_hint_listContext) {
	localctx = NewRelation_factor_in_hint_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, OBParserRULE_relation_factor_in_hint_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5727)
		p.Relation_factor_in_hint()
	}
	p.SetState(5733)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 576, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5728)
				p.Relation_sep_option()
			}
			{
				p.SetState(5729)
				p.Relation_factor_in_hint()
			}

		}
		p.SetState(5735)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 576, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelation_sep_optionContext is an interface to support dynamic dispatch.
type IRelation_sep_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Comma() antlr.TerminalNode

	// IsRelation_sep_optionContext differentiates from other interfaces.
	IsRelation_sep_optionContext()
}

type Relation_sep_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelation_sep_optionContext() *Relation_sep_optionContext {
	var p = new(Relation_sep_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_sep_option
	return p
}

func InitEmptyRelation_sep_optionContext(p *Relation_sep_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_sep_option
}

func (*Relation_sep_optionContext) IsRelation_sep_optionContext() {}

func NewRelation_sep_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relation_sep_optionContext {
	var p = new(Relation_sep_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_relation_sep_option

	return p
}

func (s *Relation_sep_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Relation_sep_optionContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Relation_sep_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relation_sep_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relation_sep_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRelation_sep_option(s)
	}
}

func (s *Relation_sep_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRelation_sep_option(s)
	}
}

func (s *Relation_sep_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRelation_sep_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Relation_sep_option() (localctx IRelation_sep_optionContext) {
	localctx = NewRelation_sep_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, OBParserRULE_relation_sep_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserComma {
		{
			p.SetState(5736)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelation_factor_in_pq_hintContext is an interface to support dynamic dispatch.
type IRelation_factor_in_pq_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Relation_factor_in_hint() IRelation_factor_in_hintContext
	LeftParen() antlr.TerminalNode
	Relation_factor_in_hint_list() IRelation_factor_in_hint_listContext
	RightParen() antlr.TerminalNode

	// IsRelation_factor_in_pq_hintContext differentiates from other interfaces.
	IsRelation_factor_in_pq_hintContext()
}

type Relation_factor_in_pq_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelation_factor_in_pq_hintContext() *Relation_factor_in_pq_hintContext {
	var p = new(Relation_factor_in_pq_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor_in_pq_hint
	return p
}

func InitEmptyRelation_factor_in_pq_hintContext(p *Relation_factor_in_pq_hintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor_in_pq_hint
}

func (*Relation_factor_in_pq_hintContext) IsRelation_factor_in_pq_hintContext() {}

func NewRelation_factor_in_pq_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relation_factor_in_pq_hintContext {
	var p = new(Relation_factor_in_pq_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_relation_factor_in_pq_hint

	return p
}

func (s *Relation_factor_in_pq_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *Relation_factor_in_pq_hintContext) Relation_factor_in_hint() IRelation_factor_in_hintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_hintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_hintContext)
}

func (s *Relation_factor_in_pq_hintContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Relation_factor_in_pq_hintContext) Relation_factor_in_hint_list() IRelation_factor_in_hint_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_hint_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_hint_listContext)
}

func (s *Relation_factor_in_pq_hintContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Relation_factor_in_pq_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relation_factor_in_pq_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relation_factor_in_pq_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRelation_factor_in_pq_hint(s)
	}
}

func (s *Relation_factor_in_pq_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRelation_factor_in_pq_hint(s)
	}
}

func (s *Relation_factor_in_pq_hintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRelation_factor_in_pq_hint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Relation_factor_in_pq_hint() (localctx IRelation_factor_in_pq_hintContext) {
	localctx = NewRelation_factor_in_pq_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, OBParserRULE_relation_factor_in_pq_hint)
	p.SetState(5744)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserNAME_OB, OBParserSTAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5739)
			p.Relation_factor_in_hint()
		}

	case OBParserLeftParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5740)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5741)
			p.Relation_factor_in_hint_list()
		}
		{
			p.SetState(5742)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelation_factor_in_leading_hintContext is an interface to support dynamic dispatch.
type IRelation_factor_in_leading_hintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	Relation_factor_in_hint_list() IRelation_factor_in_hint_listContext
	RightParen() antlr.TerminalNode

	// IsRelation_factor_in_leading_hintContext differentiates from other interfaces.
	IsRelation_factor_in_leading_hintContext()
}

type Relation_factor_in_leading_hintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelation_factor_in_leading_hintContext() *Relation_factor_in_leading_hintContext {
	var p = new(Relation_factor_in_leading_hintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor_in_leading_hint
	return p
}

func InitEmptyRelation_factor_in_leading_hintContext(p *Relation_factor_in_leading_hintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor_in_leading_hint
}

func (*Relation_factor_in_leading_hintContext) IsRelation_factor_in_leading_hintContext() {}

func NewRelation_factor_in_leading_hintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relation_factor_in_leading_hintContext {
	var p = new(Relation_factor_in_leading_hintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_relation_factor_in_leading_hint

	return p
}

func (s *Relation_factor_in_leading_hintContext) GetParser() antlr.Parser { return s.parser }

func (s *Relation_factor_in_leading_hintContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Relation_factor_in_leading_hintContext) Relation_factor_in_hint_list() IRelation_factor_in_hint_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_hint_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_hint_listContext)
}

func (s *Relation_factor_in_leading_hintContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Relation_factor_in_leading_hintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relation_factor_in_leading_hintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relation_factor_in_leading_hintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRelation_factor_in_leading_hint(s)
	}
}

func (s *Relation_factor_in_leading_hintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRelation_factor_in_leading_hint(s)
	}
}

func (s *Relation_factor_in_leading_hintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRelation_factor_in_leading_hint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Relation_factor_in_leading_hint() (localctx IRelation_factor_in_leading_hintContext) {
	localctx = NewRelation_factor_in_leading_hintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, OBParserRULE_relation_factor_in_leading_hint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5746)
		p.Match(OBParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5747)
		p.Relation_factor_in_hint_list()
	}
	{
		p.SetState(5748)
		p.Match(OBParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelation_factor_in_leading_hint_listContext is an interface to support dynamic dispatch.
type IRelation_factor_in_leading_hint_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Relation_factor_in_leading_hint() IRelation_factor_in_leading_hintContext
	LeftParen() antlr.TerminalNode
	AllRelation_factor_in_leading_hint_list() []IRelation_factor_in_leading_hint_listContext
	Relation_factor_in_leading_hint_list(i int) IRelation_factor_in_leading_hint_listContext
	RightParen() antlr.TerminalNode
	Relation_factor_in_hint_list() IRelation_factor_in_hint_listContext
	AllRelation_sep_option() []IRelation_sep_optionContext
	Relation_sep_option(i int) IRelation_sep_optionContext
	Relation_factor_in_hint() IRelation_factor_in_hintContext

	// IsRelation_factor_in_leading_hint_listContext differentiates from other interfaces.
	IsRelation_factor_in_leading_hint_listContext()
}

type Relation_factor_in_leading_hint_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelation_factor_in_leading_hint_listContext() *Relation_factor_in_leading_hint_listContext {
	var p = new(Relation_factor_in_leading_hint_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor_in_leading_hint_list
	return p
}

func InitEmptyRelation_factor_in_leading_hint_listContext(p *Relation_factor_in_leading_hint_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor_in_leading_hint_list
}

func (*Relation_factor_in_leading_hint_listContext) IsRelation_factor_in_leading_hint_listContext() {}

func NewRelation_factor_in_leading_hint_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relation_factor_in_leading_hint_listContext {
	var p = new(Relation_factor_in_leading_hint_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_relation_factor_in_leading_hint_list

	return p
}

func (s *Relation_factor_in_leading_hint_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Relation_factor_in_leading_hint_listContext) Relation_factor_in_leading_hint() IRelation_factor_in_leading_hintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_leading_hintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_leading_hintContext)
}

func (s *Relation_factor_in_leading_hint_listContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Relation_factor_in_leading_hint_listContext) AllRelation_factor_in_leading_hint_list() []IRelation_factor_in_leading_hint_listContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_factor_in_leading_hint_listContext); ok {
			len++
		}
	}

	tst := make([]IRelation_factor_in_leading_hint_listContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_factor_in_leading_hint_listContext); ok {
			tst[i] = t.(IRelation_factor_in_leading_hint_listContext)
			i++
		}
	}

	return tst
}

func (s *Relation_factor_in_leading_hint_listContext) Relation_factor_in_leading_hint_list(i int) IRelation_factor_in_leading_hint_listContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_leading_hint_listContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_leading_hint_listContext)
}

func (s *Relation_factor_in_leading_hint_listContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Relation_factor_in_leading_hint_listContext) Relation_factor_in_hint_list() IRelation_factor_in_hint_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_hint_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_hint_listContext)
}

func (s *Relation_factor_in_leading_hint_listContext) AllRelation_sep_option() []IRelation_sep_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_sep_optionContext); ok {
			len++
		}
	}

	tst := make([]IRelation_sep_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_sep_optionContext); ok {
			tst[i] = t.(IRelation_sep_optionContext)
			i++
		}
	}

	return tst
}

func (s *Relation_factor_in_leading_hint_listContext) Relation_sep_option(i int) IRelation_sep_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_sep_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_sep_optionContext)
}

func (s *Relation_factor_in_leading_hint_listContext) Relation_factor_in_hint() IRelation_factor_in_hintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_hintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_hintContext)
}

func (s *Relation_factor_in_leading_hint_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relation_factor_in_leading_hint_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relation_factor_in_leading_hint_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRelation_factor_in_leading_hint_list(s)
	}
}

func (s *Relation_factor_in_leading_hint_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRelation_factor_in_leading_hint_list(s)
	}
}

func (s *Relation_factor_in_leading_hint_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRelation_factor_in_leading_hint_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Relation_factor_in_leading_hint_list() (localctx IRelation_factor_in_leading_hint_listContext) {
	return p.relation_factor_in_leading_hint_list(0)
}

func (p *OBParser) relation_factor_in_leading_hint_list(_p int) (localctx IRelation_factor_in_leading_hint_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewRelation_factor_in_leading_hint_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRelation_factor_in_leading_hint_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 606
	p.EnterRecursionRule(localctx, 606, OBParserRULE_relation_factor_in_leading_hint_list, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 579, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5751)
			p.Relation_factor_in_leading_hint()
		}

	case 2:
		{
			p.SetState(5752)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5753)
			p.relation_factor_in_leading_hint_list(0)
		}
		{
			p.SetState(5754)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(5756)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5757)
			p.Relation_factor_in_hint_list()
		}
		{
			p.SetState(5758)
			p.Relation_sep_option()
		}
		{
			p.SetState(5759)
			p.relation_factor_in_leading_hint_list(0)
		}
		{
			p.SetState(5760)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5782)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 581, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5780)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 580, p.GetParserRuleContext()) {
			case 1:
				localctx = NewRelation_factor_in_leading_hint_listContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_relation_factor_in_leading_hint_list)
				p.SetState(5764)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(5765)
					p.Relation_sep_option()
				}
				{
					p.SetState(5766)
					p.Relation_factor_in_leading_hint()
				}

			case 2:
				localctx = NewRelation_factor_in_leading_hint_listContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_relation_factor_in_leading_hint_list)
				p.SetState(5768)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(5769)
					p.Relation_sep_option()
				}
				{
					p.SetState(5770)
					p.Relation_factor_in_hint()
				}

			case 3:
				localctx = NewRelation_factor_in_leading_hint_listContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_relation_factor_in_leading_hint_list)
				p.SetState(5772)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5773)
					p.Relation_sep_option()
				}
				{
					p.SetState(5774)
					p.Match(OBParserLeftParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5775)
					p.Relation_factor_in_hint_list()
				}
				{
					p.SetState(5776)
					p.Relation_sep_option()
				}
				{
					p.SetState(5777)
					p.relation_factor_in_leading_hint_list(0)
				}
				{
					p.SetState(5778)
					p.Match(OBParserRightParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5784)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 581, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelation_factor_in_leading_hint_list_entryContext is an interface to support dynamic dispatch.
type IRelation_factor_in_leading_hint_list_entryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Relation_factor_in_leading_hint_list() IRelation_factor_in_leading_hint_listContext
	Relation_factor_in_hint_list() IRelation_factor_in_hint_listContext
	Relation_sep_option() IRelation_sep_optionContext

	// IsRelation_factor_in_leading_hint_list_entryContext differentiates from other interfaces.
	IsRelation_factor_in_leading_hint_list_entryContext()
}

type Relation_factor_in_leading_hint_list_entryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelation_factor_in_leading_hint_list_entryContext() *Relation_factor_in_leading_hint_list_entryContext {
	var p = new(Relation_factor_in_leading_hint_list_entryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor_in_leading_hint_list_entry
	return p
}

func InitEmptyRelation_factor_in_leading_hint_list_entryContext(p *Relation_factor_in_leading_hint_list_entryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor_in_leading_hint_list_entry
}

func (*Relation_factor_in_leading_hint_list_entryContext) IsRelation_factor_in_leading_hint_list_entryContext() {
}

func NewRelation_factor_in_leading_hint_list_entryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relation_factor_in_leading_hint_list_entryContext {
	var p = new(Relation_factor_in_leading_hint_list_entryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_relation_factor_in_leading_hint_list_entry

	return p
}

func (s *Relation_factor_in_leading_hint_list_entryContext) GetParser() antlr.Parser { return s.parser }

func (s *Relation_factor_in_leading_hint_list_entryContext) Relation_factor_in_leading_hint_list() IRelation_factor_in_leading_hint_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_leading_hint_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_leading_hint_listContext)
}

func (s *Relation_factor_in_leading_hint_list_entryContext) Relation_factor_in_hint_list() IRelation_factor_in_hint_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_hint_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_hint_listContext)
}

func (s *Relation_factor_in_leading_hint_list_entryContext) Relation_sep_option() IRelation_sep_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_sep_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_sep_optionContext)
}

func (s *Relation_factor_in_leading_hint_list_entryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relation_factor_in_leading_hint_list_entryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relation_factor_in_leading_hint_list_entryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRelation_factor_in_leading_hint_list_entry(s)
	}
}

func (s *Relation_factor_in_leading_hint_list_entryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRelation_factor_in_leading_hint_list_entry(s)
	}
}

func (s *Relation_factor_in_leading_hint_list_entryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRelation_factor_in_leading_hint_list_entry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Relation_factor_in_leading_hint_list_entry() (localctx IRelation_factor_in_leading_hint_list_entryContext) {
	localctx = NewRelation_factor_in_leading_hint_list_entryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, OBParserRULE_relation_factor_in_leading_hint_list_entry)
	p.SetState(5790)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserLeftParen:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5785)
			p.relation_factor_in_leading_hint_list(0)
		}

	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserNAME_OB, OBParserSTAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5786)
			p.Relation_factor_in_hint_list()
		}
		{
			p.SetState(5787)
			p.Relation_sep_option()
		}
		{
			p.SetState(5788)
			p.relation_factor_in_leading_hint_list(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelation_factor_in_use_join_hint_listContext is an interface to support dynamic dispatch.
type IRelation_factor_in_use_join_hint_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Relation_factor_in_hint() IRelation_factor_in_hintContext
	LeftParen() antlr.TerminalNode
	Relation_factor_in_hint_list() IRelation_factor_in_hint_listContext
	RightParen() antlr.TerminalNode
	Relation_factor_in_use_join_hint_list() IRelation_factor_in_use_join_hint_listContext
	Relation_sep_option() IRelation_sep_optionContext

	// IsRelation_factor_in_use_join_hint_listContext differentiates from other interfaces.
	IsRelation_factor_in_use_join_hint_listContext()
}

type Relation_factor_in_use_join_hint_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelation_factor_in_use_join_hint_listContext() *Relation_factor_in_use_join_hint_listContext {
	var p = new(Relation_factor_in_use_join_hint_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor_in_use_join_hint_list
	return p
}

func InitEmptyRelation_factor_in_use_join_hint_listContext(p *Relation_factor_in_use_join_hint_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_factor_in_use_join_hint_list
}

func (*Relation_factor_in_use_join_hint_listContext) IsRelation_factor_in_use_join_hint_listContext() {
}

func NewRelation_factor_in_use_join_hint_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relation_factor_in_use_join_hint_listContext {
	var p = new(Relation_factor_in_use_join_hint_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_relation_factor_in_use_join_hint_list

	return p
}

func (s *Relation_factor_in_use_join_hint_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Relation_factor_in_use_join_hint_listContext) Relation_factor_in_hint() IRelation_factor_in_hintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_hintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_hintContext)
}

func (s *Relation_factor_in_use_join_hint_listContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Relation_factor_in_use_join_hint_listContext) Relation_factor_in_hint_list() IRelation_factor_in_hint_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_hint_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_hint_listContext)
}

func (s *Relation_factor_in_use_join_hint_listContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Relation_factor_in_use_join_hint_listContext) Relation_factor_in_use_join_hint_list() IRelation_factor_in_use_join_hint_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factor_in_use_join_hint_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factor_in_use_join_hint_listContext)
}

func (s *Relation_factor_in_use_join_hint_listContext) Relation_sep_option() IRelation_sep_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_sep_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_sep_optionContext)
}

func (s *Relation_factor_in_use_join_hint_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relation_factor_in_use_join_hint_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relation_factor_in_use_join_hint_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRelation_factor_in_use_join_hint_list(s)
	}
}

func (s *Relation_factor_in_use_join_hint_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRelation_factor_in_use_join_hint_list(s)
	}
}

func (s *Relation_factor_in_use_join_hint_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRelation_factor_in_use_join_hint_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Relation_factor_in_use_join_hint_list() (localctx IRelation_factor_in_use_join_hint_listContext) {
	return p.relation_factor_in_use_join_hint_list(0)
}

func (p *OBParser) relation_factor_in_use_join_hint_list(_p int) (localctx IRelation_factor_in_use_join_hint_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewRelation_factor_in_use_join_hint_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRelation_factor_in_use_join_hint_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 610
	p.EnterRecursionRule(localctx, 610, OBParserRULE_relation_factor_in_use_join_hint_list, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5798)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserNAME_OB, OBParserSTAT:
		{
			p.SetState(5793)
			p.Relation_factor_in_hint()
		}

	case OBParserLeftParen:
		{
			p.SetState(5794)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5795)
			p.Relation_factor_in_hint_list()
		}
		{
			p.SetState(5796)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 585, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5810)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 584, p.GetParserRuleContext()) {
			case 1:
				localctx = NewRelation_factor_in_use_join_hint_listContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_relation_factor_in_use_join_hint_list)
				p.SetState(5800)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(5801)
					p.Relation_sep_option()
				}
				{
					p.SetState(5802)
					p.Relation_factor_in_hint()
				}

			case 2:
				localctx = NewRelation_factor_in_use_join_hint_listContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_relation_factor_in_use_join_hint_list)
				p.SetState(5804)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5805)
					p.Relation_sep_option()
				}
				{
					p.SetState(5806)
					p.Match(OBParserLeftParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5807)
					p.Relation_factor_in_hint_list()
				}
				{
					p.SetState(5808)
					p.Match(OBParserRightParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5814)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 585, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITracing_num_listContext is an interface to support dynamic dispatch.
type ITracing_num_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTNUM() antlr.TerminalNode
	Relation_sep_option() IRelation_sep_optionContext
	Tracing_num_list() ITracing_num_listContext

	// IsTracing_num_listContext differentiates from other interfaces.
	IsTracing_num_listContext()
}

type Tracing_num_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTracing_num_listContext() *Tracing_num_listContext {
	var p = new(Tracing_num_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tracing_num_list
	return p
}

func InitEmptyTracing_num_listContext(p *Tracing_num_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tracing_num_list
}

func (*Tracing_num_listContext) IsTracing_num_listContext() {}

func NewTracing_num_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tracing_num_listContext {
	var p = new(Tracing_num_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tracing_num_list

	return p
}

func (s *Tracing_num_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Tracing_num_listContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Tracing_num_listContext) Relation_sep_option() IRelation_sep_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_sep_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_sep_optionContext)
}

func (s *Tracing_num_listContext) Tracing_num_list() ITracing_num_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITracing_num_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITracing_num_listContext)
}

func (s *Tracing_num_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tracing_num_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tracing_num_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTracing_num_list(s)
	}
}

func (s *Tracing_num_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTracing_num_list(s)
	}
}

func (s *Tracing_num_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTracing_num_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tracing_num_list() (localctx ITracing_num_listContext) {
	localctx = NewTracing_num_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, OBParserRULE_tracing_num_list)
	p.SetState(5820)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 586, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5815)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5816)
			p.Relation_sep_option()
		}
		{
			p.SetState(5817)
			p.Tracing_num_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5819)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoin_conditionContext is an interface to support dynamic dispatch.
type IJoin_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	Expr() IExprContext
	USING() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Column_list() IColumn_listContext
	RightParen() antlr.TerminalNode

	// IsJoin_conditionContext differentiates from other interfaces.
	IsJoin_conditionContext()
}

type Join_conditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_conditionContext() *Join_conditionContext {
	var p = new(Join_conditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_join_condition
	return p
}

func InitEmptyJoin_conditionContext(p *Join_conditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_join_condition
}

func (*Join_conditionContext) IsJoin_conditionContext() {}

func NewJoin_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_conditionContext {
	var p = new(Join_conditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_join_condition

	return p
}

func (s *Join_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_conditionContext) ON() antlr.TerminalNode {
	return s.GetToken(OBParserON, 0)
}

func (s *Join_conditionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Join_conditionContext) USING() antlr.TerminalNode {
	return s.GetToken(OBParserUSING, 0)
}

func (s *Join_conditionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Join_conditionContext) Column_list() IColumn_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_listContext)
}

func (s *Join_conditionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Join_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterJoin_condition(s)
	}
}

func (s *Join_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitJoin_condition(s)
	}
}

func (s *Join_conditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitJoin_condition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Join_condition() (localctx IJoin_conditionContext) {
	localctx = NewJoin_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, OBParserRULE_join_condition)
	p.SetState(5829)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5822)
			p.Match(OBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5823)
			p.expr(0)
		}

	case OBParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5824)
			p.Match(OBParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5825)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5826)
			p.Column_list()
		}
		{
			p.SetState(5827)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoined_tableContext is an interface to support dynamic dispatch.
type IJoined_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTable_factor() []ITable_factorContext
	Table_factor(i int) ITable_factorContext
	Inner_join_type() IInner_join_typeContext
	ON() antlr.TerminalNode
	Expr() IExprContext
	USING() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Column_list() IColumn_listContext
	RightParen() antlr.TerminalNode
	Outer_join_type() IOuter_join_typeContext
	Join_condition() IJoin_conditionContext
	Natural_join_type() INatural_join_typeContext
	Joined_table() IJoined_tableContext

	// IsJoined_tableContext differentiates from other interfaces.
	IsJoined_tableContext()
}

type Joined_tableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoined_tableContext() *Joined_tableContext {
	var p = new(Joined_tableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_joined_table
	return p
}

func InitEmptyJoined_tableContext(p *Joined_tableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_joined_table
}

func (*Joined_tableContext) IsJoined_tableContext() {}

func NewJoined_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Joined_tableContext {
	var p = new(Joined_tableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_joined_table

	return p
}

func (s *Joined_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Joined_tableContext) AllTable_factor() []ITable_factorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITable_factorContext); ok {
			len++
		}
	}

	tst := make([]ITable_factorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITable_factorContext); ok {
			tst[i] = t.(ITable_factorContext)
			i++
		}
	}

	return tst
}

func (s *Joined_tableContext) Table_factor(i int) ITable_factorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_factorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_factorContext)
}

func (s *Joined_tableContext) Inner_join_type() IInner_join_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInner_join_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInner_join_typeContext)
}

func (s *Joined_tableContext) ON() antlr.TerminalNode {
	return s.GetToken(OBParserON, 0)
}

func (s *Joined_tableContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Joined_tableContext) USING() antlr.TerminalNode {
	return s.GetToken(OBParserUSING, 0)
}

func (s *Joined_tableContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Joined_tableContext) Column_list() IColumn_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_listContext)
}

func (s *Joined_tableContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Joined_tableContext) Outer_join_type() IOuter_join_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOuter_join_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOuter_join_typeContext)
}

func (s *Joined_tableContext) Join_condition() IJoin_conditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoin_conditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoin_conditionContext)
}

func (s *Joined_tableContext) Natural_join_type() INatural_join_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INatural_join_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INatural_join_typeContext)
}

func (s *Joined_tableContext) Joined_table() IJoined_tableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoined_tableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoined_tableContext)
}

func (s *Joined_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Joined_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Joined_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterJoined_table(s)
	}
}

func (s *Joined_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitJoined_table(s)
	}
}

func (s *Joined_tableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitJoined_table(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Joined_table() (localctx IJoined_tableContext) {
	return p.joined_table(0)
}

func (p *OBParser) joined_table(_p int) (localctx IJoined_tableContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewJoined_tableContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IJoined_tableContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 616
	p.EnterRecursionRule(localctx, 616, OBParserRULE_joined_table, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5859)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 588, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5832)
			p.Table_factor()
		}
		{
			p.SetState(5833)
			p.Inner_join_type()
		}
		{
			p.SetState(5834)
			p.Table_factor()
		}

	case 2:
		{
			p.SetState(5836)
			p.Table_factor()
		}
		{
			p.SetState(5837)
			p.Inner_join_type()
		}
		{
			p.SetState(5838)
			p.Table_factor()
		}
		{
			p.SetState(5839)
			p.Match(OBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5840)
			p.expr(0)
		}

	case 3:
		{
			p.SetState(5842)
			p.Table_factor()
		}
		{
			p.SetState(5843)
			p.Inner_join_type()
		}
		{
			p.SetState(5844)
			p.Table_factor()
		}
		{
			p.SetState(5845)
			p.Match(OBParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5846)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5847)
			p.Column_list()
		}
		{
			p.SetState(5848)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(5850)
			p.Table_factor()
		}
		{
			p.SetState(5851)
			p.Outer_join_type()
		}
		{
			p.SetState(5852)
			p.Table_factor()
		}
		{
			p.SetState(5853)
			p.Join_condition()
		}

	case 5:
		{
			p.SetState(5855)
			p.Table_factor()
		}
		{
			p.SetState(5856)
			p.Natural_join_type()
		}
		{
			p.SetState(5857)
			p.Table_factor()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5890)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 590, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5888)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 589, p.GetParserRuleContext()) {
			case 1:
				localctx = NewJoined_tableContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_joined_table)
				p.SetState(5861)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(5862)
					p.Inner_join_type()
				}
				{
					p.SetState(5863)
					p.Table_factor()
				}

			case 2:
				localctx = NewJoined_tableContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_joined_table)
				p.SetState(5865)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(5866)
					p.Inner_join_type()
				}
				{
					p.SetState(5867)
					p.Table_factor()
				}
				{
					p.SetState(5868)
					p.Match(OBParserON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5869)
					p.expr(0)
				}

			case 3:
				localctx = NewJoined_tableContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_joined_table)
				p.SetState(5871)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(5872)
					p.Inner_join_type()
				}
				{
					p.SetState(5873)
					p.Table_factor()
				}
				{
					p.SetState(5874)
					p.Match(OBParserUSING)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5875)
					p.Match(OBParserLeftParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5876)
					p.Column_list()
				}
				{
					p.SetState(5877)
					p.Match(OBParserRightParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 4:
				localctx = NewJoined_tableContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_joined_table)
				p.SetState(5879)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(5880)
					p.Outer_join_type()
				}
				{
					p.SetState(5881)
					p.Table_factor()
				}
				{
					p.SetState(5882)
					p.Join_condition()
				}

			case 5:
				localctx = NewJoined_tableContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_joined_table)
				p.SetState(5884)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5885)
					p.Natural_join_type()
				}
				{
					p.SetState(5886)
					p.Table_factor()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5892)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 590, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INatural_join_typeContext is an interface to support dynamic dispatch.
type INatural_join_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NATURAL() antlr.TerminalNode
	Outer_join_type() IOuter_join_typeContext
	JOIN() antlr.TerminalNode
	INNER() antlr.TerminalNode

	// IsNatural_join_typeContext differentiates from other interfaces.
	IsNatural_join_typeContext()
}

type Natural_join_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNatural_join_typeContext() *Natural_join_typeContext {
	var p = new(Natural_join_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_natural_join_type
	return p
}

func InitEmptyNatural_join_typeContext(p *Natural_join_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_natural_join_type
}

func (*Natural_join_typeContext) IsNatural_join_typeContext() {}

func NewNatural_join_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Natural_join_typeContext {
	var p = new(Natural_join_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_natural_join_type

	return p
}

func (s *Natural_join_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Natural_join_typeContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(OBParserNATURAL, 0)
}

func (s *Natural_join_typeContext) Outer_join_type() IOuter_join_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOuter_join_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOuter_join_typeContext)
}

func (s *Natural_join_typeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(OBParserJOIN, 0)
}

func (s *Natural_join_typeContext) INNER() antlr.TerminalNode {
	return s.GetToken(OBParserINNER, 0)
}

func (s *Natural_join_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Natural_join_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Natural_join_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterNatural_join_type(s)
	}
}

func (s *Natural_join_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitNatural_join_type(s)
	}
}

func (s *Natural_join_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitNatural_join_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Natural_join_type() (localctx INatural_join_typeContext) {
	localctx = NewNatural_join_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, OBParserRULE_natural_join_type)
	var _la int

	p.SetState(5900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 592, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5893)
			p.Match(OBParserNATURAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5894)
			p.Outer_join_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5895)
			p.Match(OBParserNATURAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5897)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserINNER {
			{
				p.SetState(5896)
				p.Match(OBParserINNER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5899)
			p.Match(OBParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInner_join_typeContext is an interface to support dynamic dispatch.
type IInner_join_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JOIN() antlr.TerminalNode
	INNER() antlr.TerminalNode
	CROSS() antlr.TerminalNode

	// IsInner_join_typeContext differentiates from other interfaces.
	IsInner_join_typeContext()
}

type Inner_join_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInner_join_typeContext() *Inner_join_typeContext {
	var p = new(Inner_join_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_inner_join_type
	return p
}

func InitEmptyInner_join_typeContext(p *Inner_join_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_inner_join_type
}

func (*Inner_join_typeContext) IsInner_join_typeContext() {}

func NewInner_join_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inner_join_typeContext {
	var p = new(Inner_join_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_inner_join_type

	return p
}

func (s *Inner_join_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Inner_join_typeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(OBParserJOIN, 0)
}

func (s *Inner_join_typeContext) INNER() antlr.TerminalNode {
	return s.GetToken(OBParserINNER, 0)
}

func (s *Inner_join_typeContext) CROSS() antlr.TerminalNode {
	return s.GetToken(OBParserCROSS, 0)
}

func (s *Inner_join_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inner_join_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inner_join_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterInner_join_type(s)
	}
}

func (s *Inner_join_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitInner_join_type(s)
	}
}

func (s *Inner_join_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitInner_join_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Inner_join_type() (localctx IInner_join_typeContext) {
	localctx = NewInner_join_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, OBParserRULE_inner_join_type)
	p.SetState(5907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserJOIN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5902)
			p.Match(OBParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserINNER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5903)
			p.Match(OBParserINNER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5904)
			p.Match(OBParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserCROSS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5905)
			p.Match(OBParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5906)
			p.Match(OBParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOuter_join_typeContext is an interface to support dynamic dispatch.
type IOuter_join_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FULL() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	RIGHT() antlr.TerminalNode

	// IsOuter_join_typeContext differentiates from other interfaces.
	IsOuter_join_typeContext()
}

type Outer_join_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOuter_join_typeContext() *Outer_join_typeContext {
	var p = new(Outer_join_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_outer_join_type
	return p
}

func InitEmptyOuter_join_typeContext(p *Outer_join_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_outer_join_type
}

func (*Outer_join_typeContext) IsOuter_join_typeContext() {}

func NewOuter_join_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Outer_join_typeContext {
	var p = new(Outer_join_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_outer_join_type

	return p
}

func (s *Outer_join_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Outer_join_typeContext) FULL() antlr.TerminalNode {
	return s.GetToken(OBParserFULL, 0)
}

func (s *Outer_join_typeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(OBParserJOIN, 0)
}

func (s *Outer_join_typeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(OBParserOUTER, 0)
}

func (s *Outer_join_typeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(OBParserLEFT, 0)
}

func (s *Outer_join_typeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(OBParserRIGHT, 0)
}

func (s *Outer_join_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Outer_join_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Outer_join_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOuter_join_type(s)
	}
}

func (s *Outer_join_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOuter_join_type(s)
	}
}

func (s *Outer_join_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOuter_join_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Outer_join_type() (localctx IOuter_join_typeContext) {
	localctx = NewOuter_join_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, OBParserRULE_outer_join_type)
	var _la int

	p.SetState(5924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserFULL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5909)
			p.Match(OBParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5911)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserOUTER {
			{
				p.SetState(5910)
				p.Match(OBParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5913)
			p.Match(OBParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserLEFT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5914)
			p.Match(OBParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5916)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserOUTER {
			{
				p.SetState(5915)
				p.Match(OBParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5918)
			p.Match(OBParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserRIGHT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5919)
			p.Match(OBParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5921)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserOUTER {
			{
				p.SetState(5920)
				p.Match(OBParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5923)
			p.Match(OBParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyze_stmtContext is an interface to support dynamic dispatch.
type IAnalyze_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Relation_factor() IRelation_factorContext
	UPDATE() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	ON() antlr.TerminalNode
	Column_name_list() IColumn_name_listContext
	WITH() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	DROP() antlr.TerminalNode

	// IsAnalyze_stmtContext differentiates from other interfaces.
	IsAnalyze_stmtContext()
}

type Analyze_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyze_stmtContext() *Analyze_stmtContext {
	var p = new(Analyze_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_analyze_stmt
	return p
}

func InitEmptyAnalyze_stmtContext(p *Analyze_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_analyze_stmt
}

func (*Analyze_stmtContext) IsAnalyze_stmtContext() {}

func NewAnalyze_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Analyze_stmtContext {
	var p = new(Analyze_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_analyze_stmt

	return p
}

func (s *Analyze_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Analyze_stmtContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(OBParserANALYZE, 0)
}

func (s *Analyze_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE, 0)
}

func (s *Analyze_stmtContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Analyze_stmtContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(OBParserUPDATE, 0)
}

func (s *Analyze_stmtContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(OBParserHISTOGRAM, 0)
}

func (s *Analyze_stmtContext) ON() antlr.TerminalNode {
	return s.GetToken(OBParserON, 0)
}

func (s *Analyze_stmtContext) Column_name_list() IColumn_name_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_name_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_name_listContext)
}

func (s *Analyze_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(OBParserWITH, 0)
}

func (s *Analyze_stmtContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Analyze_stmtContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(OBParserBUCKETS, 0)
}

func (s *Analyze_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Analyze_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Analyze_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Analyze_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAnalyze_stmt(s)
	}
}

func (s *Analyze_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAnalyze_stmt(s)
	}
}

func (s *Analyze_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAnalyze_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Analyze_stmt() (localctx IAnalyze_stmtContext) {
	localctx = NewAnalyze_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, OBParserRULE_analyze_stmt)
	p.SetState(5945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 598, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5926)
			p.Match(OBParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5927)
			p.Match(OBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5928)
			p.Relation_factor()
		}
		{
			p.SetState(5929)
			p.Match(OBParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5930)
			p.Match(OBParserHISTOGRAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5931)
			p.Match(OBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5932)
			p.Column_name_list()
		}
		{
			p.SetState(5933)
			p.Match(OBParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5934)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5935)
			p.Match(OBParserBUCKETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5937)
			p.Match(OBParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5938)
			p.Match(OBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5939)
			p.Relation_factor()
		}
		{
			p.SetState(5940)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5941)
			p.Match(OBParserHISTOGRAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5942)
			p.Match(OBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5943)
			p.Column_name_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_outline_stmtContext is an interface to support dynamic dispatch.
type ICreate_outline_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	OUTLINE() antlr.TerminalNode
	Relation_name() IRelation_nameContext
	ON() antlr.TerminalNode
	AllExplainable_stmt() []IExplainable_stmtContext
	Explainable_stmt(i int) IExplainable_stmtContext
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	TO() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	USING() antlr.TerminalNode
	HINT_HINT_BEGIN() antlr.TerminalNode
	Hint_list_with_end() IHint_list_with_endContext

	// IsCreate_outline_stmtContext differentiates from other interfaces.
	IsCreate_outline_stmtContext()
}

type Create_outline_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_outline_stmtContext() *Create_outline_stmtContext {
	var p = new(Create_outline_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_outline_stmt
	return p
}

func InitEmptyCreate_outline_stmtContext(p *Create_outline_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_outline_stmt
}

func (*Create_outline_stmtContext) IsCreate_outline_stmtContext() {}

func NewCreate_outline_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_outline_stmtContext {
	var p = new(Create_outline_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_create_outline_stmt

	return p
}

func (s *Create_outline_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_outline_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE, 0)
}

func (s *Create_outline_stmtContext) OUTLINE() antlr.TerminalNode {
	return s.GetToken(OBParserOUTLINE, 0)
}

func (s *Create_outline_stmtContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Create_outline_stmtContext) ON() antlr.TerminalNode {
	return s.GetToken(OBParserON, 0)
}

func (s *Create_outline_stmtContext) AllExplainable_stmt() []IExplainable_stmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExplainable_stmtContext); ok {
			len++
		}
	}

	tst := make([]IExplainable_stmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExplainable_stmtContext); ok {
			tst[i] = t.(IExplainable_stmtContext)
			i++
		}
	}

	return tst
}

func (s *Create_outline_stmtContext) Explainable_stmt(i int) IExplainable_stmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainable_stmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainable_stmtContext)
}

func (s *Create_outline_stmtContext) OR() antlr.TerminalNode {
	return s.GetToken(OBParserOR, 0)
}

func (s *Create_outline_stmtContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(OBParserREPLACE, 0)
}

func (s *Create_outline_stmtContext) TO() antlr.TerminalNode {
	return s.GetToken(OBParserTO, 0)
}

func (s *Create_outline_stmtContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Create_outline_stmtContext) USING() antlr.TerminalNode {
	return s.GetToken(OBParserUSING, 0)
}

func (s *Create_outline_stmtContext) HINT_HINT_BEGIN() antlr.TerminalNode {
	return s.GetToken(OBParserHINT_HINT_BEGIN, 0)
}

func (s *Create_outline_stmtContext) Hint_list_with_end() IHint_list_with_endContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHint_list_with_endContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHint_list_with_endContext)
}

func (s *Create_outline_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_outline_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_outline_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCreate_outline_stmt(s)
	}
}

func (s *Create_outline_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCreate_outline_stmt(s)
	}
}

func (s *Create_outline_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCreate_outline_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Create_outline_stmt() (localctx ICreate_outline_stmtContext) {
	localctx = NewCreate_outline_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, OBParserRULE_create_outline_stmt)
	var _la int

	p.SetState(5973)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 602, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5947)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserOR {
			{
				p.SetState(5948)
				p.Match(OBParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5949)
				p.Match(OBParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5952)
			p.Match(OBParserOUTLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5953)
			p.Relation_name()
		}
		{
			p.SetState(5954)
			p.Match(OBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5955)
			p.Explainable_stmt()
		}
		p.SetState(5958)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTO {
			{
				p.SetState(5956)
				p.Match(OBParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5957)
				p.Explainable_stmt()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5960)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5963)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserOR {
			{
				p.SetState(5961)
				p.Match(OBParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5962)
				p.Match(OBParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5965)
			p.Match(OBParserOUTLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5966)
			p.Relation_name()
		}
		{
			p.SetState(5967)
			p.Match(OBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5968)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5969)
			p.Match(OBParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5970)
			p.Match(OBParserHINT_HINT_BEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5971)
			p.Hint_list_with_end()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_outline_stmtContext is an interface to support dynamic dispatch.
type IAlter_outline_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	OUTLINE() antlr.TerminalNode
	Relation_name() IRelation_nameContext
	ADD() antlr.TerminalNode
	AllExplainable_stmt() []IExplainable_stmtContext
	Explainable_stmt(i int) IExplainable_stmtContext
	TO() antlr.TerminalNode

	// IsAlter_outline_stmtContext differentiates from other interfaces.
	IsAlter_outline_stmtContext()
}

type Alter_outline_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_outline_stmtContext() *Alter_outline_stmtContext {
	var p = new(Alter_outline_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_outline_stmt
	return p
}

func InitEmptyAlter_outline_stmtContext(p *Alter_outline_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_outline_stmt
}

func (*Alter_outline_stmtContext) IsAlter_outline_stmtContext() {}

func NewAlter_outline_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_outline_stmtContext {
	var p = new(Alter_outline_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_outline_stmt

	return p
}

func (s *Alter_outline_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_outline_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(OBParserALTER, 0)
}

func (s *Alter_outline_stmtContext) OUTLINE() antlr.TerminalNode {
	return s.GetToken(OBParserOUTLINE, 0)
}

func (s *Alter_outline_stmtContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Alter_outline_stmtContext) ADD() antlr.TerminalNode {
	return s.GetToken(OBParserADD, 0)
}

func (s *Alter_outline_stmtContext) AllExplainable_stmt() []IExplainable_stmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExplainable_stmtContext); ok {
			len++
		}
	}

	tst := make([]IExplainable_stmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExplainable_stmtContext); ok {
			tst[i] = t.(IExplainable_stmtContext)
			i++
		}
	}

	return tst
}

func (s *Alter_outline_stmtContext) Explainable_stmt(i int) IExplainable_stmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainable_stmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainable_stmtContext)
}

func (s *Alter_outline_stmtContext) TO() antlr.TerminalNode {
	return s.GetToken(OBParserTO, 0)
}

func (s *Alter_outline_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_outline_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_outline_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_outline_stmt(s)
	}
}

func (s *Alter_outline_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_outline_stmt(s)
	}
}

func (s *Alter_outline_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_outline_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_outline_stmt() (localctx IAlter_outline_stmtContext) {
	localctx = NewAlter_outline_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, OBParserRULE_alter_outline_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5975)
		p.Match(OBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5976)
		p.Match(OBParserOUTLINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5977)
		p.Relation_name()
	}
	{
		p.SetState(5978)
		p.Match(OBParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5979)
		p.Explainable_stmt()
	}
	p.SetState(5982)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserTO {
		{
			p.SetState(5980)
			p.Match(OBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5981)
			p.Explainable_stmt()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_outline_stmtContext is an interface to support dynamic dispatch.
type IDrop_outline_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	OUTLINE() antlr.TerminalNode
	Relation_factor() IRelation_factorContext

	// IsDrop_outline_stmtContext differentiates from other interfaces.
	IsDrop_outline_stmtContext()
}

type Drop_outline_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_outline_stmtContext() *Drop_outline_stmtContext {
	var p = new(Drop_outline_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_outline_stmt
	return p
}

func InitEmptyDrop_outline_stmtContext(p *Drop_outline_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_outline_stmt
}

func (*Drop_outline_stmtContext) IsDrop_outline_stmtContext() {}

func NewDrop_outline_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_outline_stmtContext {
	var p = new(Drop_outline_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_drop_outline_stmt

	return p
}

func (s *Drop_outline_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_outline_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Drop_outline_stmtContext) OUTLINE() antlr.TerminalNode {
	return s.GetToken(OBParserOUTLINE, 0)
}

func (s *Drop_outline_stmtContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Drop_outline_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_outline_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_outline_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDrop_outline_stmt(s)
	}
}

func (s *Drop_outline_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDrop_outline_stmt(s)
	}
}

func (s *Drop_outline_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDrop_outline_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Drop_outline_stmt() (localctx IDrop_outline_stmtContext) {
	localctx = NewDrop_outline_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, OBParserRULE_drop_outline_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5984)
		p.Match(OBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5985)
		p.Match(OBParserOUTLINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5986)
		p.Relation_factor()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplain_stmtContext is an interface to support dynamic dispatch.
type IExplain_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Explain_or_desc() IExplain_or_descContext
	Relation_factor() IRelation_factorContext
	STRING_VALUE() antlr.TerminalNode
	Column_name() IColumn_nameContext
	Explainable_stmt() IExplainable_stmtContext
	BASIC() antlr.TerminalNode
	OUTLINE() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	EXTENDED_NOADDR() antlr.TerminalNode
	PLANREGRESS() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode
	Format_name() IFormat_nameContext

	// IsExplain_stmtContext differentiates from other interfaces.
	IsExplain_stmtContext()
}

type Explain_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplain_stmtContext() *Explain_stmtContext {
	var p = new(Explain_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_explain_stmt
	return p
}

func InitEmptyExplain_stmtContext(p *Explain_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_explain_stmt
}

func (*Explain_stmtContext) IsExplain_stmtContext() {}

func NewExplain_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Explain_stmtContext {
	var p = new(Explain_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_explain_stmt

	return p
}

func (s *Explain_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Explain_stmtContext) Explain_or_desc() IExplain_or_descContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplain_or_descContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplain_or_descContext)
}

func (s *Explain_stmtContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Explain_stmtContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Explain_stmtContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Explain_stmtContext) Explainable_stmt() IExplainable_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainable_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainable_stmtContext)
}

func (s *Explain_stmtContext) BASIC() antlr.TerminalNode {
	return s.GetToken(OBParserBASIC, 0)
}

func (s *Explain_stmtContext) OUTLINE() antlr.TerminalNode {
	return s.GetToken(OBParserOUTLINE, 0)
}

func (s *Explain_stmtContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(OBParserEXTENDED, 0)
}

func (s *Explain_stmtContext) EXTENDED_NOADDR() antlr.TerminalNode {
	return s.GetToken(OBParserEXTENDED_NOADDR, 0)
}

func (s *Explain_stmtContext) PLANREGRESS() antlr.TerminalNode {
	return s.GetToken(OBParserPLANREGRESS, 0)
}

func (s *Explain_stmtContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITIONS, 0)
}

func (s *Explain_stmtContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(OBParserFORMAT, 0)
}

func (s *Explain_stmtContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Explain_stmtContext) Format_name() IFormat_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormat_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormat_nameContext)
}

func (s *Explain_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Explain_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Explain_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterExplain_stmt(s)
	}
}

func (s *Explain_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitExplain_stmt(s)
	}
}

func (s *Explain_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitExplain_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Explain_stmt() (localctx IExplain_stmtContext) {
	localctx = NewExplain_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, OBParserRULE_explain_stmt)
	p.SetState(6027)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 605, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5988)
			p.Explain_or_desc()
		}
		{
			p.SetState(5989)
			p.Relation_factor()
		}
		p.SetState(5992)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case OBParserSTRING_VALUE:
			{
				p.SetState(5990)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserNAME_OB, OBParserSTAT:
			{
				p.SetState(5991)
				p.Column_name()
			}

		case OBParserEOF, OBParserDELIMITER:

		default:
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5994)
			p.Explain_or_desc()
		}
		{
			p.SetState(5995)
			p.Explainable_stmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5997)
			p.Explain_or_desc()
		}
		{
			p.SetState(5998)
			p.Match(OBParserBASIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5999)
			p.Explainable_stmt()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6001)
			p.Explain_or_desc()
		}
		{
			p.SetState(6002)
			p.Match(OBParserOUTLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6003)
			p.Explainable_stmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6005)
			p.Explain_or_desc()
		}
		{
			p.SetState(6006)
			p.Match(OBParserEXTENDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6007)
			p.Explainable_stmt()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6009)
			p.Explain_or_desc()
		}
		{
			p.SetState(6010)
			p.Match(OBParserEXTENDED_NOADDR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6011)
			p.Explainable_stmt()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6013)
			p.Explain_or_desc()
		}
		{
			p.SetState(6014)
			p.Match(OBParserPLANREGRESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6015)
			p.Explainable_stmt()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6017)
			p.Explain_or_desc()
		}
		{
			p.SetState(6018)
			p.Match(OBParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6019)
			p.Explainable_stmt()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6021)
			p.Explain_or_desc()
		}
		{
			p.SetState(6022)
			p.Match(OBParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6023)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6024)
			p.Format_name()
		}
		{
			p.SetState(6025)
			p.Explainable_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplain_or_descContext is an interface to support dynamic dispatch.
type IExplain_or_descContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPLAIN() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsExplain_or_descContext differentiates from other interfaces.
	IsExplain_or_descContext()
}

type Explain_or_descContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplain_or_descContext() *Explain_or_descContext {
	var p = new(Explain_or_descContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_explain_or_desc
	return p
}

func InitEmptyExplain_or_descContext(p *Explain_or_descContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_explain_or_desc
}

func (*Explain_or_descContext) IsExplain_or_descContext() {}

func NewExplain_or_descContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Explain_or_descContext {
	var p = new(Explain_or_descContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_explain_or_desc

	return p
}

func (s *Explain_or_descContext) GetParser() antlr.Parser { return s.parser }

func (s *Explain_or_descContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(OBParserEXPLAIN, 0)
}

func (s *Explain_or_descContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(OBParserDESCRIBE, 0)
}

func (s *Explain_or_descContext) DESC() antlr.TerminalNode {
	return s.GetToken(OBParserDESC, 0)
}

func (s *Explain_or_descContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Explain_or_descContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Explain_or_descContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterExplain_or_desc(s)
	}
}

func (s *Explain_or_descContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitExplain_or_desc(s)
	}
}

func (s *Explain_or_descContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitExplain_or_desc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Explain_or_desc() (localctx IExplain_or_descContext) {
	localctx = NewExplain_or_descContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, OBParserRULE_explain_or_desc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6029)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-55)) & ^0x3f) == 0 && ((int64(1)<<(_la-55))&65539) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainable_stmtContext is an interface to support dynamic dispatch.
type IExplainable_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_stmt() ISelect_stmtContext
	Delete_stmt() IDelete_stmtContext
	Insert_stmt() IInsert_stmtContext
	Update_stmt() IUpdate_stmtContext

	// IsExplainable_stmtContext differentiates from other interfaces.
	IsExplainable_stmtContext()
}

type Explainable_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainable_stmtContext() *Explainable_stmtContext {
	var p = new(Explainable_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_explainable_stmt
	return p
}

func InitEmptyExplainable_stmtContext(p *Explainable_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_explainable_stmt
}

func (*Explainable_stmtContext) IsExplainable_stmtContext() {}

func NewExplainable_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Explainable_stmtContext {
	var p = new(Explainable_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_explainable_stmt

	return p
}

func (s *Explainable_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Explainable_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Explainable_stmtContext) Delete_stmt() IDelete_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelete_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelete_stmtContext)
}

func (s *Explainable_stmtContext) Insert_stmt() IInsert_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmtContext)
}

func (s *Explainable_stmtContext) Update_stmt() IUpdate_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_stmtContext)
}

func (s *Explainable_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Explainable_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Explainable_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterExplainable_stmt(s)
	}
}

func (s *Explainable_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitExplainable_stmt(s)
	}
}

func (s *Explainable_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitExplainable_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Explainable_stmt() (localctx IExplainable_stmtContext) {
	localctx = NewExplainable_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, OBParserRULE_explainable_stmt)
	p.SetState(6035)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserSELECT, OBParserLeftParen, OBParserSELECT_HINT_BEGIN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6031)
			p.Select_stmt()
		}

	case OBParserDELETE, OBParserDELETE_HINT_BEGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6032)
			p.Delete_stmt()
		}

	case OBParserINSERT, OBParserREPLACE, OBParserREPLACE_HINT_BEGIN, OBParserINSERT_HINT_BEGIN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6033)
			p.Insert_stmt()
		}

	case OBParserUPDATE, OBParserUPDATE_HINT_BEGIN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6034)
			p.Update_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormat_nameContext is an interface to support dynamic dispatch.
type IFormat_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRADITIONAL() antlr.TerminalNode
	JSON() antlr.TerminalNode

	// IsFormat_nameContext differentiates from other interfaces.
	IsFormat_nameContext()
}

type Format_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormat_nameContext() *Format_nameContext {
	var p = new(Format_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_format_name
	return p
}

func InitEmptyFormat_nameContext(p *Format_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_format_name
}

func (*Format_nameContext) IsFormat_nameContext() {}

func NewFormat_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Format_nameContext {
	var p = new(Format_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_format_name

	return p
}

func (s *Format_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Format_nameContext) TRADITIONAL() antlr.TerminalNode {
	return s.GetToken(OBParserTRADITIONAL, 0)
}

func (s *Format_nameContext) JSON() antlr.TerminalNode {
	return s.GetToken(OBParserJSON, 0)
}

func (s *Format_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Format_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Format_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterFormat_name(s)
	}
}

func (s *Format_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitFormat_name(s)
	}
}

func (s *Format_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitFormat_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Format_name() (localctx IFormat_nameContext) {
	localctx = NewFormat_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, OBParserRULE_format_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6037)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserTRADITIONAL || _la == OBParserJSON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShow_stmtContext is an interface to support dynamic dispatch.
type IShow_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FULL() antlr.TerminalNode
	AllFrom_or_in() []IFrom_or_inContext
	From_or_in(i int) IFrom_or_inContext
	Database_factor() IDatabase_factorContext
	LIKE() antlr.TerminalNode
	AllSTRING_VALUE() []antlr.TerminalNode
	STRING_VALUE(i int) antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expr() IExprContext
	Databases_or_schemas() IDatabases_or_schemasContext
	STATUS() antlr.TerminalNode
	Columns_or_fields() IColumns_or_fieldsContext
	Relation_factor() IRelation_factorContext
	TABLE() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	Database_or_schema() IDatabase_or_schemaContext
	IF() antlr.TerminalNode
	Not() INotContext
	EXISTS() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	AllINTNUM() []antlr.TerminalNode
	INTNUM(i int) antlr.TerminalNode
	Comma() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Star() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	Opt_for_grant_user() IOpt_for_grant_userContext
	Charset_key() ICharset_keyContext
	TRACE() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	PARAMETERS() antlr.TerminalNode
	Tenant_name() ITenant_nameContext
	Index_or_indexes_or_keys() IIndex_or_indexes_or_keysContext
	Opt_hint_value() IOpt_hint_valueContext
	PROCESSLIST() antlr.TerminalNode
	TABLEGROUPS() antlr.TerminalNode
	TENANT() antlr.TerminalNode
	Relation_name() IRelation_nameContext
	ENGINES() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	RECYCLEBIN() antlr.TerminalNode
	TABLEGROUP() antlr.TerminalNode

	// IsShow_stmtContext differentiates from other interfaces.
	IsShow_stmtContext()
}

type Show_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShow_stmtContext() *Show_stmtContext {
	var p = new(Show_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_show_stmt
	return p
}

func InitEmptyShow_stmtContext(p *Show_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_show_stmt
}

func (*Show_stmtContext) IsShow_stmtContext() {}

func NewShow_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Show_stmtContext {
	var p = new(Show_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_show_stmt

	return p
}

func (s *Show_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Show_stmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(OBParserSHOW, 0)
}

func (s *Show_stmtContext) TABLES() antlr.TerminalNode {
	return s.GetToken(OBParserTABLES, 0)
}

func (s *Show_stmtContext) FULL() antlr.TerminalNode {
	return s.GetToken(OBParserFULL, 0)
}

func (s *Show_stmtContext) AllFrom_or_in() []IFrom_or_inContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrom_or_inContext); ok {
			len++
		}
	}

	tst := make([]IFrom_or_inContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrom_or_inContext); ok {
			tst[i] = t.(IFrom_or_inContext)
			i++
		}
	}

	return tst
}

func (s *Show_stmtContext) From_or_in(i int) IFrom_or_inContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_or_inContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_or_inContext)
}

func (s *Show_stmtContext) Database_factor() IDatabase_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_factorContext)
}

func (s *Show_stmtContext) LIKE() antlr.TerminalNode {
	return s.GetToken(OBParserLIKE, 0)
}

func (s *Show_stmtContext) AllSTRING_VALUE() []antlr.TerminalNode {
	return s.GetTokens(OBParserSTRING_VALUE)
}

func (s *Show_stmtContext) STRING_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, i)
}

func (s *Show_stmtContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(OBParserESCAPE, 0)
}

func (s *Show_stmtContext) WHERE() antlr.TerminalNode {
	return s.GetToken(OBParserWHERE, 0)
}

func (s *Show_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Show_stmtContext) Databases_or_schemas() IDatabases_or_schemasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabases_or_schemasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabases_or_schemasContext)
}

func (s *Show_stmtContext) STATUS() antlr.TerminalNode {
	return s.GetToken(OBParserSTATUS, 0)
}

func (s *Show_stmtContext) Columns_or_fields() IColumns_or_fieldsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumns_or_fieldsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumns_or_fieldsContext)
}

func (s *Show_stmtContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Show_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE, 0)
}

func (s *Show_stmtContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(OBParserPROCEDURE, 0)
}

func (s *Show_stmtContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(OBParserFUNCTION, 0)
}

func (s *Show_stmtContext) SERVER() antlr.TerminalNode {
	return s.GetToken(OBParserSERVER, 0)
}

func (s *Show_stmtContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(OBParserVARIABLES, 0)
}

func (s *Show_stmtContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(OBParserGLOBAL, 0)
}

func (s *Show_stmtContext) SESSION() antlr.TerminalNode {
	return s.GetToken(OBParserSESSION, 0)
}

func (s *Show_stmtContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(OBParserLOCAL, 0)
}

func (s *Show_stmtContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(OBParserSCHEMA, 0)
}

func (s *Show_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE, 0)
}

func (s *Show_stmtContext) Database_or_schema() IDatabase_or_schemaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_or_schemaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_or_schemaContext)
}

func (s *Show_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Show_stmtContext) Not() INotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotContext)
}

func (s *Show_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Show_stmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(OBParserVIEW, 0)
}

func (s *Show_stmtContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(OBParserWARNINGS, 0)
}

func (s *Show_stmtContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(OBParserLIMIT, 0)
}

func (s *Show_stmtContext) AllINTNUM() []antlr.TerminalNode {
	return s.GetTokens(OBParserINTNUM)
}

func (s *Show_stmtContext) INTNUM(i int) antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, i)
}

func (s *Show_stmtContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Show_stmtContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(OBParserERRORS, 0)
}

func (s *Show_stmtContext) COUNT() antlr.TerminalNode {
	return s.GetToken(OBParserCOUNT, 0)
}

func (s *Show_stmtContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Show_stmtContext) Star() antlr.TerminalNode {
	return s.GetToken(OBParserStar, 0)
}

func (s *Show_stmtContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Show_stmtContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(OBParserGRANTS, 0)
}

func (s *Show_stmtContext) Opt_for_grant_user() IOpt_for_grant_userContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_for_grant_userContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_for_grant_userContext)
}

func (s *Show_stmtContext) Charset_key() ICharset_keyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_keyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_keyContext)
}

func (s *Show_stmtContext) TRACE() antlr.TerminalNode {
	return s.GetToken(OBParserTRACE, 0)
}

func (s *Show_stmtContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(OBParserCOLLATION, 0)
}

func (s *Show_stmtContext) PARAMETERS() antlr.TerminalNode {
	return s.GetToken(OBParserPARAMETERS, 0)
}

func (s *Show_stmtContext) Tenant_name() ITenant_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITenant_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITenant_nameContext)
}

func (s *Show_stmtContext) Index_or_indexes_or_keys() IIndex_or_indexes_or_keysContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_or_indexes_or_keysContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_or_indexes_or_keysContext)
}

func (s *Show_stmtContext) Opt_hint_value() IOpt_hint_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_hint_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_hint_valueContext)
}

func (s *Show_stmtContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(OBParserPROCESSLIST, 0)
}

func (s *Show_stmtContext) TABLEGROUPS() antlr.TerminalNode {
	return s.GetToken(OBParserTABLEGROUPS, 0)
}

func (s *Show_stmtContext) TENANT() antlr.TerminalNode {
	return s.GetToken(OBParserTENANT, 0)
}

func (s *Show_stmtContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Show_stmtContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(OBParserENGINES, 0)
}

func (s *Show_stmtContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(OBParserSTORAGE, 0)
}

func (s *Show_stmtContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(OBParserPRIVILEGES, 0)
}

func (s *Show_stmtContext) RECYCLEBIN() antlr.TerminalNode {
	return s.GetToken(OBParserRECYCLEBIN, 0)
}

func (s *Show_stmtContext) TABLEGROUP() antlr.TerminalNode {
	return s.GetToken(OBParserTABLEGROUP, 0)
}

func (s *Show_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Show_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Show_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterShow_stmt(s)
	}
}

func (s *Show_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitShow_stmt(s)
	}
}

func (s *Show_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitShow_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Show_stmt() (localctx IShow_stmtContext) {
	localctx = NewShow_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, OBParserRULE_show_stmt)
	var _la int

	p.SetState(6362)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 640, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6039)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6041)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFULL {
			{
				p.SetState(6040)
				p.Match(OBParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6043)
			p.Match(OBParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6047)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFROM || _la == OBParserIN {
			{
				p.SetState(6044)
				p.From_or_in()
			}
			{
				p.SetState(6045)
				p.Database_factor()
			}

		}
		p.SetState(6057)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 609, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6049)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6050)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 609, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6051)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6052)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6053)
				p.Match(OBParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6054)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 609, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(6055)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6056)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6059)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6060)
			p.Databases_or_schemas()
		}
		p.SetState(6062)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSTATUS {
			{
				p.SetState(6061)
				p.Match(OBParserSTATUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(6072)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 611, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6064)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6065)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 611, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6066)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6067)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6068)
				p.Match(OBParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6069)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 611, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(6070)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6071)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6074)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6076)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFULL {
			{
				p.SetState(6075)
				p.Match(OBParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6078)
			p.Columns_or_fields()
		}
		{
			p.SetState(6079)
			p.From_or_in()
		}
		{
			p.SetState(6080)
			p.Relation_factor()
		}
		p.SetState(6084)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFROM || _la == OBParserIN {
			{
				p.SetState(6081)
				p.From_or_in()
			}
			{
				p.SetState(6082)
				p.Database_factor()
			}

		}
		p.SetState(6094)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 614, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6086)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6087)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 614, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6088)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6089)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6090)
				p.Match(OBParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6091)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 614, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(6092)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6093)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6096)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6097)
			p.Match(OBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6098)
			p.Match(OBParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6102)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFROM || _la == OBParserIN {
			{
				p.SetState(6099)
				p.From_or_in()
			}
			{
				p.SetState(6100)
				p.Database_factor()
			}

		}
		p.SetState(6112)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 616, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6104)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6105)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 616, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6106)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6107)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6108)
				p.Match(OBParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6109)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 616, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(6110)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6111)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6114)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6115)
			p.Match(OBParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6116)
			p.Match(OBParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6120)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFROM || _la == OBParserIN {
			{
				p.SetState(6117)
				p.From_or_in()
			}
			{
				p.SetState(6118)
				p.Database_factor()
			}

		}
		p.SetState(6130)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 618, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6122)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6123)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 618, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6124)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6125)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6126)
				p.Match(OBParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6127)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 618, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(6128)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6129)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6132)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6133)
			p.Match(OBParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6134)
			p.Match(OBParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6138)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFROM || _la == OBParserIN {
			{
				p.SetState(6135)
				p.From_or_in()
			}
			{
				p.SetState(6136)
				p.Database_factor()
			}

		}
		p.SetState(6148)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 620, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6140)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6141)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 620, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6142)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6143)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6144)
				p.Match(OBParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6145)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 620, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(6146)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6147)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6150)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6151)
			p.Match(OBParserSERVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6152)
			p.Match(OBParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6161)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 621, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6153)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6154)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 621, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6155)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6156)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6157)
				p.Match(OBParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6158)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 621, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(6159)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6160)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6163)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6165)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserLOCAL || _la == OBParserGLOBAL || _la == OBParserSESSION {
			{
				p.SetState(6164)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserLOCAL || _la == OBParserGLOBAL || _la == OBParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(6167)
			p.Match(OBParserVARIABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6176)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 623, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6168)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6169)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 623, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6170)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6171)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6172)
				p.Match(OBParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6173)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 623, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(6174)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6175)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6178)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6179)
			p.Match(OBParserSCHEMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6180)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6181)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6182)
			p.Database_or_schema()
		}
		p.SetState(6187)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIF {
			{
				p.SetState(6183)
				p.Match(OBParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6184)
				p.Not()
			}
			{
				p.SetState(6185)
				p.Match(OBParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6189)
			p.Database_factor()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6191)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6192)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6193)
			p.Match(OBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6194)
			p.Relation_factor()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6195)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6196)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6197)
			p.Match(OBParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6198)
			p.Relation_factor()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6199)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6200)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6201)
			p.Match(OBParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6202)
			p.Relation_factor()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6203)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6204)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6205)
			p.Match(OBParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6206)
			p.Relation_factor()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(6207)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6208)
			p.Match(OBParserWARNINGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6215)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 625, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6209)
				p.Match(OBParserLIMIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6210)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6211)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6212)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 625, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6213)
				p.Match(OBParserLIMIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6214)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(6217)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6218)
			p.Match(OBParserERRORS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6225)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 626, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6219)
				p.Match(OBParserLIMIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6220)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6221)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6222)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 626, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6223)
				p.Match(OBParserLIMIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6224)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(6227)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6228)
			p.Match(OBParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6229)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6230)
			p.Match(OBParserStar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6231)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6232)
			p.Match(OBParserWARNINGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(6233)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6234)
			p.Match(OBParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6235)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6236)
			p.Match(OBParserStar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6237)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6238)
			p.Match(OBParserERRORS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(6239)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6240)
			p.Match(OBParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6241)
			p.Opt_for_grant_user()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(6242)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6243)
			p.Charset_key()
		}
		p.SetState(6252)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 627, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6244)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6245)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 627, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6246)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6247)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6248)
				p.Match(OBParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6249)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 627, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(6250)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6251)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(6254)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6255)
			p.Match(OBParserTRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6264)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 628, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6256)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6257)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 628, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6258)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6259)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6260)
				p.Match(OBParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6261)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 628, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(6262)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6263)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(6266)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6267)
			p.Match(OBParserCOLLATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6276)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 629, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6268)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6269)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 629, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6270)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6271)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6272)
				p.Match(OBParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6273)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 629, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(6274)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6275)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(6278)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6279)
			p.Match(OBParserPARAMETERS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6288)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 630, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6280)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6281)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 630, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6282)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6283)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6284)
				p.Match(OBParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6285)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 630, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(6286)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6287)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTENANT {
			{
				p.SetState(6290)
				p.Tenant_name()
			}

		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(6293)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6294)
			p.Index_or_indexes_or_keys()
		}
		{
			p.SetState(6295)
			p.From_or_in()
		}
		{
			p.SetState(6296)
			p.Relation_factor()
		}
		p.SetState(6300)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFROM || _la == OBParserIN {
			{
				p.SetState(6297)
				p.From_or_in()
			}
			{
				p.SetState(6298)
				p.Database_factor()
			}

		}
		p.SetState(6306)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserWHERE {
			{
				p.SetState(6302)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6303)
				p.Opt_hint_value()
			}
			{
				p.SetState(6304)
				p.expr(0)
			}

		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(6308)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6310)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFULL {
			{
				p.SetState(6309)
				p.Match(OBParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6312)
			p.Match(OBParserPROCESSLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(6313)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6314)
			p.Match(OBParserTABLEGROUPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6323)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 635, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6315)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6316)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 635, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6317)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6318)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6319)
				p.Match(OBParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6320)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 635, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(6321)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6322)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(6325)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserLOCAL || _la == OBParserGLOBAL || _la == OBParserSESSION {
			{
				p.SetState(6326)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserLOCAL || _la == OBParserGLOBAL || _la == OBParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(6329)
			p.Match(OBParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6338)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 637, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6330)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6331)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 637, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6332)
				p.Match(OBParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6333)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6334)
				p.Match(OBParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6335)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 637, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(6336)
				p.Match(OBParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6337)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(6340)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6341)
			p.Match(OBParserTENANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6343)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSTATUS {
			{
				p.SetState(6342)
				p.Match(OBParserSTATUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(6345)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6346)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6347)
			p.Match(OBParserTENANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6348)
			p.Relation_name()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(6349)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6351)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSTORAGE {
			{
				p.SetState(6350)
				p.Match(OBParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6353)
			p.Match(OBParserENGINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(6354)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6355)
			p.Match(OBParserPRIVILEGES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(6356)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6357)
			p.Match(OBParserRECYCLEBIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(6358)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6359)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6360)
			p.Match(OBParserTABLEGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6361)
			p.Relation_name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatabases_or_schemasContext is an interface to support dynamic dispatch.
type IDatabases_or_schemasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATABASES() antlr.TerminalNode
	SCHEMAS() antlr.TerminalNode

	// IsDatabases_or_schemasContext differentiates from other interfaces.
	IsDatabases_or_schemasContext()
}

type Databases_or_schemasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabases_or_schemasContext() *Databases_or_schemasContext {
	var p = new(Databases_or_schemasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_databases_or_schemas
	return p
}

func InitEmptyDatabases_or_schemasContext(p *Databases_or_schemasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_databases_or_schemas
}

func (*Databases_or_schemasContext) IsDatabases_or_schemasContext() {}

func NewDatabases_or_schemasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Databases_or_schemasContext {
	var p = new(Databases_or_schemasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_databases_or_schemas

	return p
}

func (s *Databases_or_schemasContext) GetParser() antlr.Parser { return s.parser }

func (s *Databases_or_schemasContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(OBParserDATABASES, 0)
}

func (s *Databases_or_schemasContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(OBParserSCHEMAS, 0)
}

func (s *Databases_or_schemasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Databases_or_schemasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Databases_or_schemasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDatabases_or_schemas(s)
	}
}

func (s *Databases_or_schemasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDatabases_or_schemas(s)
	}
}

func (s *Databases_or_schemasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDatabases_or_schemas(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Databases_or_schemas() (localctx IDatabases_or_schemasContext) {
	localctx = NewDatabases_or_schemasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, OBParserRULE_databases_or_schemas)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6364)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserDATABASES || _la == OBParserSCHEMAS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_for_grant_userContext is an interface to support dynamic dispatch.
type IOpt_for_grant_userContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Opt_for_user() IOpt_for_userContext
	FOR() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode

	// IsOpt_for_grant_userContext differentiates from other interfaces.
	IsOpt_for_grant_userContext()
}

type Opt_for_grant_userContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_for_grant_userContext() *Opt_for_grant_userContext {
	var p = new(Opt_for_grant_userContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_for_grant_user
	return p
}

func InitEmptyOpt_for_grant_userContext(p *Opt_for_grant_userContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_for_grant_user
}

func (*Opt_for_grant_userContext) IsOpt_for_grant_userContext() {}

func NewOpt_for_grant_userContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_for_grant_userContext {
	var p = new(Opt_for_grant_userContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_for_grant_user

	return p
}

func (s *Opt_for_grant_userContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_for_grant_userContext) Opt_for_user() IOpt_for_userContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_for_userContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_for_userContext)
}

func (s *Opt_for_grant_userContext) FOR() antlr.TerminalNode {
	return s.GetToken(OBParserFOR, 0)
}

func (s *Opt_for_grant_userContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(OBParserCURRENT_USER, 0)
}

func (s *Opt_for_grant_userContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Opt_for_grant_userContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Opt_for_grant_userContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_for_grant_userContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_for_grant_userContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_for_grant_user(s)
	}
}

func (s *Opt_for_grant_userContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_for_grant_user(s)
	}
}

func (s *Opt_for_grant_userContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_for_grant_user(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_for_grant_user() (localctx IOpt_for_grant_userContext) {
	localctx = NewOpt_for_grant_userContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, OBParserRULE_opt_for_grant_user)
	p.SetState(6373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 641, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6366)
			p.Opt_for_user()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6367)
			p.Match(OBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6368)
			p.Match(OBParserCURRENT_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6369)
			p.Match(OBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6370)
			p.Match(OBParserCURRENT_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6371)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6372)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumns_or_fieldsContext is an interface to support dynamic dispatch.
type IColumns_or_fieldsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS() antlr.TerminalNode
	FIELDS() antlr.TerminalNode

	// IsColumns_or_fieldsContext differentiates from other interfaces.
	IsColumns_or_fieldsContext()
}

type Columns_or_fieldsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumns_or_fieldsContext() *Columns_or_fieldsContext {
	var p = new(Columns_or_fieldsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_columns_or_fields
	return p
}

func InitEmptyColumns_or_fieldsContext(p *Columns_or_fieldsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_columns_or_fields
}

func (*Columns_or_fieldsContext) IsColumns_or_fieldsContext() {}

func NewColumns_or_fieldsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Columns_or_fieldsContext {
	var p = new(Columns_or_fieldsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_columns_or_fields

	return p
}

func (s *Columns_or_fieldsContext) GetParser() antlr.Parser { return s.parser }

func (s *Columns_or_fieldsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(OBParserCOLUMNS, 0)
}

func (s *Columns_or_fieldsContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(OBParserFIELDS, 0)
}

func (s *Columns_or_fieldsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Columns_or_fieldsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Columns_or_fieldsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterColumns_or_fields(s)
	}
}

func (s *Columns_or_fieldsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitColumns_or_fields(s)
	}
}

func (s *Columns_or_fieldsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitColumns_or_fields(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Columns_or_fields() (localctx IColumns_or_fieldsContext) {
	localctx = NewColumns_or_fieldsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, OBParserRULE_columns_or_fields)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6375)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserCOLUMNS || _la == OBParserFIELDS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatabase_or_schemaContext is an interface to support dynamic dispatch.
type IDatabase_or_schemaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode

	// IsDatabase_or_schemaContext differentiates from other interfaces.
	IsDatabase_or_schemaContext()
}

type Database_or_schemaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabase_or_schemaContext() *Database_or_schemaContext {
	var p = new(Database_or_schemaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_database_or_schema
	return p
}

func InitEmptyDatabase_or_schemaContext(p *Database_or_schemaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_database_or_schema
}

func (*Database_or_schemaContext) IsDatabase_or_schemaContext() {}

func NewDatabase_or_schemaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Database_or_schemaContext {
	var p = new(Database_or_schemaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_database_or_schema

	return p
}

func (s *Database_or_schemaContext) GetParser() antlr.Parser { return s.parser }

func (s *Database_or_schemaContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(OBParserDATABASE, 0)
}

func (s *Database_or_schemaContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(OBParserSCHEMA, 0)
}

func (s *Database_or_schemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Database_or_schemaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Database_or_schemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDatabase_or_schema(s)
	}
}

func (s *Database_or_schemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDatabase_or_schema(s)
	}
}

func (s *Database_or_schemaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDatabase_or_schema(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Database_or_schema() (localctx IDatabase_or_schemaContext) {
	localctx = NewDatabase_or_schemaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, OBParserRULE_database_or_schema)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6377)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserDATABASE || _la == OBParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_or_indexes_or_keysContext is an interface to support dynamic dispatch.
type IIndex_or_indexes_or_keysContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INDEX() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	KEYS() antlr.TerminalNode

	// IsIndex_or_indexes_or_keysContext differentiates from other interfaces.
	IsIndex_or_indexes_or_keysContext()
}

type Index_or_indexes_or_keysContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_or_indexes_or_keysContext() *Index_or_indexes_or_keysContext {
	var p = new(Index_or_indexes_or_keysContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_or_indexes_or_keys
	return p
}

func InitEmptyIndex_or_indexes_or_keysContext(p *Index_or_indexes_or_keysContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_index_or_indexes_or_keys
}

func (*Index_or_indexes_or_keysContext) IsIndex_or_indexes_or_keysContext() {}

func NewIndex_or_indexes_or_keysContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_or_indexes_or_keysContext {
	var p = new(Index_or_indexes_or_keysContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_index_or_indexes_or_keys

	return p
}

func (s *Index_or_indexes_or_keysContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_or_indexes_or_keysContext) INDEX() antlr.TerminalNode {
	return s.GetToken(OBParserINDEX, 0)
}

func (s *Index_or_indexes_or_keysContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(OBParserINDEXES, 0)
}

func (s *Index_or_indexes_or_keysContext) KEYS() antlr.TerminalNode {
	return s.GetToken(OBParserKEYS, 0)
}

func (s *Index_or_indexes_or_keysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_or_indexes_or_keysContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_or_indexes_or_keysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterIndex_or_indexes_or_keys(s)
	}
}

func (s *Index_or_indexes_or_keysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitIndex_or_indexes_or_keys(s)
	}
}

func (s *Index_or_indexes_or_keysContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitIndex_or_indexes_or_keys(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Index_or_indexes_or_keys() (localctx IIndex_or_indexes_or_keysContext) {
	localctx = NewIndex_or_indexes_or_keysContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, OBParserRULE_index_or_indexes_or_keys)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6379)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserINDEX || _la == OBParserKEYS || _la == OBParserINDEXES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_or_inContext is an interface to support dynamic dispatch.
type IFrom_or_inContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsFrom_or_inContext differentiates from other interfaces.
	IsFrom_or_inContext()
}

type From_or_inContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_or_inContext() *From_or_inContext {
	var p = new(From_or_inContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_from_or_in
	return p
}

func InitEmptyFrom_or_inContext(p *From_or_inContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_from_or_in
}

func (*From_or_inContext) IsFrom_or_inContext() {}

func NewFrom_or_inContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_or_inContext {
	var p = new(From_or_inContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_from_or_in

	return p
}

func (s *From_or_inContext) GetParser() antlr.Parser { return s.parser }

func (s *From_or_inContext) FROM() antlr.TerminalNode {
	return s.GetToken(OBParserFROM, 0)
}

func (s *From_or_inContext) IN() antlr.TerminalNode {
	return s.GetToken(OBParserIN, 0)
}

func (s *From_or_inContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_or_inContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_or_inContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterFrom_or_in(s)
	}
}

func (s *From_or_inContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitFrom_or_in(s)
	}
}

func (s *From_or_inContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitFrom_or_in(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) From_or_in() (localctx IFrom_or_inContext) {
	localctx = NewFrom_or_inContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, OBParserRULE_from_or_in)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6381)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserFROM || _la == OBParserIN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelp_stmtContext is an interface to support dynamic dispatch.
type IHelp_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HELP() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	NAME_OB() antlr.TerminalNode

	// IsHelp_stmtContext differentiates from other interfaces.
	IsHelp_stmtContext()
}

type Help_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelp_stmtContext() *Help_stmtContext {
	var p = new(Help_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_help_stmt
	return p
}

func InitEmptyHelp_stmtContext(p *Help_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_help_stmt
}

func (*Help_stmtContext) IsHelp_stmtContext() {}

func NewHelp_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Help_stmtContext {
	var p = new(Help_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_help_stmt

	return p
}

func (s *Help_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Help_stmtContext) HELP() antlr.TerminalNode {
	return s.GetToken(OBParserHELP, 0)
}

func (s *Help_stmtContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Help_stmtContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Help_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Help_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Help_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterHelp_stmt(s)
	}
}

func (s *Help_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitHelp_stmt(s)
	}
}

func (s *Help_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitHelp_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Help_stmt() (localctx IHelp_stmtContext) {
	localctx = NewHelp_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, OBParserRULE_help_stmt)
	p.SetState(6387)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 642, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6383)
			p.Match(OBParserHELP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6384)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6385)
			p.Match(OBParserHELP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6386)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_tablespace_stmtContext is an interface to support dynamic dispatch.
type ICreate_tablespace_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	Tablespace() ITablespaceContext
	Permanent_tablespace() IPermanent_tablespaceContext

	// IsCreate_tablespace_stmtContext differentiates from other interfaces.
	IsCreate_tablespace_stmtContext()
}

type Create_tablespace_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_tablespace_stmtContext() *Create_tablespace_stmtContext {
	var p = new(Create_tablespace_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_tablespace_stmt
	return p
}

func InitEmptyCreate_tablespace_stmtContext(p *Create_tablespace_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_tablespace_stmt
}

func (*Create_tablespace_stmtContext) IsCreate_tablespace_stmtContext() {}

func NewCreate_tablespace_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_tablespace_stmtContext {
	var p = new(Create_tablespace_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_create_tablespace_stmt

	return p
}

func (s *Create_tablespace_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_tablespace_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE, 0)
}

func (s *Create_tablespace_stmtContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLESPACE, 0)
}

func (s *Create_tablespace_stmtContext) Tablespace() ITablespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceContext)
}

func (s *Create_tablespace_stmtContext) Permanent_tablespace() IPermanent_tablespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermanent_tablespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermanent_tablespaceContext)
}

func (s *Create_tablespace_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_tablespace_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_tablespace_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCreate_tablespace_stmt(s)
	}
}

func (s *Create_tablespace_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCreate_tablespace_stmt(s)
	}
}

func (s *Create_tablespace_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCreate_tablespace_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Create_tablespace_stmt() (localctx ICreate_tablespace_stmtContext) {
	localctx = NewCreate_tablespace_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, OBParserRULE_create_tablespace_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6389)
		p.Match(OBParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6390)
		p.Match(OBParserTABLESPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6391)
		p.Tablespace()
	}
	{
		p.SetState(6392)
		p.Permanent_tablespace()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPermanent_tablespaceContext is an interface to support dynamic dispatch.
type IPermanent_tablespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Permanent_tablespace_options() IPermanent_tablespace_optionsContext

	// IsPermanent_tablespaceContext differentiates from other interfaces.
	IsPermanent_tablespaceContext()
}

type Permanent_tablespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermanent_tablespaceContext() *Permanent_tablespaceContext {
	var p = new(Permanent_tablespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_permanent_tablespace
	return p
}

func InitEmptyPermanent_tablespaceContext(p *Permanent_tablespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_permanent_tablespace
}

func (*Permanent_tablespaceContext) IsPermanent_tablespaceContext() {}

func NewPermanent_tablespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Permanent_tablespaceContext {
	var p = new(Permanent_tablespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_permanent_tablespace

	return p
}

func (s *Permanent_tablespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Permanent_tablespaceContext) Permanent_tablespace_options() IPermanent_tablespace_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermanent_tablespace_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermanent_tablespace_optionsContext)
}

func (s *Permanent_tablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Permanent_tablespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Permanent_tablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterPermanent_tablespace(s)
	}
}

func (s *Permanent_tablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitPermanent_tablespace(s)
	}
}

func (s *Permanent_tablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitPermanent_tablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Permanent_tablespace() (localctx IPermanent_tablespaceContext) {
	localctx = NewPermanent_tablespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, OBParserRULE_permanent_tablespace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6395)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserENCRYPTION {
		{
			p.SetState(6394)
			p.Permanent_tablespace_options()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPermanent_tablespace_optionContext is an interface to support dynamic dispatch.
type IPermanent_tablespace_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENCRYPTION() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode

	// IsPermanent_tablespace_optionContext differentiates from other interfaces.
	IsPermanent_tablespace_optionContext()
}

type Permanent_tablespace_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermanent_tablespace_optionContext() *Permanent_tablespace_optionContext {
	var p = new(Permanent_tablespace_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_permanent_tablespace_option
	return p
}

func InitEmptyPermanent_tablespace_optionContext(p *Permanent_tablespace_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_permanent_tablespace_option
}

func (*Permanent_tablespace_optionContext) IsPermanent_tablespace_optionContext() {}

func NewPermanent_tablespace_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Permanent_tablespace_optionContext {
	var p = new(Permanent_tablespace_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_permanent_tablespace_option

	return p
}

func (s *Permanent_tablespace_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Permanent_tablespace_optionContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(OBParserENCRYPTION, 0)
}

func (s *Permanent_tablespace_optionContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Permanent_tablespace_optionContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Permanent_tablespace_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Permanent_tablespace_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Permanent_tablespace_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterPermanent_tablespace_option(s)
	}
}

func (s *Permanent_tablespace_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitPermanent_tablespace_option(s)
	}
}

func (s *Permanent_tablespace_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitPermanent_tablespace_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Permanent_tablespace_option() (localctx IPermanent_tablespace_optionContext) {
	localctx = NewPermanent_tablespace_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, OBParserRULE_permanent_tablespace_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6397)
		p.Match(OBParserENCRYPTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCOMP_EQ {
		{
			p.SetState(6398)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(6401)
		p.Match(OBParserSTRING_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_tablespace_stmtContext is an interface to support dynamic dispatch.
type IDrop_tablespace_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	Tablespace() ITablespaceContext

	// IsDrop_tablespace_stmtContext differentiates from other interfaces.
	IsDrop_tablespace_stmtContext()
}

type Drop_tablespace_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_tablespace_stmtContext() *Drop_tablespace_stmtContext {
	var p = new(Drop_tablespace_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_tablespace_stmt
	return p
}

func InitEmptyDrop_tablespace_stmtContext(p *Drop_tablespace_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_tablespace_stmt
}

func (*Drop_tablespace_stmtContext) IsDrop_tablespace_stmtContext() {}

func NewDrop_tablespace_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_tablespace_stmtContext {
	var p = new(Drop_tablespace_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_drop_tablespace_stmt

	return p
}

func (s *Drop_tablespace_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_tablespace_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Drop_tablespace_stmtContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLESPACE, 0)
}

func (s *Drop_tablespace_stmtContext) Tablespace() ITablespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceContext)
}

func (s *Drop_tablespace_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_tablespace_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_tablespace_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDrop_tablespace_stmt(s)
	}
}

func (s *Drop_tablespace_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDrop_tablespace_stmt(s)
	}
}

func (s *Drop_tablespace_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDrop_tablespace_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Drop_tablespace_stmt() (localctx IDrop_tablespace_stmtContext) {
	localctx = NewDrop_tablespace_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, OBParserRULE_drop_tablespace_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6403)
		p.Match(OBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6404)
		p.Match(OBParserTABLESPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6405)
		p.Tablespace()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_tablespace_actionsContext is an interface to support dynamic dispatch.
type IAlter_tablespace_actionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlter_tablespace_action() []IAlter_tablespace_actionContext
	Alter_tablespace_action(i int) IAlter_tablespace_actionContext
	Comma() antlr.TerminalNode

	// IsAlter_tablespace_actionsContext differentiates from other interfaces.
	IsAlter_tablespace_actionsContext()
}

type Alter_tablespace_actionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_tablespace_actionsContext() *Alter_tablespace_actionsContext {
	var p = new(Alter_tablespace_actionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tablespace_actions
	return p
}

func InitEmptyAlter_tablespace_actionsContext(p *Alter_tablespace_actionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tablespace_actions
}

func (*Alter_tablespace_actionsContext) IsAlter_tablespace_actionsContext() {}

func NewAlter_tablespace_actionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_tablespace_actionsContext {
	var p = new(Alter_tablespace_actionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_tablespace_actions

	return p
}

func (s *Alter_tablespace_actionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_tablespace_actionsContext) AllAlter_tablespace_action() []IAlter_tablespace_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_tablespace_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_tablespace_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_tablespace_actionContext); ok {
			tst[i] = t.(IAlter_tablespace_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_tablespace_actionsContext) Alter_tablespace_action(i int) IAlter_tablespace_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_tablespace_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_tablespace_actionContext)
}

func (s *Alter_tablespace_actionsContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Alter_tablespace_actionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_tablespace_actionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_tablespace_actionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_tablespace_actions(s)
	}
}

func (s *Alter_tablespace_actionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_tablespace_actions(s)
	}
}

func (s *Alter_tablespace_actionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_tablespace_actions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_tablespace_actions() (localctx IAlter_tablespace_actionsContext) {
	localctx = NewAlter_tablespace_actionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, OBParserRULE_alter_tablespace_actions)
	p.SetState(6412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 645, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6407)
			p.Alter_tablespace_action()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6408)
			p.Alter_tablespace_action()
		}
		{
			p.SetState(6409)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6410)
			p.Alter_tablespace_action()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_tablespace_actionContext is an interface to support dynamic dispatch.
type IAlter_tablespace_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Permanent_tablespace_option() IPermanent_tablespace_optionContext
	SET() antlr.TerminalNode

	// IsAlter_tablespace_actionContext differentiates from other interfaces.
	IsAlter_tablespace_actionContext()
}

type Alter_tablespace_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_tablespace_actionContext() *Alter_tablespace_actionContext {
	var p = new(Alter_tablespace_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tablespace_action
	return p
}

func InitEmptyAlter_tablespace_actionContext(p *Alter_tablespace_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tablespace_action
}

func (*Alter_tablespace_actionContext) IsAlter_tablespace_actionContext() {}

func NewAlter_tablespace_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_tablespace_actionContext {
	var p = new(Alter_tablespace_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_tablespace_action

	return p
}

func (s *Alter_tablespace_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_tablespace_actionContext) Permanent_tablespace_option() IPermanent_tablespace_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermanent_tablespace_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermanent_tablespace_optionContext)
}

func (s *Alter_tablespace_actionContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Alter_tablespace_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_tablespace_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_tablespace_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_tablespace_action(s)
	}
}

func (s *Alter_tablespace_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_tablespace_action(s)
	}
}

func (s *Alter_tablespace_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_tablespace_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_tablespace_action() (localctx IAlter_tablespace_actionContext) {
	localctx = NewAlter_tablespace_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, OBParserRULE_alter_tablespace_action)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserSET {
		{
			p.SetState(6414)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(6417)
		p.Permanent_tablespace_option()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_tablespace_stmtContext is an interface to support dynamic dispatch.
type IAlter_tablespace_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	Tablespace() ITablespaceContext
	Alter_tablespace_actions() IAlter_tablespace_actionsContext

	// IsAlter_tablespace_stmtContext differentiates from other interfaces.
	IsAlter_tablespace_stmtContext()
}

type Alter_tablespace_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_tablespace_stmtContext() *Alter_tablespace_stmtContext {
	var p = new(Alter_tablespace_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tablespace_stmt
	return p
}

func InitEmptyAlter_tablespace_stmtContext(p *Alter_tablespace_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tablespace_stmt
}

func (*Alter_tablespace_stmtContext) IsAlter_tablespace_stmtContext() {}

func NewAlter_tablespace_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_tablespace_stmtContext {
	var p = new(Alter_tablespace_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_tablespace_stmt

	return p
}

func (s *Alter_tablespace_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_tablespace_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(OBParserALTER, 0)
}

func (s *Alter_tablespace_stmtContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLESPACE, 0)
}

func (s *Alter_tablespace_stmtContext) Tablespace() ITablespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceContext)
}

func (s *Alter_tablespace_stmtContext) Alter_tablespace_actions() IAlter_tablespace_actionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_tablespace_actionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_tablespace_actionsContext)
}

func (s *Alter_tablespace_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_tablespace_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_tablespace_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_tablespace_stmt(s)
	}
}

func (s *Alter_tablespace_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_tablespace_stmt(s)
	}
}

func (s *Alter_tablespace_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_tablespace_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_tablespace_stmt() (localctx IAlter_tablespace_stmtContext) {
	localctx = NewAlter_tablespace_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, OBParserRULE_alter_tablespace_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6419)
		p.Match(OBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6420)
		p.Match(OBParserTABLESPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6421)
		p.Tablespace()
	}
	{
		p.SetState(6422)
		p.Alter_tablespace_actions()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRotate_master_key_stmtContext is an interface to support dynamic dispatch.
type IRotate_master_key_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	INSTANCE() antlr.TerminalNode
	ROTATE() antlr.TerminalNode
	INNODB() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsRotate_master_key_stmtContext differentiates from other interfaces.
	IsRotate_master_key_stmtContext()
}

type Rotate_master_key_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRotate_master_key_stmtContext() *Rotate_master_key_stmtContext {
	var p = new(Rotate_master_key_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rotate_master_key_stmt
	return p
}

func InitEmptyRotate_master_key_stmtContext(p *Rotate_master_key_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rotate_master_key_stmt
}

func (*Rotate_master_key_stmtContext) IsRotate_master_key_stmtContext() {}

func NewRotate_master_key_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rotate_master_key_stmtContext {
	var p = new(Rotate_master_key_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_rotate_master_key_stmt

	return p
}

func (s *Rotate_master_key_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Rotate_master_key_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(OBParserALTER, 0)
}

func (s *Rotate_master_key_stmtContext) INSTANCE() antlr.TerminalNode {
	return s.GetToken(OBParserINSTANCE, 0)
}

func (s *Rotate_master_key_stmtContext) ROTATE() antlr.TerminalNode {
	return s.GetToken(OBParserROTATE, 0)
}

func (s *Rotate_master_key_stmtContext) INNODB() antlr.TerminalNode {
	return s.GetToken(OBParserINNODB, 0)
}

func (s *Rotate_master_key_stmtContext) MASTER() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER, 0)
}

func (s *Rotate_master_key_stmtContext) KEY() antlr.TerminalNode {
	return s.GetToken(OBParserKEY, 0)
}

func (s *Rotate_master_key_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rotate_master_key_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rotate_master_key_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRotate_master_key_stmt(s)
	}
}

func (s *Rotate_master_key_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRotate_master_key_stmt(s)
	}
}

func (s *Rotate_master_key_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRotate_master_key_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Rotate_master_key_stmt() (localctx IRotate_master_key_stmtContext) {
	localctx = NewRotate_master_key_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, OBParserRULE_rotate_master_key_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6424)
		p.Match(OBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6425)
		p.Match(OBParserINSTANCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6426)
		p.Match(OBParserROTATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6427)
		p.Match(OBParserINNODB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6428)
		p.Match(OBParserMASTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6429)
		p.Match(OBParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPermanent_tablespace_optionsContext is an interface to support dynamic dispatch.
type IPermanent_tablespace_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPermanent_tablespace_option() []IPermanent_tablespace_optionContext
	Permanent_tablespace_option(i int) IPermanent_tablespace_optionContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsPermanent_tablespace_optionsContext differentiates from other interfaces.
	IsPermanent_tablespace_optionsContext()
}

type Permanent_tablespace_optionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPermanent_tablespace_optionsContext() *Permanent_tablespace_optionsContext {
	var p = new(Permanent_tablespace_optionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_permanent_tablespace_options
	return p
}

func InitEmptyPermanent_tablespace_optionsContext(p *Permanent_tablespace_optionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_permanent_tablespace_options
}

func (*Permanent_tablespace_optionsContext) IsPermanent_tablespace_optionsContext() {}

func NewPermanent_tablespace_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Permanent_tablespace_optionsContext {
	var p = new(Permanent_tablespace_optionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_permanent_tablespace_options

	return p
}

func (s *Permanent_tablespace_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Permanent_tablespace_optionsContext) AllPermanent_tablespace_option() []IPermanent_tablespace_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPermanent_tablespace_optionContext); ok {
			len++
		}
	}

	tst := make([]IPermanent_tablespace_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPermanent_tablespace_optionContext); ok {
			tst[i] = t.(IPermanent_tablespace_optionContext)
			i++
		}
	}

	return tst
}

func (s *Permanent_tablespace_optionsContext) Permanent_tablespace_option(i int) IPermanent_tablespace_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPermanent_tablespace_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPermanent_tablespace_optionContext)
}

func (s *Permanent_tablespace_optionsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Permanent_tablespace_optionsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Permanent_tablespace_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Permanent_tablespace_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Permanent_tablespace_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterPermanent_tablespace_options(s)
	}
}

func (s *Permanent_tablespace_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitPermanent_tablespace_options(s)
	}
}

func (s *Permanent_tablespace_optionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitPermanent_tablespace_options(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Permanent_tablespace_options() (localctx IPermanent_tablespace_optionsContext) {
	localctx = NewPermanent_tablespace_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, OBParserRULE_permanent_tablespace_options)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6431)
		p.Permanent_tablespace_option()
	}
	p.SetState(6436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(6432)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6433)
			p.Permanent_tablespace_option()
		}

		p.SetState(6438)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_user_stmtContext is an interface to support dynamic dispatch.
type ICreate_user_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	USER() antlr.TerminalNode
	User_specification_list() IUser_specification_listContext
	IF() antlr.TerminalNode
	Not() INotContext
	EXISTS() antlr.TerminalNode
	Require_specification() IRequire_specificationContext

	// IsCreate_user_stmtContext differentiates from other interfaces.
	IsCreate_user_stmtContext()
}

type Create_user_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_user_stmtContext() *Create_user_stmtContext {
	var p = new(Create_user_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_user_stmt
	return p
}

func InitEmptyCreate_user_stmtContext(p *Create_user_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_user_stmt
}

func (*Create_user_stmtContext) IsCreate_user_stmtContext() {}

func NewCreate_user_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_user_stmtContext {
	var p = new(Create_user_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_create_user_stmt

	return p
}

func (s *Create_user_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_user_stmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE, 0)
}

func (s *Create_user_stmtContext) USER() antlr.TerminalNode {
	return s.GetToken(OBParserUSER, 0)
}

func (s *Create_user_stmtContext) User_specification_list() IUser_specification_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUser_specification_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUser_specification_listContext)
}

func (s *Create_user_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(OBParserIF, 0)
}

func (s *Create_user_stmtContext) Not() INotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotContext)
}

func (s *Create_user_stmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(OBParserEXISTS, 0)
}

func (s *Create_user_stmtContext) Require_specification() IRequire_specificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequire_specificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequire_specificationContext)
}

func (s *Create_user_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_user_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_user_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCreate_user_stmt(s)
	}
}

func (s *Create_user_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCreate_user_stmt(s)
	}
}

func (s *Create_user_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCreate_user_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Create_user_stmt() (localctx ICreate_user_stmtContext) {
	localctx = NewCreate_user_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, OBParserRULE_create_user_stmt)
	var _la int

	p.SetState(6459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 650, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6439)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6440)
			p.Match(OBParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6445)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIF {
			{
				p.SetState(6441)
				p.Match(OBParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6442)
				p.Not()
			}
			{
				p.SetState(6443)
				p.Match(OBParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6447)
			p.User_specification_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6448)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6449)
			p.Match(OBParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6454)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIF {
			{
				p.SetState(6450)
				p.Match(OBParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6451)
				p.Not()
			}
			{
				p.SetState(6452)
				p.Match(OBParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6456)
			p.User_specification_list()
		}
		{
			p.SetState(6457)
			p.Require_specification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUser_specification_listContext is an interface to support dynamic dispatch.
type IUser_specification_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUser_specification() []IUser_specificationContext
	User_specification(i int) IUser_specificationContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsUser_specification_listContext differentiates from other interfaces.
	IsUser_specification_listContext()
}

type User_specification_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUser_specification_listContext() *User_specification_listContext {
	var p = new(User_specification_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_user_specification_list
	return p
}

func InitEmptyUser_specification_listContext(p *User_specification_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_user_specification_list
}

func (*User_specification_listContext) IsUser_specification_listContext() {}

func NewUser_specification_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *User_specification_listContext {
	var p = new(User_specification_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_user_specification_list

	return p
}

func (s *User_specification_listContext) GetParser() antlr.Parser { return s.parser }

func (s *User_specification_listContext) AllUser_specification() []IUser_specificationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUser_specificationContext); ok {
			len++
		}
	}

	tst := make([]IUser_specificationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUser_specificationContext); ok {
			tst[i] = t.(IUser_specificationContext)
			i++
		}
	}

	return tst
}

func (s *User_specification_listContext) User_specification(i int) IUser_specificationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUser_specificationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUser_specificationContext)
}

func (s *User_specification_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *User_specification_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *User_specification_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *User_specification_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *User_specification_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUser_specification_list(s)
	}
}

func (s *User_specification_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUser_specification_list(s)
	}
}

func (s *User_specification_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUser_specification_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) User_specification_list() (localctx IUser_specification_listContext) {
	localctx = NewUser_specification_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, OBParserRULE_user_specification_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6461)
		p.User_specification()
	}
	p.SetState(6466)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(6462)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6463)
			p.User_specification()
		}

		p.SetState(6468)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUser_specificationContext is an interface to support dynamic dispatch.
type IUser_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	User() IUserContext
	USER_VARIABLE() antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	BY() antlr.TerminalNode
	Password() IPasswordContext
	PASSWORD() antlr.TerminalNode

	// IsUser_specificationContext differentiates from other interfaces.
	IsUser_specificationContext()
}

type User_specificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUser_specificationContext() *User_specificationContext {
	var p = new(User_specificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_user_specification
	return p
}

func InitEmptyUser_specificationContext(p *User_specificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_user_specification
}

func (*User_specificationContext) IsUser_specificationContext() {}

func NewUser_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *User_specificationContext {
	var p = new(User_specificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_user_specification

	return p
}

func (s *User_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *User_specificationContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *User_specificationContext) USER_VARIABLE() antlr.TerminalNode {
	return s.GetToken(OBParserUSER_VARIABLE, 0)
}

func (s *User_specificationContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(OBParserIDENTIFIED, 0)
}

func (s *User_specificationContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *User_specificationContext) Password() IPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordContext)
}

func (s *User_specificationContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(OBParserPASSWORD, 0)
}

func (s *User_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *User_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *User_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUser_specification(s)
	}
}

func (s *User_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUser_specification(s)
	}
}

func (s *User_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUser_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) User_specification() (localctx IUser_specificationContext) {
	localctx = NewUser_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, OBParserRULE_user_specification)
	var _la int

	p.SetState(6490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 655, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6469)
			p.User()
		}
		p.SetState(6471)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserUSER_VARIABLE {
			{
				p.SetState(6470)
				p.Match(OBParserUSER_VARIABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6473)
			p.User()
		}
		p.SetState(6475)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserUSER_VARIABLE {
			{
				p.SetState(6474)
				p.Match(OBParserUSER_VARIABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6477)
			p.Match(OBParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6478)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6479)
			p.Password()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6481)
			p.User()
		}
		p.SetState(6483)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserUSER_VARIABLE {
			{
				p.SetState(6482)
				p.Match(OBParserUSER_VARIABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6485)
			p.Match(OBParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6486)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6487)
			p.Match(OBParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6488)
			p.Password()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRequire_specificationContext is an interface to support dynamic dispatch.
type IRequire_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REQUIRE() antlr.TerminalNode
	NONE() antlr.TerminalNode
	SSL() antlr.TerminalNode
	X509() antlr.TerminalNode
	Tls_option_list() ITls_option_listContext

	// IsRequire_specificationContext differentiates from other interfaces.
	IsRequire_specificationContext()
}

type Require_specificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequire_specificationContext() *Require_specificationContext {
	var p = new(Require_specificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_require_specification
	return p
}

func InitEmptyRequire_specificationContext(p *Require_specificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_require_specification
}

func (*Require_specificationContext) IsRequire_specificationContext() {}

func NewRequire_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Require_specificationContext {
	var p = new(Require_specificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_require_specification

	return p
}

func (s *Require_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Require_specificationContext) REQUIRE() antlr.TerminalNode {
	return s.GetToken(OBParserREQUIRE, 0)
}

func (s *Require_specificationContext) NONE() antlr.TerminalNode {
	return s.GetToken(OBParserNONE, 0)
}

func (s *Require_specificationContext) SSL() antlr.TerminalNode {
	return s.GetToken(OBParserSSL, 0)
}

func (s *Require_specificationContext) X509() antlr.TerminalNode {
	return s.GetToken(OBParserX509, 0)
}

func (s *Require_specificationContext) Tls_option_list() ITls_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITls_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITls_option_listContext)
}

func (s *Require_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Require_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Require_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRequire_specification(s)
	}
}

func (s *Require_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRequire_specification(s)
	}
}

func (s *Require_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRequire_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Require_specification() (localctx IRequire_specificationContext) {
	localctx = NewRequire_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, OBParserRULE_require_specification)
	p.SetState(6500)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 656, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6492)
			p.Match(OBParserREQUIRE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6493)
			p.Match(OBParserNONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6494)
			p.Match(OBParserREQUIRE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6495)
			p.Match(OBParserSSL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6496)
			p.Match(OBParserREQUIRE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6497)
			p.Match(OBParserX509)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6498)
			p.Match(OBParserREQUIRE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6499)
			p.tls_option_list(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITls_option_listContext is an interface to support dynamic dispatch.
type ITls_option_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Tls_option() ITls_optionContext
	Tls_option_list() ITls_option_listContext
	AND() antlr.TerminalNode

	// IsTls_option_listContext differentiates from other interfaces.
	IsTls_option_listContext()
}

type Tls_option_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTls_option_listContext() *Tls_option_listContext {
	var p = new(Tls_option_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tls_option_list
	return p
}

func InitEmptyTls_option_listContext(p *Tls_option_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tls_option_list
}

func (*Tls_option_listContext) IsTls_option_listContext() {}

func NewTls_option_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tls_option_listContext {
	var p = new(Tls_option_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tls_option_list

	return p
}

func (s *Tls_option_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Tls_option_listContext) Tls_option() ITls_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITls_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITls_optionContext)
}

func (s *Tls_option_listContext) Tls_option_list() ITls_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITls_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITls_option_listContext)
}

func (s *Tls_option_listContext) AND() antlr.TerminalNode {
	return s.GetToken(OBParserAND, 0)
}

func (s *Tls_option_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tls_option_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tls_option_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTls_option_list(s)
	}
}

func (s *Tls_option_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTls_option_list(s)
	}
}

func (s *Tls_option_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTls_option_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tls_option_list() (localctx ITls_option_listContext) {
	return p.tls_option_list(0)
}

func (p *OBParser) tls_option_list(_p int) (localctx ITls_option_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewTls_option_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITls_option_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 682
	p.EnterRecursionRule(localctx, 682, OBParserRULE_tls_option_list, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6503)
		p.Tls_option()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 658, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6510)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 657, p.GetParserRuleContext()) {
			case 1:
				localctx = NewTls_option_listContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_tls_option_list)
				p.SetState(6505)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(6506)
					p.Tls_option()
				}

			case 2:
				localctx = NewTls_option_listContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, OBParserRULE_tls_option_list)
				p.SetState(6507)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(6508)
					p.Match(OBParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6509)
					p.Tls_option()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6514)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 658, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITls_optionContext is an interface to support dynamic dispatch.
type ITls_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CIPHER() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	ISSUER() antlr.TerminalNode
	SUBJECT() antlr.TerminalNode

	// IsTls_optionContext differentiates from other interfaces.
	IsTls_optionContext()
}

type Tls_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTls_optionContext() *Tls_optionContext {
	var p = new(Tls_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tls_option
	return p
}

func InitEmptyTls_optionContext(p *Tls_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tls_option
}

func (*Tls_optionContext) IsTls_optionContext() {}

func NewTls_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tls_optionContext {
	var p = new(Tls_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tls_option

	return p
}

func (s *Tls_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tls_optionContext) CIPHER() antlr.TerminalNode {
	return s.GetToken(OBParserCIPHER, 0)
}

func (s *Tls_optionContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Tls_optionContext) ISSUER() antlr.TerminalNode {
	return s.GetToken(OBParserISSUER, 0)
}

func (s *Tls_optionContext) SUBJECT() antlr.TerminalNode {
	return s.GetToken(OBParserSUBJECT, 0)
}

func (s *Tls_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tls_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tls_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTls_option(s)
	}
}

func (s *Tls_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTls_option(s)
	}
}

func (s *Tls_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTls_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tls_option() (localctx ITls_optionContext) {
	localctx = NewTls_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, OBParserRULE_tls_option)
	p.SetState(6521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserCIPHER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6515)
			p.Match(OBParserCIPHER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6516)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserISSUER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6517)
			p.Match(OBParserISSUER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6518)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserSUBJECT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6519)
			p.Match(OBParserSUBJECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6520)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserContext is an interface to support dynamic dispatch.
type IUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_VALUE() antlr.TerminalNode
	NAME_OB() antlr.TerminalNode
	Unreserved_keyword() IUnreserved_keywordContext

	// IsUserContext differentiates from other interfaces.
	IsUserContext()
}

type UserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserContext() *UserContext {
	var p = new(UserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_user
	return p
}

func InitEmptyUserContext(p *UserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_user
}

func (*UserContext) IsUserContext() {}

func NewUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserContext {
	var p = new(UserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_user

	return p
}

func (s *UserContext) GetParser() antlr.Parser { return s.parser }

func (s *UserContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *UserContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *UserContext) Unreserved_keyword() IUnreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keywordContext)
}

func (s *UserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUser(s)
	}
}

func (s *UserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUser(s)
	}
}

func (s *UserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) User() (localctx IUserContext) {
	localctx = NewUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, OBParserRULE_user)
	p.SetState(6526)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6523)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserNAME_OB:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6524)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserSTAT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6525)
			p.Unreserved_keyword()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_host_nameContext is an interface to support dynamic dispatch.
type IOpt_host_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USER_VARIABLE() antlr.TerminalNode

	// IsOpt_host_nameContext differentiates from other interfaces.
	IsOpt_host_nameContext()
}

type Opt_host_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_host_nameContext() *Opt_host_nameContext {
	var p = new(Opt_host_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_host_name
	return p
}

func InitEmptyOpt_host_nameContext(p *Opt_host_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_host_name
}

func (*Opt_host_nameContext) IsOpt_host_nameContext() {}

func NewOpt_host_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_host_nameContext {
	var p = new(Opt_host_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_host_name

	return p
}

func (s *Opt_host_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_host_nameContext) USER_VARIABLE() antlr.TerminalNode {
	return s.GetToken(OBParserUSER_VARIABLE, 0)
}

func (s *Opt_host_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_host_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_host_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_host_name(s)
	}
}

func (s *Opt_host_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_host_name(s)
	}
}

func (s *Opt_host_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_host_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_host_name() (localctx IOpt_host_nameContext) {
	localctx = NewOpt_host_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, OBParserRULE_opt_host_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserUSER_VARIABLE {
		{
			p.SetState(6528)
			p.Match(OBParserUSER_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUser_with_host_nameContext is an interface to support dynamic dispatch.
type IUser_with_host_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	User() IUserContext
	USER_VARIABLE() antlr.TerminalNode

	// IsUser_with_host_nameContext differentiates from other interfaces.
	IsUser_with_host_nameContext()
}

type User_with_host_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUser_with_host_nameContext() *User_with_host_nameContext {
	var p = new(User_with_host_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_user_with_host_name
	return p
}

func InitEmptyUser_with_host_nameContext(p *User_with_host_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_user_with_host_name
}

func (*User_with_host_nameContext) IsUser_with_host_nameContext() {}

func NewUser_with_host_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *User_with_host_nameContext {
	var p = new(User_with_host_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_user_with_host_name

	return p
}

func (s *User_with_host_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *User_with_host_nameContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *User_with_host_nameContext) USER_VARIABLE() antlr.TerminalNode {
	return s.GetToken(OBParserUSER_VARIABLE, 0)
}

func (s *User_with_host_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *User_with_host_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *User_with_host_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUser_with_host_name(s)
	}
}

func (s *User_with_host_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUser_with_host_name(s)
	}
}

func (s *User_with_host_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUser_with_host_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) User_with_host_name() (localctx IUser_with_host_nameContext) {
	localctx = NewUser_with_host_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, OBParserRULE_user_with_host_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6531)
		p.User()
	}
	p.SetState(6533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserUSER_VARIABLE {
		{
			p.SetState(6532)
			p.Match(OBParserUSER_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPasswordContext is an interface to support dynamic dispatch.
type IPasswordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_VALUE() antlr.TerminalNode

	// IsPasswordContext differentiates from other interfaces.
	IsPasswordContext()
}

type PasswordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPasswordContext() *PasswordContext {
	var p = new(PasswordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_password
	return p
}

func InitEmptyPasswordContext(p *PasswordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_password
}

func (*PasswordContext) IsPasswordContext() {}

func NewPasswordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordContext {
	var p = new(PasswordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_password

	return p
}

func (s *PasswordContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *PasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterPassword(s)
	}
}

func (s *PasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitPassword(s)
	}
}

func (s *PasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitPassword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Password() (localctx IPasswordContext) {
	localctx = NewPasswordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, OBParserRULE_password)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6535)
		p.Match(OBParserSTRING_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_user_stmtContext is an interface to support dynamic dispatch.
type IDrop_user_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	USER() antlr.TerminalNode
	User_list() IUser_listContext

	// IsDrop_user_stmtContext differentiates from other interfaces.
	IsDrop_user_stmtContext()
}

type Drop_user_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_user_stmtContext() *Drop_user_stmtContext {
	var p = new(Drop_user_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_user_stmt
	return p
}

func InitEmptyDrop_user_stmtContext(p *Drop_user_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_user_stmt
}

func (*Drop_user_stmtContext) IsDrop_user_stmtContext() {}

func NewDrop_user_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_user_stmtContext {
	var p = new(Drop_user_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_drop_user_stmt

	return p
}

func (s *Drop_user_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_user_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Drop_user_stmtContext) USER() antlr.TerminalNode {
	return s.GetToken(OBParserUSER, 0)
}

func (s *Drop_user_stmtContext) User_list() IUser_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUser_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUser_listContext)
}

func (s *Drop_user_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_user_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_user_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDrop_user_stmt(s)
	}
}

func (s *Drop_user_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDrop_user_stmt(s)
	}
}

func (s *Drop_user_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDrop_user_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Drop_user_stmt() (localctx IDrop_user_stmtContext) {
	localctx = NewDrop_user_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, OBParserRULE_drop_user_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6537)
		p.Match(OBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6538)
		p.Match(OBParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6539)
		p.User_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUser_listContext is an interface to support dynamic dispatch.
type IUser_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUser_with_host_name() []IUser_with_host_nameContext
	User_with_host_name(i int) IUser_with_host_nameContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsUser_listContext differentiates from other interfaces.
	IsUser_listContext()
}

type User_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUser_listContext() *User_listContext {
	var p = new(User_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_user_list
	return p
}

func InitEmptyUser_listContext(p *User_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_user_list
}

func (*User_listContext) IsUser_listContext() {}

func NewUser_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *User_listContext {
	var p = new(User_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_user_list

	return p
}

func (s *User_listContext) GetParser() antlr.Parser { return s.parser }

func (s *User_listContext) AllUser_with_host_name() []IUser_with_host_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUser_with_host_nameContext); ok {
			len++
		}
	}

	tst := make([]IUser_with_host_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUser_with_host_nameContext); ok {
			tst[i] = t.(IUser_with_host_nameContext)
			i++
		}
	}

	return tst
}

func (s *User_listContext) User_with_host_name(i int) IUser_with_host_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUser_with_host_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUser_with_host_nameContext)
}

func (s *User_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *User_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *User_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *User_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *User_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUser_list(s)
	}
}

func (s *User_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUser_list(s)
	}
}

func (s *User_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUser_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) User_list() (localctx IUser_listContext) {
	localctx = NewUser_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, OBParserRULE_user_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6541)
		p.User_with_host_name()
	}
	p.SetState(6546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(6542)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6543)
			p.User_with_host_name()
		}

		p.SetState(6548)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_password_stmtContext is an interface to support dynamic dispatch.
type ISet_password_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	AllPASSWORD() []antlr.TerminalNode
	PASSWORD(i int) antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	FOR() antlr.TerminalNode
	User() IUserContext
	Opt_host_name() IOpt_host_nameContext
	LeftParen() antlr.TerminalNode
	Password() IPasswordContext
	RightParen() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	USER() antlr.TerminalNode
	User_with_host_name() IUser_with_host_nameContext
	IDENTIFIED() antlr.TerminalNode
	BY() antlr.TerminalNode
	Require_specification() IRequire_specificationContext

	// IsSet_password_stmtContext differentiates from other interfaces.
	IsSet_password_stmtContext()
}

type Set_password_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_password_stmtContext() *Set_password_stmtContext {
	var p = new(Set_password_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_password_stmt
	return p
}

func InitEmptySet_password_stmtContext(p *Set_password_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_password_stmt
}

func (*Set_password_stmtContext) IsSet_password_stmtContext() {}

func NewSet_password_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_password_stmtContext {
	var p = new(Set_password_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_set_password_stmt

	return p
}

func (s *Set_password_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_password_stmtContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Set_password_stmtContext) AllPASSWORD() []antlr.TerminalNode {
	return s.GetTokens(OBParserPASSWORD)
}

func (s *Set_password_stmtContext) PASSWORD(i int) antlr.TerminalNode {
	return s.GetToken(OBParserPASSWORD, i)
}

func (s *Set_password_stmtContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Set_password_stmtContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Set_password_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(OBParserFOR, 0)
}

func (s *Set_password_stmtContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *Set_password_stmtContext) Opt_host_name() IOpt_host_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_host_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_host_nameContext)
}

func (s *Set_password_stmtContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Set_password_stmtContext) Password() IPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordContext)
}

func (s *Set_password_stmtContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Set_password_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(OBParserALTER, 0)
}

func (s *Set_password_stmtContext) USER() antlr.TerminalNode {
	return s.GetToken(OBParserUSER, 0)
}

func (s *Set_password_stmtContext) User_with_host_name() IUser_with_host_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUser_with_host_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUser_with_host_nameContext)
}

func (s *Set_password_stmtContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(OBParserIDENTIFIED, 0)
}

func (s *Set_password_stmtContext) BY() antlr.TerminalNode {
	return s.GetToken(OBParserBY, 0)
}

func (s *Set_password_stmtContext) Require_specification() IRequire_specificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequire_specificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequire_specificationContext)
}

func (s *Set_password_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_password_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_password_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSet_password_stmt(s)
	}
}

func (s *Set_password_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSet_password_stmt(s)
	}
}

func (s *Set_password_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSet_password_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Set_password_stmt() (localctx ISet_password_stmtContext) {
	localctx = NewSet_password_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, OBParserRULE_set_password_stmt)
	var _la int

	p.SetState(6585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 666, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6549)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6550)
			p.Match(OBParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6555)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFOR {
			{
				p.SetState(6551)
				p.Match(OBParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6552)
				p.User()
			}
			{
				p.SetState(6553)
				p.Opt_host_name()
			}

		}
		{
			p.SetState(6557)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6558)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6559)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6560)
			p.Match(OBParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFOR {
			{
				p.SetState(6561)
				p.Match(OBParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6562)
				p.User()
			}
			{
				p.SetState(6563)
				p.Opt_host_name()
			}

		}
		{
			p.SetState(6567)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6568)
			p.Match(OBParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6569)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6570)
			p.Password()
		}
		{
			p.SetState(6571)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6573)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6574)
			p.Match(OBParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6575)
			p.User_with_host_name()
		}
		{
			p.SetState(6576)
			p.Match(OBParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6577)
			p.Match(OBParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6578)
			p.Password()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6580)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6581)
			p.Match(OBParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6582)
			p.User_with_host_name()
		}
		{
			p.SetState(6583)
			p.Require_specification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_for_userContext is an interface to support dynamic dispatch.
type IOpt_for_userContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	User() IUserContext
	Opt_host_name() IOpt_host_nameContext
	Empty() IEmptyContext

	// IsOpt_for_userContext differentiates from other interfaces.
	IsOpt_for_userContext()
}

type Opt_for_userContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_for_userContext() *Opt_for_userContext {
	var p = new(Opt_for_userContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_for_user
	return p
}

func InitEmptyOpt_for_userContext(p *Opt_for_userContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_for_user
}

func (*Opt_for_userContext) IsOpt_for_userContext() {}

func NewOpt_for_userContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_for_userContext {
	var p = new(Opt_for_userContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_for_user

	return p
}

func (s *Opt_for_userContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_for_userContext) FOR() antlr.TerminalNode {
	return s.GetToken(OBParserFOR, 0)
}

func (s *Opt_for_userContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *Opt_for_userContext) Opt_host_name() IOpt_host_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_host_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_host_nameContext)
}

func (s *Opt_for_userContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Opt_for_userContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_for_userContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_for_userContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_for_user(s)
	}
}

func (s *Opt_for_userContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_for_user(s)
	}
}

func (s *Opt_for_userContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_for_user(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_for_user() (localctx IOpt_for_userContext) {
	localctx = NewOpt_for_userContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, OBParserRULE_opt_for_user)
	p.SetState(6592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6587)
			p.Match(OBParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6588)
			p.User()
		}
		{
			p.SetState(6589)
			p.Opt_host_name()
		}

	case OBParserEOF, OBParserDELIMITER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6591)
			p.Empty()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRename_user_stmtContext is an interface to support dynamic dispatch.
type IRename_user_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	USER() antlr.TerminalNode
	Rename_list() IRename_listContext

	// IsRename_user_stmtContext differentiates from other interfaces.
	IsRename_user_stmtContext()
}

type Rename_user_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRename_user_stmtContext() *Rename_user_stmtContext {
	var p = new(Rename_user_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rename_user_stmt
	return p
}

func InitEmptyRename_user_stmtContext(p *Rename_user_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rename_user_stmt
}

func (*Rename_user_stmtContext) IsRename_user_stmtContext() {}

func NewRename_user_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rename_user_stmtContext {
	var p = new(Rename_user_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_rename_user_stmt

	return p
}

func (s *Rename_user_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Rename_user_stmtContext) RENAME() antlr.TerminalNode {
	return s.GetToken(OBParserRENAME, 0)
}

func (s *Rename_user_stmtContext) USER() antlr.TerminalNode {
	return s.GetToken(OBParserUSER, 0)
}

func (s *Rename_user_stmtContext) Rename_list() IRename_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRename_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRename_listContext)
}

func (s *Rename_user_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rename_user_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rename_user_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRename_user_stmt(s)
	}
}

func (s *Rename_user_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRename_user_stmt(s)
	}
}

func (s *Rename_user_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRename_user_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Rename_user_stmt() (localctx IRename_user_stmtContext) {
	localctx = NewRename_user_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, OBParserRULE_rename_user_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6594)
		p.Match(OBParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6595)
		p.Match(OBParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6596)
		p.Rename_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRename_infoContext is an interface to support dynamic dispatch.
type IRename_infoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUser() []IUserContext
	User(i int) IUserContext
	TO() antlr.TerminalNode
	AllUSER_VARIABLE() []antlr.TerminalNode
	USER_VARIABLE(i int) antlr.TerminalNode

	// IsRename_infoContext differentiates from other interfaces.
	IsRename_infoContext()
}

type Rename_infoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRename_infoContext() *Rename_infoContext {
	var p = new(Rename_infoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rename_info
	return p
}

func InitEmptyRename_infoContext(p *Rename_infoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rename_info
}

func (*Rename_infoContext) IsRename_infoContext() {}

func NewRename_infoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rename_infoContext {
	var p = new(Rename_infoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_rename_info

	return p
}

func (s *Rename_infoContext) GetParser() antlr.Parser { return s.parser }

func (s *Rename_infoContext) AllUser() []IUserContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserContext); ok {
			len++
		}
	}

	tst := make([]IUserContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserContext); ok {
			tst[i] = t.(IUserContext)
			i++
		}
	}

	return tst
}

func (s *Rename_infoContext) User(i int) IUserContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *Rename_infoContext) TO() antlr.TerminalNode {
	return s.GetToken(OBParserTO, 0)
}

func (s *Rename_infoContext) AllUSER_VARIABLE() []antlr.TerminalNode {
	return s.GetTokens(OBParserUSER_VARIABLE)
}

func (s *Rename_infoContext) USER_VARIABLE(i int) antlr.TerminalNode {
	return s.GetToken(OBParserUSER_VARIABLE, i)
}

func (s *Rename_infoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rename_infoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rename_infoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRename_info(s)
	}
}

func (s *Rename_infoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRename_info(s)
	}
}

func (s *Rename_infoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRename_info(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Rename_info() (localctx IRename_infoContext) {
	localctx = NewRename_infoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, OBParserRULE_rename_info)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6598)
		p.User()
	}
	p.SetState(6600)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserUSER_VARIABLE {
		{
			p.SetState(6599)
			p.Match(OBParserUSER_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(6602)
		p.Match(OBParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6603)
		p.User()
	}
	p.SetState(6605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserUSER_VARIABLE {
		{
			p.SetState(6604)
			p.Match(OBParserUSER_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRename_listContext is an interface to support dynamic dispatch.
type IRename_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRename_info() []IRename_infoContext
	Rename_info(i int) IRename_infoContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsRename_listContext differentiates from other interfaces.
	IsRename_listContext()
}

type Rename_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRename_listContext() *Rename_listContext {
	var p = new(Rename_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rename_list
	return p
}

func InitEmptyRename_listContext(p *Rename_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rename_list
}

func (*Rename_listContext) IsRename_listContext() {}

func NewRename_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rename_listContext {
	var p = new(Rename_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_rename_list

	return p
}

func (s *Rename_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Rename_listContext) AllRename_info() []IRename_infoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRename_infoContext); ok {
			len++
		}
	}

	tst := make([]IRename_infoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRename_infoContext); ok {
			tst[i] = t.(IRename_infoContext)
			i++
		}
	}

	return tst
}

func (s *Rename_listContext) Rename_info(i int) IRename_infoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRename_infoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRename_infoContext)
}

func (s *Rename_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Rename_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Rename_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rename_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rename_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRename_list(s)
	}
}

func (s *Rename_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRename_list(s)
	}
}

func (s *Rename_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRename_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Rename_list() (localctx IRename_listContext) {
	localctx = NewRename_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, OBParserRULE_rename_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6607)
		p.Rename_info()
	}
	p.SetState(6612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(6608)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6609)
			p.Rename_info()
		}

		p.SetState(6614)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILock_user_stmtContext is an interface to support dynamic dispatch.
type ILock_user_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	USER() antlr.TerminalNode
	User_list() IUser_listContext
	ACCOUNT() antlr.TerminalNode
	Lock_spec_mysql57() ILock_spec_mysql57Context

	// IsLock_user_stmtContext differentiates from other interfaces.
	IsLock_user_stmtContext()
}

type Lock_user_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLock_user_stmtContext() *Lock_user_stmtContext {
	var p = new(Lock_user_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_lock_user_stmt
	return p
}

func InitEmptyLock_user_stmtContext(p *Lock_user_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_lock_user_stmt
}

func (*Lock_user_stmtContext) IsLock_user_stmtContext() {}

func NewLock_user_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_user_stmtContext {
	var p = new(Lock_user_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_lock_user_stmt

	return p
}

func (s *Lock_user_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Lock_user_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(OBParserALTER, 0)
}

func (s *Lock_user_stmtContext) USER() antlr.TerminalNode {
	return s.GetToken(OBParserUSER, 0)
}

func (s *Lock_user_stmtContext) User_list() IUser_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUser_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUser_listContext)
}

func (s *Lock_user_stmtContext) ACCOUNT() antlr.TerminalNode {
	return s.GetToken(OBParserACCOUNT, 0)
}

func (s *Lock_user_stmtContext) Lock_spec_mysql57() ILock_spec_mysql57Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILock_spec_mysql57Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILock_spec_mysql57Context)
}

func (s *Lock_user_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_user_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_user_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLock_user_stmt(s)
	}
}

func (s *Lock_user_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLock_user_stmt(s)
	}
}

func (s *Lock_user_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLock_user_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Lock_user_stmt() (localctx ILock_user_stmtContext) {
	localctx = NewLock_user_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, OBParserRULE_lock_user_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6615)
		p.Match(OBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6616)
		p.Match(OBParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6617)
		p.User_list()
	}
	{
		p.SetState(6618)
		p.Match(OBParserACCOUNT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6619)
		p.Lock_spec_mysql57()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILock_spec_mysql57Context is an interface to support dynamic dispatch.
type ILock_spec_mysql57Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCK_() antlr.TerminalNode
	UNLOCK() antlr.TerminalNode

	// IsLock_spec_mysql57Context differentiates from other interfaces.
	IsLock_spec_mysql57Context()
}

type Lock_spec_mysql57Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLock_spec_mysql57Context() *Lock_spec_mysql57Context {
	var p = new(Lock_spec_mysql57Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_lock_spec_mysql57
	return p
}

func InitEmptyLock_spec_mysql57Context(p *Lock_spec_mysql57Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_lock_spec_mysql57
}

func (*Lock_spec_mysql57Context) IsLock_spec_mysql57Context() {}

func NewLock_spec_mysql57Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_spec_mysql57Context {
	var p = new(Lock_spec_mysql57Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_lock_spec_mysql57

	return p
}

func (s *Lock_spec_mysql57Context) GetParser() antlr.Parser { return s.parser }

func (s *Lock_spec_mysql57Context) LOCK_() antlr.TerminalNode {
	return s.GetToken(OBParserLOCK_, 0)
}

func (s *Lock_spec_mysql57Context) UNLOCK() antlr.TerminalNode {
	return s.GetToken(OBParserUNLOCK, 0)
}

func (s *Lock_spec_mysql57Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_spec_mysql57Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_spec_mysql57Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLock_spec_mysql57(s)
	}
}

func (s *Lock_spec_mysql57Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLock_spec_mysql57(s)
	}
}

func (s *Lock_spec_mysql57Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLock_spec_mysql57(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Lock_spec_mysql57() (localctx ILock_spec_mysql57Context) {
	localctx = NewLock_spec_mysql57Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, OBParserRULE_lock_spec_mysql57)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6621)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserLOCK_ || _la == OBParserUNLOCK) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILock_tables_stmtContext is an interface to support dynamic dispatch.
type ILock_tables_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCK_() antlr.TerminalNode
	Table_or_tables() ITable_or_tablesContext
	Lock_table_list() ILock_table_listContext

	// IsLock_tables_stmtContext differentiates from other interfaces.
	IsLock_tables_stmtContext()
}

type Lock_tables_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLock_tables_stmtContext() *Lock_tables_stmtContext {
	var p = new(Lock_tables_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_lock_tables_stmt
	return p
}

func InitEmptyLock_tables_stmtContext(p *Lock_tables_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_lock_tables_stmt
}

func (*Lock_tables_stmtContext) IsLock_tables_stmtContext() {}

func NewLock_tables_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_tables_stmtContext {
	var p = new(Lock_tables_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_lock_tables_stmt

	return p
}

func (s *Lock_tables_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Lock_tables_stmtContext) LOCK_() antlr.TerminalNode {
	return s.GetToken(OBParserLOCK_, 0)
}

func (s *Lock_tables_stmtContext) Table_or_tables() ITable_or_tablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_or_tablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_or_tablesContext)
}

func (s *Lock_tables_stmtContext) Lock_table_list() ILock_table_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILock_table_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILock_table_listContext)
}

func (s *Lock_tables_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_tables_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_tables_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLock_tables_stmt(s)
	}
}

func (s *Lock_tables_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLock_tables_stmt(s)
	}
}

func (s *Lock_tables_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLock_tables_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Lock_tables_stmt() (localctx ILock_tables_stmtContext) {
	localctx = NewLock_tables_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, OBParserRULE_lock_tables_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6623)
		p.Match(OBParserLOCK_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6624)
		p.Table_or_tables()
	}
	{
		p.SetState(6625)
		p.Lock_table_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnlock_tables_stmtContext is an interface to support dynamic dispatch.
type IUnlock_tables_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNLOCK() antlr.TerminalNode
	TABLES() antlr.TerminalNode

	// IsUnlock_tables_stmtContext differentiates from other interfaces.
	IsUnlock_tables_stmtContext()
}

type Unlock_tables_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnlock_tables_stmtContext() *Unlock_tables_stmtContext {
	var p = new(Unlock_tables_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_unlock_tables_stmt
	return p
}

func InitEmptyUnlock_tables_stmtContext(p *Unlock_tables_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_unlock_tables_stmt
}

func (*Unlock_tables_stmtContext) IsUnlock_tables_stmtContext() {}

func NewUnlock_tables_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unlock_tables_stmtContext {
	var p = new(Unlock_tables_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_unlock_tables_stmt

	return p
}

func (s *Unlock_tables_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Unlock_tables_stmtContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(OBParserUNLOCK, 0)
}

func (s *Unlock_tables_stmtContext) TABLES() antlr.TerminalNode {
	return s.GetToken(OBParserTABLES, 0)
}

func (s *Unlock_tables_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unlock_tables_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unlock_tables_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUnlock_tables_stmt(s)
	}
}

func (s *Unlock_tables_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUnlock_tables_stmt(s)
	}
}

func (s *Unlock_tables_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUnlock_tables_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Unlock_tables_stmt() (localctx IUnlock_tables_stmtContext) {
	localctx = NewUnlock_tables_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, OBParserRULE_unlock_tables_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6627)
		p.Match(OBParserUNLOCK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6628)
		p.Match(OBParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILock_table_listContext is an interface to support dynamic dispatch.
type ILock_table_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLock_table() []ILock_tableContext
	Lock_table(i int) ILock_tableContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsLock_table_listContext differentiates from other interfaces.
	IsLock_table_listContext()
}

type Lock_table_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLock_table_listContext() *Lock_table_listContext {
	var p = new(Lock_table_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_lock_table_list
	return p
}

func InitEmptyLock_table_listContext(p *Lock_table_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_lock_table_list
}

func (*Lock_table_listContext) IsLock_table_listContext() {}

func NewLock_table_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_table_listContext {
	var p = new(Lock_table_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_lock_table_list

	return p
}

func (s *Lock_table_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Lock_table_listContext) AllLock_table() []ILock_tableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILock_tableContext); ok {
			len++
		}
	}

	tst := make([]ILock_tableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILock_tableContext); ok {
			tst[i] = t.(ILock_tableContext)
			i++
		}
	}

	return tst
}

func (s *Lock_table_listContext) Lock_table(i int) ILock_tableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILock_tableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILock_tableContext)
}

func (s *Lock_table_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Lock_table_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Lock_table_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_table_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_table_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLock_table_list(s)
	}
}

func (s *Lock_table_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLock_table_list(s)
	}
}

func (s *Lock_table_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLock_table_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Lock_table_list() (localctx ILock_table_listContext) {
	localctx = NewLock_table_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, OBParserRULE_lock_table_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6630)
		p.Lock_table()
	}
	p.SetState(6635)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(6631)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6632)
			p.Lock_table()
		}

		p.SetState(6637)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILock_tableContext is an interface to support dynamic dispatch.
type ILock_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Relation_factor() IRelation_factorContext
	Lock_type() ILock_typeContext
	Relation_name() IRelation_nameContext
	AS() antlr.TerminalNode

	// IsLock_tableContext differentiates from other interfaces.
	IsLock_tableContext()
}

type Lock_tableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLock_tableContext() *Lock_tableContext {
	var p = new(Lock_tableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_lock_table
	return p
}

func InitEmptyLock_tableContext(p *Lock_tableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_lock_table
}

func (*Lock_tableContext) IsLock_tableContext() {}

func NewLock_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_tableContext {
	var p = new(Lock_tableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_lock_table

	return p
}

func (s *Lock_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Lock_tableContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Lock_tableContext) Lock_type() ILock_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILock_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILock_typeContext)
}

func (s *Lock_tableContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Lock_tableContext) AS() antlr.TerminalNode {
	return s.GetToken(OBParserAS, 0)
}

func (s *Lock_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLock_table(s)
	}
}

func (s *Lock_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLock_table(s)
	}
}

func (s *Lock_tableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLock_table(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Lock_table() (localctx ILock_tableContext) {
	localctx = NewLock_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, OBParserRULE_lock_table)
	var _la int

	p.SetState(6648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 673, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6638)
			p.Relation_factor()
		}
		{
			p.SetState(6639)
			p.Lock_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6641)
			p.Relation_factor()
		}
		p.SetState(6643)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserAS {
			{
				p.SetState(6642)
				p.Match(OBParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6645)
			p.Relation_name()
		}
		{
			p.SetState(6646)
			p.Lock_type()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILock_typeContext is an interface to support dynamic dispatch.
type ILock_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode

	// IsLock_typeContext differentiates from other interfaces.
	IsLock_typeContext()
}

type Lock_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLock_typeContext() *Lock_typeContext {
	var p = new(Lock_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_lock_type
	return p
}

func InitEmptyLock_typeContext(p *Lock_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_lock_type
}

func (*Lock_typeContext) IsLock_typeContext() {}

func NewLock_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_typeContext {
	var p = new(Lock_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_lock_type

	return p
}

func (s *Lock_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Lock_typeContext) READ() antlr.TerminalNode {
	return s.GetToken(OBParserREAD, 0)
}

func (s *Lock_typeContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(OBParserLOCAL, 0)
}

func (s *Lock_typeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(OBParserWRITE, 0)
}

func (s *Lock_typeContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(OBParserLOW_PRIORITY, 0)
}

func (s *Lock_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterLock_type(s)
	}
}

func (s *Lock_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitLock_type(s)
	}
}

func (s *Lock_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitLock_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Lock_type() (localctx ILock_typeContext) {
	localctx = NewLock_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, OBParserRULE_lock_type)
	var _la int

	p.SetState(6657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserREAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6650)
			p.Match(OBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6652)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserLOCAL {
			{
				p.SetState(6651)
				p.Match(OBParserLOCAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case OBParserWRITE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6654)
			p.Match(OBParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserLOW_PRIORITY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6655)
			p.Match(OBParserLOW_PRIORITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6656)
			p.Match(OBParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBegin_stmtContext is an interface to support dynamic dispatch.
type IBegin_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGI() antlr.TerminalNode
	WORK() antlr.TerminalNode
	START() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	Transaction_access_mode() ITransaction_access_modeContext
	WITH() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	Comma() antlr.TerminalNode

	// IsBegin_stmtContext differentiates from other interfaces.
	IsBegin_stmtContext()
}

type Begin_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBegin_stmtContext() *Begin_stmtContext {
	var p = new(Begin_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_begin_stmt
	return p
}

func InitEmptyBegin_stmtContext(p *Begin_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_begin_stmt
}

func (*Begin_stmtContext) IsBegin_stmtContext() {}

func NewBegin_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Begin_stmtContext {
	var p = new(Begin_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_begin_stmt

	return p
}

func (s *Begin_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Begin_stmtContext) BEGI() antlr.TerminalNode {
	return s.GetToken(OBParserBEGI, 0)
}

func (s *Begin_stmtContext) WORK() antlr.TerminalNode {
	return s.GetToken(OBParserWORK, 0)
}

func (s *Begin_stmtContext) START() antlr.TerminalNode {
	return s.GetToken(OBParserSTART, 0)
}

func (s *Begin_stmtContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(OBParserTRANSACTION, 0)
}

func (s *Begin_stmtContext) Transaction_access_mode() ITransaction_access_modeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransaction_access_modeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransaction_access_modeContext)
}

func (s *Begin_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(OBParserWITH, 0)
}

func (s *Begin_stmtContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(OBParserCONSISTENT, 0)
}

func (s *Begin_stmtContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(OBParserSNAPSHOT, 0)
}

func (s *Begin_stmtContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Begin_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Begin_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Begin_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterBegin_stmt(s)
	}
}

func (s *Begin_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitBegin_stmt(s)
	}
}

func (s *Begin_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitBegin_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Begin_stmt() (localctx IBegin_stmtContext) {
	localctx = NewBegin_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, OBParserRULE_begin_stmt)
	var _la int

	p.SetState(6682)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserBEGI:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6659)
			p.Match(OBParserBEGI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6661)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserWORK {
			{
				p.SetState(6660)
				p.Match(OBParserWORK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case OBParserSTART:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6663)
			p.Match(OBParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6664)
			p.Match(OBParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6680)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 677, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6665)
				p.Match(OBParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6666)
				p.Match(OBParserCONSISTENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6667)
				p.Match(OBParserSNAPSHOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 677, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6668)
				p.Transaction_access_mode()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 677, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(6669)
				p.Match(OBParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6670)
				p.Match(OBParserCONSISTENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6671)
				p.Match(OBParserSNAPSHOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6672)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6673)
				p.Transaction_access_mode()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 677, p.GetParserRuleContext()) == 4 {
			{
				p.SetState(6674)
				p.Transaction_access_mode()
			}
			{
				p.SetState(6675)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6676)
				p.Match(OBParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6677)
				p.Match(OBParserCONSISTENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6678)
				p.Match(OBParserSNAPSHOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommit_stmtContext is an interface to support dynamic dispatch.
type ICommit_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMIT() antlr.TerminalNode
	WORK() antlr.TerminalNode

	// IsCommit_stmtContext differentiates from other interfaces.
	IsCommit_stmtContext()
}

type Commit_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommit_stmtContext() *Commit_stmtContext {
	var p = new(Commit_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_commit_stmt
	return p
}

func InitEmptyCommit_stmtContext(p *Commit_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_commit_stmt
}

func (*Commit_stmtContext) IsCommit_stmtContext() {}

func NewCommit_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Commit_stmtContext {
	var p = new(Commit_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_commit_stmt

	return p
}

func (s *Commit_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Commit_stmtContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(OBParserCOMMIT, 0)
}

func (s *Commit_stmtContext) WORK() antlr.TerminalNode {
	return s.GetToken(OBParserWORK, 0)
}

func (s *Commit_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Commit_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Commit_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCommit_stmt(s)
	}
}

func (s *Commit_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCommit_stmt(s)
	}
}

func (s *Commit_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCommit_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Commit_stmt() (localctx ICommit_stmtContext) {
	localctx = NewCommit_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, OBParserRULE_commit_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6684)
		p.Match(OBParserCOMMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserWORK {
		{
			p.SetState(6685)
			p.Match(OBParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollback_stmtContext is an interface to support dynamic dispatch.
type IRollback_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLBACK() antlr.TerminalNode
	WORK() antlr.TerminalNode

	// IsRollback_stmtContext differentiates from other interfaces.
	IsRollback_stmtContext()
}

type Rollback_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollback_stmtContext() *Rollback_stmtContext {
	var p = new(Rollback_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rollback_stmt
	return p
}

func InitEmptyRollback_stmtContext(p *Rollback_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rollback_stmt
}

func (*Rollback_stmtContext) IsRollback_stmtContext() {}

func NewRollback_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rollback_stmtContext {
	var p = new(Rollback_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_rollback_stmt

	return p
}

func (s *Rollback_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Rollback_stmtContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(OBParserROLLBACK, 0)
}

func (s *Rollback_stmtContext) WORK() antlr.TerminalNode {
	return s.GetToken(OBParserWORK, 0)
}

func (s *Rollback_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rollback_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rollback_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRollback_stmt(s)
	}
}

func (s *Rollback_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRollback_stmt(s)
	}
}

func (s *Rollback_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRollback_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Rollback_stmt() (localctx IRollback_stmtContext) {
	localctx = NewRollback_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, OBParserRULE_rollback_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6688)
		p.Match(OBParserROLLBACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6690)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserWORK {
		{
			p.SetState(6689)
			p.Match(OBParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKill_stmtContext is an interface to support dynamic dispatch.
type IKill_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KILL() antlr.TerminalNode
	Expr() IExprContext
	CONNECTION() antlr.TerminalNode
	QUERY() antlr.TerminalNode

	// IsKill_stmtContext differentiates from other interfaces.
	IsKill_stmtContext()
}

type Kill_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKill_stmtContext() *Kill_stmtContext {
	var p = new(Kill_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_kill_stmt
	return p
}

func InitEmptyKill_stmtContext(p *Kill_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_kill_stmt
}

func (*Kill_stmtContext) IsKill_stmtContext() {}

func NewKill_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Kill_stmtContext {
	var p = new(Kill_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_kill_stmt

	return p
}

func (s *Kill_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Kill_stmtContext) KILL() antlr.TerminalNode {
	return s.GetToken(OBParserKILL, 0)
}

func (s *Kill_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Kill_stmtContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(OBParserCONNECTION, 0)
}

func (s *Kill_stmtContext) QUERY() antlr.TerminalNode {
	return s.GetToken(OBParserQUERY, 0)
}

func (s *Kill_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Kill_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Kill_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterKill_stmt(s)
	}
}

func (s *Kill_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitKill_stmt(s)
	}
}

func (s *Kill_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitKill_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Kill_stmt() (localctx IKill_stmtContext) {
	localctx = NewKill_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, OBParserRULE_kill_stmt)
	p.SetState(6700)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 681, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6692)
			p.Match(OBParserKILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6693)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6694)
			p.Match(OBParserKILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6695)
			p.Match(OBParserCONNECTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6696)
			p.expr(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6697)
			p.Match(OBParserKILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6698)
			p.Match(OBParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6699)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrant_stmtContext is an interface to support dynamic dispatch.
type IGrant_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GRANT() antlr.TerminalNode
	Grant_privileges() IGrant_privilegesContext
	ON() antlr.TerminalNode
	Priv_level() IPriv_levelContext
	TO() antlr.TerminalNode
	User_specification_list() IUser_specification_listContext
	Grant_options() IGrant_optionsContext

	// IsGrant_stmtContext differentiates from other interfaces.
	IsGrant_stmtContext()
}

type Grant_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrant_stmtContext() *Grant_stmtContext {
	var p = new(Grant_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_grant_stmt
	return p
}

func InitEmptyGrant_stmtContext(p *Grant_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_grant_stmt
}

func (*Grant_stmtContext) IsGrant_stmtContext() {}

func NewGrant_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grant_stmtContext {
	var p = new(Grant_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_grant_stmt

	return p
}

func (s *Grant_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Grant_stmtContext) GRANT() antlr.TerminalNode {
	return s.GetToken(OBParserGRANT, 0)
}

func (s *Grant_stmtContext) Grant_privileges() IGrant_privilegesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrant_privilegesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrant_privilegesContext)
}

func (s *Grant_stmtContext) ON() antlr.TerminalNode {
	return s.GetToken(OBParserON, 0)
}

func (s *Grant_stmtContext) Priv_level() IPriv_levelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPriv_levelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPriv_levelContext)
}

func (s *Grant_stmtContext) TO() antlr.TerminalNode {
	return s.GetToken(OBParserTO, 0)
}

func (s *Grant_stmtContext) User_specification_list() IUser_specification_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUser_specification_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUser_specification_listContext)
}

func (s *Grant_stmtContext) Grant_options() IGrant_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrant_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrant_optionsContext)
}

func (s *Grant_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grant_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Grant_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterGrant_stmt(s)
	}
}

func (s *Grant_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitGrant_stmt(s)
	}
}

func (s *Grant_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitGrant_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Grant_stmt() (localctx IGrant_stmtContext) {
	localctx = NewGrant_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, OBParserRULE_grant_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6702)
		p.Match(OBParserGRANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6703)
		p.Grant_privileges()
	}
	{
		p.SetState(6704)
		p.Match(OBParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6705)
		p.Priv_level()
	}
	{
		p.SetState(6706)
		p.Match(OBParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6707)
		p.User_specification_list()
	}
	{
		p.SetState(6708)
		p.Grant_options()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrant_privilegesContext is an interface to support dynamic dispatch.
type IGrant_privilegesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Priv_type_list() IPriv_type_listContext
	ALL() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode

	// IsGrant_privilegesContext differentiates from other interfaces.
	IsGrant_privilegesContext()
}

type Grant_privilegesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrant_privilegesContext() *Grant_privilegesContext {
	var p = new(Grant_privilegesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_grant_privileges
	return p
}

func InitEmptyGrant_privilegesContext(p *Grant_privilegesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_grant_privileges
}

func (*Grant_privilegesContext) IsGrant_privilegesContext() {}

func NewGrant_privilegesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grant_privilegesContext {
	var p = new(Grant_privilegesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_grant_privileges

	return p
}

func (s *Grant_privilegesContext) GetParser() antlr.Parser { return s.parser }

func (s *Grant_privilegesContext) Priv_type_list() IPriv_type_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPriv_type_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPriv_type_listContext)
}

func (s *Grant_privilegesContext) ALL() antlr.TerminalNode {
	return s.GetToken(OBParserALL, 0)
}

func (s *Grant_privilegesContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(OBParserPRIVILEGES, 0)
}

func (s *Grant_privilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grant_privilegesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Grant_privilegesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterGrant_privileges(s)
	}
}

func (s *Grant_privilegesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitGrant_privileges(s)
	}
}

func (s *Grant_privilegesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitGrant_privileges(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Grant_privileges() (localctx IGrant_privilegesContext) {
	localctx = NewGrant_privilegesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, OBParserRULE_grant_privileges)
	var _la int

	p.SetState(6715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserALTER, OBParserCREATE, OBParserDELETE, OBParserDROP, OBParserGRANT, OBParserINDEX, OBParserINSERT, OBParserSELECT, OBParserSHOW, OBParserUPDATE, OBParserUSAGE, OBParserPROCESS, OBParserSUPER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6710)
			p.Priv_type_list()
		}

	case OBParserALL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6711)
			p.Match(OBParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6713)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPRIVILEGES {
			{
				p.SetState(6712)
				p.Match(OBParserPRIVILEGES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPriv_type_listContext is an interface to support dynamic dispatch.
type IPriv_type_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPriv_type() []IPriv_typeContext
	Priv_type(i int) IPriv_typeContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsPriv_type_listContext differentiates from other interfaces.
	IsPriv_type_listContext()
}

type Priv_type_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPriv_type_listContext() *Priv_type_listContext {
	var p = new(Priv_type_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_priv_type_list
	return p
}

func InitEmptyPriv_type_listContext(p *Priv_type_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_priv_type_list
}

func (*Priv_type_listContext) IsPriv_type_listContext() {}

func NewPriv_type_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Priv_type_listContext {
	var p = new(Priv_type_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_priv_type_list

	return p
}

func (s *Priv_type_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Priv_type_listContext) AllPriv_type() []IPriv_typeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPriv_typeContext); ok {
			len++
		}
	}

	tst := make([]IPriv_typeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPriv_typeContext); ok {
			tst[i] = t.(IPriv_typeContext)
			i++
		}
	}

	return tst
}

func (s *Priv_type_listContext) Priv_type(i int) IPriv_typeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPriv_typeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPriv_typeContext)
}

func (s *Priv_type_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Priv_type_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Priv_type_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Priv_type_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Priv_type_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterPriv_type_list(s)
	}
}

func (s *Priv_type_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitPriv_type_list(s)
	}
}

func (s *Priv_type_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitPriv_type_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Priv_type_list() (localctx IPriv_type_listContext) {
	localctx = NewPriv_type_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, OBParserRULE_priv_type_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6717)
		p.Priv_type()
	}
	p.SetState(6722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(6718)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6719)
			p.Priv_type()
		}

		p.SetState(6724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPriv_typeContext is an interface to support dynamic dispatch.
type IPriv_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	USER() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	USAGE() antlr.TerminalNode
	SYNONYM() antlr.TerminalNode

	// IsPriv_typeContext differentiates from other interfaces.
	IsPriv_typeContext()
}

type Priv_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPriv_typeContext() *Priv_typeContext {
	var p = new(Priv_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_priv_type
	return p
}

func InitEmptyPriv_typeContext(p *Priv_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_priv_type
}

func (*Priv_typeContext) IsPriv_typeContext() {}

func NewPriv_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Priv_typeContext {
	var p = new(Priv_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_priv_type

	return p
}

func (s *Priv_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Priv_typeContext) ALTER() antlr.TerminalNode {
	return s.GetToken(OBParserALTER, 0)
}

func (s *Priv_typeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE, 0)
}

func (s *Priv_typeContext) USER() antlr.TerminalNode {
	return s.GetToken(OBParserUSER, 0)
}

func (s *Priv_typeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(OBParserDELETE, 0)
}

func (s *Priv_typeContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Priv_typeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(OBParserGRANT, 0)
}

func (s *Priv_typeContext) OPTION() antlr.TerminalNode {
	return s.GetToken(OBParserOPTION, 0)
}

func (s *Priv_typeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(OBParserINSERT, 0)
}

func (s *Priv_typeContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(OBParserUPDATE, 0)
}

func (s *Priv_typeContext) SELECT() antlr.TerminalNode {
	return s.GetToken(OBParserSELECT, 0)
}

func (s *Priv_typeContext) INDEX() antlr.TerminalNode {
	return s.GetToken(OBParserINDEX, 0)
}

func (s *Priv_typeContext) VIEW() antlr.TerminalNode {
	return s.GetToken(OBParserVIEW, 0)
}

func (s *Priv_typeContext) SHOW() antlr.TerminalNode {
	return s.GetToken(OBParserSHOW, 0)
}

func (s *Priv_typeContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(OBParserDATABASES, 0)
}

func (s *Priv_typeContext) SUPER() antlr.TerminalNode {
	return s.GetToken(OBParserSUPER, 0)
}

func (s *Priv_typeContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(OBParserPROCESS, 0)
}

func (s *Priv_typeContext) USAGE() antlr.TerminalNode {
	return s.GetToken(OBParserUSAGE, 0)
}

func (s *Priv_typeContext) SYNONYM() antlr.TerminalNode {
	return s.GetToken(OBParserSYNONYM, 0)
}

func (s *Priv_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Priv_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Priv_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterPriv_type(s)
	}
}

func (s *Priv_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitPriv_type(s)
	}
}

func (s *Priv_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitPriv_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Priv_type() (localctx IPriv_typeContext) {
	localctx = NewPriv_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, OBParserRULE_priv_type)
	p.SetState(6748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 685, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6725)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6726)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6727)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6728)
			p.Match(OBParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6729)
			p.Match(OBParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6730)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6731)
			p.Match(OBParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6732)
			p.Match(OBParserOPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6733)
			p.Match(OBParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6734)
			p.Match(OBParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6735)
			p.Match(OBParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6736)
			p.Match(OBParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6737)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6738)
			p.Match(OBParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6739)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6740)
			p.Match(OBParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6741)
			p.Match(OBParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6742)
			p.Match(OBParserDATABASES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6743)
			p.Match(OBParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(6744)
			p.Match(OBParserPROCESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(6745)
			p.Match(OBParserUSAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(6746)
			p.Match(OBParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6747)
			p.Match(OBParserSYNONYM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPriv_levelContext is an interface to support dynamic dispatch.
type IPriv_levelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStar() []antlr.TerminalNode
	Star(i int) antlr.TerminalNode
	Dot() antlr.TerminalNode
	AllRelation_name() []IRelation_nameContext
	Relation_name(i int) IRelation_nameContext

	// IsPriv_levelContext differentiates from other interfaces.
	IsPriv_levelContext()
}

type Priv_levelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPriv_levelContext() *Priv_levelContext {
	var p = new(Priv_levelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_priv_level
	return p
}

func InitEmptyPriv_levelContext(p *Priv_levelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_priv_level
}

func (*Priv_levelContext) IsPriv_levelContext() {}

func NewPriv_levelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Priv_levelContext {
	var p = new(Priv_levelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_priv_level

	return p
}

func (s *Priv_levelContext) GetParser() antlr.Parser { return s.parser }

func (s *Priv_levelContext) AllStar() []antlr.TerminalNode {
	return s.GetTokens(OBParserStar)
}

func (s *Priv_levelContext) Star(i int) antlr.TerminalNode {
	return s.GetToken(OBParserStar, i)
}

func (s *Priv_levelContext) Dot() antlr.TerminalNode {
	return s.GetToken(OBParserDot, 0)
}

func (s *Priv_levelContext) AllRelation_name() []IRelation_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_nameContext); ok {
			len++
		}
	}

	tst := make([]IRelation_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_nameContext); ok {
			tst[i] = t.(IRelation_nameContext)
			i++
		}
	}

	return tst
}

func (s *Priv_levelContext) Relation_name(i int) IRelation_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Priv_levelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Priv_levelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Priv_levelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterPriv_level(s)
	}
}

func (s *Priv_levelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitPriv_level(s)
	}
}

func (s *Priv_levelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitPriv_level(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Priv_level() (localctx IPriv_levelContext) {
	localctx = NewPriv_levelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, OBParserRULE_priv_level)
	p.SetState(6763)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 686, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6750)
			p.Match(OBParserStar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6751)
			p.Match(OBParserStar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6752)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6753)
			p.Match(OBParserStar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6754)
			p.Relation_name()
		}
		{
			p.SetState(6755)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6756)
			p.Match(OBParserStar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6758)
			p.Relation_name()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6759)
			p.Relation_name()
		}
		{
			p.SetState(6760)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6761)
			p.Relation_name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrant_optionsContext is an interface to support dynamic dispatch.
type IGrant_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	Empty() IEmptyContext

	// IsGrant_optionsContext differentiates from other interfaces.
	IsGrant_optionsContext()
}

type Grant_optionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrant_optionsContext() *Grant_optionsContext {
	var p = new(Grant_optionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_grant_options
	return p
}

func InitEmptyGrant_optionsContext(p *Grant_optionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_grant_options
}

func (*Grant_optionsContext) IsGrant_optionsContext() {}

func NewGrant_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grant_optionsContext {
	var p = new(Grant_optionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_grant_options

	return p
}

func (s *Grant_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Grant_optionsContext) WITH() antlr.TerminalNode {
	return s.GetToken(OBParserWITH, 0)
}

func (s *Grant_optionsContext) GRANT() antlr.TerminalNode {
	return s.GetToken(OBParserGRANT, 0)
}

func (s *Grant_optionsContext) OPTION() antlr.TerminalNode {
	return s.GetToken(OBParserOPTION, 0)
}

func (s *Grant_optionsContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Grant_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grant_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Grant_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterGrant_options(s)
	}
}

func (s *Grant_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitGrant_options(s)
	}
}

func (s *Grant_optionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitGrant_options(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Grant_options() (localctx IGrant_optionsContext) {
	localctx = NewGrant_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, OBParserRULE_grant_options)
	p.SetState(6769)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserWITH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6765)
			p.Match(OBParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6766)
			p.Match(OBParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6767)
			p.Match(OBParserOPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserEOF, OBParserDELIMITER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6768)
			p.Empty()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevoke_stmtContext is an interface to support dynamic dispatch.
type IRevoke_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REVOKE() antlr.TerminalNode
	Grant_privileges() IGrant_privilegesContext
	ON() antlr.TerminalNode
	Priv_level() IPriv_levelContext
	FROM() antlr.TerminalNode
	User_list() IUser_listContext
	ALL() antlr.TerminalNode
	Comma() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode

	// IsRevoke_stmtContext differentiates from other interfaces.
	IsRevoke_stmtContext()
}

type Revoke_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevoke_stmtContext() *Revoke_stmtContext {
	var p = new(Revoke_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_revoke_stmt
	return p
}

func InitEmptyRevoke_stmtContext(p *Revoke_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_revoke_stmt
}

func (*Revoke_stmtContext) IsRevoke_stmtContext() {}

func NewRevoke_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Revoke_stmtContext {
	var p = new(Revoke_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_revoke_stmt

	return p
}

func (s *Revoke_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Revoke_stmtContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(OBParserREVOKE, 0)
}

func (s *Revoke_stmtContext) Grant_privileges() IGrant_privilegesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrant_privilegesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrant_privilegesContext)
}

func (s *Revoke_stmtContext) ON() antlr.TerminalNode {
	return s.GetToken(OBParserON, 0)
}

func (s *Revoke_stmtContext) Priv_level() IPriv_levelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPriv_levelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPriv_levelContext)
}

func (s *Revoke_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(OBParserFROM, 0)
}

func (s *Revoke_stmtContext) User_list() IUser_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUser_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUser_listContext)
}

func (s *Revoke_stmtContext) ALL() antlr.TerminalNode {
	return s.GetToken(OBParserALL, 0)
}

func (s *Revoke_stmtContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Revoke_stmtContext) GRANT() antlr.TerminalNode {
	return s.GetToken(OBParserGRANT, 0)
}

func (s *Revoke_stmtContext) OPTION() antlr.TerminalNode {
	return s.GetToken(OBParserOPTION, 0)
}

func (s *Revoke_stmtContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(OBParserPRIVILEGES, 0)
}

func (s *Revoke_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Revoke_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Revoke_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRevoke_stmt(s)
	}
}

func (s *Revoke_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRevoke_stmt(s)
	}
}

func (s *Revoke_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRevoke_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Revoke_stmt() (localctx IRevoke_stmtContext) {
	localctx = NewRevoke_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, OBParserRULE_revoke_stmt)
	var _la int

	p.SetState(6788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 689, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6771)
			p.Match(OBParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6772)
			p.Grant_privileges()
		}
		{
			p.SetState(6773)
			p.Match(OBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6774)
			p.Priv_level()
		}
		{
			p.SetState(6775)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6776)
			p.User_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6778)
			p.Match(OBParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6779)
			p.Match(OBParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6781)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserPRIVILEGES {
			{
				p.SetState(6780)
				p.Match(OBParserPRIVILEGES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6783)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6784)
			p.Match(OBParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6785)
			p.Match(OBParserOPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6786)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6787)
			p.User_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrepare_stmtContext is an interface to support dynamic dispatch.
type IPrepare_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PREPARE() antlr.TerminalNode
	Stmt_name() IStmt_nameContext
	FROM() antlr.TerminalNode
	Preparable_stmt() IPreparable_stmtContext

	// IsPrepare_stmtContext differentiates from other interfaces.
	IsPrepare_stmtContext()
}

type Prepare_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrepare_stmtContext() *Prepare_stmtContext {
	var p = new(Prepare_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_prepare_stmt
	return p
}

func InitEmptyPrepare_stmtContext(p *Prepare_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_prepare_stmt
}

func (*Prepare_stmtContext) IsPrepare_stmtContext() {}

func NewPrepare_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Prepare_stmtContext {
	var p = new(Prepare_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_prepare_stmt

	return p
}

func (s *Prepare_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Prepare_stmtContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(OBParserPREPARE, 0)
}

func (s *Prepare_stmtContext) Stmt_name() IStmt_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_nameContext)
}

func (s *Prepare_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(OBParserFROM, 0)
}

func (s *Prepare_stmtContext) Preparable_stmt() IPreparable_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreparable_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreparable_stmtContext)
}

func (s *Prepare_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Prepare_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Prepare_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterPrepare_stmt(s)
	}
}

func (s *Prepare_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitPrepare_stmt(s)
	}
}

func (s *Prepare_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitPrepare_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Prepare_stmt() (localctx IPrepare_stmtContext) {
	localctx = NewPrepare_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, OBParserRULE_prepare_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6790)
		p.Match(OBParserPREPARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6791)
		p.Stmt_name()
	}
	{
		p.SetState(6792)
		p.Match(OBParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6793)
		p.Preparable_stmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmt_nameContext is an interface to support dynamic dispatch.
type IStmt_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_label() IColumn_labelContext

	// IsStmt_nameContext differentiates from other interfaces.
	IsStmt_nameContext()
}

type Stmt_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmt_nameContext() *Stmt_nameContext {
	var p = new(Stmt_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_stmt_name
	return p
}

func InitEmptyStmt_nameContext(p *Stmt_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_stmt_name
}

func (*Stmt_nameContext) IsStmt_nameContext() {}

func NewStmt_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Stmt_nameContext {
	var p = new(Stmt_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_stmt_name

	return p
}

func (s *Stmt_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Stmt_nameContext) Column_label() IColumn_labelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_labelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_labelContext)
}

func (s *Stmt_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Stmt_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterStmt_name(s)
	}
}

func (s *Stmt_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitStmt_name(s)
	}
}

func (s *Stmt_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitStmt_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Stmt_name() (localctx IStmt_nameContext) {
	localctx = NewStmt_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, OBParserRULE_stmt_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6795)
		p.Column_label()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPreparable_stmtContext is an interface to support dynamic dispatch.
type IPreparable_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Text_string() IText_stringContext
	USER_VARIABLE() antlr.TerminalNode

	// IsPreparable_stmtContext differentiates from other interfaces.
	IsPreparable_stmtContext()
}

type Preparable_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreparable_stmtContext() *Preparable_stmtContext {
	var p = new(Preparable_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_preparable_stmt
	return p
}

func InitEmptyPreparable_stmtContext(p *Preparable_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_preparable_stmt
}

func (*Preparable_stmtContext) IsPreparable_stmtContext() {}

func NewPreparable_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Preparable_stmtContext {
	var p = new(Preparable_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_preparable_stmt

	return p
}

func (s *Preparable_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Preparable_stmtContext) Text_string() IText_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IText_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IText_stringContext)
}

func (s *Preparable_stmtContext) USER_VARIABLE() antlr.TerminalNode {
	return s.GetToken(OBParserUSER_VARIABLE, 0)
}

func (s *Preparable_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Preparable_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Preparable_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterPreparable_stmt(s)
	}
}

func (s *Preparable_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitPreparable_stmt(s)
	}
}

func (s *Preparable_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitPreparable_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Preparable_stmt() (localctx IPreparable_stmtContext) {
	localctx = NewPreparable_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, OBParserRULE_preparable_stmt)
	p.SetState(6799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserHEX_STRING_VALUE, OBParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6797)
			p.Text_string()
		}

	case OBParserUSER_VARIABLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6798)
			p.Match(OBParserUSER_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariable_set_stmtContext is an interface to support dynamic dispatch.
type IVariable_set_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	Var_and_val_list() IVar_and_val_listContext

	// IsVariable_set_stmtContext differentiates from other interfaces.
	IsVariable_set_stmtContext()
}

type Variable_set_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_set_stmtContext() *Variable_set_stmtContext {
	var p = new(Variable_set_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_variable_set_stmt
	return p
}

func InitEmptyVariable_set_stmtContext(p *Variable_set_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_variable_set_stmt
}

func (*Variable_set_stmtContext) IsVariable_set_stmtContext() {}

func NewVariable_set_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_set_stmtContext {
	var p = new(Variable_set_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_variable_set_stmt

	return p
}

func (s *Variable_set_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_set_stmtContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Variable_set_stmtContext) Var_and_val_list() IVar_and_val_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVar_and_val_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVar_and_val_listContext)
}

func (s *Variable_set_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_set_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_set_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterVariable_set_stmt(s)
	}
}

func (s *Variable_set_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitVariable_set_stmt(s)
	}
}

func (s *Variable_set_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitVariable_set_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Variable_set_stmt() (localctx IVariable_set_stmtContext) {
	localctx = NewVariable_set_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, OBParserRULE_variable_set_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6801)
		p.Match(OBParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6802)
		p.Var_and_val_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISys_var_and_val_listContext is an interface to support dynamic dispatch.
type ISys_var_and_val_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSys_var_and_val() []ISys_var_and_valContext
	Sys_var_and_val(i int) ISys_var_and_valContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsSys_var_and_val_listContext differentiates from other interfaces.
	IsSys_var_and_val_listContext()
}

type Sys_var_and_val_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySys_var_and_val_listContext() *Sys_var_and_val_listContext {
	var p = new(Sys_var_and_val_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sys_var_and_val_list
	return p
}

func InitEmptySys_var_and_val_listContext(p *Sys_var_and_val_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sys_var_and_val_list
}

func (*Sys_var_and_val_listContext) IsSys_var_and_val_listContext() {}

func NewSys_var_and_val_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sys_var_and_val_listContext {
	var p = new(Sys_var_and_val_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_sys_var_and_val_list

	return p
}

func (s *Sys_var_and_val_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Sys_var_and_val_listContext) AllSys_var_and_val() []ISys_var_and_valContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISys_var_and_valContext); ok {
			len++
		}
	}

	tst := make([]ISys_var_and_valContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISys_var_and_valContext); ok {
			tst[i] = t.(ISys_var_and_valContext)
			i++
		}
	}

	return tst
}

func (s *Sys_var_and_val_listContext) Sys_var_and_val(i int) ISys_var_and_valContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISys_var_and_valContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISys_var_and_valContext)
}

func (s *Sys_var_and_val_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Sys_var_and_val_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Sys_var_and_val_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sys_var_and_val_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sys_var_and_val_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSys_var_and_val_list(s)
	}
}

func (s *Sys_var_and_val_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSys_var_and_val_list(s)
	}
}

func (s *Sys_var_and_val_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSys_var_and_val_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Sys_var_and_val_list() (localctx ISys_var_and_val_listContext) {
	localctx = NewSys_var_and_val_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, OBParserRULE_sys_var_and_val_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6804)
		p.Sys_var_and_val()
	}
	p.SetState(6809)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(6805)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6806)
			p.Sys_var_and_val()
		}

		p.SetState(6811)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVar_and_val_listContext is an interface to support dynamic dispatch.
type IVar_and_val_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVar_and_val() []IVar_and_valContext
	Var_and_val(i int) IVar_and_valContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsVar_and_val_listContext differentiates from other interfaces.
	IsVar_and_val_listContext()
}

type Var_and_val_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_and_val_listContext() *Var_and_val_listContext {
	var p = new(Var_and_val_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_var_and_val_list
	return p
}

func InitEmptyVar_and_val_listContext(p *Var_and_val_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_var_and_val_list
}

func (*Var_and_val_listContext) IsVar_and_val_listContext() {}

func NewVar_and_val_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_and_val_listContext {
	var p = new(Var_and_val_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_var_and_val_list

	return p
}

func (s *Var_and_val_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Var_and_val_listContext) AllVar_and_val() []IVar_and_valContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVar_and_valContext); ok {
			len++
		}
	}

	tst := make([]IVar_and_valContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVar_and_valContext); ok {
			tst[i] = t.(IVar_and_valContext)
			i++
		}
	}

	return tst
}

func (s *Var_and_val_listContext) Var_and_val(i int) IVar_and_valContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVar_and_valContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVar_and_valContext)
}

func (s *Var_and_val_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Var_and_val_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Var_and_val_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_and_val_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_and_val_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterVar_and_val_list(s)
	}
}

func (s *Var_and_val_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitVar_and_val_list(s)
	}
}

func (s *Var_and_val_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitVar_and_val_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Var_and_val_list() (localctx IVar_and_val_listContext) {
	localctx = NewVar_and_val_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, OBParserRULE_var_and_val_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6812)
		p.Var_and_val()
	}
	p.SetState(6817)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(6813)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6814)
			p.Var_and_val()
		}

		p.SetState(6819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_expr_or_defaultContext is an interface to support dynamic dispatch.
type ISet_expr_or_defaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	ON() antlr.TerminalNode
	OFF() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsSet_expr_or_defaultContext differentiates from other interfaces.
	IsSet_expr_or_defaultContext()
}

type Set_expr_or_defaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_expr_or_defaultContext() *Set_expr_or_defaultContext {
	var p = new(Set_expr_or_defaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_expr_or_default
	return p
}

func InitEmptySet_expr_or_defaultContext(p *Set_expr_or_defaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_expr_or_default
}

func (*Set_expr_or_defaultContext) IsSet_expr_or_defaultContext() {}

func NewSet_expr_or_defaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_expr_or_defaultContext {
	var p = new(Set_expr_or_defaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_set_expr_or_default

	return p
}

func (s *Set_expr_or_defaultContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_expr_or_defaultContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Set_expr_or_defaultContext) ON() antlr.TerminalNode {
	return s.GetToken(OBParserON, 0)
}

func (s *Set_expr_or_defaultContext) OFF() antlr.TerminalNode {
	return s.GetToken(OBParserOFF, 0)
}

func (s *Set_expr_or_defaultContext) BINARY() antlr.TerminalNode {
	return s.GetToken(OBParserBINARY, 0)
}

func (s *Set_expr_or_defaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT, 0)
}

func (s *Set_expr_or_defaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_expr_or_defaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_expr_or_defaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSet_expr_or_default(s)
	}
}

func (s *Set_expr_or_defaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSet_expr_or_default(s)
	}
}

func (s *Set_expr_or_defaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSet_expr_or_default(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Set_expr_or_default() (localctx ISet_expr_or_defaultContext) {
	localctx = NewSet_expr_or_defaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, OBParserRULE_set_expr_or_default)
	p.SetState(6825)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 693, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6820)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6821)
			p.Match(OBParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6822)
			p.Match(OBParserOFF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6823)
			p.Match(OBParserBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6824)
			p.Match(OBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVar_and_valContext is an interface to support dynamic dispatch.
type IVar_and_valContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USER_VARIABLE() antlr.TerminalNode
	To_or_eq() ITo_or_eqContext
	Expr() IExprContext
	SET_VAR() antlr.TerminalNode
	Sys_var_and_val() ISys_var_and_valContext
	Scope_or_scope_alias() IScope_or_scope_aliasContext
	Column_name() IColumn_nameContext
	Set_expr_or_default() ISet_expr_or_defaultContext
	SYSTEM_VARIABLE() antlr.TerminalNode

	// IsVar_and_valContext differentiates from other interfaces.
	IsVar_and_valContext()
}

type Var_and_valContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_and_valContext() *Var_and_valContext {
	var p = new(Var_and_valContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_var_and_val
	return p
}

func InitEmptyVar_and_valContext(p *Var_and_valContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_var_and_val
}

func (*Var_and_valContext) IsVar_and_valContext() {}

func NewVar_and_valContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_and_valContext {
	var p = new(Var_and_valContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_var_and_val

	return p
}

func (s *Var_and_valContext) GetParser() antlr.Parser { return s.parser }

func (s *Var_and_valContext) USER_VARIABLE() antlr.TerminalNode {
	return s.GetToken(OBParserUSER_VARIABLE, 0)
}

func (s *Var_and_valContext) To_or_eq() ITo_or_eqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITo_or_eqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITo_or_eqContext)
}

func (s *Var_and_valContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Var_and_valContext) SET_VAR() antlr.TerminalNode {
	return s.GetToken(OBParserSET_VAR, 0)
}

func (s *Var_and_valContext) Sys_var_and_val() ISys_var_and_valContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISys_var_and_valContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISys_var_and_valContext)
}

func (s *Var_and_valContext) Scope_or_scope_alias() IScope_or_scope_aliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScope_or_scope_aliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScope_or_scope_aliasContext)
}

func (s *Var_and_valContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Var_and_valContext) Set_expr_or_default() ISet_expr_or_defaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_expr_or_defaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_expr_or_defaultContext)
}

func (s *Var_and_valContext) SYSTEM_VARIABLE() antlr.TerminalNode {
	return s.GetToken(OBParserSYSTEM_VARIABLE, 0)
}

func (s *Var_and_valContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_and_valContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_and_valContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterVar_and_val(s)
	}
}

func (s *Var_and_valContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitVar_and_val(s)
	}
}

func (s *Var_and_valContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitVar_and_val(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Var_and_val() (localctx IVar_and_valContext) {
	localctx = NewVar_and_valContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, OBParserRULE_var_and_val)
	p.SetState(6844)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 694, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6827)
			p.Match(OBParserUSER_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6828)
			p.To_or_eq()
		}
		{
			p.SetState(6829)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6831)
			p.Match(OBParserUSER_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6832)
			p.Match(OBParserSET_VAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6833)
			p.expr(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6834)
			p.Sys_var_and_val()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6835)
			p.Scope_or_scope_alias()
		}
		{
			p.SetState(6836)
			p.Column_name()
		}
		{
			p.SetState(6837)
			p.To_or_eq()
		}
		{
			p.SetState(6838)
			p.Set_expr_or_default()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6840)
			p.Match(OBParserSYSTEM_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6841)
			p.To_or_eq()
		}
		{
			p.SetState(6842)
			p.Set_expr_or_default()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISys_var_and_valContext is an interface to support dynamic dispatch.
type ISys_var_and_valContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Var_name() IVar_nameContext
	To_or_eq() ITo_or_eqContext
	Set_expr_or_default() ISet_expr_or_defaultContext
	SET_VAR() antlr.TerminalNode

	// IsSys_var_and_valContext differentiates from other interfaces.
	IsSys_var_and_valContext()
}

type Sys_var_and_valContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySys_var_and_valContext() *Sys_var_and_valContext {
	var p = new(Sys_var_and_valContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sys_var_and_val
	return p
}

func InitEmptySys_var_and_valContext(p *Sys_var_and_valContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sys_var_and_val
}

func (*Sys_var_and_valContext) IsSys_var_and_valContext() {}

func NewSys_var_and_valContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sys_var_and_valContext {
	var p = new(Sys_var_and_valContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_sys_var_and_val

	return p
}

func (s *Sys_var_and_valContext) GetParser() antlr.Parser { return s.parser }

func (s *Sys_var_and_valContext) Var_name() IVar_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVar_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVar_nameContext)
}

func (s *Sys_var_and_valContext) To_or_eq() ITo_or_eqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITo_or_eqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITo_or_eqContext)
}

func (s *Sys_var_and_valContext) Set_expr_or_default() ISet_expr_or_defaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_expr_or_defaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_expr_or_defaultContext)
}

func (s *Sys_var_and_valContext) SET_VAR() antlr.TerminalNode {
	return s.GetToken(OBParserSET_VAR, 0)
}

func (s *Sys_var_and_valContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sys_var_and_valContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sys_var_and_valContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSys_var_and_val(s)
	}
}

func (s *Sys_var_and_valContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSys_var_and_val(s)
	}
}

func (s *Sys_var_and_valContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSys_var_and_val(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Sys_var_and_val() (localctx ISys_var_and_valContext) {
	localctx = NewSys_var_and_valContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, OBParserRULE_sys_var_and_val)
	p.SetState(6854)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 695, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6846)
			p.Var_name()
		}
		{
			p.SetState(6847)
			p.To_or_eq()
		}
		{
			p.SetState(6848)
			p.Set_expr_or_default()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6850)
			p.Var_name()
		}
		{
			p.SetState(6851)
			p.Match(OBParserSET_VAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6852)
			p.Set_expr_or_default()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScope_or_scope_aliasContext is an interface to support dynamic dispatch.
type IScope_or_scope_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	GLOBAL_ALIAS() antlr.TerminalNode
	Dot() antlr.TerminalNode
	SESSION_ALIAS() antlr.TerminalNode

	// IsScope_or_scope_aliasContext differentiates from other interfaces.
	IsScope_or_scope_aliasContext()
}

type Scope_or_scope_aliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScope_or_scope_aliasContext() *Scope_or_scope_aliasContext {
	var p = new(Scope_or_scope_aliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_scope_or_scope_alias
	return p
}

func InitEmptyScope_or_scope_aliasContext(p *Scope_or_scope_aliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_scope_or_scope_alias
}

func (*Scope_or_scope_aliasContext) IsScope_or_scope_aliasContext() {}

func NewScope_or_scope_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Scope_or_scope_aliasContext {
	var p = new(Scope_or_scope_aliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_scope_or_scope_alias

	return p
}

func (s *Scope_or_scope_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Scope_or_scope_aliasContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(OBParserGLOBAL, 0)
}

func (s *Scope_or_scope_aliasContext) SESSION() antlr.TerminalNode {
	return s.GetToken(OBParserSESSION, 0)
}

func (s *Scope_or_scope_aliasContext) GLOBAL_ALIAS() antlr.TerminalNode {
	return s.GetToken(OBParserGLOBAL_ALIAS, 0)
}

func (s *Scope_or_scope_aliasContext) Dot() antlr.TerminalNode {
	return s.GetToken(OBParserDot, 0)
}

func (s *Scope_or_scope_aliasContext) SESSION_ALIAS() antlr.TerminalNode {
	return s.GetToken(OBParserSESSION_ALIAS, 0)
}

func (s *Scope_or_scope_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Scope_or_scope_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Scope_or_scope_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterScope_or_scope_alias(s)
	}
}

func (s *Scope_or_scope_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitScope_or_scope_alias(s)
	}
}

func (s *Scope_or_scope_aliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitScope_or_scope_alias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Scope_or_scope_alias() (localctx IScope_or_scope_aliasContext) {
	localctx = NewScope_or_scope_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, OBParserRULE_scope_or_scope_alias)
	p.SetState(6862)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserGLOBAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6856)
			p.Match(OBParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserSESSION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6857)
			p.Match(OBParserSESSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserGLOBAL_ALIAS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6858)
			p.Match(OBParserGLOBAL_ALIAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6859)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserSESSION_ALIAS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6860)
			p.Match(OBParserSESSION_ALIAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6861)
			p.Match(OBParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITo_or_eqContext is an interface to support dynamic dispatch.
type ITo_or_eqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TO() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode

	// IsTo_or_eqContext differentiates from other interfaces.
	IsTo_or_eqContext()
}

type To_or_eqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTo_or_eqContext() *To_or_eqContext {
	var p = new(To_or_eqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_to_or_eq
	return p
}

func InitEmptyTo_or_eqContext(p *To_or_eqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_to_or_eq
}

func (*To_or_eqContext) IsTo_or_eqContext() {}

func NewTo_or_eqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *To_or_eqContext {
	var p = new(To_or_eqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_to_or_eq

	return p
}

func (s *To_or_eqContext) GetParser() antlr.Parser { return s.parser }

func (s *To_or_eqContext) TO() antlr.TerminalNode {
	return s.GetToken(OBParserTO, 0)
}

func (s *To_or_eqContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *To_or_eqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *To_or_eqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *To_or_eqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTo_or_eq(s)
	}
}

func (s *To_or_eqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTo_or_eq(s)
	}
}

func (s *To_or_eqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTo_or_eq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) To_or_eq() (localctx ITo_or_eqContext) {
	localctx = NewTo_or_eqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 764, OBParserRULE_to_or_eq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6864)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserTO || _la == OBParserCOMP_EQ) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecute_stmtContext is an interface to support dynamic dispatch.
type IExecute_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	Stmt_name() IStmt_nameContext
	USING() antlr.TerminalNode
	Argument_list() IArgument_listContext

	// IsExecute_stmtContext differentiates from other interfaces.
	IsExecute_stmtContext()
}

type Execute_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecute_stmtContext() *Execute_stmtContext {
	var p = new(Execute_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_execute_stmt
	return p
}

func InitEmptyExecute_stmtContext(p *Execute_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_execute_stmt
}

func (*Execute_stmtContext) IsExecute_stmtContext() {}

func NewExecute_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Execute_stmtContext {
	var p = new(Execute_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_execute_stmt

	return p
}

func (s *Execute_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Execute_stmtContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(OBParserEXECUTE, 0)
}

func (s *Execute_stmtContext) Stmt_name() IStmt_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_nameContext)
}

func (s *Execute_stmtContext) USING() antlr.TerminalNode {
	return s.GetToken(OBParserUSING, 0)
}

func (s *Execute_stmtContext) Argument_list() IArgument_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgument_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgument_listContext)
}

func (s *Execute_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Execute_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Execute_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterExecute_stmt(s)
	}
}

func (s *Execute_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitExecute_stmt(s)
	}
}

func (s *Execute_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitExecute_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Execute_stmt() (localctx IExecute_stmtContext) {
	localctx = NewExecute_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, OBParserRULE_execute_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6866)
		p.Match(OBParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6867)
		p.Stmt_name()
	}
	p.SetState(6870)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserUSING {
		{
			p.SetState(6868)
			p.Match(OBParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6869)
			p.Argument_list()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgument_listContext is an interface to support dynamic dispatch.
type IArgument_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllArgument() []IArgumentContext
	Argument(i int) IArgumentContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsArgument_listContext differentiates from other interfaces.
	IsArgument_listContext()
}

type Argument_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgument_listContext() *Argument_listContext {
	var p = new(Argument_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_argument_list
	return p
}

func InitEmptyArgument_listContext(p *Argument_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_argument_list
}

func (*Argument_listContext) IsArgument_listContext() {}

func NewArgument_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Argument_listContext {
	var p = new(Argument_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_argument_list

	return p
}

func (s *Argument_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Argument_listContext) AllArgument() []IArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentContext); ok {
			len++
		}
	}

	tst := make([]IArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentContext); ok {
			tst[i] = t.(IArgumentContext)
			i++
		}
	}

	return tst
}

func (s *Argument_listContext) Argument(i int) IArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *Argument_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Argument_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Argument_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Argument_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Argument_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterArgument_list(s)
	}
}

func (s *Argument_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitArgument_list(s)
	}
}

func (s *Argument_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitArgument_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Argument_list() (localctx IArgument_listContext) {
	localctx = NewArgument_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, OBParserRULE_argument_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6872)
		p.Argument()
	}
	p.SetState(6877)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(6873)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6874)
			p.Argument()
		}

		p.SetState(6879)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USER_VARIABLE() antlr.TerminalNode

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_argument
	return p
}

func InitEmptyArgumentContext(p *ArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_argument
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) USER_VARIABLE() antlr.TerminalNode {
	return s.GetToken(OBParserUSER_VARIABLE, 0)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitArgument(s)
	}
}

func (s *ArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, OBParserRULE_argument)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6880)
		p.Match(OBParserUSER_VARIABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeallocate_prepare_stmtContext is an interface to support dynamic dispatch.
type IDeallocate_prepare_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Deallocate_or_drop() IDeallocate_or_dropContext
	PREPARE() antlr.TerminalNode
	Stmt_name() IStmt_nameContext

	// IsDeallocate_prepare_stmtContext differentiates from other interfaces.
	IsDeallocate_prepare_stmtContext()
}

type Deallocate_prepare_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeallocate_prepare_stmtContext() *Deallocate_prepare_stmtContext {
	var p = new(Deallocate_prepare_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_deallocate_prepare_stmt
	return p
}

func InitEmptyDeallocate_prepare_stmtContext(p *Deallocate_prepare_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_deallocate_prepare_stmt
}

func (*Deallocate_prepare_stmtContext) IsDeallocate_prepare_stmtContext() {}

func NewDeallocate_prepare_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Deallocate_prepare_stmtContext {
	var p = new(Deallocate_prepare_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_deallocate_prepare_stmt

	return p
}

func (s *Deallocate_prepare_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Deallocate_prepare_stmtContext) Deallocate_or_drop() IDeallocate_or_dropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeallocate_or_dropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeallocate_or_dropContext)
}

func (s *Deallocate_prepare_stmtContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(OBParserPREPARE, 0)
}

func (s *Deallocate_prepare_stmtContext) Stmt_name() IStmt_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_nameContext)
}

func (s *Deallocate_prepare_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Deallocate_prepare_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Deallocate_prepare_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDeallocate_prepare_stmt(s)
	}
}

func (s *Deallocate_prepare_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDeallocate_prepare_stmt(s)
	}
}

func (s *Deallocate_prepare_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDeallocate_prepare_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Deallocate_prepare_stmt() (localctx IDeallocate_prepare_stmtContext) {
	localctx = NewDeallocate_prepare_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, OBParserRULE_deallocate_prepare_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6882)
		p.Deallocate_or_drop()
	}
	{
		p.SetState(6883)
		p.Match(OBParserPREPARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6884)
		p.Stmt_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeallocate_or_dropContext is an interface to support dynamic dispatch.
type IDeallocate_or_dropContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEALLOCATE() antlr.TerminalNode
	DROP() antlr.TerminalNode

	// IsDeallocate_or_dropContext differentiates from other interfaces.
	IsDeallocate_or_dropContext()
}

type Deallocate_or_dropContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeallocate_or_dropContext() *Deallocate_or_dropContext {
	var p = new(Deallocate_or_dropContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_deallocate_or_drop
	return p
}

func InitEmptyDeallocate_or_dropContext(p *Deallocate_or_dropContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_deallocate_or_drop
}

func (*Deallocate_or_dropContext) IsDeallocate_or_dropContext() {}

func NewDeallocate_or_dropContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Deallocate_or_dropContext {
	var p = new(Deallocate_or_dropContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_deallocate_or_drop

	return p
}

func (s *Deallocate_or_dropContext) GetParser() antlr.Parser { return s.parser }

func (s *Deallocate_or_dropContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(OBParserDEALLOCATE, 0)
}

func (s *Deallocate_or_dropContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Deallocate_or_dropContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Deallocate_or_dropContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Deallocate_or_dropContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDeallocate_or_drop(s)
	}
}

func (s *Deallocate_or_dropContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDeallocate_or_drop(s)
	}
}

func (s *Deallocate_or_dropContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDeallocate_or_drop(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Deallocate_or_drop() (localctx IDeallocate_or_dropContext) {
	localctx = NewDeallocate_or_dropContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, OBParserRULE_deallocate_or_drop)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6886)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserDROP || _la == OBParserDEALLOCATE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncate_table_stmtContext is an interface to support dynamic dispatch.
type ITruncate_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	Relation_factor() IRelation_factorContext
	TABLE() antlr.TerminalNode

	// IsTruncate_table_stmtContext differentiates from other interfaces.
	IsTruncate_table_stmtContext()
}

type Truncate_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncate_table_stmtContext() *Truncate_table_stmtContext {
	var p = new(Truncate_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_truncate_table_stmt
	return p
}

func InitEmptyTruncate_table_stmtContext(p *Truncate_table_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_truncate_table_stmt
}

func (*Truncate_table_stmtContext) IsTruncate_table_stmtContext() {}

func NewTruncate_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Truncate_table_stmtContext {
	var p = new(Truncate_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_truncate_table_stmt

	return p
}

func (s *Truncate_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Truncate_table_stmtContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(OBParserTRUNCATE, 0)
}

func (s *Truncate_table_stmtContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Truncate_table_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE, 0)
}

func (s *Truncate_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Truncate_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Truncate_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTruncate_table_stmt(s)
	}
}

func (s *Truncate_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTruncate_table_stmt(s)
	}
}

func (s *Truncate_table_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTruncate_table_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Truncate_table_stmt() (localctx ITruncate_table_stmtContext) {
	localctx = NewTruncate_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, OBParserRULE_truncate_table_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6888)
		p.Match(OBParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6890)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserTABLE {
		{
			p.SetState(6889)
			p.Match(OBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(6892)
		p.Relation_factor()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRename_table_stmtContext is an interface to support dynamic dispatch.
type IRename_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Rename_table_actions() IRename_table_actionsContext

	// IsRename_table_stmtContext differentiates from other interfaces.
	IsRename_table_stmtContext()
}

type Rename_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRename_table_stmtContext() *Rename_table_stmtContext {
	var p = new(Rename_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rename_table_stmt
	return p
}

func InitEmptyRename_table_stmtContext(p *Rename_table_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rename_table_stmt
}

func (*Rename_table_stmtContext) IsRename_table_stmtContext() {}

func NewRename_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rename_table_stmtContext {
	var p = new(Rename_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_rename_table_stmt

	return p
}

func (s *Rename_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Rename_table_stmtContext) RENAME() antlr.TerminalNode {
	return s.GetToken(OBParserRENAME, 0)
}

func (s *Rename_table_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE, 0)
}

func (s *Rename_table_stmtContext) Rename_table_actions() IRename_table_actionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRename_table_actionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRename_table_actionsContext)
}

func (s *Rename_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rename_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rename_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRename_table_stmt(s)
	}
}

func (s *Rename_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRename_table_stmt(s)
	}
}

func (s *Rename_table_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRename_table_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Rename_table_stmt() (localctx IRename_table_stmtContext) {
	localctx = NewRename_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, OBParserRULE_rename_table_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6894)
		p.Match(OBParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6895)
		p.Match(OBParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6896)
		p.Rename_table_actions()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRename_table_actionsContext is an interface to support dynamic dispatch.
type IRename_table_actionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRename_table_action() []IRename_table_actionContext
	Rename_table_action(i int) IRename_table_actionContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsRename_table_actionsContext differentiates from other interfaces.
	IsRename_table_actionsContext()
}

type Rename_table_actionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRename_table_actionsContext() *Rename_table_actionsContext {
	var p = new(Rename_table_actionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rename_table_actions
	return p
}

func InitEmptyRename_table_actionsContext(p *Rename_table_actionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rename_table_actions
}

func (*Rename_table_actionsContext) IsRename_table_actionsContext() {}

func NewRename_table_actionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rename_table_actionsContext {
	var p = new(Rename_table_actionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_rename_table_actions

	return p
}

func (s *Rename_table_actionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Rename_table_actionsContext) AllRename_table_action() []IRename_table_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRename_table_actionContext); ok {
			len++
		}
	}

	tst := make([]IRename_table_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRename_table_actionContext); ok {
			tst[i] = t.(IRename_table_actionContext)
			i++
		}
	}

	return tst
}

func (s *Rename_table_actionsContext) Rename_table_action(i int) IRename_table_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRename_table_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRename_table_actionContext)
}

func (s *Rename_table_actionsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Rename_table_actionsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Rename_table_actionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rename_table_actionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rename_table_actionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRename_table_actions(s)
	}
}

func (s *Rename_table_actionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRename_table_actions(s)
	}
}

func (s *Rename_table_actionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRename_table_actions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Rename_table_actions() (localctx IRename_table_actionsContext) {
	localctx = NewRename_table_actionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, OBParserRULE_rename_table_actions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6898)
		p.Rename_table_action()
	}
	p.SetState(6903)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(6899)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6900)
			p.Rename_table_action()
		}

		p.SetState(6905)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRename_table_actionContext is an interface to support dynamic dispatch.
type IRename_table_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelation_factor() []IRelation_factorContext
	Relation_factor(i int) IRelation_factorContext
	TO() antlr.TerminalNode

	// IsRename_table_actionContext differentiates from other interfaces.
	IsRename_table_actionContext()
}

type Rename_table_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRename_table_actionContext() *Rename_table_actionContext {
	var p = new(Rename_table_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rename_table_action
	return p
}

func InitEmptyRename_table_actionContext(p *Rename_table_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rename_table_action
}

func (*Rename_table_actionContext) IsRename_table_actionContext() {}

func NewRename_table_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rename_table_actionContext {
	var p = new(Rename_table_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_rename_table_action

	return p
}

func (s *Rename_table_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Rename_table_actionContext) AllRelation_factor() []IRelation_factorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_factorContext); ok {
			len++
		}
	}

	tst := make([]IRelation_factorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_factorContext); ok {
			tst[i] = t.(IRelation_factorContext)
			i++
		}
	}

	return tst
}

func (s *Rename_table_actionContext) Relation_factor(i int) IRelation_factorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Rename_table_actionContext) TO() antlr.TerminalNode {
	return s.GetToken(OBParserTO, 0)
}

func (s *Rename_table_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rename_table_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rename_table_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRename_table_action(s)
	}
}

func (s *Rename_table_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRename_table_action(s)
	}
}

func (s *Rename_table_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRename_table_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Rename_table_action() (localctx IRename_table_actionContext) {
	localctx = NewRename_table_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, OBParserRULE_rename_table_action)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6906)
		p.Relation_factor()
	}
	{
		p.SetState(6907)
		p.Match(OBParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6908)
		p.Relation_factor()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_stmtContext is an interface to support dynamic dispatch.
type IAlter_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Relation_factor() IRelation_factorContext
	Alter_table_actions() IAlter_table_actionsContext

	// IsAlter_table_stmtContext differentiates from other interfaces.
	IsAlter_table_stmtContext()
}

type Alter_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_stmtContext() *Alter_table_stmtContext {
	var p = new(Alter_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_table_stmt
	return p
}

func InitEmptyAlter_table_stmtContext(p *Alter_table_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_table_stmt
}

func (*Alter_table_stmtContext) IsAlter_table_stmtContext() {}

func NewAlter_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_stmtContext {
	var p = new(Alter_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_table_stmt

	return p
}

func (s *Alter_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(OBParserALTER, 0)
}

func (s *Alter_table_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE, 0)
}

func (s *Alter_table_stmtContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Alter_table_stmtContext) Alter_table_actions() IAlter_table_actionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_actionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_actionsContext)
}

func (s *Alter_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_table_stmt(s)
	}
}

func (s *Alter_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_table_stmt(s)
	}
}

func (s *Alter_table_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_table_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_table_stmt() (localctx IAlter_table_stmtContext) {
	localctx = NewAlter_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, OBParserRULE_alter_table_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6910)
		p.Match(OBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6911)
		p.Match(OBParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6912)
		p.Relation_factor()
	}
	{
		p.SetState(6913)
		p.alter_table_actions(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_actionsContext is an interface to support dynamic dispatch.
type IAlter_table_actionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_action() IAlter_table_actionContext
	Empty() IEmptyContext
	Alter_table_actions() IAlter_table_actionsContext
	Comma() antlr.TerminalNode

	// IsAlter_table_actionsContext differentiates from other interfaces.
	IsAlter_table_actionsContext()
}

type Alter_table_actionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_actionsContext() *Alter_table_actionsContext {
	var p = new(Alter_table_actionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_table_actions
	return p
}

func InitEmptyAlter_table_actionsContext(p *Alter_table_actionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_table_actions
}

func (*Alter_table_actionsContext) IsAlter_table_actionsContext() {}

func NewAlter_table_actionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_actionsContext {
	var p = new(Alter_table_actionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_table_actions

	return p
}

func (s *Alter_table_actionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_actionsContext) Alter_table_action() IAlter_table_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_actionContext)
}

func (s *Alter_table_actionsContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Alter_table_actionsContext) Alter_table_actions() IAlter_table_actionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_actionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_actionsContext)
}

func (s *Alter_table_actionsContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Alter_table_actionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_actionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_actionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_table_actions(s)
	}
}

func (s *Alter_table_actionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_table_actions(s)
	}
}

func (s *Alter_table_actionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_table_actions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_table_actions() (localctx IAlter_table_actionsContext) {
	return p.alter_table_actions(0)
}

func (p *OBParser) alter_table_actions(_p int) (localctx IAlter_table_actionsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewAlter_table_actionsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAlter_table_actionsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 786
	p.EnterRecursionRule(localctx, 786, OBParserRULE_alter_table_actions, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6918)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 701, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6916)
			p.Alter_table_action()
		}

	case 2:
		{
			p.SetState(6917)
			p.Empty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6925)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 702, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAlter_table_actionsContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, OBParserRULE_alter_table_actions)
			p.SetState(6920)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(6921)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6922)
				p.Alter_table_action()
			}

		}
		p.SetState(6927)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 702, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_actionContext is an interface to support dynamic dispatch.
type IAlter_table_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_option_list_space_seperated() ITable_option_list_space_seperatedContext
	SET() antlr.TerminalNode
	Alter_column_option() IAlter_column_optionContext
	Alter_tablegroup_option() IAlter_tablegroup_optionContext
	RENAME() antlr.TerminalNode
	Relation_factor() IRelation_factorContext
	TO() antlr.TerminalNode
	Alter_index_option() IAlter_index_optionContext
	Alter_partition_option() IAlter_partition_optionContext
	Alter_constraint_option() IAlter_constraint_optionContext
	Alter_foreign_key_action() IAlter_foreign_key_actionContext

	// IsAlter_table_actionContext differentiates from other interfaces.
	IsAlter_table_actionContext()
}

type Alter_table_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_actionContext() *Alter_table_actionContext {
	var p = new(Alter_table_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_table_action
	return p
}

func InitEmptyAlter_table_actionContext(p *Alter_table_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_table_action
}

func (*Alter_table_actionContext) IsAlter_table_actionContext() {}

func NewAlter_table_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_actionContext {
	var p = new(Alter_table_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_table_action

	return p
}

func (s *Alter_table_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_actionContext) Table_option_list_space_seperated() ITable_option_list_space_seperatedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_option_list_space_seperatedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_option_list_space_seperatedContext)
}

func (s *Alter_table_actionContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Alter_table_actionContext) Alter_column_option() IAlter_column_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_column_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_column_optionContext)
}

func (s *Alter_table_actionContext) Alter_tablegroup_option() IAlter_tablegroup_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_tablegroup_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_tablegroup_optionContext)
}

func (s *Alter_table_actionContext) RENAME() antlr.TerminalNode {
	return s.GetToken(OBParserRENAME, 0)
}

func (s *Alter_table_actionContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Alter_table_actionContext) TO() antlr.TerminalNode {
	return s.GetToken(OBParserTO, 0)
}

func (s *Alter_table_actionContext) Alter_index_option() IAlter_index_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_index_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_index_optionContext)
}

func (s *Alter_table_actionContext) Alter_partition_option() IAlter_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_partition_optionContext)
}

func (s *Alter_table_actionContext) Alter_constraint_option() IAlter_constraint_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_constraint_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_constraint_optionContext)
}

func (s *Alter_table_actionContext) Alter_foreign_key_action() IAlter_foreign_key_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_foreign_key_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_foreign_key_actionContext)
}

func (s *Alter_table_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_table_action(s)
	}
}

func (s *Alter_table_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_table_action(s)
	}
}

func (s *Alter_table_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_table_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_table_action() (localctx IAlter_table_actionContext) {
	localctx = NewAlter_table_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, OBParserRULE_alter_table_action)
	var _la int

	p.SetState(6943)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 705, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6929)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSET {
			{
				p.SetState(6928)
				p.Match(OBParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6931)
			p.Table_option_list_space_seperated()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6932)
			p.Alter_column_option()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6933)
			p.Alter_tablegroup_option()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6934)
			p.Match(OBParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6936)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTO {
			{
				p.SetState(6935)
				p.Match(OBParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6938)
			p.Relation_factor()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6939)
			p.Alter_index_option()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6940)
			p.Alter_partition_option()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6941)
			p.Alter_constraint_option()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6942)
			p.Alter_foreign_key_action()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_constraint_optionContext is an interface to support dynamic dispatch.
type IAlter_constraint_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	CONSTRAINT() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Name_list() IName_listContext
	RightParen() antlr.TerminalNode
	ADD() antlr.TerminalNode
	Constraint_name() IConstraint_nameContext
	CHECK() antlr.TerminalNode
	Expr() IExprContext

	// IsAlter_constraint_optionContext differentiates from other interfaces.
	IsAlter_constraint_optionContext()
}

type Alter_constraint_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_constraint_optionContext() *Alter_constraint_optionContext {
	var p = new(Alter_constraint_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_constraint_option
	return p
}

func InitEmptyAlter_constraint_optionContext(p *Alter_constraint_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_constraint_option
}

func (*Alter_constraint_optionContext) IsAlter_constraint_optionContext() {}

func NewAlter_constraint_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_constraint_optionContext {
	var p = new(Alter_constraint_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_constraint_option

	return p
}

func (s *Alter_constraint_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_constraint_optionContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Alter_constraint_optionContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(OBParserCONSTRAINT, 0)
}

func (s *Alter_constraint_optionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Alter_constraint_optionContext) Name_list() IName_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IName_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *Alter_constraint_optionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Alter_constraint_optionContext) ADD() antlr.TerminalNode {
	return s.GetToken(OBParserADD, 0)
}

func (s *Alter_constraint_optionContext) Constraint_name() IConstraint_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraint_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraint_nameContext)
}

func (s *Alter_constraint_optionContext) CHECK() antlr.TerminalNode {
	return s.GetToken(OBParserCHECK, 0)
}

func (s *Alter_constraint_optionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Alter_constraint_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_constraint_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_constraint_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_constraint_option(s)
	}
}

func (s *Alter_constraint_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_constraint_option(s)
	}
}

func (s *Alter_constraint_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_constraint_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_constraint_option() (localctx IAlter_constraint_optionContext) {
	localctx = NewAlter_constraint_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, OBParserRULE_alter_constraint_option)
	p.SetState(6959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserDROP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6945)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6946)
			p.Match(OBParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6947)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6948)
			p.name_list(0)
		}
		{
			p.SetState(6949)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserADD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6951)
			p.Match(OBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6952)
			p.Match(OBParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6953)
			p.Constraint_name()
		}
		{
			p.SetState(6954)
			p.Match(OBParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6955)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6956)
			p.expr(0)
		}
		{
			p.SetState(6957)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_partition_optionContext is an interface to support dynamic dispatch.
type IAlter_partition_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	Drop_partition_name_list() IDrop_partition_name_listContext
	ADD() antlr.TerminalNode
	Opt_partition_range_or_list() IOpt_partition_range_or_listContext
	Modify_partition_info() IModify_partition_infoContext
	REORGANIZE() antlr.TerminalNode
	Name_list() IName_listContext
	INTO() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode

	// IsAlter_partition_optionContext differentiates from other interfaces.
	IsAlter_partition_optionContext()
}

type Alter_partition_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_partition_optionContext() *Alter_partition_optionContext {
	var p = new(Alter_partition_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_partition_option
	return p
}

func InitEmptyAlter_partition_optionContext(p *Alter_partition_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_partition_option
}

func (*Alter_partition_optionContext) IsAlter_partition_optionContext() {}

func NewAlter_partition_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_partition_optionContext {
	var p = new(Alter_partition_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_partition_option

	return p
}

func (s *Alter_partition_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_partition_optionContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Alter_partition_optionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *Alter_partition_optionContext) Drop_partition_name_list() IDrop_partition_name_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_partition_name_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_partition_name_listContext)
}

func (s *Alter_partition_optionContext) ADD() antlr.TerminalNode {
	return s.GetToken(OBParserADD, 0)
}

func (s *Alter_partition_optionContext) Opt_partition_range_or_list() IOpt_partition_range_or_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_partition_range_or_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_partition_range_or_listContext)
}

func (s *Alter_partition_optionContext) Modify_partition_info() IModify_partition_infoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModify_partition_infoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModify_partition_infoContext)
}

func (s *Alter_partition_optionContext) REORGANIZE() antlr.TerminalNode {
	return s.GetToken(OBParserREORGANIZE, 0)
}

func (s *Alter_partition_optionContext) Name_list() IName_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IName_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *Alter_partition_optionContext) INTO() antlr.TerminalNode {
	return s.GetToken(OBParserINTO, 0)
}

func (s *Alter_partition_optionContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(OBParserTRUNCATE, 0)
}

func (s *Alter_partition_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_partition_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_partition_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_partition_option(s)
	}
}

func (s *Alter_partition_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_partition_option(s)
	}
}

func (s *Alter_partition_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_partition_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_partition_option() (localctx IAlter_partition_optionContext) {
	localctx = NewAlter_partition_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, OBParserRULE_alter_partition_option)
	p.SetState(6977)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserDROP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6961)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6962)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6963)
			p.Drop_partition_name_list()
		}

	case OBParserADD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6964)
			p.Match(OBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6965)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6966)
			p.Opt_partition_range_or_list()
		}

	case OBParserPARTITION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6967)
			p.Modify_partition_info()
		}

	case OBParserREORGANIZE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6968)
			p.Match(OBParserREORGANIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6969)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6970)
			p.name_list(0)
		}
		{
			p.SetState(6971)
			p.Match(OBParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6972)
			p.Opt_partition_range_or_list()
		}

	case OBParserTRUNCATE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6974)
			p.Match(OBParserTRUNCATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6975)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6976)
			p.name_list(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpt_partition_range_or_listContext is an interface to support dynamic dispatch.
type IOpt_partition_range_or_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Opt_range_partition_list() IOpt_range_partition_listContext
	Opt_list_partition_list() IOpt_list_partition_listContext

	// IsOpt_partition_range_or_listContext differentiates from other interfaces.
	IsOpt_partition_range_or_listContext()
}

type Opt_partition_range_or_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpt_partition_range_or_listContext() *Opt_partition_range_or_listContext {
	var p = new(Opt_partition_range_or_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_partition_range_or_list
	return p
}

func InitEmptyOpt_partition_range_or_listContext(p *Opt_partition_range_or_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_opt_partition_range_or_list
}

func (*Opt_partition_range_or_listContext) IsOpt_partition_range_or_listContext() {}

func NewOpt_partition_range_or_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Opt_partition_range_or_listContext {
	var p = new(Opt_partition_range_or_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_opt_partition_range_or_list

	return p
}

func (s *Opt_partition_range_or_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Opt_partition_range_or_listContext) Opt_range_partition_list() IOpt_range_partition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_range_partition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_range_partition_listContext)
}

func (s *Opt_partition_range_or_listContext) Opt_list_partition_list() IOpt_list_partition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_list_partition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_list_partition_listContext)
}

func (s *Opt_partition_range_or_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Opt_partition_range_or_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Opt_partition_range_or_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOpt_partition_range_or_list(s)
	}
}

func (s *Opt_partition_range_or_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOpt_partition_range_or_list(s)
	}
}

func (s *Opt_partition_range_or_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOpt_partition_range_or_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Opt_partition_range_or_list() (localctx IOpt_partition_range_or_listContext) {
	localctx = NewOpt_partition_range_or_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, OBParserRULE_opt_partition_range_or_list)
	p.SetState(6981)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 708, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6979)
			p.Opt_range_partition_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6980)
			p.Opt_list_partition_list()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_tg_partition_optionContext is an interface to support dynamic dispatch.
type IAlter_tg_partition_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	Drop_partition_name_list() IDrop_partition_name_listContext
	ADD() antlr.TerminalNode
	Opt_partition_range_or_list() IOpt_partition_range_or_listContext
	Modify_tg_partition_info() IModify_tg_partition_infoContext
	REORGANIZE() antlr.TerminalNode
	Name_list() IName_listContext
	INTO() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode

	// IsAlter_tg_partition_optionContext differentiates from other interfaces.
	IsAlter_tg_partition_optionContext()
}

type Alter_tg_partition_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_tg_partition_optionContext() *Alter_tg_partition_optionContext {
	var p = new(Alter_tg_partition_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tg_partition_option
	return p
}

func InitEmptyAlter_tg_partition_optionContext(p *Alter_tg_partition_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tg_partition_option
}

func (*Alter_tg_partition_optionContext) IsAlter_tg_partition_optionContext() {}

func NewAlter_tg_partition_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_tg_partition_optionContext {
	var p = new(Alter_tg_partition_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_tg_partition_option

	return p
}

func (s *Alter_tg_partition_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_tg_partition_optionContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Alter_tg_partition_optionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *Alter_tg_partition_optionContext) Drop_partition_name_list() IDrop_partition_name_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_partition_name_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_partition_name_listContext)
}

func (s *Alter_tg_partition_optionContext) ADD() antlr.TerminalNode {
	return s.GetToken(OBParserADD, 0)
}

func (s *Alter_tg_partition_optionContext) Opt_partition_range_or_list() IOpt_partition_range_or_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_partition_range_or_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_partition_range_or_listContext)
}

func (s *Alter_tg_partition_optionContext) Modify_tg_partition_info() IModify_tg_partition_infoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModify_tg_partition_infoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModify_tg_partition_infoContext)
}

func (s *Alter_tg_partition_optionContext) REORGANIZE() antlr.TerminalNode {
	return s.GetToken(OBParserREORGANIZE, 0)
}

func (s *Alter_tg_partition_optionContext) Name_list() IName_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IName_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *Alter_tg_partition_optionContext) INTO() antlr.TerminalNode {
	return s.GetToken(OBParserINTO, 0)
}

func (s *Alter_tg_partition_optionContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(OBParserTRUNCATE, 0)
}

func (s *Alter_tg_partition_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_tg_partition_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_tg_partition_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_tg_partition_option(s)
	}
}

func (s *Alter_tg_partition_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_tg_partition_option(s)
	}
}

func (s *Alter_tg_partition_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_tg_partition_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_tg_partition_option() (localctx IAlter_tg_partition_optionContext) {
	localctx = NewAlter_tg_partition_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, OBParserRULE_alter_tg_partition_option)
	p.SetState(6999)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserDROP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6983)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6984)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6985)
			p.Drop_partition_name_list()
		}

	case OBParserADD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6986)
			p.Match(OBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6987)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6988)
			p.Opt_partition_range_or_list()
		}

	case OBParserPARTITION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6989)
			p.Modify_tg_partition_info()
		}

	case OBParserREORGANIZE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6990)
			p.Match(OBParserREORGANIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6991)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6992)
			p.name_list(0)
		}
		{
			p.SetState(6993)
			p.Match(OBParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6994)
			p.Opt_partition_range_or_list()
		}

	case OBParserTRUNCATE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6996)
			p.Match(OBParserTRUNCATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6997)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6998)
			p.name_list(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_partition_name_listContext is an interface to support dynamic dispatch.
type IDrop_partition_name_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Name_list() IName_listContext
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode

	// IsDrop_partition_name_listContext differentiates from other interfaces.
	IsDrop_partition_name_listContext()
}

type Drop_partition_name_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_partition_name_listContext() *Drop_partition_name_listContext {
	var p = new(Drop_partition_name_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_partition_name_list
	return p
}

func InitEmptyDrop_partition_name_listContext(p *Drop_partition_name_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_drop_partition_name_list
}

func (*Drop_partition_name_listContext) IsDrop_partition_name_listContext() {}

func NewDrop_partition_name_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_partition_name_listContext {
	var p = new(Drop_partition_name_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_drop_partition_name_list

	return p
}

func (s *Drop_partition_name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_partition_name_listContext) Name_list() IName_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IName_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *Drop_partition_name_listContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Drop_partition_name_listContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Drop_partition_name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_partition_name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_partition_name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDrop_partition_name_list(s)
	}
}

func (s *Drop_partition_name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDrop_partition_name_list(s)
	}
}

func (s *Drop_partition_name_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDrop_partition_name_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Drop_partition_name_list() (localctx IDrop_partition_name_listContext) {
	localctx = NewDrop_partition_name_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, OBParserRULE_drop_partition_name_list)
	p.SetState(7006)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserNAME_OB:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7001)
			p.name_list(0)
		}

	case OBParserLeftParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7002)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7003)
			p.name_list(0)
		}
		{
			p.SetState(7004)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModify_partition_infoContext is an interface to support dynamic dispatch.
type IModify_partition_infoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Hash_partition_option() IHash_partition_optionContext
	Key_partition_option() IKey_partition_optionContext
	Range_partition_option() IRange_partition_optionContext
	List_partition_option() IList_partition_optionContext

	// IsModify_partition_infoContext differentiates from other interfaces.
	IsModify_partition_infoContext()
}

type Modify_partition_infoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModify_partition_infoContext() *Modify_partition_infoContext {
	var p = new(Modify_partition_infoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_modify_partition_info
	return p
}

func InitEmptyModify_partition_infoContext(p *Modify_partition_infoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_modify_partition_info
}

func (*Modify_partition_infoContext) IsModify_partition_infoContext() {}

func NewModify_partition_infoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modify_partition_infoContext {
	var p = new(Modify_partition_infoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_modify_partition_info

	return p
}

func (s *Modify_partition_infoContext) GetParser() antlr.Parser { return s.parser }

func (s *Modify_partition_infoContext) Hash_partition_option() IHash_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHash_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHash_partition_optionContext)
}

func (s *Modify_partition_infoContext) Key_partition_option() IKey_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKey_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKey_partition_optionContext)
}

func (s *Modify_partition_infoContext) Range_partition_option() IRange_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRange_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRange_partition_optionContext)
}

func (s *Modify_partition_infoContext) List_partition_option() IList_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_partition_optionContext)
}

func (s *Modify_partition_infoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modify_partition_infoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modify_partition_infoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterModify_partition_info(s)
	}
}

func (s *Modify_partition_infoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitModify_partition_info(s)
	}
}

func (s *Modify_partition_infoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitModify_partition_info(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Modify_partition_info() (localctx IModify_partition_infoContext) {
	localctx = NewModify_partition_infoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, OBParserRULE_modify_partition_info)
	p.SetState(7012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 711, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7008)
			p.Hash_partition_option()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7009)
			p.Key_partition_option()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7010)
			p.Range_partition_option()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7011)
			p.List_partition_option()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModify_tg_partition_infoContext is an interface to support dynamic dispatch.
type IModify_tg_partition_infoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Tg_hash_partition_option() ITg_hash_partition_optionContext
	Tg_key_partition_option() ITg_key_partition_optionContext
	Tg_range_partition_option() ITg_range_partition_optionContext
	Tg_list_partition_option() ITg_list_partition_optionContext

	// IsModify_tg_partition_infoContext differentiates from other interfaces.
	IsModify_tg_partition_infoContext()
}

type Modify_tg_partition_infoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModify_tg_partition_infoContext() *Modify_tg_partition_infoContext {
	var p = new(Modify_tg_partition_infoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_modify_tg_partition_info
	return p
}

func InitEmptyModify_tg_partition_infoContext(p *Modify_tg_partition_infoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_modify_tg_partition_info
}

func (*Modify_tg_partition_infoContext) IsModify_tg_partition_infoContext() {}

func NewModify_tg_partition_infoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modify_tg_partition_infoContext {
	var p = new(Modify_tg_partition_infoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_modify_tg_partition_info

	return p
}

func (s *Modify_tg_partition_infoContext) GetParser() antlr.Parser { return s.parser }

func (s *Modify_tg_partition_infoContext) Tg_hash_partition_option() ITg_hash_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITg_hash_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITg_hash_partition_optionContext)
}

func (s *Modify_tg_partition_infoContext) Tg_key_partition_option() ITg_key_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITg_key_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITg_key_partition_optionContext)
}

func (s *Modify_tg_partition_infoContext) Tg_range_partition_option() ITg_range_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITg_range_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITg_range_partition_optionContext)
}

func (s *Modify_tg_partition_infoContext) Tg_list_partition_option() ITg_list_partition_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITg_list_partition_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITg_list_partition_optionContext)
}

func (s *Modify_tg_partition_infoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modify_tg_partition_infoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modify_tg_partition_infoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterModify_tg_partition_info(s)
	}
}

func (s *Modify_tg_partition_infoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitModify_tg_partition_info(s)
	}
}

func (s *Modify_tg_partition_infoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitModify_tg_partition_info(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Modify_tg_partition_info() (localctx IModify_tg_partition_infoContext) {
	localctx = NewModify_tg_partition_infoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, OBParserRULE_modify_tg_partition_info)
	p.SetState(7018)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 712, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7014)
			p.Tg_hash_partition_option()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7015)
			p.Tg_key_partition_option()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7016)
			p.Tg_range_partition_option()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7017)
			p.Tg_list_partition_option()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_index_optionContext is an interface to support dynamic dispatch.
type IAlter_index_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	Key_or_index() IKey_or_indexContext
	LeftParen() antlr.TerminalNode
	Sort_column_list() ISort_column_listContext
	RightParen() antlr.TerminalNode
	AllIndex_name() []IIndex_nameContext
	Index_name(i int) IIndex_nameContext
	Index_using_algorithm() IIndex_using_algorithmContext
	Opt_index_options() IOpt_index_optionsContext
	UNIQUE() antlr.TerminalNode
	CONSTRAINT() antlr.TerminalNode
	Constraint_name() IConstraint_nameContext
	FULLTEXT() antlr.TerminalNode
	DROP() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	Column_name_list() IColumn_name_listContext
	Opt_constraint_name() IOpt_constraint_nameContext
	ALTER() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Visibility_option() IVisibility_optionContext
	RENAME() antlr.TerminalNode
	TO() antlr.TerminalNode

	// IsAlter_index_optionContext differentiates from other interfaces.
	IsAlter_index_optionContext()
}

type Alter_index_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_index_optionContext() *Alter_index_optionContext {
	var p = new(Alter_index_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_index_option
	return p
}

func InitEmptyAlter_index_optionContext(p *Alter_index_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_index_option
}

func (*Alter_index_optionContext) IsAlter_index_optionContext() {}

func NewAlter_index_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_index_optionContext {
	var p = new(Alter_index_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_index_option

	return p
}

func (s *Alter_index_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_index_optionContext) ADD() antlr.TerminalNode {
	return s.GetToken(OBParserADD, 0)
}

func (s *Alter_index_optionContext) Key_or_index() IKey_or_indexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKey_or_indexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKey_or_indexContext)
}

func (s *Alter_index_optionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Alter_index_optionContext) Sort_column_list() ISort_column_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISort_column_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISort_column_listContext)
}

func (s *Alter_index_optionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Alter_index_optionContext) AllIndex_name() []IIndex_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndex_nameContext); ok {
			len++
		}
	}

	tst := make([]IIndex_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndex_nameContext); ok {
			tst[i] = t.(IIndex_nameContext)
			i++
		}
	}

	return tst
}

func (s *Alter_index_optionContext) Index_name(i int) IIndex_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_nameContext)
}

func (s *Alter_index_optionContext) Index_using_algorithm() IIndex_using_algorithmContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_using_algorithmContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_using_algorithmContext)
}

func (s *Alter_index_optionContext) Opt_index_options() IOpt_index_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_index_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_index_optionsContext)
}

func (s *Alter_index_optionContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(OBParserUNIQUE, 0)
}

func (s *Alter_index_optionContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(OBParserCONSTRAINT, 0)
}

func (s *Alter_index_optionContext) Constraint_name() IConstraint_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraint_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraint_nameContext)
}

func (s *Alter_index_optionContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(OBParserFULLTEXT, 0)
}

func (s *Alter_index_optionContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Alter_index_optionContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(OBParserPRIMARY, 0)
}

func (s *Alter_index_optionContext) KEY() antlr.TerminalNode {
	return s.GetToken(OBParserKEY, 0)
}

func (s *Alter_index_optionContext) Column_name_list() IColumn_name_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_name_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_name_listContext)
}

func (s *Alter_index_optionContext) Opt_constraint_name() IOpt_constraint_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_constraint_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_constraint_nameContext)
}

func (s *Alter_index_optionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(OBParserALTER, 0)
}

func (s *Alter_index_optionContext) INDEX() antlr.TerminalNode {
	return s.GetToken(OBParserINDEX, 0)
}

func (s *Alter_index_optionContext) Visibility_option() IVisibility_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibility_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibility_optionContext)
}

func (s *Alter_index_optionContext) RENAME() antlr.TerminalNode {
	return s.GetToken(OBParserRENAME, 0)
}

func (s *Alter_index_optionContext) TO() antlr.TerminalNode {
	return s.GetToken(OBParserTO, 0)
}

func (s *Alter_index_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_index_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_index_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_index_option(s)
	}
}

func (s *Alter_index_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_index_option(s)
	}
}

func (s *Alter_index_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_index_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_index_option() (localctx IAlter_index_optionContext) {
	localctx = NewAlter_index_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, OBParserRULE_alter_index_option)
	var _la int

	p.SetState(7117)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 731, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7020)
			p.Match(OBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7021)
			p.Key_or_index()
		}
		p.SetState(7023)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&140737496744065) != 0) || ((int64((_la-92)) & ^0x3f) == 0 && ((int64(1)<<(_la-92))&288230513726980097) != 0) || ((int64((_la-163)) & ^0x3f) == 0 && ((int64(1)<<(_la-163))&11821949038624769) != 0) || ((int64((_la-250)) & ^0x3f) == 0 && ((int64(1)<<(_la-250))&-4629700416945258495) != 0) || ((int64((_la-314)) & ^0x3f) == 0 && ((int64(1)<<(_la-314))&-587737344112594961) != 0) || ((int64((_la-378)) & ^0x3f) == 0 && ((int64(1)<<(_la-378))&-603552873430712321) != 0) || ((int64((_la-442)) & ^0x3f) == 0 && ((int64(1)<<(_la-442))&-2305913515397021697) != 0) || ((int64((_la-506)) & ^0x3f) == 0 && ((int64(1)<<(_la-506))&8070450531845275647) != 0) || ((int64((_la-570)) & ^0x3f) == 0 && ((int64(1)<<(_la-570))&-18159534061387777) != 0) || ((int64((_la-634)) & ^0x3f) == 0 && ((int64(1)<<(_la-634))&-18146237874177) != 0) || ((int64((_la-698)) & ^0x3f) == 0 && ((int64(1)<<(_la-698))&-2533274790395907) != 0) || ((int64((_la-762)) & ^0x3f) == 0 && ((int64(1)<<(_la-762))&-1157425104234217473) != 0) || ((int64((_la-826)) & ^0x3f) == 0 && ((int64(1)<<(_la-826))&137342196111112175) != 0) || _la == OBParserNAME_OB || _la == OBParserSTAT {
			{
				p.SetState(7022)
				p.Index_name()
			}

		}
		p.SetState(7026)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserUSING {
			{
				p.SetState(7025)
				p.Index_using_algorithm()
			}

		}
		{
			p.SetState(7028)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7029)
			p.Sort_column_list()
		}
		{
			p.SetState(7030)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7032)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 715, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7031)
				p.Opt_index_options()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7034)
			p.Match(OBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7035)
			p.Match(OBParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7037)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserINDEX || _la == OBParserKEY {
			{
				p.SetState(7036)
				p.Key_or_index()
			}

		}
		p.SetState(7040)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&140737496744065) != 0) || ((int64((_la-92)) & ^0x3f) == 0 && ((int64(1)<<(_la-92))&288230513726980097) != 0) || ((int64((_la-163)) & ^0x3f) == 0 && ((int64(1)<<(_la-163))&11821949038624769) != 0) || ((int64((_la-250)) & ^0x3f) == 0 && ((int64(1)<<(_la-250))&-4629700416945258495) != 0) || ((int64((_la-314)) & ^0x3f) == 0 && ((int64(1)<<(_la-314))&-587737344112594961) != 0) || ((int64((_la-378)) & ^0x3f) == 0 && ((int64(1)<<(_la-378))&-603552873430712321) != 0) || ((int64((_la-442)) & ^0x3f) == 0 && ((int64(1)<<(_la-442))&-2305913515397021697) != 0) || ((int64((_la-506)) & ^0x3f) == 0 && ((int64(1)<<(_la-506))&8070450531845275647) != 0) || ((int64((_la-570)) & ^0x3f) == 0 && ((int64(1)<<(_la-570))&-18159534061387777) != 0) || ((int64((_la-634)) & ^0x3f) == 0 && ((int64(1)<<(_la-634))&-18146237874177) != 0) || ((int64((_la-698)) & ^0x3f) == 0 && ((int64(1)<<(_la-698))&-2533274790395907) != 0) || ((int64((_la-762)) & ^0x3f) == 0 && ((int64(1)<<(_la-762))&-1157425104234217473) != 0) || ((int64((_la-826)) & ^0x3f) == 0 && ((int64(1)<<(_la-826))&137342196111112175) != 0) || _la == OBParserNAME_OB || _la == OBParserSTAT {
			{
				p.SetState(7039)
				p.Index_name()
			}

		}
		p.SetState(7043)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserUSING {
			{
				p.SetState(7042)
				p.Index_using_algorithm()
			}

		}
		{
			p.SetState(7045)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7046)
			p.Sort_column_list()
		}
		{
			p.SetState(7047)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7049)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 719, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7048)
				p.Opt_index_options()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7051)
			p.Match(OBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7052)
			p.Match(OBParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7054)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&140737496744065) != 0) || ((int64((_la-92)) & ^0x3f) == 0 && ((int64(1)<<(_la-92))&288230513726980097) != 0) || ((int64((_la-163)) & ^0x3f) == 0 && ((int64(1)<<(_la-163))&11821949038624769) != 0) || ((int64((_la-250)) & ^0x3f) == 0 && ((int64(1)<<(_la-250))&-4629700416945258495) != 0) || ((int64((_la-314)) & ^0x3f) == 0 && ((int64(1)<<(_la-314))&-587737344112594961) != 0) || ((int64((_la-378)) & ^0x3f) == 0 && ((int64(1)<<(_la-378))&-603552873430712321) != 0) || ((int64((_la-442)) & ^0x3f) == 0 && ((int64(1)<<(_la-442))&-2305913515397021697) != 0) || ((int64((_la-506)) & ^0x3f) == 0 && ((int64(1)<<(_la-506))&8070450531845275647) != 0) || ((int64((_la-570)) & ^0x3f) == 0 && ((int64(1)<<(_la-570))&-18159534061387777) != 0) || ((int64((_la-634)) & ^0x3f) == 0 && ((int64(1)<<(_la-634))&-18146237874177) != 0) || ((int64((_la-698)) & ^0x3f) == 0 && ((int64(1)<<(_la-698))&-2533274790395907) != 0) || ((int64((_la-762)) & ^0x3f) == 0 && ((int64(1)<<(_la-762))&-1157425104234217473) != 0) || ((int64((_la-826)) & ^0x3f) == 0 && ((int64(1)<<(_la-826))&137342196111112175) != 0) || _la == OBParserNAME_OB || _la == OBParserSTAT {
			{
				p.SetState(7053)
				p.Constraint_name()
			}

		}
		{
			p.SetState(7056)
			p.Match(OBParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7058)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserINDEX || _la == OBParserKEY {
			{
				p.SetState(7057)
				p.Key_or_index()
			}

		}
		p.SetState(7061)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&140737496744065) != 0) || ((int64((_la-92)) & ^0x3f) == 0 && ((int64(1)<<(_la-92))&288230513726980097) != 0) || ((int64((_la-163)) & ^0x3f) == 0 && ((int64(1)<<(_la-163))&11821949038624769) != 0) || ((int64((_la-250)) & ^0x3f) == 0 && ((int64(1)<<(_la-250))&-4629700416945258495) != 0) || ((int64((_la-314)) & ^0x3f) == 0 && ((int64(1)<<(_la-314))&-587737344112594961) != 0) || ((int64((_la-378)) & ^0x3f) == 0 && ((int64(1)<<(_la-378))&-603552873430712321) != 0) || ((int64((_la-442)) & ^0x3f) == 0 && ((int64(1)<<(_la-442))&-2305913515397021697) != 0) || ((int64((_la-506)) & ^0x3f) == 0 && ((int64(1)<<(_la-506))&8070450531845275647) != 0) || ((int64((_la-570)) & ^0x3f) == 0 && ((int64(1)<<(_la-570))&-18159534061387777) != 0) || ((int64((_la-634)) & ^0x3f) == 0 && ((int64(1)<<(_la-634))&-18146237874177) != 0) || ((int64((_la-698)) & ^0x3f) == 0 && ((int64(1)<<(_la-698))&-2533274790395907) != 0) || ((int64((_la-762)) & ^0x3f) == 0 && ((int64(1)<<(_la-762))&-1157425104234217473) != 0) || ((int64((_la-826)) & ^0x3f) == 0 && ((int64(1)<<(_la-826))&137342196111112175) != 0) || _la == OBParserNAME_OB || _la == OBParserSTAT {
			{
				p.SetState(7060)
				p.Index_name()
			}

		}
		p.SetState(7064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserUSING {
			{
				p.SetState(7063)
				p.Index_using_algorithm()
			}

		}
		{
			p.SetState(7066)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7067)
			p.Sort_column_list()
		}
		{
			p.SetState(7068)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7070)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 724, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7069)
				p.Opt_index_options()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7072)
			p.Match(OBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7073)
			p.Match(OBParserFULLTEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7075)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserINDEX || _la == OBParserKEY {
			{
				p.SetState(7074)
				p.Key_or_index()
			}

		}
		p.SetState(7078)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&140737496744065) != 0) || ((int64((_la-92)) & ^0x3f) == 0 && ((int64(1)<<(_la-92))&288230513726980097) != 0) || ((int64((_la-163)) & ^0x3f) == 0 && ((int64(1)<<(_la-163))&11821949038624769) != 0) || ((int64((_la-250)) & ^0x3f) == 0 && ((int64(1)<<(_la-250))&-4629700416945258495) != 0) || ((int64((_la-314)) & ^0x3f) == 0 && ((int64(1)<<(_la-314))&-587737344112594961) != 0) || ((int64((_la-378)) & ^0x3f) == 0 && ((int64(1)<<(_la-378))&-603552873430712321) != 0) || ((int64((_la-442)) & ^0x3f) == 0 && ((int64(1)<<(_la-442))&-2305913515397021697) != 0) || ((int64((_la-506)) & ^0x3f) == 0 && ((int64(1)<<(_la-506))&8070450531845275647) != 0) || ((int64((_la-570)) & ^0x3f) == 0 && ((int64(1)<<(_la-570))&-18159534061387777) != 0) || ((int64((_la-634)) & ^0x3f) == 0 && ((int64(1)<<(_la-634))&-18146237874177) != 0) || ((int64((_la-698)) & ^0x3f) == 0 && ((int64(1)<<(_la-698))&-2533274790395907) != 0) || ((int64((_la-762)) & ^0x3f) == 0 && ((int64(1)<<(_la-762))&-1157425104234217473) != 0) || ((int64((_la-826)) & ^0x3f) == 0 && ((int64(1)<<(_la-826))&137342196111112175) != 0) || _la == OBParserNAME_OB || _la == OBParserSTAT {
			{
				p.SetState(7077)
				p.Index_name()
			}

		}
		p.SetState(7081)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserUSING {
			{
				p.SetState(7080)
				p.Index_using_algorithm()
			}

		}
		{
			p.SetState(7083)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7084)
			p.Sort_column_list()
		}
		{
			p.SetState(7085)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7087)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 728, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7086)
				p.Opt_index_options()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7089)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7090)
			p.Key_or_index()
		}
		{
			p.SetState(7091)
			p.Index_name()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7093)
			p.Match(OBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7096)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCONSTRAINT {
			{
				p.SetState(7094)
				p.Match(OBParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7095)
				p.Opt_constraint_name()
			}

		}
		{
			p.SetState(7098)
			p.Match(OBParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7099)
			p.Match(OBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7100)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7101)
			p.Column_name_list()
		}
		{
			p.SetState(7102)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7104)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 730, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7103)
				p.Opt_index_options()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7106)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7107)
			p.Match(OBParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7108)
			p.Index_name()
		}
		{
			p.SetState(7109)
			p.Visibility_option()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7111)
			p.Match(OBParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7112)
			p.Key_or_index()
		}
		{
			p.SetState(7113)
			p.Index_name()
		}
		{
			p.SetState(7114)
			p.Match(OBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7115)
			p.Index_name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_foreign_key_actionContext is an interface to support dynamic dispatch.
type IAlter_foreign_key_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	FOREIGN() antlr.TerminalNode
	KEY() antlr.TerminalNode
	Index_name() IIndex_nameContext
	ADD() antlr.TerminalNode
	AllLeftParen() []antlr.TerminalNode
	LeftParen(i int) antlr.TerminalNode
	AllColumn_name_list() []IColumn_name_listContext
	Column_name_list(i int) IColumn_name_listContext
	AllRightParen() []antlr.TerminalNode
	RightParen(i int) antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	Relation_factor() IRelation_factorContext
	CONSTRAINT() antlr.TerminalNode
	Opt_constraint_name() IOpt_constraint_nameContext
	MATCH() antlr.TerminalNode
	Match_action() IMatch_actionContext
	Opt_reference_option_list() IOpt_reference_option_listContext
	Reference_option() IReference_optionContext

	// IsAlter_foreign_key_actionContext differentiates from other interfaces.
	IsAlter_foreign_key_actionContext()
}

type Alter_foreign_key_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_foreign_key_actionContext() *Alter_foreign_key_actionContext {
	var p = new(Alter_foreign_key_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_foreign_key_action
	return p
}

func InitEmptyAlter_foreign_key_actionContext(p *Alter_foreign_key_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_foreign_key_action
}

func (*Alter_foreign_key_actionContext) IsAlter_foreign_key_actionContext() {}

func NewAlter_foreign_key_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_foreign_key_actionContext {
	var p = new(Alter_foreign_key_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_foreign_key_action

	return p
}

func (s *Alter_foreign_key_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_foreign_key_actionContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Alter_foreign_key_actionContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(OBParserFOREIGN, 0)
}

func (s *Alter_foreign_key_actionContext) KEY() antlr.TerminalNode {
	return s.GetToken(OBParserKEY, 0)
}

func (s *Alter_foreign_key_actionContext) Index_name() IIndex_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_nameContext)
}

func (s *Alter_foreign_key_actionContext) ADD() antlr.TerminalNode {
	return s.GetToken(OBParserADD, 0)
}

func (s *Alter_foreign_key_actionContext) AllLeftParen() []antlr.TerminalNode {
	return s.GetTokens(OBParserLeftParen)
}

func (s *Alter_foreign_key_actionContext) LeftParen(i int) antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, i)
}

func (s *Alter_foreign_key_actionContext) AllColumn_name_list() []IColumn_name_listContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumn_name_listContext); ok {
			len++
		}
	}

	tst := make([]IColumn_name_listContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumn_name_listContext); ok {
			tst[i] = t.(IColumn_name_listContext)
			i++
		}
	}

	return tst
}

func (s *Alter_foreign_key_actionContext) Column_name_list(i int) IColumn_name_listContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_name_listContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_name_listContext)
}

func (s *Alter_foreign_key_actionContext) AllRightParen() []antlr.TerminalNode {
	return s.GetTokens(OBParserRightParen)
}

func (s *Alter_foreign_key_actionContext) RightParen(i int) antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, i)
}

func (s *Alter_foreign_key_actionContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(OBParserREFERENCES, 0)
}

func (s *Alter_foreign_key_actionContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Alter_foreign_key_actionContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(OBParserCONSTRAINT, 0)
}

func (s *Alter_foreign_key_actionContext) Opt_constraint_name() IOpt_constraint_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_constraint_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_constraint_nameContext)
}

func (s *Alter_foreign_key_actionContext) MATCH() antlr.TerminalNode {
	return s.GetToken(OBParserMATCH, 0)
}

func (s *Alter_foreign_key_actionContext) Match_action() IMatch_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatch_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatch_actionContext)
}

func (s *Alter_foreign_key_actionContext) Opt_reference_option_list() IOpt_reference_option_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_reference_option_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_reference_option_listContext)
}

func (s *Alter_foreign_key_actionContext) Reference_option() IReference_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReference_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReference_optionContext)
}

func (s *Alter_foreign_key_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_foreign_key_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_foreign_key_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_foreign_key_action(s)
	}
}

func (s *Alter_foreign_key_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_foreign_key_action(s)
	}
}

func (s *Alter_foreign_key_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_foreign_key_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_foreign_key_action() (localctx IAlter_foreign_key_actionContext) {
	localctx = NewAlter_foreign_key_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, OBParserRULE_alter_foreign_key_action)
	var _la int

	p.SetState(7150)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserDROP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7119)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7120)
			p.Match(OBParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7121)
			p.Match(OBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7122)
			p.Index_name()
		}

	case OBParserADD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7123)
			p.Match(OBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCONSTRAINT {
			{
				p.SetState(7124)
				p.Match(OBParserCONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7125)
				p.Opt_constraint_name()
			}

		}
		{
			p.SetState(7128)
			p.Match(OBParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7129)
			p.Match(OBParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7131)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&140737496744065) != 0) || ((int64((_la-92)) & ^0x3f) == 0 && ((int64(1)<<(_la-92))&288230513726980097) != 0) || ((int64((_la-163)) & ^0x3f) == 0 && ((int64(1)<<(_la-163))&11821949038624769) != 0) || ((int64((_la-250)) & ^0x3f) == 0 && ((int64(1)<<(_la-250))&-4629700416945258495) != 0) || ((int64((_la-314)) & ^0x3f) == 0 && ((int64(1)<<(_la-314))&-587737344112594961) != 0) || ((int64((_la-378)) & ^0x3f) == 0 && ((int64(1)<<(_la-378))&-603552873430712321) != 0) || ((int64((_la-442)) & ^0x3f) == 0 && ((int64(1)<<(_la-442))&-2305913515397021697) != 0) || ((int64((_la-506)) & ^0x3f) == 0 && ((int64(1)<<(_la-506))&8070450531845275647) != 0) || ((int64((_la-570)) & ^0x3f) == 0 && ((int64(1)<<(_la-570))&-18159534061387777) != 0) || ((int64((_la-634)) & ^0x3f) == 0 && ((int64(1)<<(_la-634))&-18146237874177) != 0) || ((int64((_la-698)) & ^0x3f) == 0 && ((int64(1)<<(_la-698))&-2533274790395907) != 0) || ((int64((_la-762)) & ^0x3f) == 0 && ((int64(1)<<(_la-762))&-1157425104234217473) != 0) || ((int64((_la-826)) & ^0x3f) == 0 && ((int64(1)<<(_la-826))&137342196111112175) != 0) || _la == OBParserNAME_OB || _la == OBParserSTAT {
			{
				p.SetState(7130)
				p.Index_name()
			}

		}
		{
			p.SetState(7133)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7134)
			p.Column_name_list()
		}
		{
			p.SetState(7135)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7136)
			p.Match(OBParserREFERENCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7137)
			p.Relation_factor()
		}
		{
			p.SetState(7138)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7139)
			p.Column_name_list()
		}
		{
			p.SetState(7140)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7143)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 734, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7141)
				p.Match(OBParserMATCH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7142)
				p.Match_action()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(7148)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 735, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7145)
				p.opt_reference_option_list(0)
			}
			{
				p.SetState(7146)
				p.Reference_option()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVisibility_optionContext is an interface to support dynamic dispatch.
type IVisibility_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VISIBLE() antlr.TerminalNode
	INVISIBLE() antlr.TerminalNode

	// IsVisibility_optionContext differentiates from other interfaces.
	IsVisibility_optionContext()
}

type Visibility_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVisibility_optionContext() *Visibility_optionContext {
	var p = new(Visibility_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_visibility_option
	return p
}

func InitEmptyVisibility_optionContext(p *Visibility_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_visibility_option
}

func (*Visibility_optionContext) IsVisibility_optionContext() {}

func NewVisibility_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Visibility_optionContext {
	var p = new(Visibility_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_visibility_option

	return p
}

func (s *Visibility_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Visibility_optionContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(OBParserVISIBLE, 0)
}

func (s *Visibility_optionContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(OBParserINVISIBLE, 0)
}

func (s *Visibility_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Visibility_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Visibility_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterVisibility_option(s)
	}
}

func (s *Visibility_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitVisibility_option(s)
	}
}

func (s *Visibility_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitVisibility_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Visibility_option() (localctx IVisibility_optionContext) {
	localctx = NewVisibility_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, OBParserRULE_visibility_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7152)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserVISIBLE || _la == OBParserINVISIBLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_column_optionContext is an interface to support dynamic dispatch.
type IAlter_column_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	Column_definition() IColumn_definitionContext
	COLUMN() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Column_definition_list() IColumn_definition_listContext
	RightParen() antlr.TerminalNode
	DROP() antlr.TerminalNode
	Column_name() IColumn_nameContext
	CASCADE() antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	Alter_column_behavior() IAlter_column_behaviorContext
	CHANGE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode

	// IsAlter_column_optionContext differentiates from other interfaces.
	IsAlter_column_optionContext()
}

type Alter_column_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_column_optionContext() *Alter_column_optionContext {
	var p = new(Alter_column_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_column_option
	return p
}

func InitEmptyAlter_column_optionContext(p *Alter_column_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_column_option
}

func (*Alter_column_optionContext) IsAlter_column_optionContext() {}

func NewAlter_column_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_column_optionContext {
	var p = new(Alter_column_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_column_option

	return p
}

func (s *Alter_column_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_column_optionContext) ADD() antlr.TerminalNode {
	return s.GetToken(OBParserADD, 0)
}

func (s *Alter_column_optionContext) Column_definition() IColumn_definitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_definitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_definitionContext)
}

func (s *Alter_column_optionContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(OBParserCOLUMN, 0)
}

func (s *Alter_column_optionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Alter_column_optionContext) Column_definition_list() IColumn_definition_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_definition_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_definition_listContext)
}

func (s *Alter_column_optionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Alter_column_optionContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Alter_column_optionContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Alter_column_optionContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(OBParserCASCADE, 0)
}

func (s *Alter_column_optionContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(OBParserRESTRICT, 0)
}

func (s *Alter_column_optionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(OBParserALTER, 0)
}

func (s *Alter_column_optionContext) Alter_column_behavior() IAlter_column_behaviorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_column_behaviorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_column_behaviorContext)
}

func (s *Alter_column_optionContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(OBParserCHANGE, 0)
}

func (s *Alter_column_optionContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(OBParserMODIFY, 0)
}

func (s *Alter_column_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_column_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_column_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_column_option(s)
	}
}

func (s *Alter_column_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_column_option(s)
	}
}

func (s *Alter_column_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_column_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_column_option() (localctx IAlter_column_optionContext) {
	localctx = NewAlter_column_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 810, OBParserRULE_alter_column_option)
	var _la int

	p.SetState(7194)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 744, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7154)
			p.Match(OBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7156)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOLUMN {
			{
				p.SetState(7155)
				p.Match(OBParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7158)
			p.Column_definition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7159)
			p.Match(OBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7161)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOLUMN {
			{
				p.SetState(7160)
				p.Match(OBParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7163)
			p.Match(OBParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7164)
			p.Column_definition_list()
		}
		{
			p.SetState(7165)
			p.Match(OBParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7167)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7169)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOLUMN {
			{
				p.SetState(7168)
				p.Match(OBParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7171)
			p.Column_name()
		}
		p.SetState(7173)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 740, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7172)
				_la = p.GetTokenStream().LA(1)

				if !(_la == OBParserCASCADE || _la == OBParserRESTRICT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7175)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOLUMN {
			{
				p.SetState(7176)
				p.Match(OBParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7179)
			p.Column_name()
		}
		{
			p.SetState(7180)
			p.Alter_column_behavior()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7182)
			p.Match(OBParserCHANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7184)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOLUMN {
			{
				p.SetState(7183)
				p.Match(OBParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7186)
			p.Column_name()
		}
		{
			p.SetState(7187)
			p.Column_definition()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7189)
			p.Match(OBParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7191)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOLUMN {
			{
				p.SetState(7190)
				p.Match(OBParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7193)
			p.Column_definition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_tablegroup_optionContext is an interface to support dynamic dispatch.
type IAlter_tablegroup_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TABLEGROUP() antlr.TerminalNode

	// IsAlter_tablegroup_optionContext differentiates from other interfaces.
	IsAlter_tablegroup_optionContext()
}

type Alter_tablegroup_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_tablegroup_optionContext() *Alter_tablegroup_optionContext {
	var p = new(Alter_tablegroup_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tablegroup_option
	return p
}

func InitEmptyAlter_tablegroup_optionContext(p *Alter_tablegroup_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_tablegroup_option
}

func (*Alter_tablegroup_optionContext) IsAlter_tablegroup_optionContext() {}

func NewAlter_tablegroup_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_tablegroup_optionContext {
	var p = new(Alter_tablegroup_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_tablegroup_option

	return p
}

func (s *Alter_tablegroup_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_tablegroup_optionContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Alter_tablegroup_optionContext) TABLEGROUP() antlr.TerminalNode {
	return s.GetToken(OBParserTABLEGROUP, 0)
}

func (s *Alter_tablegroup_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_tablegroup_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_tablegroup_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_tablegroup_option(s)
	}
}

func (s *Alter_tablegroup_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_tablegroup_option(s)
	}
}

func (s *Alter_tablegroup_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_tablegroup_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_tablegroup_option() (localctx IAlter_tablegroup_optionContext) {
	localctx = NewAlter_tablegroup_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 812, OBParserRULE_alter_tablegroup_option)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7196)
		p.Match(OBParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7197)
		p.Match(OBParserTABLEGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_column_behaviorContext is an interface to support dynamic dispatch.
type IAlter_column_behaviorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	Signed_literal() ISigned_literalContext
	DROP() antlr.TerminalNode

	// IsAlter_column_behaviorContext differentiates from other interfaces.
	IsAlter_column_behaviorContext()
}

type Alter_column_behaviorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_column_behaviorContext() *Alter_column_behaviorContext {
	var p = new(Alter_column_behaviorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_column_behavior
	return p
}

func InitEmptyAlter_column_behaviorContext(p *Alter_column_behaviorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_column_behavior
}

func (*Alter_column_behaviorContext) IsAlter_column_behaviorContext() {}

func NewAlter_column_behaviorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_column_behaviorContext {
	var p = new(Alter_column_behaviorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_column_behavior

	return p
}

func (s *Alter_column_behaviorContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_column_behaviorContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Alter_column_behaviorContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT, 0)
}

func (s *Alter_column_behaviorContext) Signed_literal() ISigned_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISigned_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISigned_literalContext)
}

func (s *Alter_column_behaviorContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Alter_column_behaviorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_column_behaviorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_column_behaviorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_column_behavior(s)
	}
}

func (s *Alter_column_behaviorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_column_behavior(s)
	}
}

func (s *Alter_column_behaviorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_column_behavior(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_column_behavior() (localctx IAlter_column_behaviorContext) {
	localctx = NewAlter_column_behaviorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 814, OBParserRULE_alter_column_behavior)
	p.SetState(7204)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserSET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7199)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7200)
			p.Match(OBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7201)
			p.Signed_literal()
		}

	case OBParserDROP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7202)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7203)
			p.Match(OBParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlashback_stmtContext is an interface to support dynamic dispatch.
type IFlashback_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLASHBACK() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllRelation_factor() []IRelation_factorContext
	Relation_factor(i int) IRelation_factorContext
	AllTO() []antlr.TerminalNode
	TO(i int) antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	Database_key() IDatabase_keyContext
	AllDatabase_factor() []IDatabase_factorContext
	Database_factor(i int) IDatabase_factorContext
	TENANT() antlr.TerminalNode
	AllRelation_name() []IRelation_nameContext
	Relation_name(i int) IRelation_nameContext

	// IsFlashback_stmtContext differentiates from other interfaces.
	IsFlashback_stmtContext()
}

type Flashback_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlashback_stmtContext() *Flashback_stmtContext {
	var p = new(Flashback_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_flashback_stmt
	return p
}

func InitEmptyFlashback_stmtContext(p *Flashback_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_flashback_stmt
}

func (*Flashback_stmtContext) IsFlashback_stmtContext() {}

func NewFlashback_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flashback_stmtContext {
	var p = new(Flashback_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_flashback_stmt

	return p
}

func (s *Flashback_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Flashback_stmtContext) FLASHBACK() antlr.TerminalNode {
	return s.GetToken(OBParserFLASHBACK, 0)
}

func (s *Flashback_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE, 0)
}

func (s *Flashback_stmtContext) AllRelation_factor() []IRelation_factorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_factorContext); ok {
			len++
		}
	}

	tst := make([]IRelation_factorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_factorContext); ok {
			tst[i] = t.(IRelation_factorContext)
			i++
		}
	}

	return tst
}

func (s *Flashback_stmtContext) Relation_factor(i int) IRelation_factorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Flashback_stmtContext) AllTO() []antlr.TerminalNode {
	return s.GetTokens(OBParserTO)
}

func (s *Flashback_stmtContext) TO(i int) antlr.TerminalNode {
	return s.GetToken(OBParserTO, i)
}

func (s *Flashback_stmtContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(OBParserBEFORE, 0)
}

func (s *Flashback_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Flashback_stmtContext) RENAME() antlr.TerminalNode {
	return s.GetToken(OBParserRENAME, 0)
}

func (s *Flashback_stmtContext) Database_key() IDatabase_keyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_keyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_keyContext)
}

func (s *Flashback_stmtContext) AllDatabase_factor() []IDatabase_factorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDatabase_factorContext); ok {
			len++
		}
	}

	tst := make([]IDatabase_factorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDatabase_factorContext); ok {
			tst[i] = t.(IDatabase_factorContext)
			i++
		}
	}

	return tst
}

func (s *Flashback_stmtContext) Database_factor(i int) IDatabase_factorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_factorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_factorContext)
}

func (s *Flashback_stmtContext) TENANT() antlr.TerminalNode {
	return s.GetToken(OBParserTENANT, 0)
}

func (s *Flashback_stmtContext) AllRelation_name() []IRelation_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_nameContext); ok {
			len++
		}
	}

	tst := make([]IRelation_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_nameContext); ok {
			tst[i] = t.(IRelation_nameContext)
			i++
		}
	}

	return tst
}

func (s *Flashback_stmtContext) Relation_name(i int) IRelation_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Flashback_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flashback_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flashback_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterFlashback_stmt(s)
	}
}

func (s *Flashback_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitFlashback_stmt(s)
	}
}

func (s *Flashback_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitFlashback_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Flashback_stmt() (localctx IFlashback_stmtContext) {
	localctx = NewFlashback_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 816, OBParserRULE_flashback_stmt)
	var _la int

	p.SetState(7239)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 749, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7206)
			p.Match(OBParserFLASHBACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7207)
			p.Match(OBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7208)
			p.Relation_factor()
		}
		{
			p.SetState(7209)
			p.Match(OBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7210)
			p.Match(OBParserBEFORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7211)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserRENAME {
			{
				p.SetState(7212)
				p.Match(OBParserRENAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7213)
				p.Match(OBParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7214)
				p.Relation_factor()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7217)
			p.Match(OBParserFLASHBACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7218)
			p.Database_key()
		}
		{
			p.SetState(7219)
			p.Database_factor()
		}
		{
			p.SetState(7220)
			p.Match(OBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7221)
			p.Match(OBParserBEFORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7222)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7226)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserRENAME {
			{
				p.SetState(7223)
				p.Match(OBParserRENAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7224)
				p.Match(OBParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7225)
				p.Database_factor()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7228)
			p.Match(OBParserFLASHBACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7229)
			p.Match(OBParserTENANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7230)
			p.Relation_name()
		}
		{
			p.SetState(7231)
			p.Match(OBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7232)
			p.Match(OBParserBEFORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7233)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7237)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserRENAME {
			{
				p.SetState(7234)
				p.Match(OBParserRENAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7235)
				p.Match(OBParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7236)
				p.Relation_name()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPurge_stmtContext is an interface to support dynamic dispatch.
type IPurge_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PURGE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Relation_factor() IRelation_factorContext
	INDEX() antlr.TerminalNode
	Database_key() IDatabase_keyContext
	Database_factor() IDatabase_factorContext
	TENANT() antlr.TerminalNode
	Relation_name() IRelation_nameContext
	RECYCLEBIN() antlr.TerminalNode

	// IsPurge_stmtContext differentiates from other interfaces.
	IsPurge_stmtContext()
}

type Purge_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPurge_stmtContext() *Purge_stmtContext {
	var p = new(Purge_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_purge_stmt
	return p
}

func InitEmptyPurge_stmtContext(p *Purge_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_purge_stmt
}

func (*Purge_stmtContext) IsPurge_stmtContext() {}

func NewPurge_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Purge_stmtContext {
	var p = new(Purge_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_purge_stmt

	return p
}

func (s *Purge_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Purge_stmtContext) PURGE() antlr.TerminalNode {
	return s.GetToken(OBParserPURGE, 0)
}

func (s *Purge_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE, 0)
}

func (s *Purge_stmtContext) Relation_factor() IRelation_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_factorContext)
}

func (s *Purge_stmtContext) INDEX() antlr.TerminalNode {
	return s.GetToken(OBParserINDEX, 0)
}

func (s *Purge_stmtContext) Database_key() IDatabase_keyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_keyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_keyContext)
}

func (s *Purge_stmtContext) Database_factor() IDatabase_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabase_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabase_factorContext)
}

func (s *Purge_stmtContext) TENANT() antlr.TerminalNode {
	return s.GetToken(OBParserTENANT, 0)
}

func (s *Purge_stmtContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Purge_stmtContext) RECYCLEBIN() antlr.TerminalNode {
	return s.GetToken(OBParserRECYCLEBIN, 0)
}

func (s *Purge_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Purge_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Purge_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterPurge_stmt(s)
	}
}

func (s *Purge_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitPurge_stmt(s)
	}
}

func (s *Purge_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitPurge_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Purge_stmt() (localctx IPurge_stmtContext) {
	localctx = NewPurge_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 818, OBParserRULE_purge_stmt)
	p.SetState(7256)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 750, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7241)
			p.Match(OBParserPURGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7242)
			p.Match(OBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7243)
			p.Relation_factor()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7244)
			p.Match(OBParserPURGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7245)
			p.Match(OBParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7246)
			p.Relation_factor()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7247)
			p.Match(OBParserPURGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7248)
			p.Database_key()
		}
		{
			p.SetState(7249)
			p.Database_factor()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7251)
			p.Match(OBParserPURGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7252)
			p.Match(OBParserTENANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7253)
			p.Relation_name()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7254)
			p.Match(OBParserPURGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7255)
			p.Match(OBParserRECYCLEBIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptimize_stmtContext is an interface to support dynamic dispatch.
type IOptimize_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPTIMIZE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Table_list() ITable_listContext
	TENANT() antlr.TerminalNode
	Relation_name() IRelation_nameContext
	ALL() antlr.TerminalNode

	// IsOptimize_stmtContext differentiates from other interfaces.
	IsOptimize_stmtContext()
}

type Optimize_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptimize_stmtContext() *Optimize_stmtContext {
	var p = new(Optimize_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_optimize_stmt
	return p
}

func InitEmptyOptimize_stmtContext(p *Optimize_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_optimize_stmt
}

func (*Optimize_stmtContext) IsOptimize_stmtContext() {}

func NewOptimize_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Optimize_stmtContext {
	var p = new(Optimize_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_optimize_stmt

	return p
}

func (s *Optimize_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Optimize_stmtContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(OBParserOPTIMIZE, 0)
}

func (s *Optimize_stmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE, 0)
}

func (s *Optimize_stmtContext) Table_list() ITable_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_listContext)
}

func (s *Optimize_stmtContext) TENANT() antlr.TerminalNode {
	return s.GetToken(OBParserTENANT, 0)
}

func (s *Optimize_stmtContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Optimize_stmtContext) ALL() antlr.TerminalNode {
	return s.GetToken(OBParserALL, 0)
}

func (s *Optimize_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Optimize_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Optimize_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterOptimize_stmt(s)
	}
}

func (s *Optimize_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitOptimize_stmt(s)
	}
}

func (s *Optimize_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitOptimize_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Optimize_stmt() (localctx IOptimize_stmtContext) {
	localctx = NewOptimize_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 820, OBParserRULE_optimize_stmt)
	p.SetState(7267)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 751, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7258)
			p.Match(OBParserOPTIMIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7259)
			p.Match(OBParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7260)
			p.Table_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7261)
			p.Match(OBParserOPTIMIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7262)
			p.Match(OBParserTENANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7263)
			p.Relation_name()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7264)
			p.Match(OBParserOPTIMIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7265)
			p.Match(OBParserTENANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7266)
			p.Match(OBParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDump_memory_stmtContext is an interface to support dynamic dispatch.
type IDump_memory_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DUMP() antlr.TerminalNode
	ENTITY() antlr.TerminalNode
	ALL() antlr.TerminalNode
	P_ENTITY() antlr.TerminalNode
	AllCOMP_EQ() []antlr.TerminalNode
	COMP_EQ(i int) antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	Comma() antlr.TerminalNode
	SLOT_IDX() antlr.TerminalNode
	AllINTNUM() []antlr.TerminalNode
	INTNUM(i int) antlr.TerminalNode
	CHUNK() antlr.TerminalNode
	TENANT_ID() antlr.TerminalNode
	CTX_ID() antlr.TerminalNode
	P_CHUNK() antlr.TerminalNode
	SET() antlr.TerminalNode
	LEAK_MOD() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	LEAK() antlr.TerminalNode

	// IsDump_memory_stmtContext differentiates from other interfaces.
	IsDump_memory_stmtContext()
}

type Dump_memory_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDump_memory_stmtContext() *Dump_memory_stmtContext {
	var p = new(Dump_memory_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_dump_memory_stmt
	return p
}

func InitEmptyDump_memory_stmtContext(p *Dump_memory_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_dump_memory_stmt
}

func (*Dump_memory_stmtContext) IsDump_memory_stmtContext() {}

func NewDump_memory_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dump_memory_stmtContext {
	var p = new(Dump_memory_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_dump_memory_stmt

	return p
}

func (s *Dump_memory_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Dump_memory_stmtContext) DUMP() antlr.TerminalNode {
	return s.GetToken(OBParserDUMP, 0)
}

func (s *Dump_memory_stmtContext) ENTITY() antlr.TerminalNode {
	return s.GetToken(OBParserENTITY, 0)
}

func (s *Dump_memory_stmtContext) ALL() antlr.TerminalNode {
	return s.GetToken(OBParserALL, 0)
}

func (s *Dump_memory_stmtContext) P_ENTITY() antlr.TerminalNode {
	return s.GetToken(OBParserP_ENTITY, 0)
}

func (s *Dump_memory_stmtContext) AllCOMP_EQ() []antlr.TerminalNode {
	return s.GetTokens(OBParserCOMP_EQ)
}

func (s *Dump_memory_stmtContext) COMP_EQ(i int) antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, i)
}

func (s *Dump_memory_stmtContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Dump_memory_stmtContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Dump_memory_stmtContext) SLOT_IDX() antlr.TerminalNode {
	return s.GetToken(OBParserSLOT_IDX, 0)
}

func (s *Dump_memory_stmtContext) AllINTNUM() []antlr.TerminalNode {
	return s.GetTokens(OBParserINTNUM)
}

func (s *Dump_memory_stmtContext) INTNUM(i int) antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, i)
}

func (s *Dump_memory_stmtContext) CHUNK() antlr.TerminalNode {
	return s.GetToken(OBParserCHUNK, 0)
}

func (s *Dump_memory_stmtContext) TENANT_ID() antlr.TerminalNode {
	return s.GetToken(OBParserTENANT_ID, 0)
}

func (s *Dump_memory_stmtContext) CTX_ID() antlr.TerminalNode {
	return s.GetToken(OBParserCTX_ID, 0)
}

func (s *Dump_memory_stmtContext) P_CHUNK() antlr.TerminalNode {
	return s.GetToken(OBParserP_CHUNK, 0)
}

func (s *Dump_memory_stmtContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Dump_memory_stmtContext) LEAK_MOD() antlr.TerminalNode {
	return s.GetToken(OBParserLEAK_MOD, 0)
}

func (s *Dump_memory_stmtContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(OBParserMEMORY, 0)
}

func (s *Dump_memory_stmtContext) LEAK() antlr.TerminalNode {
	return s.GetToken(OBParserLEAK, 0)
}

func (s *Dump_memory_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dump_memory_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dump_memory_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDump_memory_stmt(s)
	}
}

func (s *Dump_memory_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDump_memory_stmt(s)
	}
}

func (s *Dump_memory_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDump_memory_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Dump_memory_stmt() (localctx IDump_memory_stmtContext) {
	localctx = NewDump_memory_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 822, OBParserRULE_dump_memory_stmt)
	p.SetState(7305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 752, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7269)
			p.Match(OBParserDUMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7270)
			p.Match(OBParserENTITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7271)
			p.Match(OBParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7272)
			p.Match(OBParserDUMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7273)
			p.Match(OBParserENTITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7274)
			p.Match(OBParserP_ENTITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7275)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7276)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7277)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7278)
			p.Match(OBParserSLOT_IDX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7279)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7280)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7281)
			p.Match(OBParserDUMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7282)
			p.Match(OBParserCHUNK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7283)
			p.Match(OBParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7284)
			p.Match(OBParserDUMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7285)
			p.Match(OBParserCHUNK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7286)
			p.Match(OBParserTENANT_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7287)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7288)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7289)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7290)
			p.Match(OBParserCTX_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7291)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7292)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7293)
			p.Match(OBParserDUMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7294)
			p.Match(OBParserCHUNK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7295)
			p.Match(OBParserP_CHUNK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7296)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7297)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7298)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7299)
			p.Match(OBParserLEAK_MOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7300)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7301)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7302)
			p.Match(OBParserDUMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7303)
			p.Match(OBParserMEMORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7304)
			p.Match(OBParserLEAK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_system_stmtContext is an interface to support dynamic dispatch.
type IAlter_system_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllALTER() []antlr.TerminalNode
	ALTER(i int) antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	BOOTSTRAP() antlr.TerminalNode
	Server_info_list() IServer_info_listContext
	CLUSTER() antlr.TerminalNode
	Cluster_role() ICluster_roleContext
	FLUSH() antlr.TerminalNode
	Cache_type() ICache_typeContext
	CACHE() antlr.TerminalNode
	Flush_scope() IFlush_scopeContext
	TENANT() antlr.TerminalNode
	AllCOMP_EQ() []antlr.TerminalNode
	COMP_EQ(i int) antlr.TerminalNode
	Tenant_name_list() ITenant_name_listContext
	SQL() antlr.TerminalNode
	KVCACHE() antlr.TerminalNode
	Tenant_name() ITenant_nameContext
	Cache_name() ICache_nameContext
	ILOGCACHE() antlr.TerminalNode
	File_id() IFile_idContext
	AllPLAN() []antlr.TerminalNode
	PLAN(i int) antlr.TerminalNode
	BASELINE() antlr.TerminalNode
	SET() antlr.TerminalNode
	Baseline_asgn_factor() IBaseline_asgn_factorContext
	Sql_id_expr() ISql_id_exprContext
	Baseline_id_expr() IBaseline_id_exprContext
	LOAD() antlr.TerminalNode
	FROM() antlr.TerminalNode
	SWITCH() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	Partition_role() IPartition_roleContext
	Partition_id_or_server_or_zone() IPartition_id_or_server_or_zoneContext
	ROOTSERVICE() antlr.TerminalNode
	Server_or_zone() IServer_or_zoneContext
	AllAlter_or_change_or_modify() []IAlter_or_change_or_modifyContext
	Alter_or_change_or_modify(i int) IAlter_or_change_or_modifyContext
	Partition_id_desc() IPartition_id_descContext
	Ip_port() IIp_portContext
	Change_actions() IChange_actionsContext
	FORCE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	CREATE_TIMESTAMP() antlr.TerminalNode
	Opt_equal_mark() IOpt_equal_markContext
	INTNUM() antlr.TerminalNode
	Zone_desc() IZone_descContext
	Migrate_action() IMigrate_actionContext
	SOURCE() antlr.TerminalNode
	AllSTRING_VALUE() []antlr.TerminalNode
	STRING_VALUE(i int) antlr.TerminalNode
	DESTINATION() antlr.TerminalNode
	REPORT() antlr.TerminalNode
	RECYCLE() antlr.TerminalNode
	START() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	Suspend_or_resume() ISuspend_or_resumeContext
	CLEAR() antlr.TerminalNode
	ERROR_P() antlr.TerminalNode
	CANCEL() antlr.TerminalNode
	Cancel_task_type() ICancel_task_typeContext
	TASK() antlr.TerminalNode
	MAJOR() antlr.TerminalNode
	FREEZE() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	Server_list() IServer_listContext
	CHECKPOINT() antlr.TerminalNode
	MINOR() antlr.TerminalNode
	Tenant_list_tuple() ITenant_list_tupleContext
	SERVER() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	ROOTTABLE() antlr.TerminalNode
	Server_action() IServer_actionContext
	ADD() antlr.TerminalNode
	ZONE() antlr.TerminalNode
	Relation_name_or_string() IRelation_name_or_stringContext
	Add_or_alter_zone_options() IAdd_or_alter_zone_optionsContext
	Zone_action() IZone_actionContext
	REFRESH() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	STAT() antlr.TerminalNode
	Alter_system_set_parameter_actions() IAlter_system_set_parameter_actionsContext
	SET_TP() antlr.TerminalNode
	Alter_system_settp_actions() IAlter_system_settp_actionsContext
	LOCATION() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	BALANCE() antlr.TerminalNode
	Zone_list() IZone_listContext
	TYPE() antlr.TerminalNode
	Balance_task_type() IBalance_task_typeContext
	RELOAD() antlr.TerminalNode
	GTS() antlr.TerminalNode
	UNIT() antlr.TerminalNode
	MIGRATE() antlr.TerminalNode
	UPGRADE() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode
	RUN() antlr.TerminalNode
	JOB() antlr.TerminalNode
	Upgrade_action() IUpgrade_actionContext
	ROLLING() antlr.TerminalNode
	TIME_ZONE_INFO() antlr.TerminalNode
	DISK() antlr.TerminalNode
	VALID() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	AllRelation_name() []IRelation_nameContext
	Relation_name(i int) IRelation_nameContext
	AT() antlr.TerminalNode
	UNTIL() antlr.TerminalNode
	WITH() antlr.TerminalNode
	CHANGE() antlr.TerminalNode
	Change_tenant_name_or_tenant_id() IChange_tenant_name_or_tenant_idContext
	TABLES() antlr.TerminalNode
	IN() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	DISKGROUP() antlr.TerminalNode
	NAME() antlr.TerminalNode
	ARCHIVELOG() antlr.TerminalNode
	NOARCHIVELOG() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	INCREMENTAL() antlr.TerminalNode
	SUSPEND() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	EXPIRED() antlr.TerminalNode
	VALIDATE() antlr.TerminalNode
	BACKUPSET() antlr.TerminalNode

	// IsAlter_system_stmtContext differentiates from other interfaces.
	IsAlter_system_stmtContext()
}

type Alter_system_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_system_stmtContext() *Alter_system_stmtContext {
	var p = new(Alter_system_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_system_stmt
	return p
}

func InitEmptyAlter_system_stmtContext(p *Alter_system_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_system_stmt
}

func (*Alter_system_stmtContext) IsAlter_system_stmtContext() {}

func NewAlter_system_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_system_stmtContext {
	var p = new(Alter_system_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_system_stmt

	return p
}

func (s *Alter_system_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_system_stmtContext) AllALTER() []antlr.TerminalNode {
	return s.GetTokens(OBParserALTER)
}

func (s *Alter_system_stmtContext) ALTER(i int) antlr.TerminalNode {
	return s.GetToken(OBParserALTER, i)
}

func (s *Alter_system_stmtContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(OBParserSYSTEM, 0)
}

func (s *Alter_system_stmtContext) BOOTSTRAP() antlr.TerminalNode {
	return s.GetToken(OBParserBOOTSTRAP, 0)
}

func (s *Alter_system_stmtContext) Server_info_list() IServer_info_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServer_info_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServer_info_listContext)
}

func (s *Alter_system_stmtContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(OBParserCLUSTER, 0)
}

func (s *Alter_system_stmtContext) Cluster_role() ICluster_roleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICluster_roleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICluster_roleContext)
}

func (s *Alter_system_stmtContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(OBParserFLUSH, 0)
}

func (s *Alter_system_stmtContext) Cache_type() ICache_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICache_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICache_typeContext)
}

func (s *Alter_system_stmtContext) CACHE() antlr.TerminalNode {
	return s.GetToken(OBParserCACHE, 0)
}

func (s *Alter_system_stmtContext) Flush_scope() IFlush_scopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlush_scopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlush_scopeContext)
}

func (s *Alter_system_stmtContext) TENANT() antlr.TerminalNode {
	return s.GetToken(OBParserTENANT, 0)
}

func (s *Alter_system_stmtContext) AllCOMP_EQ() []antlr.TerminalNode {
	return s.GetTokens(OBParserCOMP_EQ)
}

func (s *Alter_system_stmtContext) COMP_EQ(i int) antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, i)
}

func (s *Alter_system_stmtContext) Tenant_name_list() ITenant_name_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITenant_name_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITenant_name_listContext)
}

func (s *Alter_system_stmtContext) SQL() antlr.TerminalNode {
	return s.GetToken(OBParserSQL, 0)
}

func (s *Alter_system_stmtContext) KVCACHE() antlr.TerminalNode {
	return s.GetToken(OBParserKVCACHE, 0)
}

func (s *Alter_system_stmtContext) Tenant_name() ITenant_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITenant_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITenant_nameContext)
}

func (s *Alter_system_stmtContext) Cache_name() ICache_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICache_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICache_nameContext)
}

func (s *Alter_system_stmtContext) ILOGCACHE() antlr.TerminalNode {
	return s.GetToken(OBParserILOGCACHE, 0)
}

func (s *Alter_system_stmtContext) File_id() IFile_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFile_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFile_idContext)
}

func (s *Alter_system_stmtContext) AllPLAN() []antlr.TerminalNode {
	return s.GetTokens(OBParserPLAN)
}

func (s *Alter_system_stmtContext) PLAN(i int) antlr.TerminalNode {
	return s.GetToken(OBParserPLAN, i)
}

func (s *Alter_system_stmtContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(OBParserBASELINE, 0)
}

func (s *Alter_system_stmtContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Alter_system_stmtContext) Baseline_asgn_factor() IBaseline_asgn_factorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseline_asgn_factorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseline_asgn_factorContext)
}

func (s *Alter_system_stmtContext) Sql_id_expr() ISql_id_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_id_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_id_exprContext)
}

func (s *Alter_system_stmtContext) Baseline_id_expr() IBaseline_id_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseline_id_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseline_id_exprContext)
}

func (s *Alter_system_stmtContext) LOAD() antlr.TerminalNode {
	return s.GetToken(OBParserLOAD, 0)
}

func (s *Alter_system_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(OBParserFROM, 0)
}

func (s *Alter_system_stmtContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(OBParserSWITCH, 0)
}

func (s *Alter_system_stmtContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(OBParserREPLICA, 0)
}

func (s *Alter_system_stmtContext) Partition_role() IPartition_roleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartition_roleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartition_roleContext)
}

func (s *Alter_system_stmtContext) Partition_id_or_server_or_zone() IPartition_id_or_server_or_zoneContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartition_id_or_server_or_zoneContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartition_id_or_server_or_zoneContext)
}

func (s *Alter_system_stmtContext) ROOTSERVICE() antlr.TerminalNode {
	return s.GetToken(OBParserROOTSERVICE, 0)
}

func (s *Alter_system_stmtContext) Server_or_zone() IServer_or_zoneContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServer_or_zoneContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServer_or_zoneContext)
}

func (s *Alter_system_stmtContext) AllAlter_or_change_or_modify() []IAlter_or_change_or_modifyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_or_change_or_modifyContext); ok {
			len++
		}
	}

	tst := make([]IAlter_or_change_or_modifyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_or_change_or_modifyContext); ok {
			tst[i] = t.(IAlter_or_change_or_modifyContext)
			i++
		}
	}

	return tst
}

func (s *Alter_system_stmtContext) Alter_or_change_or_modify(i int) IAlter_or_change_or_modifyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_or_change_or_modifyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_or_change_or_modifyContext)
}

func (s *Alter_system_stmtContext) Partition_id_desc() IPartition_id_descContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartition_id_descContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartition_id_descContext)
}

func (s *Alter_system_stmtContext) Ip_port() IIp_portContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIp_portContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIp_portContext)
}

func (s *Alter_system_stmtContext) Change_actions() IChange_actionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChange_actionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChange_actionsContext)
}

func (s *Alter_system_stmtContext) FORCE() antlr.TerminalNode {
	return s.GetToken(OBParserFORCE, 0)
}

func (s *Alter_system_stmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(OBParserDROP, 0)
}

func (s *Alter_system_stmtContext) CREATE_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE_TIMESTAMP, 0)
}

func (s *Alter_system_stmtContext) Opt_equal_mark() IOpt_equal_markContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpt_equal_markContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpt_equal_markContext)
}

func (s *Alter_system_stmtContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Alter_system_stmtContext) Zone_desc() IZone_descContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IZone_descContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IZone_descContext)
}

func (s *Alter_system_stmtContext) Migrate_action() IMigrate_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMigrate_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMigrate_actionContext)
}

func (s *Alter_system_stmtContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(OBParserSOURCE, 0)
}

func (s *Alter_system_stmtContext) AllSTRING_VALUE() []antlr.TerminalNode {
	return s.GetTokens(OBParserSTRING_VALUE)
}

func (s *Alter_system_stmtContext) STRING_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, i)
}

func (s *Alter_system_stmtContext) DESTINATION() antlr.TerminalNode {
	return s.GetToken(OBParserDESTINATION, 0)
}

func (s *Alter_system_stmtContext) REPORT() antlr.TerminalNode {
	return s.GetToken(OBParserREPORT, 0)
}

func (s *Alter_system_stmtContext) RECYCLE() antlr.TerminalNode {
	return s.GetToken(OBParserRECYCLE, 0)
}

func (s *Alter_system_stmtContext) START() antlr.TerminalNode {
	return s.GetToken(OBParserSTART, 0)
}

func (s *Alter_system_stmtContext) MERGE() antlr.TerminalNode {
	return s.GetToken(OBParserMERGE, 0)
}

func (s *Alter_system_stmtContext) Suspend_or_resume() ISuspend_or_resumeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuspend_or_resumeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuspend_or_resumeContext)
}

func (s *Alter_system_stmtContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(OBParserCLEAR, 0)
}

func (s *Alter_system_stmtContext) ERROR_P() antlr.TerminalNode {
	return s.GetToken(OBParserERROR_P, 0)
}

func (s *Alter_system_stmtContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(OBParserCANCEL, 0)
}

func (s *Alter_system_stmtContext) Cancel_task_type() ICancel_task_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancel_task_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancel_task_typeContext)
}

func (s *Alter_system_stmtContext) TASK() antlr.TerminalNode {
	return s.GetToken(OBParserTASK, 0)
}

func (s *Alter_system_stmtContext) MAJOR() antlr.TerminalNode {
	return s.GetToken(OBParserMAJOR, 0)
}

func (s *Alter_system_stmtContext) FREEZE() antlr.TerminalNode {
	return s.GetToken(OBParserFREEZE, 0)
}

func (s *Alter_system_stmtContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(OBParserIGNORE, 0)
}

func (s *Alter_system_stmtContext) Server_list() IServer_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServer_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServer_listContext)
}

func (s *Alter_system_stmtContext) CHECKPOINT() antlr.TerminalNode {
	return s.GetToken(OBParserCHECKPOINT, 0)
}

func (s *Alter_system_stmtContext) MINOR() antlr.TerminalNode {
	return s.GetToken(OBParserMINOR, 0)
}

func (s *Alter_system_stmtContext) Tenant_list_tuple() ITenant_list_tupleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITenant_list_tupleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITenant_list_tupleContext)
}

func (s *Alter_system_stmtContext) SERVER() antlr.TerminalNode {
	return s.GetToken(OBParserSERVER, 0)
}

func (s *Alter_system_stmtContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Alter_system_stmtContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Alter_system_stmtContext) ROOTTABLE() antlr.TerminalNode {
	return s.GetToken(OBParserROOTTABLE, 0)
}

func (s *Alter_system_stmtContext) Server_action() IServer_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServer_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServer_actionContext)
}

func (s *Alter_system_stmtContext) ADD() antlr.TerminalNode {
	return s.GetToken(OBParserADD, 0)
}

func (s *Alter_system_stmtContext) ZONE() antlr.TerminalNode {
	return s.GetToken(OBParserZONE, 0)
}

func (s *Alter_system_stmtContext) Relation_name_or_string() IRelation_name_or_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_name_or_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_name_or_stringContext)
}

func (s *Alter_system_stmtContext) Add_or_alter_zone_options() IAdd_or_alter_zone_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdd_or_alter_zone_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdd_or_alter_zone_optionsContext)
}

func (s *Alter_system_stmtContext) Zone_action() IZone_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IZone_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IZone_actionContext)
}

func (s *Alter_system_stmtContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(OBParserREFRESH, 0)
}

func (s *Alter_system_stmtContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(OBParserSCHEMA, 0)
}

func (s *Alter_system_stmtContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(OBParserMEMORY, 0)
}

func (s *Alter_system_stmtContext) STAT() antlr.TerminalNode {
	return s.GetToken(OBParserSTAT, 0)
}

func (s *Alter_system_stmtContext) Alter_system_set_parameter_actions() IAlter_system_set_parameter_actionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_system_set_parameter_actionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_system_set_parameter_actionsContext)
}

func (s *Alter_system_stmtContext) SET_TP() antlr.TerminalNode {
	return s.GetToken(OBParserSET_TP, 0)
}

func (s *Alter_system_stmtContext) Alter_system_settp_actions() IAlter_system_settp_actionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_system_settp_actionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_system_settp_actionsContext)
}

func (s *Alter_system_stmtContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(OBParserLOCATION, 0)
}

func (s *Alter_system_stmtContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(OBParserREMOVE, 0)
}

func (s *Alter_system_stmtContext) BALANCE() antlr.TerminalNode {
	return s.GetToken(OBParserBALANCE, 0)
}

func (s *Alter_system_stmtContext) Zone_list() IZone_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IZone_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IZone_listContext)
}

func (s *Alter_system_stmtContext) TYPE() antlr.TerminalNode {
	return s.GetToken(OBParserTYPE, 0)
}

func (s *Alter_system_stmtContext) Balance_task_type() IBalance_task_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBalance_task_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBalance_task_typeContext)
}

func (s *Alter_system_stmtContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(OBParserRELOAD, 0)
}

func (s *Alter_system_stmtContext) GTS() antlr.TerminalNode {
	return s.GetToken(OBParserGTS, 0)
}

func (s *Alter_system_stmtContext) UNIT() antlr.TerminalNode {
	return s.GetToken(OBParserUNIT, 0)
}

func (s *Alter_system_stmtContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(OBParserMIGRATE, 0)
}

func (s *Alter_system_stmtContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(OBParserUPGRADE, 0)
}

func (s *Alter_system_stmtContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(OBParserVIRTUAL, 0)
}

func (s *Alter_system_stmtContext) RUN() antlr.TerminalNode {
	return s.GetToken(OBParserRUN, 0)
}

func (s *Alter_system_stmtContext) JOB() antlr.TerminalNode {
	return s.GetToken(OBParserJOB, 0)
}

func (s *Alter_system_stmtContext) Upgrade_action() IUpgrade_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpgrade_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpgrade_actionContext)
}

func (s *Alter_system_stmtContext) ROLLING() antlr.TerminalNode {
	return s.GetToken(OBParserROLLING, 0)
}

func (s *Alter_system_stmtContext) TIME_ZONE_INFO() antlr.TerminalNode {
	return s.GetToken(OBParserTIME_ZONE_INFO, 0)
}

func (s *Alter_system_stmtContext) DISK() antlr.TerminalNode {
	return s.GetToken(OBParserDISK, 0)
}

func (s *Alter_system_stmtContext) VALID() antlr.TerminalNode {
	return s.GetToken(OBParserVALID, 0)
}

func (s *Alter_system_stmtContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(OBParserRESTORE, 0)
}

func (s *Alter_system_stmtContext) AllRelation_name() []IRelation_nameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_nameContext); ok {
			len++
		}
	}

	tst := make([]IRelation_nameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_nameContext); ok {
			tst[i] = t.(IRelation_nameContext)
			i++
		}
	}

	return tst
}

func (s *Alter_system_stmtContext) Relation_name(i int) IRelation_nameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Alter_system_stmtContext) AT() antlr.TerminalNode {
	return s.GetToken(OBParserAT, 0)
}

func (s *Alter_system_stmtContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(OBParserUNTIL, 0)
}

func (s *Alter_system_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(OBParserWITH, 0)
}

func (s *Alter_system_stmtContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(OBParserCHANGE, 0)
}

func (s *Alter_system_stmtContext) Change_tenant_name_or_tenant_id() IChange_tenant_name_or_tenant_idContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChange_tenant_name_or_tenant_idContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChange_tenant_name_or_tenant_idContext)
}

func (s *Alter_system_stmtContext) TABLES() antlr.TerminalNode {
	return s.GetToken(OBParserTABLES, 0)
}

func (s *Alter_system_stmtContext) IN() antlr.TerminalNode {
	return s.GetToken(OBParserIN, 0)
}

func (s *Alter_system_stmtContext) SESSION() antlr.TerminalNode {
	return s.GetToken(OBParserSESSION, 0)
}

func (s *Alter_system_stmtContext) DISKGROUP() antlr.TerminalNode {
	return s.GetToken(OBParserDISKGROUP, 0)
}

func (s *Alter_system_stmtContext) NAME() antlr.TerminalNode {
	return s.GetToken(OBParserNAME, 0)
}

func (s *Alter_system_stmtContext) ARCHIVELOG() antlr.TerminalNode {
	return s.GetToken(OBParserARCHIVELOG, 0)
}

func (s *Alter_system_stmtContext) NOARCHIVELOG() antlr.TerminalNode {
	return s.GetToken(OBParserNOARCHIVELOG, 0)
}

func (s *Alter_system_stmtContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(OBParserBACKUP, 0)
}

func (s *Alter_system_stmtContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(OBParserDATABASE, 0)
}

func (s *Alter_system_stmtContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(OBParserINCREMENTAL, 0)
}

func (s *Alter_system_stmtContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(OBParserSUSPEND, 0)
}

func (s *Alter_system_stmtContext) RESUME() antlr.TerminalNode {
	return s.GetToken(OBParserRESUME, 0)
}

func (s *Alter_system_stmtContext) DELETE() antlr.TerminalNode {
	return s.GetToken(OBParserDELETE, 0)
}

func (s *Alter_system_stmtContext) EXPIRED() antlr.TerminalNode {
	return s.GetToken(OBParserEXPIRED, 0)
}

func (s *Alter_system_stmtContext) VALIDATE() antlr.TerminalNode {
	return s.GetToken(OBParserVALIDATE, 0)
}

func (s *Alter_system_stmtContext) BACKUPSET() antlr.TerminalNode {
	return s.GetToken(OBParserBACKUPSET, 0)
}

func (s *Alter_system_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_system_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_system_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_system_stmt(s)
	}
}

func (s *Alter_system_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_system_stmt(s)
	}
}

func (s *Alter_system_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_system_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_system_stmt() (localctx IAlter_system_stmtContext) {
	localctx = NewAlter_system_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 824, OBParserRULE_alter_system_stmt)
	var _la int

	p.SetState(7789)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 794, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7307)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7308)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7309)
			p.Match(OBParserBOOTSTRAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCLUSTER {
			{
				p.SetState(7310)
				p.Match(OBParserCLUSTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7311)
				p.Cluster_role()
			}

		}
		{
			p.SetState(7314)
			p.Server_info_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7315)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7316)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7317)
			p.Match(OBParserFLUSH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7318)
			p.Cache_type()
		}
		{
			p.SetState(7319)
			p.Match(OBParserCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7323)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTENANT {
			{
				p.SetState(7320)
				p.Match(OBParserTENANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7321)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7322)
				p.Tenant_name_list()
			}

		}
		{
			p.SetState(7325)
			p.Flush_scope()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7327)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7328)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7329)
			p.Match(OBParserFLUSH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7330)
			p.Match(OBParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7331)
			p.Cache_type()
		}
		p.SetState(7335)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTENANT {
			{
				p.SetState(7332)
				p.Match(OBParserTENANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7333)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7334)
				p.Tenant_name_list()
			}

		}
		{
			p.SetState(7337)
			p.Flush_scope()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7339)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7340)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7341)
			p.Match(OBParserFLUSH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7342)
			p.Match(OBParserKVCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7344)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTENANT {
			{
				p.SetState(7343)
				p.Tenant_name()
			}

		}
		p.SetState(7347)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCACHE {
			{
				p.SetState(7346)
				p.Cache_name()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7349)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7350)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7351)
			p.Match(OBParserFLUSH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7352)
			p.Match(OBParserILOGCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7354)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFILE_ID {
			{
				p.SetState(7353)
				p.File_id()
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7356)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7357)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7358)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7359)
			p.Match(OBParserPLAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7360)
			p.Match(OBParserBASELINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTENANT {
			{
				p.SetState(7361)
				p.Tenant_name()
			}

		}
		p.SetState(7365)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSQL_ID {
			{
				p.SetState(7364)
				p.Sql_id_expr()
			}

		}
		p.SetState(7368)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserBASELINE_ID {
			{
				p.SetState(7367)
				p.Baseline_id_expr()
			}

		}
		{
			p.SetState(7370)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7371)
			p.Baseline_asgn_factor()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7372)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7373)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7374)
			p.Match(OBParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7375)
			p.Match(OBParserPLAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7376)
			p.Match(OBParserBASELINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7377)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7378)
			p.Match(OBParserPLAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7379)
			p.Match(OBParserCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7383)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTENANT {
			{
				p.SetState(7380)
				p.Match(OBParserTENANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7381)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7382)
				p.Tenant_name_list()
			}

		}
		p.SetState(7386)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSQL_ID {
			{
				p.SetState(7385)
				p.Sql_id_expr()
			}

		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7388)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7389)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7390)
			p.Match(OBParserSWITCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7391)
			p.Match(OBParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7392)
			p.Partition_role()
		}
		{
			p.SetState(7393)
			p.Partition_id_or_server_or_zone()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7395)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7396)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7397)
			p.Match(OBParserSWITCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7398)
			p.Match(OBParserROOTSERVICE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7399)
			p.Partition_role()
		}
		{
			p.SetState(7400)
			p.Server_or_zone()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7402)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7403)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7404)
			p.Alter_or_change_or_modify()
		}
		{
			p.SetState(7405)
			p.Match(OBParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7406)
			p.Partition_id_desc()
		}
		{
			p.SetState(7407)
			p.Ip_port()
		}
		{
			p.SetState(7408)
			p.Alter_or_change_or_modify()
		}
		{
			p.SetState(7409)
			p.Change_actions()
		}
		p.SetState(7411)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFORCE {
			{
				p.SetState(7410)
				p.Match(OBParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(7413)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7414)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7415)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7416)
			p.Match(OBParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7417)
			p.Partition_id_desc()
		}
		{
			p.SetState(7418)
			p.Ip_port()
		}
		p.SetState(7423)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCREATE_TIMESTAMP {
			{
				p.SetState(7419)
				p.Match(OBParserCREATE_TIMESTAMP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7420)
				p.Opt_equal_mark()
			}
			{
				p.SetState(7421)
				p.Match(OBParserINTNUM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(7426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserZONE {
			{
				p.SetState(7425)
				p.Zone_desc()
			}

		}
		p.SetState(7429)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFORCE {
			{
				p.SetState(7428)
				p.Match(OBParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(7431)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7432)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7433)
			p.Migrate_action()
		}
		{
			p.SetState(7434)
			p.Match(OBParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7435)
			p.Partition_id_desc()
		}
		{
			p.SetState(7436)
			p.Match(OBParserSOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7438)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(7437)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7440)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7441)
			p.Match(OBParserDESTINATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(7442)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7445)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7447)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserFORCE {
			{
				p.SetState(7446)
				p.Match(OBParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(7449)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7450)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7451)
			p.Match(OBParserREPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7452)
			p.Match(OBParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7454)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSERVER || _la == OBParserZONE {
			{
				p.SetState(7453)
				p.Server_or_zone()
			}

		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(7456)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7457)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7458)
			p.Match(OBParserRECYCLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7459)
			p.Match(OBParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7461)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSERVER || _la == OBParserZONE {
			{
				p.SetState(7460)
				p.Server_or_zone()
			}

		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(7463)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7464)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7465)
			p.Match(OBParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7466)
			p.Match(OBParserMERGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7467)
			p.Zone_desc()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(7468)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7469)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7470)
			p.Suspend_or_resume()
		}
		{
			p.SetState(7471)
			p.Match(OBParserMERGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserZONE {
			{
				p.SetState(7472)
				p.Zone_desc()
			}

		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(7475)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7476)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7477)
			p.Match(OBParserCLEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7478)
			p.Match(OBParserMERGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7479)
			p.Match(OBParserERROR_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(7480)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7481)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7482)
			p.Match(OBParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7483)
			p.Cancel_task_type()
		}
		{
			p.SetState(7484)
			p.Match(OBParserTASK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7485)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(7487)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7488)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7489)
			p.Match(OBParserMAJOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7490)
			p.Match(OBParserFREEZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7493)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserIGNORE {
			{
				p.SetState(7491)
				p.Match(OBParserIGNORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7492)
				p.Server_list()
			}

		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(7495)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7496)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7497)
			p.Match(OBParserCHECKPOINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(7498)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7499)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7500)
			p.Match(OBParserMINOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7501)
			p.Match(OBParserFREEZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7504)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case OBParserTENANT:
			{
				p.SetState(7502)
				p.Tenant_list_tuple()
			}

		case OBParserPARTITION_ID:
			{
				p.SetState(7503)
				p.Partition_id_desc()
			}

		case OBParserEOF, OBParserSERVER, OBParserZONE, OBParserDELIMITER:

		default:
		}
		p.SetState(7512)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSERVER {
			{
				p.SetState(7506)
				p.Match(OBParserSERVER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7507)
				p.Opt_equal_mark()
			}
			{
				p.SetState(7508)
				p.Match(OBParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7509)
				p.Server_list()
			}
			{
				p.SetState(7510)
				p.Match(OBParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(7515)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserZONE {
			{
				p.SetState(7514)
				p.Zone_desc()
			}

		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(7517)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7518)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7519)
			p.Match(OBParserCLEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7520)
			p.Match(OBParserROOTTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7522)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTENANT {
			{
				p.SetState(7521)
				p.Tenant_name()
			}

		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(7524)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7525)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7526)
			p.Server_action()
		}
		{
			p.SetState(7527)
			p.Match(OBParserSERVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7528)
			p.Server_list()
		}
		p.SetState(7530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserZONE {
			{
				p.SetState(7529)
				p.Zone_desc()
			}

		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(7532)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7533)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7534)
			p.Match(OBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7535)
			p.Match(OBParserZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7536)
			p.Relation_name_or_string()
		}
		{
			p.SetState(7537)
			p.add_or_alter_zone_options(0)
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(7539)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7540)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7541)
			p.Zone_action()
		}
		{
			p.SetState(7542)
			p.Match(OBParserZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7543)
			p.Relation_name_or_string()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(7545)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7546)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7547)
			p.Alter_or_change_or_modify()
		}
		{
			p.SetState(7548)
			p.Match(OBParserZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7549)
			p.Relation_name_or_string()
		}
		p.SetState(7551)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 780, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7550)
				p.Match(OBParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7553)
			p.add_or_alter_zone_options(0)
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(7555)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7556)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7557)
			p.Match(OBParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7558)
			p.Match(OBParserSCHEMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7560)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSERVER || _la == OBParserZONE {
			{
				p.SetState(7559)
				p.Server_or_zone()
			}

		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(7562)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7563)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7564)
			p.Match(OBParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7565)
			p.Match(OBParserMEMORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7566)
			p.Match(OBParserSTAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7568)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSERVER || _la == OBParserZONE {
			{
				p.SetState(7567)
				p.Server_or_zone()
			}

		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(7570)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7571)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7573)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSET {
			{
				p.SetState(7572)
				p.Match(OBParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7575)
			p.Alter_system_set_parameter_actions()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(7576)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7577)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7578)
			p.Match(OBParserSET_TP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7579)
			p.alter_system_settp_actions(0)
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(7580)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7581)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7582)
			p.Match(OBParserCLEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7583)
			p.Match(OBParserLOCATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7584)
			p.Match(OBParserCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSERVER || _la == OBParserZONE {
			{
				p.SetState(7585)
				p.Server_or_zone()
			}

		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(7588)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7589)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7590)
			p.Match(OBParserREMOVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7591)
			p.Match(OBParserBALANCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7592)
			p.Match(OBParserTASK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTENANT {
			{
				p.SetState(7593)
				p.Match(OBParserTENANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7594)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7595)
				p.Tenant_name_list()
			}

		}
		p.SetState(7601)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserZONE {
			{
				p.SetState(7598)
				p.Match(OBParserZONE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7599)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7600)
				p.Zone_list()
			}

		}
		p.SetState(7607)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTYPE {
			{
				p.SetState(7603)
				p.Match(OBParserTYPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7604)
				p.Opt_equal_mark()
			}
			{
				p.SetState(7605)
				p.Balance_task_type()
			}

		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(7609)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7610)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7611)
			p.Match(OBParserRELOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7612)
			p.Match(OBParserGTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(7613)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7614)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7615)
			p.Match(OBParserRELOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7616)
			p.Match(OBParserUNIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(7617)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7618)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7619)
			p.Match(OBParserRELOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7620)
			p.Match(OBParserSERVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(7621)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7622)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7623)
			p.Match(OBParserRELOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7624)
			p.Match(OBParserZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(7625)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7626)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7627)
			p.Match(OBParserMIGRATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7628)
			p.Match(OBParserUNIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(7629)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7632)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7633)
			p.Match(OBParserDESTINATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7635)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(7634)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7637)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(7638)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7639)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7640)
			p.Match(OBParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7641)
			p.Match(OBParserMIGRATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7642)
			p.Match(OBParserUNIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7643)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(7644)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7645)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7646)
			p.Match(OBParserUPGRADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7647)
			p.Match(OBParserVIRTUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7648)
			p.Match(OBParserSCHEMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(7649)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7650)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7651)
			p.Match(OBParserRUN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7652)
			p.Match(OBParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7653)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7655)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSERVER || _la == OBParserZONE {
			{
				p.SetState(7654)
				p.Server_or_zone()
			}

		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(7657)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7658)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7659)
			p.Upgrade_action()
		}
		{
			p.SetState(7660)
			p.Match(OBParserUPGRADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(7662)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7663)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7664)
			p.Upgrade_action()
		}
		{
			p.SetState(7665)
			p.Match(OBParserROLLING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7666)
			p.Match(OBParserUPGRADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(7668)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7669)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7670)
			p.Match(OBParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7671)
			p.Match(OBParserTIME_ZONE_INFO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(7672)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7673)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7674)
			p.Match(OBParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7675)
			p.Match(OBParserDISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7676)
			p.Match(OBParserVALID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7677)
			p.Ip_port()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(7678)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7679)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7680)
			p.Match(OBParserRESTORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7681)
			p.Tenant_name()
		}
		{
			p.SetState(7682)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7683)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(7685)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7686)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7687)
			p.Match(OBParserRESTORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7688)
			p.Relation_name()
		}
		{
			p.SetState(7689)
			p.Match(OBParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7690)
			p.Relation_name()
		}
		{
			p.SetState(7691)
			p.Match(OBParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7692)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7693)
			p.Match(OBParserUNTIL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7694)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7695)
			p.Match(OBParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7696)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(7698)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7699)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7700)
			p.Match(OBParserCHANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7701)
			p.Match(OBParserTENANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7702)
			p.Change_tenant_name_or_tenant_id()
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(7703)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7704)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7705)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7706)
			p.Match(OBParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7707)
			p.Match(OBParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7708)
			p.Match(OBParserSESSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7709)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(7710)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7711)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7712)
			p.Match(OBParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7713)
			p.Match(OBParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7714)
			p.Match(OBParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7715)
			p.Match(OBParserSESSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7716)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(7717)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7718)
			p.Match(OBParserDISKGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7719)
			p.Relation_name()
		}
		{
			p.SetState(7720)
			p.Match(OBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7721)
			p.Match(OBParserDISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7722)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserNAME {
			{
				p.SetState(7723)
				p.Match(OBParserNAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7724)
				p.Opt_equal_mark()
			}
			{
				p.SetState(7725)
				p.Relation_name_or_string()
			}

		}
		{
			p.SetState(7729)
			p.Ip_port()
		}
		p.SetState(7731)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserZONE {
			{
				p.SetState(7730)
				p.Zone_desc()
			}

		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(7733)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7734)
			p.Match(OBParserDISKGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7735)
			p.Relation_name()
		}
		{
			p.SetState(7736)
			p.Match(OBParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7737)
			p.Match(OBParserDISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7738)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7739)
			p.Ip_port()
		}
		p.SetState(7741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserZONE {
			{
				p.SetState(7740)
				p.Zone_desc()
			}

		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(7743)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7744)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7745)
			p.Match(OBParserARCHIVELOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(7746)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7747)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7748)
			p.Match(OBParserNOARCHIVELOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(7749)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7750)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7751)
			p.Match(OBParserBACKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7752)
			p.Match(OBParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(7753)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7754)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7755)
			p.Match(OBParserBACKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7756)
			p.Match(OBParserINCREMENTAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7757)
			p.Match(OBParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(7758)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7759)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7760)
			p.Match(OBParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7761)
			p.Match(OBParserBACKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(7762)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7763)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7764)
			p.Match(OBParserSUSPEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7765)
			p.Match(OBParserBACKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(7766)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7767)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7768)
			p.Match(OBParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7769)
			p.Match(OBParserBACKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(7770)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7771)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7772)
			p.Match(OBParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7773)
			p.Match(OBParserEXPIRED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7774)
			p.Match(OBParserBACKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(7775)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7776)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7777)
			p.Match(OBParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7778)
			p.Match(OBParserBACKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7779)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 61:
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(7780)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7781)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7782)
			p.Match(OBParserVALIDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7783)
			p.Match(OBParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 62:
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(7784)
			p.Match(OBParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7785)
			p.Match(OBParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7786)
			p.Match(OBParserVALIDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7787)
			p.Match(OBParserBACKUPSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7788)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChange_tenant_name_or_tenant_idContext is an interface to support dynamic dispatch.
type IChange_tenant_name_or_tenant_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Relation_name_or_string() IRelation_name_or_stringContext
	TENANT_ID() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode

	// IsChange_tenant_name_or_tenant_idContext differentiates from other interfaces.
	IsChange_tenant_name_or_tenant_idContext()
}

type Change_tenant_name_or_tenant_idContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChange_tenant_name_or_tenant_idContext() *Change_tenant_name_or_tenant_idContext {
	var p = new(Change_tenant_name_or_tenant_idContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_change_tenant_name_or_tenant_id
	return p
}

func InitEmptyChange_tenant_name_or_tenant_idContext(p *Change_tenant_name_or_tenant_idContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_change_tenant_name_or_tenant_id
}

func (*Change_tenant_name_or_tenant_idContext) IsChange_tenant_name_or_tenant_idContext() {}

func NewChange_tenant_name_or_tenant_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Change_tenant_name_or_tenant_idContext {
	var p = new(Change_tenant_name_or_tenant_idContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_change_tenant_name_or_tenant_id

	return p
}

func (s *Change_tenant_name_or_tenant_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Change_tenant_name_or_tenant_idContext) Relation_name_or_string() IRelation_name_or_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_name_or_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_name_or_stringContext)
}

func (s *Change_tenant_name_or_tenant_idContext) TENANT_ID() antlr.TerminalNode {
	return s.GetToken(OBParserTENANT_ID, 0)
}

func (s *Change_tenant_name_or_tenant_idContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Change_tenant_name_or_tenant_idContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Change_tenant_name_or_tenant_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Change_tenant_name_or_tenant_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Change_tenant_name_or_tenant_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterChange_tenant_name_or_tenant_id(s)
	}
}

func (s *Change_tenant_name_or_tenant_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitChange_tenant_name_or_tenant_id(s)
	}
}

func (s *Change_tenant_name_or_tenant_idContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitChange_tenant_name_or_tenant_id(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Change_tenant_name_or_tenant_id() (localctx IChange_tenant_name_or_tenant_idContext) {
	localctx = NewChange_tenant_name_or_tenant_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 826, OBParserRULE_change_tenant_name_or_tenant_id)
	var _la int

	p.SetState(7797)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 796, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7791)
			p.Relation_name_or_string()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7792)
			p.Match(OBParserTENANT_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7794)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(7793)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7796)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICache_typeContext is an interface to support dynamic dispatch.
type ICache_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	CLOG() antlr.TerminalNode
	ILOG() antlr.TerminalNode
	COLUMN_STAT() antlr.TerminalNode
	BLOCK_INDEX() antlr.TerminalNode
	BLOCK() antlr.TerminalNode
	ROW() antlr.TerminalNode
	BLOOM_FILTER() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	AUDIT() antlr.TerminalNode
	PL() antlr.TerminalNode

	// IsCache_typeContext differentiates from other interfaces.
	IsCache_typeContext()
}

type Cache_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCache_typeContext() *Cache_typeContext {
	var p = new(Cache_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cache_type
	return p
}

func InitEmptyCache_typeContext(p *Cache_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cache_type
}

func (*Cache_typeContext) IsCache_typeContext() {}

func NewCache_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cache_typeContext {
	var p = new(Cache_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_cache_type

	return p
}

func (s *Cache_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Cache_typeContext) ALL() antlr.TerminalNode {
	return s.GetToken(OBParserALL, 0)
}

func (s *Cache_typeContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(OBParserLOCATION, 0)
}

func (s *Cache_typeContext) CLOG() antlr.TerminalNode {
	return s.GetToken(OBParserCLOG, 0)
}

func (s *Cache_typeContext) ILOG() antlr.TerminalNode {
	return s.GetToken(OBParserILOG, 0)
}

func (s *Cache_typeContext) COLUMN_STAT() antlr.TerminalNode {
	return s.GetToken(OBParserCOLUMN_STAT, 0)
}

func (s *Cache_typeContext) BLOCK_INDEX() antlr.TerminalNode {
	return s.GetToken(OBParserBLOCK_INDEX, 0)
}

func (s *Cache_typeContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(OBParserBLOCK, 0)
}

func (s *Cache_typeContext) ROW() antlr.TerminalNode {
	return s.GetToken(OBParserROW, 0)
}

func (s *Cache_typeContext) BLOOM_FILTER() antlr.TerminalNode {
	return s.GetToken(OBParserBLOOM_FILTER, 0)
}

func (s *Cache_typeContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(OBParserSCHEMA, 0)
}

func (s *Cache_typeContext) PLAN() antlr.TerminalNode {
	return s.GetToken(OBParserPLAN, 0)
}

func (s *Cache_typeContext) AUDIT() antlr.TerminalNode {
	return s.GetToken(OBParserAUDIT, 0)
}

func (s *Cache_typeContext) PL() antlr.TerminalNode {
	return s.GetToken(OBParserPL, 0)
}

func (s *Cache_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cache_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cache_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCache_type(s)
	}
}

func (s *Cache_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCache_type(s)
	}
}

func (s *Cache_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCache_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Cache_type() (localctx ICache_typeContext) {
	localctx = NewCache_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 828, OBParserRULE_cache_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7799)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserALL || _la == OBParserSCHEMA || _la == OBParserAUDIT || _la == OBParserLOCATION || _la == OBParserPL || _la == OBParserPLAN || _la == OBParserCLOG || ((int64((_la-705)) & ^0x3f) == 0 && ((int64(1)<<(_la-705))&51539673153) != 0) || _la == OBParserBLOCK) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBalance_task_typeContext is an interface to support dynamic dispatch.
type IBalance_task_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AUTO() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsBalance_task_typeContext differentiates from other interfaces.
	IsBalance_task_typeContext()
}

type Balance_task_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBalance_task_typeContext() *Balance_task_typeContext {
	var p = new(Balance_task_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_balance_task_type
	return p
}

func InitEmptyBalance_task_typeContext(p *Balance_task_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_balance_task_type
}

func (*Balance_task_typeContext) IsBalance_task_typeContext() {}

func NewBalance_task_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Balance_task_typeContext {
	var p = new(Balance_task_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_balance_task_type

	return p
}

func (s *Balance_task_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Balance_task_typeContext) AUTO() antlr.TerminalNode {
	return s.GetToken(OBParserAUTO, 0)
}

func (s *Balance_task_typeContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(OBParserMANUAL, 0)
}

func (s *Balance_task_typeContext) ALL() antlr.TerminalNode {
	return s.GetToken(OBParserALL, 0)
}

func (s *Balance_task_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Balance_task_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Balance_task_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterBalance_task_type(s)
	}
}

func (s *Balance_task_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitBalance_task_type(s)
	}
}

func (s *Balance_task_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitBalance_task_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Balance_task_type() (localctx IBalance_task_typeContext) {
	localctx = NewBalance_task_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 830, OBParserRULE_balance_task_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7801)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserALL || _la == OBParserMANUAL || _la == OBParserAUTO) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITenant_list_tupleContext is an interface to support dynamic dispatch.
type ITenant_list_tupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TENANT() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Tenant_name_list() ITenant_name_listContext
	RightParen() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode

	// IsTenant_list_tupleContext differentiates from other interfaces.
	IsTenant_list_tupleContext()
}

type Tenant_list_tupleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTenant_list_tupleContext() *Tenant_list_tupleContext {
	var p = new(Tenant_list_tupleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tenant_list_tuple
	return p
}

func InitEmptyTenant_list_tupleContext(p *Tenant_list_tupleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tenant_list_tuple
}

func (*Tenant_list_tupleContext) IsTenant_list_tupleContext() {}

func NewTenant_list_tupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tenant_list_tupleContext {
	var p = new(Tenant_list_tupleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tenant_list_tuple

	return p
}

func (s *Tenant_list_tupleContext) GetParser() antlr.Parser { return s.parser }

func (s *Tenant_list_tupleContext) TENANT() antlr.TerminalNode {
	return s.GetToken(OBParserTENANT, 0)
}

func (s *Tenant_list_tupleContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(OBParserLeftParen, 0)
}

func (s *Tenant_list_tupleContext) Tenant_name_list() ITenant_name_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITenant_name_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITenant_name_listContext)
}

func (s *Tenant_list_tupleContext) RightParen() antlr.TerminalNode {
	return s.GetToken(OBParserRightParen, 0)
}

func (s *Tenant_list_tupleContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Tenant_list_tupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tenant_list_tupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tenant_list_tupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTenant_list_tuple(s)
	}
}

func (s *Tenant_list_tupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTenant_list_tuple(s)
	}
}

func (s *Tenant_list_tupleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTenant_list_tuple(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tenant_list_tuple() (localctx ITenant_list_tupleContext) {
	localctx = NewTenant_list_tupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 832, OBParserRULE_tenant_list_tuple)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7803)
		p.Match(OBParserTENANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7805)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCOMP_EQ {
		{
			p.SetState(7804)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7807)
		p.Match(OBParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7808)
		p.Tenant_name_list()
	}
	{
		p.SetState(7809)
		p.Match(OBParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITenant_name_listContext is an interface to support dynamic dispatch.
type ITenant_name_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelation_name_or_string() []IRelation_name_or_stringContext
	Relation_name_or_string(i int) IRelation_name_or_stringContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsTenant_name_listContext differentiates from other interfaces.
	IsTenant_name_listContext()
}

type Tenant_name_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTenant_name_listContext() *Tenant_name_listContext {
	var p = new(Tenant_name_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tenant_name_list
	return p
}

func InitEmptyTenant_name_listContext(p *Tenant_name_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tenant_name_list
}

func (*Tenant_name_listContext) IsTenant_name_listContext() {}

func NewTenant_name_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tenant_name_listContext {
	var p = new(Tenant_name_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tenant_name_list

	return p
}

func (s *Tenant_name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Tenant_name_listContext) AllRelation_name_or_string() []IRelation_name_or_stringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_name_or_stringContext); ok {
			len++
		}
	}

	tst := make([]IRelation_name_or_stringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_name_or_stringContext); ok {
			tst[i] = t.(IRelation_name_or_stringContext)
			i++
		}
	}

	return tst
}

func (s *Tenant_name_listContext) Relation_name_or_string(i int) IRelation_name_or_stringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_name_or_stringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_name_or_stringContext)
}

func (s *Tenant_name_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Tenant_name_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Tenant_name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tenant_name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tenant_name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTenant_name_list(s)
	}
}

func (s *Tenant_name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTenant_name_list(s)
	}
}

func (s *Tenant_name_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTenant_name_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tenant_name_list() (localctx ITenant_name_listContext) {
	localctx = NewTenant_name_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 834, OBParserRULE_tenant_name_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7811)
		p.Relation_name_or_string()
	}
	p.SetState(7816)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(7812)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7813)
			p.Relation_name_or_string()
		}

		p.SetState(7818)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlush_scopeContext is an interface to support dynamic dispatch.
type IFlush_scopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL() antlr.TerminalNode

	// IsFlush_scopeContext differentiates from other interfaces.
	IsFlush_scopeContext()
}

type Flush_scopeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlush_scopeContext() *Flush_scopeContext {
	var p = new(Flush_scopeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_flush_scope
	return p
}

func InitEmptyFlush_scopeContext(p *Flush_scopeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_flush_scope
}

func (*Flush_scopeContext) IsFlush_scopeContext() {}

func NewFlush_scopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flush_scopeContext {
	var p = new(Flush_scopeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_flush_scope

	return p
}

func (s *Flush_scopeContext) GetParser() antlr.Parser { return s.parser }

func (s *Flush_scopeContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(OBParserGLOBAL, 0)
}

func (s *Flush_scopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flush_scopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flush_scopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterFlush_scope(s)
	}
}

func (s *Flush_scopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitFlush_scope(s)
	}
}

func (s *Flush_scopeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitFlush_scope(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Flush_scope() (localctx IFlush_scopeContext) {
	localctx = NewFlush_scopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 836, OBParserRULE_flush_scope)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7820)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserGLOBAL {
		{
			p.SetState(7819)
			p.Match(OBParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServer_info_listContext is an interface to support dynamic dispatch.
type IServer_info_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllServer_info() []IServer_infoContext
	Server_info(i int) IServer_infoContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsServer_info_listContext differentiates from other interfaces.
	IsServer_info_listContext()
}

type Server_info_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServer_info_listContext() *Server_info_listContext {
	var p = new(Server_info_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_server_info_list
	return p
}

func InitEmptyServer_info_listContext(p *Server_info_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_server_info_list
}

func (*Server_info_listContext) IsServer_info_listContext() {}

func NewServer_info_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Server_info_listContext {
	var p = new(Server_info_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_server_info_list

	return p
}

func (s *Server_info_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Server_info_listContext) AllServer_info() []IServer_infoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IServer_infoContext); ok {
			len++
		}
	}

	tst := make([]IServer_infoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IServer_infoContext); ok {
			tst[i] = t.(IServer_infoContext)
			i++
		}
	}

	return tst
}

func (s *Server_info_listContext) Server_info(i int) IServer_infoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServer_infoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServer_infoContext)
}

func (s *Server_info_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Server_info_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Server_info_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Server_info_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Server_info_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterServer_info_list(s)
	}
}

func (s *Server_info_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitServer_info_list(s)
	}
}

func (s *Server_info_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitServer_info_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Server_info_list() (localctx IServer_info_listContext) {
	localctx = NewServer_info_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 838, OBParserRULE_server_info_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7822)
		p.Server_info()
	}
	p.SetState(7827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(7823)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7824)
			p.Server_info()
		}

		p.SetState(7829)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServer_infoContext is an interface to support dynamic dispatch.
type IServer_infoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REGION() antlr.TerminalNode
	AllRelation_name_or_string() []IRelation_name_or_stringContext
	Relation_name_or_string(i int) IRelation_name_or_stringContext
	ZONE() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	AllCOMP_EQ() []antlr.TerminalNode
	COMP_EQ(i int) antlr.TerminalNode

	// IsServer_infoContext differentiates from other interfaces.
	IsServer_infoContext()
}

type Server_infoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServer_infoContext() *Server_infoContext {
	var p = new(Server_infoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_server_info
	return p
}

func InitEmptyServer_infoContext(p *Server_infoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_server_info
}

func (*Server_infoContext) IsServer_infoContext() {}

func NewServer_infoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Server_infoContext {
	var p = new(Server_infoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_server_info

	return p
}

func (s *Server_infoContext) GetParser() antlr.Parser { return s.parser }

func (s *Server_infoContext) REGION() antlr.TerminalNode {
	return s.GetToken(OBParserREGION, 0)
}

func (s *Server_infoContext) AllRelation_name_or_string() []IRelation_name_or_stringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelation_name_or_stringContext); ok {
			len++
		}
	}

	tst := make([]IRelation_name_or_stringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelation_name_or_stringContext); ok {
			tst[i] = t.(IRelation_name_or_stringContext)
			i++
		}
	}

	return tst
}

func (s *Server_infoContext) Relation_name_or_string(i int) IRelation_name_or_stringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_name_or_stringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_name_or_stringContext)
}

func (s *Server_infoContext) ZONE() antlr.TerminalNode {
	return s.GetToken(OBParserZONE, 0)
}

func (s *Server_infoContext) SERVER() antlr.TerminalNode {
	return s.GetToken(OBParserSERVER, 0)
}

func (s *Server_infoContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Server_infoContext) AllCOMP_EQ() []antlr.TerminalNode {
	return s.GetTokens(OBParserCOMP_EQ)
}

func (s *Server_infoContext) COMP_EQ(i int) antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, i)
}

func (s *Server_infoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Server_infoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Server_infoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterServer_info(s)
	}
}

func (s *Server_infoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitServer_info(s)
	}
}

func (s *Server_infoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitServer_info(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Server_info() (localctx IServer_infoContext) {
	localctx = NewServer_infoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 840, OBParserRULE_server_info)
	var _la int

	p.SetState(7857)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserREGION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7830)
			p.Match(OBParserREGION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7832)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(7831)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7834)
			p.Relation_name_or_string()
		}
		{
			p.SetState(7835)
			p.Match(OBParserZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7837)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(7836)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7839)
			p.Relation_name_or_string()
		}
		{
			p.SetState(7840)
			p.Match(OBParserSERVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7842)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(7841)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7844)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserZONE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7846)
			p.Match(OBParserZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7848)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(7847)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7850)
			p.Relation_name_or_string()
		}
		{
			p.SetState(7851)
			p.Match(OBParserSERVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7853)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(7852)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7855)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServer_actionContext is an interface to support dynamic dispatch.
type IServer_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	CANCEL() antlr.TerminalNode
	START() antlr.TerminalNode
	STOP() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	ISOLATE() antlr.TerminalNode

	// IsServer_actionContext differentiates from other interfaces.
	IsServer_actionContext()
}

type Server_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServer_actionContext() *Server_actionContext {
	var p = new(Server_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_server_action
	return p
}

func InitEmptyServer_actionContext(p *Server_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_server_action
}

func (*Server_actionContext) IsServer_actionContext() {}

func NewServer_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Server_actionContext {
	var p = new(Server_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_server_action

	return p
}

func (s *Server_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Server_actionContext) ADD() antlr.TerminalNode {
	return s.GetToken(OBParserADD, 0)
}

func (s *Server_actionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(OBParserDELETE, 0)
}

func (s *Server_actionContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(OBParserCANCEL, 0)
}

func (s *Server_actionContext) START() antlr.TerminalNode {
	return s.GetToken(OBParserSTART, 0)
}

func (s *Server_actionContext) STOP() antlr.TerminalNode {
	return s.GetToken(OBParserSTOP, 0)
}

func (s *Server_actionContext) FORCE() antlr.TerminalNode {
	return s.GetToken(OBParserFORCE, 0)
}

func (s *Server_actionContext) ISOLATE() antlr.TerminalNode {
	return s.GetToken(OBParserISOLATE, 0)
}

func (s *Server_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Server_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Server_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterServer_action(s)
	}
}

func (s *Server_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitServer_action(s)
	}
}

func (s *Server_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitServer_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Server_action() (localctx IServer_actionContext) {
	localctx = NewServer_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 842, OBParserRULE_server_action)
	p.SetState(7868)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserADD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7859)
			p.Match(OBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserDELETE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7860)
			p.Match(OBParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserCANCEL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7861)
			p.Match(OBParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7862)
			p.Match(OBParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserSTART:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7863)
			p.Match(OBParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserSTOP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7864)
			p.Match(OBParserSTOP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserFORCE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7865)
			p.Match(OBParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7866)
			p.Match(OBParserSTOP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserISOLATE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7867)
			p.Match(OBParserISOLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServer_listContext is an interface to support dynamic dispatch.
type IServer_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_VALUE() []antlr.TerminalNode
	STRING_VALUE(i int) antlr.TerminalNode
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsServer_listContext differentiates from other interfaces.
	IsServer_listContext()
}

type Server_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServer_listContext() *Server_listContext {
	var p = new(Server_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_server_list
	return p
}

func InitEmptyServer_listContext(p *Server_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_server_list
}

func (*Server_listContext) IsServer_listContext() {}

func NewServer_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Server_listContext {
	var p = new(Server_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_server_list

	return p
}

func (s *Server_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Server_listContext) AllSTRING_VALUE() []antlr.TerminalNode {
	return s.GetTokens(OBParserSTRING_VALUE)
}

func (s *Server_listContext) STRING_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, i)
}

func (s *Server_listContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Server_listContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Server_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Server_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Server_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterServer_list(s)
	}
}

func (s *Server_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitServer_list(s)
	}
}

func (s *Server_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitServer_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Server_list() (localctx IServer_listContext) {
	localctx = NewServer_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 844, OBParserRULE_server_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7870)
		p.Match(OBParserSTRING_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7875)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(7871)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7872)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(7877)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IZone_actionContext is an interface to support dynamic dispatch.
type IZone_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	START() antlr.TerminalNode
	STOP() antlr.TerminalNode
	FORCE() antlr.TerminalNode

	// IsZone_actionContext differentiates from other interfaces.
	IsZone_actionContext()
}

type Zone_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyZone_actionContext() *Zone_actionContext {
	var p = new(Zone_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_zone_action
	return p
}

func InitEmptyZone_actionContext(p *Zone_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_zone_action
}

func (*Zone_actionContext) IsZone_actionContext() {}

func NewZone_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Zone_actionContext {
	var p = new(Zone_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_zone_action

	return p
}

func (s *Zone_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Zone_actionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(OBParserDELETE, 0)
}

func (s *Zone_actionContext) START() antlr.TerminalNode {
	return s.GetToken(OBParserSTART, 0)
}

func (s *Zone_actionContext) STOP() antlr.TerminalNode {
	return s.GetToken(OBParserSTOP, 0)
}

func (s *Zone_actionContext) FORCE() antlr.TerminalNode {
	return s.GetToken(OBParserFORCE, 0)
}

func (s *Zone_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Zone_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Zone_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterZone_action(s)
	}
}

func (s *Zone_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitZone_action(s)
	}
}

func (s *Zone_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitZone_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Zone_action() (localctx IZone_actionContext) {
	localctx = NewZone_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 846, OBParserRULE_zone_action)
	p.SetState(7883)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserDELETE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7878)
			p.Match(OBParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserSTART:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7879)
			p.Match(OBParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserSTOP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7880)
			p.Match(OBParserSTOP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserFORCE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7881)
			p.Match(OBParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7882)
			p.Match(OBParserSTOP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIp_portContext is an interface to support dynamic dispatch.
type IIp_portContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SERVER() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode

	// IsIp_portContext differentiates from other interfaces.
	IsIp_portContext()
}

type Ip_portContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIp_portContext() *Ip_portContext {
	var p = new(Ip_portContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_ip_port
	return p
}

func InitEmptyIp_portContext(p *Ip_portContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_ip_port
}

func (*Ip_portContext) IsIp_portContext() {}

func NewIp_portContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ip_portContext {
	var p = new(Ip_portContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_ip_port

	return p
}

func (s *Ip_portContext) GetParser() antlr.Parser { return s.parser }

func (s *Ip_portContext) SERVER() antlr.TerminalNode {
	return s.GetToken(OBParserSERVER, 0)
}

func (s *Ip_portContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Ip_portContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Ip_portContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ip_portContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ip_portContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterIp_port(s)
	}
}

func (s *Ip_portContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitIp_port(s)
	}
}

func (s *Ip_portContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitIp_port(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Ip_port() (localctx IIp_portContext) {
	localctx = NewIp_portContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 848, OBParserRULE_ip_port)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7885)
		p.Match(OBParserSERVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7887)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCOMP_EQ {
		{
			p.SetState(7886)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7889)
		p.Match(OBParserSTRING_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IZone_descContext is an interface to support dynamic dispatch.
type IZone_descContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ZONE() antlr.TerminalNode
	Relation_name_or_string() IRelation_name_or_stringContext
	COMP_EQ() antlr.TerminalNode

	// IsZone_descContext differentiates from other interfaces.
	IsZone_descContext()
}

type Zone_descContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyZone_descContext() *Zone_descContext {
	var p = new(Zone_descContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_zone_desc
	return p
}

func InitEmptyZone_descContext(p *Zone_descContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_zone_desc
}

func (*Zone_descContext) IsZone_descContext() {}

func NewZone_descContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Zone_descContext {
	var p = new(Zone_descContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_zone_desc

	return p
}

func (s *Zone_descContext) GetParser() antlr.Parser { return s.parser }

func (s *Zone_descContext) ZONE() antlr.TerminalNode {
	return s.GetToken(OBParserZONE, 0)
}

func (s *Zone_descContext) Relation_name_or_string() IRelation_name_or_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_name_or_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_name_or_stringContext)
}

func (s *Zone_descContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Zone_descContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Zone_descContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Zone_descContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterZone_desc(s)
	}
}

func (s *Zone_descContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitZone_desc(s)
	}
}

func (s *Zone_descContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitZone_desc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Zone_desc() (localctx IZone_descContext) {
	localctx = NewZone_descContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 850, OBParserRULE_zone_desc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7891)
		p.Match(OBParserZONE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7893)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCOMP_EQ {
		{
			p.SetState(7892)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7895)
		p.Relation_name_or_string()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServer_or_zoneContext is an interface to support dynamic dispatch.
type IServer_or_zoneContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ip_port() IIp_portContext
	Zone_desc() IZone_descContext

	// IsServer_or_zoneContext differentiates from other interfaces.
	IsServer_or_zoneContext()
}

type Server_or_zoneContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServer_or_zoneContext() *Server_or_zoneContext {
	var p = new(Server_or_zoneContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_server_or_zone
	return p
}

func InitEmptyServer_or_zoneContext(p *Server_or_zoneContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_server_or_zone
}

func (*Server_or_zoneContext) IsServer_or_zoneContext() {}

func NewServer_or_zoneContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Server_or_zoneContext {
	var p = new(Server_or_zoneContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_server_or_zone

	return p
}

func (s *Server_or_zoneContext) GetParser() antlr.Parser { return s.parser }

func (s *Server_or_zoneContext) Ip_port() IIp_portContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIp_portContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIp_portContext)
}

func (s *Server_or_zoneContext) Zone_desc() IZone_descContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IZone_descContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IZone_descContext)
}

func (s *Server_or_zoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Server_or_zoneContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Server_or_zoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterServer_or_zone(s)
	}
}

func (s *Server_or_zoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitServer_or_zone(s)
	}
}

func (s *Server_or_zoneContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitServer_or_zone(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Server_or_zone() (localctx IServer_or_zoneContext) {
	localctx = NewServer_or_zoneContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 852, OBParserRULE_server_or_zone)
	p.SetState(7899)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserSERVER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7897)
			p.Ip_port()
		}

	case OBParserZONE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7898)
			p.Zone_desc()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdd_or_alter_zone_optionContext is an interface to support dynamic dispatch.
type IAdd_or_alter_zone_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REGION() antlr.TerminalNode
	Relation_name_or_string() IRelation_name_or_stringContext
	COMP_EQ() antlr.TerminalNode
	IDC() antlr.TerminalNode
	ZONE_TYPE() antlr.TerminalNode

	// IsAdd_or_alter_zone_optionContext differentiates from other interfaces.
	IsAdd_or_alter_zone_optionContext()
}

type Add_or_alter_zone_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdd_or_alter_zone_optionContext() *Add_or_alter_zone_optionContext {
	var p = new(Add_or_alter_zone_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_add_or_alter_zone_option
	return p
}

func InitEmptyAdd_or_alter_zone_optionContext(p *Add_or_alter_zone_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_add_or_alter_zone_option
}

func (*Add_or_alter_zone_optionContext) IsAdd_or_alter_zone_optionContext() {}

func NewAdd_or_alter_zone_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Add_or_alter_zone_optionContext {
	var p = new(Add_or_alter_zone_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_add_or_alter_zone_option

	return p
}

func (s *Add_or_alter_zone_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Add_or_alter_zone_optionContext) REGION() antlr.TerminalNode {
	return s.GetToken(OBParserREGION, 0)
}

func (s *Add_or_alter_zone_optionContext) Relation_name_or_string() IRelation_name_or_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_name_or_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_name_or_stringContext)
}

func (s *Add_or_alter_zone_optionContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Add_or_alter_zone_optionContext) IDC() antlr.TerminalNode {
	return s.GetToken(OBParserIDC, 0)
}

func (s *Add_or_alter_zone_optionContext) ZONE_TYPE() antlr.TerminalNode {
	return s.GetToken(OBParserZONE_TYPE, 0)
}

func (s *Add_or_alter_zone_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_or_alter_zone_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Add_or_alter_zone_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAdd_or_alter_zone_option(s)
	}
}

func (s *Add_or_alter_zone_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAdd_or_alter_zone_option(s)
	}
}

func (s *Add_or_alter_zone_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAdd_or_alter_zone_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Add_or_alter_zone_option() (localctx IAdd_or_alter_zone_optionContext) {
	localctx = NewAdd_or_alter_zone_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 854, OBParserRULE_add_or_alter_zone_option)
	var _la int

	p.SetState(7916)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserREGION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7901)
			p.Match(OBParserREGION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7903)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(7902)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7905)
			p.Relation_name_or_string()
		}

	case OBParserIDC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7906)
			p.Match(OBParserIDC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(7907)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7910)
			p.Relation_name_or_string()
		}

	case OBParserZONE_TYPE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7911)
			p.Match(OBParserZONE_TYPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(7912)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7915)
			p.Relation_name_or_string()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdd_or_alter_zone_optionsContext is an interface to support dynamic dispatch.
type IAdd_or_alter_zone_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Add_or_alter_zone_option() IAdd_or_alter_zone_optionContext
	Empty() IEmptyContext
	Add_or_alter_zone_options() IAdd_or_alter_zone_optionsContext
	Comma() antlr.TerminalNode

	// IsAdd_or_alter_zone_optionsContext differentiates from other interfaces.
	IsAdd_or_alter_zone_optionsContext()
}

type Add_or_alter_zone_optionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdd_or_alter_zone_optionsContext() *Add_or_alter_zone_optionsContext {
	var p = new(Add_or_alter_zone_optionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_add_or_alter_zone_options
	return p
}

func InitEmptyAdd_or_alter_zone_optionsContext(p *Add_or_alter_zone_optionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_add_or_alter_zone_options
}

func (*Add_or_alter_zone_optionsContext) IsAdd_or_alter_zone_optionsContext() {}

func NewAdd_or_alter_zone_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Add_or_alter_zone_optionsContext {
	var p = new(Add_or_alter_zone_optionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_add_or_alter_zone_options

	return p
}

func (s *Add_or_alter_zone_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Add_or_alter_zone_optionsContext) Add_or_alter_zone_option() IAdd_or_alter_zone_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdd_or_alter_zone_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdd_or_alter_zone_optionContext)
}

func (s *Add_or_alter_zone_optionsContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Add_or_alter_zone_optionsContext) Add_or_alter_zone_options() IAdd_or_alter_zone_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdd_or_alter_zone_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdd_or_alter_zone_optionsContext)
}

func (s *Add_or_alter_zone_optionsContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Add_or_alter_zone_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_or_alter_zone_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Add_or_alter_zone_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAdd_or_alter_zone_options(s)
	}
}

func (s *Add_or_alter_zone_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAdd_or_alter_zone_options(s)
	}
}

func (s *Add_or_alter_zone_optionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAdd_or_alter_zone_options(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Add_or_alter_zone_options() (localctx IAdd_or_alter_zone_optionsContext) {
	return p.add_or_alter_zone_options(0)
}

func (p *OBParser) add_or_alter_zone_options(_p int) (localctx IAdd_or_alter_zone_optionsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewAdd_or_alter_zone_optionsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAdd_or_alter_zone_optionsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 856
	p.EnterRecursionRule(localctx, 856, OBParserRULE_add_or_alter_zone_options, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7921)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 817, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(7919)
			p.Add_or_alter_zone_option()
		}

	case 2:
		{
			p.SetState(7920)
			p.Empty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(7928)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 818, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAdd_or_alter_zone_optionsContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, OBParserRULE_add_or_alter_zone_options)
			p.SetState(7923)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(7924)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7925)
				p.Add_or_alter_zone_option()
			}

		}
		p.SetState(7930)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 818, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_or_change_or_modifyContext is an interface to support dynamic dispatch.
type IAlter_or_change_or_modifyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	CHANGE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode

	// IsAlter_or_change_or_modifyContext differentiates from other interfaces.
	IsAlter_or_change_or_modifyContext()
}

type Alter_or_change_or_modifyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_or_change_or_modifyContext() *Alter_or_change_or_modifyContext {
	var p = new(Alter_or_change_or_modifyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_or_change_or_modify
	return p
}

func InitEmptyAlter_or_change_or_modifyContext(p *Alter_or_change_or_modifyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_or_change_or_modify
}

func (*Alter_or_change_or_modifyContext) IsAlter_or_change_or_modifyContext() {}

func NewAlter_or_change_or_modifyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_or_change_or_modifyContext {
	var p = new(Alter_or_change_or_modifyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_or_change_or_modify

	return p
}

func (s *Alter_or_change_or_modifyContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_or_change_or_modifyContext) ALTER() antlr.TerminalNode {
	return s.GetToken(OBParserALTER, 0)
}

func (s *Alter_or_change_or_modifyContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(OBParserCHANGE, 0)
}

func (s *Alter_or_change_or_modifyContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(OBParserMODIFY, 0)
}

func (s *Alter_or_change_or_modifyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_or_change_or_modifyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_or_change_or_modifyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_or_change_or_modify(s)
	}
}

func (s *Alter_or_change_or_modifyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_or_change_or_modify(s)
	}
}

func (s *Alter_or_change_or_modifyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_or_change_or_modify(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_or_change_or_modify() (localctx IAlter_or_change_or_modifyContext) {
	localctx = NewAlter_or_change_or_modifyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 858, OBParserRULE_alter_or_change_or_modify)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7931)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserALTER || _la == OBParserCHANGE || _la == OBParserMODIFY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartition_id_descContext is an interface to support dynamic dispatch.
type IPartition_id_descContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION_ID() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode

	// IsPartition_id_descContext differentiates from other interfaces.
	IsPartition_id_descContext()
}

type Partition_id_descContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartition_id_descContext() *Partition_id_descContext {
	var p = new(Partition_id_descContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_partition_id_desc
	return p
}

func InitEmptyPartition_id_descContext(p *Partition_id_descContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_partition_id_desc
}

func (*Partition_id_descContext) IsPartition_id_descContext() {}

func NewPartition_id_descContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_id_descContext {
	var p = new(Partition_id_descContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_partition_id_desc

	return p
}

func (s *Partition_id_descContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_id_descContext) PARTITION_ID() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION_ID, 0)
}

func (s *Partition_id_descContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Partition_id_descContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Partition_id_descContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_id_descContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Partition_id_descContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterPartition_id_desc(s)
	}
}

func (s *Partition_id_descContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitPartition_id_desc(s)
	}
}

func (s *Partition_id_descContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitPartition_id_desc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Partition_id_desc() (localctx IPartition_id_descContext) {
	localctx = NewPartition_id_descContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 860, OBParserRULE_partition_id_desc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7933)
		p.Match(OBParserPARTITION_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7935)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCOMP_EQ {
		{
			p.SetState(7934)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7937)
		p.Match(OBParserSTRING_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartition_id_or_server_or_zoneContext is an interface to support dynamic dispatch.
type IPartition_id_or_server_or_zoneContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Partition_id_desc() IPartition_id_descContext
	Ip_port() IIp_portContext
	Tenant_name() ITenant_nameContext
	Zone_desc() IZone_descContext

	// IsPartition_id_or_server_or_zoneContext differentiates from other interfaces.
	IsPartition_id_or_server_or_zoneContext()
}

type Partition_id_or_server_or_zoneContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartition_id_or_server_or_zoneContext() *Partition_id_or_server_or_zoneContext {
	var p = new(Partition_id_or_server_or_zoneContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_partition_id_or_server_or_zone
	return p
}

func InitEmptyPartition_id_or_server_or_zoneContext(p *Partition_id_or_server_or_zoneContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_partition_id_or_server_or_zone
}

func (*Partition_id_or_server_or_zoneContext) IsPartition_id_or_server_or_zoneContext() {}

func NewPartition_id_or_server_or_zoneContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_id_or_server_or_zoneContext {
	var p = new(Partition_id_or_server_or_zoneContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_partition_id_or_server_or_zone

	return p
}

func (s *Partition_id_or_server_or_zoneContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_id_or_server_or_zoneContext) Partition_id_desc() IPartition_id_descContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartition_id_descContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartition_id_descContext)
}

func (s *Partition_id_or_server_or_zoneContext) Ip_port() IIp_portContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIp_portContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIp_portContext)
}

func (s *Partition_id_or_server_or_zoneContext) Tenant_name() ITenant_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITenant_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITenant_nameContext)
}

func (s *Partition_id_or_server_or_zoneContext) Zone_desc() IZone_descContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IZone_descContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IZone_descContext)
}

func (s *Partition_id_or_server_or_zoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_id_or_server_or_zoneContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Partition_id_or_server_or_zoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterPartition_id_or_server_or_zone(s)
	}
}

func (s *Partition_id_or_server_or_zoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitPartition_id_or_server_or_zone(s)
	}
}

func (s *Partition_id_or_server_or_zoneContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitPartition_id_or_server_or_zone(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Partition_id_or_server_or_zone() (localctx IPartition_id_or_server_or_zoneContext) {
	localctx = NewPartition_id_or_server_or_zoneContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 862, OBParserRULE_partition_id_or_server_or_zone)
	var _la int

	p.SetState(7950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserPARTITION_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7939)
			p.Partition_id_desc()
		}
		{
			p.SetState(7940)
			p.Ip_port()
		}

	case OBParserSERVER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7942)
			p.Ip_port()
		}
		p.SetState(7944)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTENANT {
			{
				p.SetState(7943)
				p.Tenant_name()
			}

		}

	case OBParserZONE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7946)
			p.Zone_desc()
		}
		p.SetState(7948)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTENANT {
			{
				p.SetState(7947)
				p.Tenant_name()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMigrate_actionContext is an interface to support dynamic dispatch.
type IMigrate_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MOVE() antlr.TerminalNode
	COPY() antlr.TerminalNode

	// IsMigrate_actionContext differentiates from other interfaces.
	IsMigrate_actionContext()
}

type Migrate_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMigrate_actionContext() *Migrate_actionContext {
	var p = new(Migrate_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_migrate_action
	return p
}

func InitEmptyMigrate_actionContext(p *Migrate_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_migrate_action
}

func (*Migrate_actionContext) IsMigrate_actionContext() {}

func NewMigrate_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Migrate_actionContext {
	var p = new(Migrate_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_migrate_action

	return p
}

func (s *Migrate_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Migrate_actionContext) MOVE() antlr.TerminalNode {
	return s.GetToken(OBParserMOVE, 0)
}

func (s *Migrate_actionContext) COPY() antlr.TerminalNode {
	return s.GetToken(OBParserCOPY, 0)
}

func (s *Migrate_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Migrate_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Migrate_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterMigrate_action(s)
	}
}

func (s *Migrate_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitMigrate_action(s)
	}
}

func (s *Migrate_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitMigrate_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Migrate_action() (localctx IMigrate_actionContext) {
	localctx = NewMigrate_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 864, OBParserRULE_migrate_action)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7952)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserMOVE || _la == OBParserCOPY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChange_actionsContext is an interface to support dynamic dispatch.
type IChange_actionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Change_action() IChange_actionContext
	Change_actions() IChange_actionsContext

	// IsChange_actionsContext differentiates from other interfaces.
	IsChange_actionsContext()
}

type Change_actionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChange_actionsContext() *Change_actionsContext {
	var p = new(Change_actionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_change_actions
	return p
}

func InitEmptyChange_actionsContext(p *Change_actionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_change_actions
}

func (*Change_actionsContext) IsChange_actionsContext() {}

func NewChange_actionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Change_actionsContext {
	var p = new(Change_actionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_change_actions

	return p
}

func (s *Change_actionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Change_actionsContext) Change_action() IChange_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChange_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChange_actionContext)
}

func (s *Change_actionsContext) Change_actions() IChange_actionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChange_actionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChange_actionsContext)
}

func (s *Change_actionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Change_actionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Change_actionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterChange_actions(s)
	}
}

func (s *Change_actionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitChange_actions(s)
	}
}

func (s *Change_actionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitChange_actions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Change_actions() (localctx IChange_actionsContext) {
	localctx = NewChange_actionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 866, OBParserRULE_change_actions)
	p.SetState(7958)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 823, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7954)
			p.Change_action()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7955)
			p.Change_action()
		}
		{
			p.SetState(7956)
			p.Change_actions()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChange_actionContext is an interface to support dynamic dispatch.
type IChange_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Replica_type() IReplica_typeContext

	// IsChange_actionContext differentiates from other interfaces.
	IsChange_actionContext()
}

type Change_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChange_actionContext() *Change_actionContext {
	var p = new(Change_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_change_action
	return p
}

func InitEmptyChange_actionContext(p *Change_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_change_action
}

func (*Change_actionContext) IsChange_actionContext() {}

func NewChange_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Change_actionContext {
	var p = new(Change_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_change_action

	return p
}

func (s *Change_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Change_actionContext) Replica_type() IReplica_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplica_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplica_typeContext)
}

func (s *Change_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Change_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Change_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterChange_action(s)
	}
}

func (s *Change_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitChange_action(s)
	}
}

func (s *Change_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitChange_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Change_action() (localctx IChange_actionContext) {
	localctx = NewChange_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 868, OBParserRULE_change_action)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7960)
		p.Replica_type()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplica_typeContext is an interface to support dynamic dispatch.
type IReplica_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLICA_TYPE() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode

	// IsReplica_typeContext differentiates from other interfaces.
	IsReplica_typeContext()
}

type Replica_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplica_typeContext() *Replica_typeContext {
	var p = new(Replica_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_replica_type
	return p
}

func InitEmptyReplica_typeContext(p *Replica_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_replica_type
}

func (*Replica_typeContext) IsReplica_typeContext() {}

func NewReplica_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Replica_typeContext {
	var p = new(Replica_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_replica_type

	return p
}

func (s *Replica_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Replica_typeContext) REPLICA_TYPE() antlr.TerminalNode {
	return s.GetToken(OBParserREPLICA_TYPE, 0)
}

func (s *Replica_typeContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Replica_typeContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Replica_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Replica_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Replica_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterReplica_type(s)
	}
}

func (s *Replica_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitReplica_type(s)
	}
}

func (s *Replica_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitReplica_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Replica_type() (localctx IReplica_typeContext) {
	localctx = NewReplica_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 870, OBParserRULE_replica_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7962)
		p.Match(OBParserREPLICA_TYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7964)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCOMP_EQ {
		{
			p.SetState(7963)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7966)
		p.Match(OBParserSTRING_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISuspend_or_resumeContext is an interface to support dynamic dispatch.
type ISuspend_or_resumeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUSPEND() antlr.TerminalNode
	RESUME() antlr.TerminalNode

	// IsSuspend_or_resumeContext differentiates from other interfaces.
	IsSuspend_or_resumeContext()
}

type Suspend_or_resumeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuspend_or_resumeContext() *Suspend_or_resumeContext {
	var p = new(Suspend_or_resumeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_suspend_or_resume
	return p
}

func InitEmptySuspend_or_resumeContext(p *Suspend_or_resumeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_suspend_or_resume
}

func (*Suspend_or_resumeContext) IsSuspend_or_resumeContext() {}

func NewSuspend_or_resumeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Suspend_or_resumeContext {
	var p = new(Suspend_or_resumeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_suspend_or_resume

	return p
}

func (s *Suspend_or_resumeContext) GetParser() antlr.Parser { return s.parser }

func (s *Suspend_or_resumeContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(OBParserSUSPEND, 0)
}

func (s *Suspend_or_resumeContext) RESUME() antlr.TerminalNode {
	return s.GetToken(OBParserRESUME, 0)
}

func (s *Suspend_or_resumeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Suspend_or_resumeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Suspend_or_resumeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSuspend_or_resume(s)
	}
}

func (s *Suspend_or_resumeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSuspend_or_resume(s)
	}
}

func (s *Suspend_or_resumeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSuspend_or_resume(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Suspend_or_resume() (localctx ISuspend_or_resumeContext) {
	localctx = NewSuspend_or_resumeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 872, OBParserRULE_suspend_or_resume)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7968)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserSUSPEND || _la == OBParserRESUME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseline_id_exprContext is an interface to support dynamic dispatch.
type IBaseline_id_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BASELINE_ID() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode

	// IsBaseline_id_exprContext differentiates from other interfaces.
	IsBaseline_id_exprContext()
}

type Baseline_id_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseline_id_exprContext() *Baseline_id_exprContext {
	var p = new(Baseline_id_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_baseline_id_expr
	return p
}

func InitEmptyBaseline_id_exprContext(p *Baseline_id_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_baseline_id_expr
}

func (*Baseline_id_exprContext) IsBaseline_id_exprContext() {}

func NewBaseline_id_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Baseline_id_exprContext {
	var p = new(Baseline_id_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_baseline_id_expr

	return p
}

func (s *Baseline_id_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Baseline_id_exprContext) BASELINE_ID() antlr.TerminalNode {
	return s.GetToken(OBParserBASELINE_ID, 0)
}

func (s *Baseline_id_exprContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Baseline_id_exprContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Baseline_id_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Baseline_id_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Baseline_id_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterBaseline_id_expr(s)
	}
}

func (s *Baseline_id_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitBaseline_id_expr(s)
	}
}

func (s *Baseline_id_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitBaseline_id_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Baseline_id_expr() (localctx IBaseline_id_exprContext) {
	localctx = NewBaseline_id_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 874, OBParserRULE_baseline_id_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7970)
		p.Match(OBParserBASELINE_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7972)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCOMP_EQ {
		{
			p.SetState(7971)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7974)
		p.Match(OBParserINTNUM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISql_id_exprContext is an interface to support dynamic dispatch.
type ISql_id_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SQL_ID() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode

	// IsSql_id_exprContext differentiates from other interfaces.
	IsSql_id_exprContext()
}

type Sql_id_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_id_exprContext() *Sql_id_exprContext {
	var p = new(Sql_id_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sql_id_expr
	return p
}

func InitEmptySql_id_exprContext(p *Sql_id_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_sql_id_expr
}

func (*Sql_id_exprContext) IsSql_id_exprContext() {}

func NewSql_id_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_id_exprContext {
	var p = new(Sql_id_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_sql_id_expr

	return p
}

func (s *Sql_id_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_id_exprContext) SQL_ID() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_ID, 0)
}

func (s *Sql_id_exprContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Sql_id_exprContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Sql_id_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_id_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sql_id_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSql_id_expr(s)
	}
}

func (s *Sql_id_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSql_id_expr(s)
	}
}

func (s *Sql_id_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSql_id_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Sql_id_expr() (localctx ISql_id_exprContext) {
	localctx = NewSql_id_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 876, OBParserRULE_sql_id_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7976)
		p.Match(OBParserSQL_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7978)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCOMP_EQ {
		{
			p.SetState(7977)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7980)
		p.Match(OBParserSTRING_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseline_asgn_factorContext is an interface to support dynamic dispatch.
type IBaseline_asgn_factorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_name() IColumn_nameContext
	COMP_EQ() antlr.TerminalNode
	Literal() ILiteralContext

	// IsBaseline_asgn_factorContext differentiates from other interfaces.
	IsBaseline_asgn_factorContext()
}

type Baseline_asgn_factorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseline_asgn_factorContext() *Baseline_asgn_factorContext {
	var p = new(Baseline_asgn_factorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_baseline_asgn_factor
	return p
}

func InitEmptyBaseline_asgn_factorContext(p *Baseline_asgn_factorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_baseline_asgn_factor
}

func (*Baseline_asgn_factorContext) IsBaseline_asgn_factorContext() {}

func NewBaseline_asgn_factorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Baseline_asgn_factorContext {
	var p = new(Baseline_asgn_factorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_baseline_asgn_factor

	return p
}

func (s *Baseline_asgn_factorContext) GetParser() antlr.Parser { return s.parser }

func (s *Baseline_asgn_factorContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Baseline_asgn_factorContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Baseline_asgn_factorContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *Baseline_asgn_factorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Baseline_asgn_factorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Baseline_asgn_factorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterBaseline_asgn_factor(s)
	}
}

func (s *Baseline_asgn_factorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitBaseline_asgn_factor(s)
	}
}

func (s *Baseline_asgn_factorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitBaseline_asgn_factor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Baseline_asgn_factor() (localctx IBaseline_asgn_factorContext) {
	localctx = NewBaseline_asgn_factorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 878, OBParserRULE_baseline_asgn_factor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7982)
		p.Column_name()
	}
	{
		p.SetState(7983)
		p.Match(OBParserCOMP_EQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7984)
		p.Literal()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITenant_nameContext is an interface to support dynamic dispatch.
type ITenant_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TENANT() antlr.TerminalNode
	Relation_name_or_string() IRelation_name_or_stringContext
	COMP_EQ() antlr.TerminalNode

	// IsTenant_nameContext differentiates from other interfaces.
	IsTenant_nameContext()
}

type Tenant_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTenant_nameContext() *Tenant_nameContext {
	var p = new(Tenant_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tenant_name
	return p
}

func InitEmptyTenant_nameContext(p *Tenant_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_tenant_name
}

func (*Tenant_nameContext) IsTenant_nameContext() {}

func NewTenant_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tenant_nameContext {
	var p = new(Tenant_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_tenant_name

	return p
}

func (s *Tenant_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Tenant_nameContext) TENANT() antlr.TerminalNode {
	return s.GetToken(OBParserTENANT, 0)
}

func (s *Tenant_nameContext) Relation_name_or_string() IRelation_name_or_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_name_or_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_name_or_stringContext)
}

func (s *Tenant_nameContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Tenant_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tenant_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tenant_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTenant_name(s)
	}
}

func (s *Tenant_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTenant_name(s)
	}
}

func (s *Tenant_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTenant_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Tenant_name() (localctx ITenant_nameContext) {
	localctx = NewTenant_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 880, OBParserRULE_tenant_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7986)
		p.Match(OBParserTENANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7988)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCOMP_EQ {
		{
			p.SetState(7987)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7990)
		p.Relation_name_or_string()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICache_nameContext is an interface to support dynamic dispatch.
type ICache_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CACHE() antlr.TerminalNode
	Relation_name_or_string() IRelation_name_or_stringContext
	COMP_EQ() antlr.TerminalNode

	// IsCache_nameContext differentiates from other interfaces.
	IsCache_nameContext()
}

type Cache_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCache_nameContext() *Cache_nameContext {
	var p = new(Cache_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cache_name
	return p
}

func InitEmptyCache_nameContext(p *Cache_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cache_name
}

func (*Cache_nameContext) IsCache_nameContext() {}

func NewCache_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cache_nameContext {
	var p = new(Cache_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_cache_name

	return p
}

func (s *Cache_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Cache_nameContext) CACHE() antlr.TerminalNode {
	return s.GetToken(OBParserCACHE, 0)
}

func (s *Cache_nameContext) Relation_name_or_string() IRelation_name_or_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_name_or_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_name_or_stringContext)
}

func (s *Cache_nameContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Cache_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cache_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cache_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCache_name(s)
	}
}

func (s *Cache_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCache_name(s)
	}
}

func (s *Cache_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCache_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Cache_name() (localctx ICache_nameContext) {
	localctx = NewCache_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 882, OBParserRULE_cache_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7992)
		p.Match(OBParserCACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7994)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCOMP_EQ {
		{
			p.SetState(7993)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7996)
		p.Relation_name_or_string()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFile_idContext is an interface to support dynamic dispatch.
type IFile_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILE_ID() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode

	// IsFile_idContext differentiates from other interfaces.
	IsFile_idContext()
}

type File_idContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_idContext() *File_idContext {
	var p = new(File_idContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_file_id
	return p
}

func InitEmptyFile_idContext(p *File_idContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_file_id
}

func (*File_idContext) IsFile_idContext() {}

func NewFile_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_idContext {
	var p = new(File_idContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_file_id

	return p
}

func (s *File_idContext) GetParser() antlr.Parser { return s.parser }

func (s *File_idContext) FILE_ID() antlr.TerminalNode {
	return s.GetToken(OBParserFILE_ID, 0)
}

func (s *File_idContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *File_idContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *File_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterFile_id(s)
	}
}

func (s *File_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitFile_id(s)
	}
}

func (s *File_idContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitFile_id(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) File_id() (localctx IFile_idContext) {
	localctx = NewFile_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 884, OBParserRULE_file_id)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7998)
		p.Match(OBParserFILE_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(8000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCOMP_EQ {
		{
			p.SetState(7999)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(8002)
		p.Match(OBParserINTNUM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancel_task_typeContext is an interface to support dynamic dispatch.
type ICancel_task_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	MIGRATION() antlr.TerminalNode
	Empty() IEmptyContext

	// IsCancel_task_typeContext differentiates from other interfaces.
	IsCancel_task_typeContext()
}

type Cancel_task_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancel_task_typeContext() *Cancel_task_typeContext {
	var p = new(Cancel_task_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cancel_task_type
	return p
}

func InitEmptyCancel_task_typeContext(p *Cancel_task_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cancel_task_type
}

func (*Cancel_task_typeContext) IsCancel_task_typeContext() {}

func NewCancel_task_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cancel_task_typeContext {
	var p = new(Cancel_task_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_cancel_task_type

	return p
}

func (s *Cancel_task_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Cancel_task_typeContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION, 0)
}

func (s *Cancel_task_typeContext) MIGRATION() antlr.TerminalNode {
	return s.GetToken(OBParserMIGRATION, 0)
}

func (s *Cancel_task_typeContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Cancel_task_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cancel_task_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cancel_task_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCancel_task_type(s)
	}
}

func (s *Cancel_task_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCancel_task_type(s)
	}
}

func (s *Cancel_task_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCancel_task_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Cancel_task_type() (localctx ICancel_task_typeContext) {
	localctx = NewCancel_task_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 886, OBParserRULE_cancel_task_type)
	p.SetState(8007)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserPARTITION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8004)
			p.Match(OBParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8005)
			p.Match(OBParserMIGRATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserTASK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8006)
			p.Empty()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_system_set_parameter_actionsContext is an interface to support dynamic dispatch.
type IAlter_system_set_parameter_actionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlter_system_set_parameter_action() []IAlter_system_set_parameter_actionContext
	Alter_system_set_parameter_action(i int) IAlter_system_set_parameter_actionContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsAlter_system_set_parameter_actionsContext differentiates from other interfaces.
	IsAlter_system_set_parameter_actionsContext()
}

type Alter_system_set_parameter_actionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_system_set_parameter_actionsContext() *Alter_system_set_parameter_actionsContext {
	var p = new(Alter_system_set_parameter_actionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_system_set_parameter_actions
	return p
}

func InitEmptyAlter_system_set_parameter_actionsContext(p *Alter_system_set_parameter_actionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_system_set_parameter_actions
}

func (*Alter_system_set_parameter_actionsContext) IsAlter_system_set_parameter_actionsContext() {}

func NewAlter_system_set_parameter_actionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_system_set_parameter_actionsContext {
	var p = new(Alter_system_set_parameter_actionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_system_set_parameter_actions

	return p
}

func (s *Alter_system_set_parameter_actionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_system_set_parameter_actionsContext) AllAlter_system_set_parameter_action() []IAlter_system_set_parameter_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlter_system_set_parameter_actionContext); ok {
			len++
		}
	}

	tst := make([]IAlter_system_set_parameter_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlter_system_set_parameter_actionContext); ok {
			tst[i] = t.(IAlter_system_set_parameter_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_system_set_parameter_actionsContext) Alter_system_set_parameter_action(i int) IAlter_system_set_parameter_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_system_set_parameter_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_system_set_parameter_actionContext)
}

func (s *Alter_system_set_parameter_actionsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(OBParserComma)
}

func (s *Alter_system_set_parameter_actionsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(OBParserComma, i)
}

func (s *Alter_system_set_parameter_actionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_system_set_parameter_actionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_system_set_parameter_actionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_system_set_parameter_actions(s)
	}
}

func (s *Alter_system_set_parameter_actionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_system_set_parameter_actions(s)
	}
}

func (s *Alter_system_set_parameter_actionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_system_set_parameter_actions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_system_set_parameter_actions() (localctx IAlter_system_set_parameter_actionsContext) {
	localctx = NewAlter_system_set_parameter_actionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 888, OBParserRULE_alter_system_set_parameter_actions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8009)
		p.Alter_system_set_parameter_action()
	}
	p.SetState(8014)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == OBParserComma {
		{
			p.SetState(8010)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8011)
			p.Alter_system_set_parameter_action()
		}

		p.SetState(8016)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_system_set_parameter_actionContext is an interface to support dynamic dispatch.
type IAlter_system_set_parameter_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME_OB() antlr.TerminalNode
	AllCOMP_EQ() []antlr.TerminalNode
	COMP_EQ(i int) antlr.TerminalNode
	Conf_const() IConf_constContext
	COMMENT() antlr.TerminalNode
	STRING_VALUE() antlr.TerminalNode
	Server_or_zone() IServer_or_zoneContext
	Tenant_name() ITenant_nameContext
	SCOPE() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	SPFILE() antlr.TerminalNode
	BOTH() antlr.TerminalNode
	TABLET_SIZE() antlr.TerminalNode
	CLUSTER_ID() antlr.TerminalNode

	// IsAlter_system_set_parameter_actionContext differentiates from other interfaces.
	IsAlter_system_set_parameter_actionContext()
}

type Alter_system_set_parameter_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_system_set_parameter_actionContext() *Alter_system_set_parameter_actionContext {
	var p = new(Alter_system_set_parameter_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_system_set_parameter_action
	return p
}

func InitEmptyAlter_system_set_parameter_actionContext(p *Alter_system_set_parameter_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_system_set_parameter_action
}

func (*Alter_system_set_parameter_actionContext) IsAlter_system_set_parameter_actionContext() {}

func NewAlter_system_set_parameter_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_system_set_parameter_actionContext {
	var p = new(Alter_system_set_parameter_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_system_set_parameter_action

	return p
}

func (s *Alter_system_set_parameter_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_system_set_parameter_actionContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Alter_system_set_parameter_actionContext) AllCOMP_EQ() []antlr.TerminalNode {
	return s.GetTokens(OBParserCOMP_EQ)
}

func (s *Alter_system_set_parameter_actionContext) COMP_EQ(i int) antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, i)
}

func (s *Alter_system_set_parameter_actionContext) Conf_const() IConf_constContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConf_constContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConf_constContext)
}

func (s *Alter_system_set_parameter_actionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(OBParserCOMMENT, 0)
}

func (s *Alter_system_set_parameter_actionContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Alter_system_set_parameter_actionContext) Server_or_zone() IServer_or_zoneContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServer_or_zoneContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServer_or_zoneContext)
}

func (s *Alter_system_set_parameter_actionContext) Tenant_name() ITenant_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITenant_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITenant_nameContext)
}

func (s *Alter_system_set_parameter_actionContext) SCOPE() antlr.TerminalNode {
	return s.GetToken(OBParserSCOPE, 0)
}

func (s *Alter_system_set_parameter_actionContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(OBParserMEMORY, 0)
}

func (s *Alter_system_set_parameter_actionContext) SPFILE() antlr.TerminalNode {
	return s.GetToken(OBParserSPFILE, 0)
}

func (s *Alter_system_set_parameter_actionContext) BOTH() antlr.TerminalNode {
	return s.GetToken(OBParserBOTH, 0)
}

func (s *Alter_system_set_parameter_actionContext) TABLET_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLET_SIZE, 0)
}

func (s *Alter_system_set_parameter_actionContext) CLUSTER_ID() antlr.TerminalNode {
	return s.GetToken(OBParserCLUSTER_ID, 0)
}

func (s *Alter_system_set_parameter_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_system_set_parameter_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_system_set_parameter_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_system_set_parameter_action(s)
	}
}

func (s *Alter_system_set_parameter_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_system_set_parameter_action(s)
	}
}

func (s *Alter_system_set_parameter_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_system_set_parameter_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_system_set_parameter_action() (localctx IAlter_system_set_parameter_actionContext) {
	localctx = NewAlter_system_set_parameter_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 890, OBParserRULE_alter_system_set_parameter_action)
	var _la int

	p.SetState(8089)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserNAME_OB:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8017)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8018)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8019)
			p.Conf_const()
		}
		p.SetState(8022)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMMENT {
			{
				p.SetState(8020)
				p.Match(OBParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8021)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(8033)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 833, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(8024)
				p.Match(OBParserSCOPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8025)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8026)
				p.Match(OBParserMEMORY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 833, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(8027)
				p.Match(OBParserSCOPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8028)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8029)
				p.Match(OBParserSPFILE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 833, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(8030)
				p.Match(OBParserSCOPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8031)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8032)
				p.Match(OBParserBOTH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(8036)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSERVER || _la == OBParserZONE {
			{
				p.SetState(8035)
				p.Server_or_zone()
			}

		}
		p.SetState(8039)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTENANT {
			{
				p.SetState(8038)
				p.Tenant_name()
			}

		}

	case OBParserTABLET_SIZE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8041)
			p.Match(OBParserTABLET_SIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8042)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8043)
			p.Conf_const()
		}
		p.SetState(8046)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMMENT {
			{
				p.SetState(8044)
				p.Match(OBParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8045)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(8057)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 837, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(8048)
				p.Match(OBParserSCOPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8049)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8050)
				p.Match(OBParserMEMORY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 837, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(8051)
				p.Match(OBParserSCOPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8052)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8053)
				p.Match(OBParserSPFILE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 837, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(8054)
				p.Match(OBParserSCOPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8055)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8056)
				p.Match(OBParserBOTH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(8060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSERVER || _la == OBParserZONE {
			{
				p.SetState(8059)
				p.Server_or_zone()
			}

		}
		p.SetState(8063)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTENANT {
			{
				p.SetState(8062)
				p.Tenant_name()
			}

		}

	case OBParserCLUSTER_ID:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8065)
			p.Match(OBParserCLUSTER_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8066)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8067)
			p.Conf_const()
		}
		p.SetState(8070)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMMENT {
			{
				p.SetState(8068)
				p.Match(OBParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8069)
				p.Match(OBParserSTRING_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(8081)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 841, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(8072)
				p.Match(OBParserSCOPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8073)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8074)
				p.Match(OBParserMEMORY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 841, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(8075)
				p.Match(OBParserSCOPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8076)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8077)
				p.Match(OBParserSPFILE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 841, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(8078)
				p.Match(OBParserSCOPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8079)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8080)
				p.Match(OBParserBOTH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(8084)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserSERVER || _la == OBParserZONE {
			{
				p.SetState(8083)
				p.Server_or_zone()
			}

		}
		p.SetState(8087)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserTENANT {
			{
				p.SetState(8086)
				p.Tenant_name()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_system_settp_actionsContext is an interface to support dynamic dispatch.
type IAlter_system_settp_actionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Settp_option() ISettp_optionContext
	Empty() IEmptyContext
	Alter_system_settp_actions() IAlter_system_settp_actionsContext
	Comma() antlr.TerminalNode

	// IsAlter_system_settp_actionsContext differentiates from other interfaces.
	IsAlter_system_settp_actionsContext()
}

type Alter_system_settp_actionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_system_settp_actionsContext() *Alter_system_settp_actionsContext {
	var p = new(Alter_system_settp_actionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_system_settp_actions
	return p
}

func InitEmptyAlter_system_settp_actionsContext(p *Alter_system_settp_actionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_system_settp_actions
}

func (*Alter_system_settp_actionsContext) IsAlter_system_settp_actionsContext() {}

func NewAlter_system_settp_actionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_system_settp_actionsContext {
	var p = new(Alter_system_settp_actionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_system_settp_actions

	return p
}

func (s *Alter_system_settp_actionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_system_settp_actionsContext) Settp_option() ISettp_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISettp_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISettp_optionContext)
}

func (s *Alter_system_settp_actionsContext) Empty() IEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyContext)
}

func (s *Alter_system_settp_actionsContext) Alter_system_settp_actions() IAlter_system_settp_actionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_system_settp_actionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_system_settp_actionsContext)
}

func (s *Alter_system_settp_actionsContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Alter_system_settp_actionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_system_settp_actionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_system_settp_actionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_system_settp_actions(s)
	}
}

func (s *Alter_system_settp_actionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_system_settp_actions(s)
	}
}

func (s *Alter_system_settp_actionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_system_settp_actions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_system_settp_actions() (localctx IAlter_system_settp_actionsContext) {
	return p.alter_system_settp_actions(0)
}

func (p *OBParser) alter_system_settp_actions(_p int) (localctx IAlter_system_settp_actionsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewAlter_system_settp_actionsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAlter_system_settp_actionsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 892
	p.EnterRecursionRule(localctx, 892, OBParserRULE_alter_system_settp_actions, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(8094)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 845, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(8092)
			p.Settp_option()
		}

	case 2:
		{
			p.SetState(8093)
			p.Empty()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(8101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 846, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAlter_system_settp_actionsContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, OBParserRULE_alter_system_settp_actions)
			p.SetState(8096)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(8097)
				p.Match(OBParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8098)
				p.Settp_option()
			}

		}
		p.SetState(8103)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 846, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISettp_optionContext is an interface to support dynamic dispatch.
type ISettp_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TP_NO() antlr.TerminalNode
	INTNUM() antlr.TerminalNode
	COMP_EQ() antlr.TerminalNode
	TP_NAME() antlr.TerminalNode
	Relation_name_or_string() IRelation_name_or_stringContext
	OCCUR() antlr.TerminalNode
	FREQUENCY() antlr.TerminalNode
	ERROR_CODE() antlr.TerminalNode

	// IsSettp_optionContext differentiates from other interfaces.
	IsSettp_optionContext()
}

type Settp_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySettp_optionContext() *Settp_optionContext {
	var p = new(Settp_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_settp_option
	return p
}

func InitEmptySettp_optionContext(p *Settp_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_settp_option
}

func (*Settp_optionContext) IsSettp_optionContext() {}

func NewSettp_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Settp_optionContext {
	var p = new(Settp_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_settp_option

	return p
}

func (s *Settp_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Settp_optionContext) TP_NO() antlr.TerminalNode {
	return s.GetToken(OBParserTP_NO, 0)
}

func (s *Settp_optionContext) INTNUM() antlr.TerminalNode {
	return s.GetToken(OBParserINTNUM, 0)
}

func (s *Settp_optionContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Settp_optionContext) TP_NAME() antlr.TerminalNode {
	return s.GetToken(OBParserTP_NAME, 0)
}

func (s *Settp_optionContext) Relation_name_or_string() IRelation_name_or_stringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_name_or_stringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_name_or_stringContext)
}

func (s *Settp_optionContext) OCCUR() antlr.TerminalNode {
	return s.GetToken(OBParserOCCUR, 0)
}

func (s *Settp_optionContext) FREQUENCY() antlr.TerminalNode {
	return s.GetToken(OBParserFREQUENCY, 0)
}

func (s *Settp_optionContext) ERROR_CODE() antlr.TerminalNode {
	return s.GetToken(OBParserERROR_CODE, 0)
}

func (s *Settp_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Settp_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Settp_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSettp_option(s)
	}
}

func (s *Settp_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSettp_option(s)
	}
}

func (s *Settp_optionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSettp_option(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Settp_option() (localctx ISettp_optionContext) {
	localctx = NewSettp_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 894, OBParserRULE_settp_option)
	var _la int

	p.SetState(8129)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserTP_NO:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8104)
			p.Match(OBParserTP_NO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8106)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(8105)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(8108)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserTP_NAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8109)
			p.Match(OBParserTP_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8111)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(8110)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(8113)
			p.Relation_name_or_string()
		}

	case OBParserOCCUR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8114)
			p.Match(OBParserOCCUR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8116)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(8115)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(8118)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserFREQUENCY:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8119)
			p.Match(OBParserFREQUENCY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8121)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(8120)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(8123)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserERROR_CODE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(8124)
			p.Match(OBParserERROR_CODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserCOMP_EQ {
			{
				p.SetState(8125)
				p.Match(OBParserCOMP_EQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(8128)
			p.Match(OBParserINTNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICluster_roleContext is an interface to support dynamic dispatch.
type ICluster_roleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRIMARY() antlr.TerminalNode
	STANDBY() antlr.TerminalNode

	// IsCluster_roleContext differentiates from other interfaces.
	IsCluster_roleContext()
}

type Cluster_roleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCluster_roleContext() *Cluster_roleContext {
	var p = new(Cluster_roleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cluster_role
	return p
}

func InitEmptyCluster_roleContext(p *Cluster_roleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cluster_role
}

func (*Cluster_roleContext) IsCluster_roleContext() {}

func NewCluster_roleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cluster_roleContext {
	var p = new(Cluster_roleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_cluster_role

	return p
}

func (s *Cluster_roleContext) GetParser() antlr.Parser { return s.parser }

func (s *Cluster_roleContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(OBParserPRIMARY, 0)
}

func (s *Cluster_roleContext) STANDBY() antlr.TerminalNode {
	return s.GetToken(OBParserSTANDBY, 0)
}

func (s *Cluster_roleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cluster_roleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cluster_roleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCluster_role(s)
	}
}

func (s *Cluster_roleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCluster_role(s)
	}
}

func (s *Cluster_roleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCluster_role(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Cluster_role() (localctx ICluster_roleContext) {
	localctx = NewCluster_roleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 896, OBParserRULE_cluster_role)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8131)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserPRIMARY || _la == OBParserSTANDBY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartition_roleContext is an interface to support dynamic dispatch.
type IPartition_roleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEADER() antlr.TerminalNode
	FOLLOWER() antlr.TerminalNode

	// IsPartition_roleContext differentiates from other interfaces.
	IsPartition_roleContext()
}

type Partition_roleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartition_roleContext() *Partition_roleContext {
	var p = new(Partition_roleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_partition_role
	return p
}

func InitEmptyPartition_roleContext(p *Partition_roleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_partition_role
}

func (*Partition_roleContext) IsPartition_roleContext() {}

func NewPartition_roleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_roleContext {
	var p = new(Partition_roleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_partition_role

	return p
}

func (s *Partition_roleContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_roleContext) LEADER() antlr.TerminalNode {
	return s.GetToken(OBParserLEADER, 0)
}

func (s *Partition_roleContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(OBParserFOLLOWER, 0)
}

func (s *Partition_roleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_roleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Partition_roleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterPartition_role(s)
	}
}

func (s *Partition_roleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitPartition_role(s)
	}
}

func (s *Partition_roleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitPartition_role(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Partition_role() (localctx IPartition_roleContext) {
	localctx = NewPartition_roleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 898, OBParserRULE_partition_role)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8133)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserFOLLOWER || _la == OBParserLEADER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpgrade_actionContext is an interface to support dynamic dispatch.
type IUpgrade_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGI() antlr.TerminalNode
	END() antlr.TerminalNode

	// IsUpgrade_actionContext differentiates from other interfaces.
	IsUpgrade_actionContext()
}

type Upgrade_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpgrade_actionContext() *Upgrade_actionContext {
	var p = new(Upgrade_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_upgrade_action
	return p
}

func InitEmptyUpgrade_actionContext(p *Upgrade_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_upgrade_action
}

func (*Upgrade_actionContext) IsUpgrade_actionContext() {}

func NewUpgrade_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Upgrade_actionContext {
	var p = new(Upgrade_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_upgrade_action

	return p
}

func (s *Upgrade_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Upgrade_actionContext) BEGI() antlr.TerminalNode {
	return s.GetToken(OBParserBEGI, 0)
}

func (s *Upgrade_actionContext) END() antlr.TerminalNode {
	return s.GetToken(OBParserEND, 0)
}

func (s *Upgrade_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Upgrade_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Upgrade_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUpgrade_action(s)
	}
}

func (s *Upgrade_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUpgrade_action(s)
	}
}

func (s *Upgrade_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUpgrade_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Upgrade_action() (localctx IUpgrade_actionContext) {
	localctx = NewUpgrade_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 900, OBParserRULE_upgrade_action)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8135)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserBEGI || _la == OBParserEND) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_names_stmtContext is an interface to support dynamic dispatch.
type ISet_names_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	NAMES() antlr.TerminalNode
	Charset_name_or_default() ICharset_name_or_defaultContext
	Collation() ICollationContext

	// IsSet_names_stmtContext differentiates from other interfaces.
	IsSet_names_stmtContext()
}

type Set_names_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_names_stmtContext() *Set_names_stmtContext {
	var p = new(Set_names_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_names_stmt
	return p
}

func InitEmptySet_names_stmtContext(p *Set_names_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_names_stmt
}

func (*Set_names_stmtContext) IsSet_names_stmtContext() {}

func NewSet_names_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_names_stmtContext {
	var p = new(Set_names_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_set_names_stmt

	return p
}

func (s *Set_names_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_names_stmtContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Set_names_stmtContext) NAMES() antlr.TerminalNode {
	return s.GetToken(OBParserNAMES, 0)
}

func (s *Set_names_stmtContext) Charset_name_or_default() ICharset_name_or_defaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_name_or_defaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_name_or_defaultContext)
}

func (s *Set_names_stmtContext) Collation() ICollationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationContext)
}

func (s *Set_names_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_names_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_names_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSet_names_stmt(s)
	}
}

func (s *Set_names_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSet_names_stmt(s)
	}
}

func (s *Set_names_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSet_names_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Set_names_stmt() (localctx ISet_names_stmtContext) {
	localctx = NewSet_names_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 902, OBParserRULE_set_names_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8137)
		p.Match(OBParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8138)
		p.Match(OBParserNAMES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8139)
		p.Charset_name_or_default()
	}
	p.SetState(8141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCOLLATE {
		{
			p.SetState(8140)
			p.Collation()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_charset_stmtContext is an interface to support dynamic dispatch.
type ISet_charset_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	Charset_key() ICharset_keyContext
	Charset_name_or_default() ICharset_name_or_defaultContext

	// IsSet_charset_stmtContext differentiates from other interfaces.
	IsSet_charset_stmtContext()
}

type Set_charset_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_charset_stmtContext() *Set_charset_stmtContext {
	var p = new(Set_charset_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_charset_stmt
	return p
}

func InitEmptySet_charset_stmtContext(p *Set_charset_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_charset_stmt
}

func (*Set_charset_stmtContext) IsSet_charset_stmtContext() {}

func NewSet_charset_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_charset_stmtContext {
	var p = new(Set_charset_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_set_charset_stmt

	return p
}

func (s *Set_charset_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_charset_stmtContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Set_charset_stmtContext) Charset_key() ICharset_keyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_keyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_keyContext)
}

func (s *Set_charset_stmtContext) Charset_name_or_default() ICharset_name_or_defaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharset_name_or_defaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharset_name_or_defaultContext)
}

func (s *Set_charset_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_charset_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_charset_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSet_charset_stmt(s)
	}
}

func (s *Set_charset_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSet_charset_stmt(s)
	}
}

func (s *Set_charset_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSet_charset_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Set_charset_stmt() (localctx ISet_charset_stmtContext) {
	localctx = NewSet_charset_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 904, OBParserRULE_set_charset_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8143)
		p.Match(OBParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8144)
		p.Charset_key()
	}
	{
		p.SetState(8145)
		p.Charset_name_or_default()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_transaction_stmtContext is an interface to support dynamic dispatch.
type ISet_transaction_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	Transaction_characteristics() ITransaction_characteristicsContext
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsSet_transaction_stmtContext differentiates from other interfaces.
	IsSet_transaction_stmtContext()
}

type Set_transaction_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_transaction_stmtContext() *Set_transaction_stmtContext {
	var p = new(Set_transaction_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_transaction_stmt
	return p
}

func InitEmptySet_transaction_stmtContext(p *Set_transaction_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_set_transaction_stmt
}

func (*Set_transaction_stmtContext) IsSet_transaction_stmtContext() {}

func NewSet_transaction_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_transaction_stmtContext {
	var p = new(Set_transaction_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_set_transaction_stmt

	return p
}

func (s *Set_transaction_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_transaction_stmtContext) SET() antlr.TerminalNode {
	return s.GetToken(OBParserSET, 0)
}

func (s *Set_transaction_stmtContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(OBParserTRANSACTION, 0)
}

func (s *Set_transaction_stmtContext) Transaction_characteristics() ITransaction_characteristicsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransaction_characteristicsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransaction_characteristicsContext)
}

func (s *Set_transaction_stmtContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(OBParserGLOBAL, 0)
}

func (s *Set_transaction_stmtContext) SESSION() antlr.TerminalNode {
	return s.GetToken(OBParserSESSION, 0)
}

func (s *Set_transaction_stmtContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(OBParserLOCAL, 0)
}

func (s *Set_transaction_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_transaction_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_transaction_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSet_transaction_stmt(s)
	}
}

func (s *Set_transaction_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSet_transaction_stmt(s)
	}
}

func (s *Set_transaction_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSet_transaction_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Set_transaction_stmt() (localctx ISet_transaction_stmtContext) {
	localctx = NewSet_transaction_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 906, OBParserRULE_set_transaction_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8147)
		p.Match(OBParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(8149)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserLOCAL || _la == OBParserGLOBAL || _la == OBParserSESSION {
		{
			p.SetState(8148)
			_la = p.GetTokenStream().LA(1)

			if !(_la == OBParserLOCAL || _la == OBParserGLOBAL || _la == OBParserSESSION) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(8151)
		p.Match(OBParserTRANSACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8152)
		p.Transaction_characteristics()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransaction_characteristicsContext is an interface to support dynamic dispatch.
type ITransaction_characteristicsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Transaction_access_mode() ITransaction_access_modeContext
	ISOLATION() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	Isolation_level() IIsolation_levelContext
	Comma() antlr.TerminalNode

	// IsTransaction_characteristicsContext differentiates from other interfaces.
	IsTransaction_characteristicsContext()
}

type Transaction_characteristicsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransaction_characteristicsContext() *Transaction_characteristicsContext {
	var p = new(Transaction_characteristicsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_transaction_characteristics
	return p
}

func InitEmptyTransaction_characteristicsContext(p *Transaction_characteristicsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_transaction_characteristics
}

func (*Transaction_characteristicsContext) IsTransaction_characteristicsContext() {}

func NewTransaction_characteristicsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transaction_characteristicsContext {
	var p = new(Transaction_characteristicsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_transaction_characteristics

	return p
}

func (s *Transaction_characteristicsContext) GetParser() antlr.Parser { return s.parser }

func (s *Transaction_characteristicsContext) Transaction_access_mode() ITransaction_access_modeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransaction_access_modeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransaction_access_modeContext)
}

func (s *Transaction_characteristicsContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(OBParserISOLATION, 0)
}

func (s *Transaction_characteristicsContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(OBParserLEVEL, 0)
}

func (s *Transaction_characteristicsContext) Isolation_level() IIsolation_levelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsolation_levelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsolation_levelContext)
}

func (s *Transaction_characteristicsContext) Comma() antlr.TerminalNode {
	return s.GetToken(OBParserComma, 0)
}

func (s *Transaction_characteristicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transaction_characteristicsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transaction_characteristicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTransaction_characteristics(s)
	}
}

func (s *Transaction_characteristicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTransaction_characteristics(s)
	}
}

func (s *Transaction_characteristicsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTransaction_characteristics(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Transaction_characteristics() (localctx ITransaction_characteristicsContext) {
	localctx = NewTransaction_characteristicsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 908, OBParserRULE_transaction_characteristics)
	p.SetState(8170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 855, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8154)
			p.Transaction_access_mode()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8155)
			p.Match(OBParserISOLATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8156)
			p.Match(OBParserLEVEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8157)
			p.Isolation_level()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8158)
			p.Transaction_access_mode()
		}
		{
			p.SetState(8159)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8160)
			p.Match(OBParserISOLATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8161)
			p.Match(OBParserLEVEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8162)
			p.Isolation_level()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8164)
			p.Match(OBParserISOLATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8165)
			p.Match(OBParserLEVEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8166)
			p.Isolation_level()
		}
		{
			p.SetState(8167)
			p.Match(OBParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8168)
			p.Transaction_access_mode()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransaction_access_modeContext is an interface to support dynamic dispatch.
type ITransaction_access_modeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	WRITE() antlr.TerminalNode

	// IsTransaction_access_modeContext differentiates from other interfaces.
	IsTransaction_access_modeContext()
}

type Transaction_access_modeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransaction_access_modeContext() *Transaction_access_modeContext {
	var p = new(Transaction_access_modeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_transaction_access_mode
	return p
}

func InitEmptyTransaction_access_modeContext(p *Transaction_access_modeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_transaction_access_mode
}

func (*Transaction_access_modeContext) IsTransaction_access_modeContext() {}

func NewTransaction_access_modeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transaction_access_modeContext {
	var p = new(Transaction_access_modeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_transaction_access_mode

	return p
}

func (s *Transaction_access_modeContext) GetParser() antlr.Parser { return s.parser }

func (s *Transaction_access_modeContext) READ() antlr.TerminalNode {
	return s.GetToken(OBParserREAD, 0)
}

func (s *Transaction_access_modeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(OBParserONLY, 0)
}

func (s *Transaction_access_modeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(OBParserWRITE, 0)
}

func (s *Transaction_access_modeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transaction_access_modeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transaction_access_modeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterTransaction_access_mode(s)
	}
}

func (s *Transaction_access_modeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitTransaction_access_mode(s)
	}
}

func (s *Transaction_access_modeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitTransaction_access_mode(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Transaction_access_mode() (localctx ITransaction_access_modeContext) {
	localctx = NewTransaction_access_modeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 910, OBParserRULE_transaction_access_mode)
	p.SetState(8176)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 856, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8172)
			p.Match(OBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8173)
			p.Match(OBParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8174)
			p.Match(OBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8175)
			p.Match(OBParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsolation_levelContext is an interface to support dynamic dispatch.
type IIsolation_levelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsIsolation_levelContext differentiates from other interfaces.
	IsIsolation_levelContext()
}

type Isolation_levelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsolation_levelContext() *Isolation_levelContext {
	var p = new(Isolation_levelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_isolation_level
	return p
}

func InitEmptyIsolation_levelContext(p *Isolation_levelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_isolation_level
}

func (*Isolation_levelContext) IsIsolation_levelContext() {}

func NewIsolation_levelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Isolation_levelContext {
	var p = new(Isolation_levelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_isolation_level

	return p
}

func (s *Isolation_levelContext) GetParser() antlr.Parser { return s.parser }

func (s *Isolation_levelContext) READ() antlr.TerminalNode {
	return s.GetToken(OBParserREAD, 0)
}

func (s *Isolation_levelContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(OBParserUNCOMMITTED, 0)
}

func (s *Isolation_levelContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(OBParserCOMMITTED, 0)
}

func (s *Isolation_levelContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(OBParserREPEATABLE, 0)
}

func (s *Isolation_levelContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(OBParserSERIALIZABLE, 0)
}

func (s *Isolation_levelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Isolation_levelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Isolation_levelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterIsolation_level(s)
	}
}

func (s *Isolation_levelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitIsolation_level(s)
	}
}

func (s *Isolation_levelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitIsolation_level(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Isolation_level() (localctx IIsolation_levelContext) {
	localctx = NewIsolation_levelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 912, OBParserRULE_isolation_level)
	p.SetState(8185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 857, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8178)
			p.Match(OBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8179)
			p.Match(OBParserUNCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8180)
			p.Match(OBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8181)
			p.Match(OBParserCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8182)
			p.Match(OBParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8183)
			p.Match(OBParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8184)
			p.Match(OBParserSERIALIZABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_savepoint_stmtContext is an interface to support dynamic dispatch.
type ICreate_savepoint_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAVEPOINT() antlr.TerminalNode
	Var_name() IVar_nameContext

	// IsCreate_savepoint_stmtContext differentiates from other interfaces.
	IsCreate_savepoint_stmtContext()
}

type Create_savepoint_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_savepoint_stmtContext() *Create_savepoint_stmtContext {
	var p = new(Create_savepoint_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_savepoint_stmt
	return p
}

func InitEmptyCreate_savepoint_stmtContext(p *Create_savepoint_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_create_savepoint_stmt
}

func (*Create_savepoint_stmtContext) IsCreate_savepoint_stmtContext() {}

func NewCreate_savepoint_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_savepoint_stmtContext {
	var p = new(Create_savepoint_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_create_savepoint_stmt

	return p
}

func (s *Create_savepoint_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_savepoint_stmtContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(OBParserSAVEPOINT, 0)
}

func (s *Create_savepoint_stmtContext) Var_name() IVar_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVar_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVar_nameContext)
}

func (s *Create_savepoint_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_savepoint_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_savepoint_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCreate_savepoint_stmt(s)
	}
}

func (s *Create_savepoint_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCreate_savepoint_stmt(s)
	}
}

func (s *Create_savepoint_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCreate_savepoint_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Create_savepoint_stmt() (localctx ICreate_savepoint_stmtContext) {
	localctx = NewCreate_savepoint_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 914, OBParserRULE_create_savepoint_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8187)
		p.Match(OBParserSAVEPOINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8188)
		p.Var_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollback_savepoint_stmtContext is an interface to support dynamic dispatch.
type IRollback_savepoint_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLBACK() antlr.TerminalNode
	TO() antlr.TerminalNode
	Var_name() IVar_nameContext
	WORK() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode

	// IsRollback_savepoint_stmtContext differentiates from other interfaces.
	IsRollback_savepoint_stmtContext()
}

type Rollback_savepoint_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollback_savepoint_stmtContext() *Rollback_savepoint_stmtContext {
	var p = new(Rollback_savepoint_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rollback_savepoint_stmt
	return p
}

func InitEmptyRollback_savepoint_stmtContext(p *Rollback_savepoint_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_rollback_savepoint_stmt
}

func (*Rollback_savepoint_stmtContext) IsRollback_savepoint_stmtContext() {}

func NewRollback_savepoint_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rollback_savepoint_stmtContext {
	var p = new(Rollback_savepoint_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_rollback_savepoint_stmt

	return p
}

func (s *Rollback_savepoint_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Rollback_savepoint_stmtContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(OBParserROLLBACK, 0)
}

func (s *Rollback_savepoint_stmtContext) TO() antlr.TerminalNode {
	return s.GetToken(OBParserTO, 0)
}

func (s *Rollback_savepoint_stmtContext) Var_name() IVar_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVar_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVar_nameContext)
}

func (s *Rollback_savepoint_stmtContext) WORK() antlr.TerminalNode {
	return s.GetToken(OBParserWORK, 0)
}

func (s *Rollback_savepoint_stmtContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(OBParserSAVEPOINT, 0)
}

func (s *Rollback_savepoint_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rollback_savepoint_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rollback_savepoint_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRollback_savepoint_stmt(s)
	}
}

func (s *Rollback_savepoint_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRollback_savepoint_stmt(s)
	}
}

func (s *Rollback_savepoint_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRollback_savepoint_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Rollback_savepoint_stmt() (localctx IRollback_savepoint_stmtContext) {
	localctx = NewRollback_savepoint_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 916, OBParserRULE_rollback_savepoint_stmt)
	p.SetState(8201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 858, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8190)
			p.Match(OBParserROLLBACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8191)
			p.Match(OBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8192)
			p.Var_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8193)
			p.Match(OBParserROLLBACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8194)
			p.Match(OBParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8195)
			p.Match(OBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8196)
			p.Var_name()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8197)
			p.Match(OBParserROLLBACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8198)
			p.Match(OBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8199)
			p.Match(OBParserSAVEPOINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8200)
			p.Var_name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelease_savepoint_stmtContext is an interface to support dynamic dispatch.
type IRelease_savepoint_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RELEASE() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode
	Var_name() IVar_nameContext

	// IsRelease_savepoint_stmtContext differentiates from other interfaces.
	IsRelease_savepoint_stmtContext()
}

type Release_savepoint_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelease_savepoint_stmtContext() *Release_savepoint_stmtContext {
	var p = new(Release_savepoint_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_release_savepoint_stmt
	return p
}

func InitEmptyRelease_savepoint_stmtContext(p *Release_savepoint_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_release_savepoint_stmt
}

func (*Release_savepoint_stmtContext) IsRelease_savepoint_stmtContext() {}

func NewRelease_savepoint_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Release_savepoint_stmtContext {
	var p = new(Release_savepoint_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_release_savepoint_stmt

	return p
}

func (s *Release_savepoint_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Release_savepoint_stmtContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(OBParserRELEASE, 0)
}

func (s *Release_savepoint_stmtContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(OBParserSAVEPOINT, 0)
}

func (s *Release_savepoint_stmtContext) Var_name() IVar_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVar_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVar_nameContext)
}

func (s *Release_savepoint_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Release_savepoint_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Release_savepoint_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRelease_savepoint_stmt(s)
	}
}

func (s *Release_savepoint_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRelease_savepoint_stmt(s)
	}
}

func (s *Release_savepoint_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRelease_savepoint_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Release_savepoint_stmt() (localctx IRelease_savepoint_stmtContext) {
	localctx = NewRelease_savepoint_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 918, OBParserRULE_release_savepoint_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8203)
		p.Match(OBParserRELEASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8204)
		p.Match(OBParserSAVEPOINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8205)
		p.Var_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_cluster_stmtContext is an interface to support dynamic dispatch.
type IAlter_cluster_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	Cluster_action() ICluster_actionContext
	Cluster_name() ICluster_nameContext
	CLUSTER_ID() antlr.TerminalNode
	Conf_const() IConf_constContext
	COMP_EQ() antlr.TerminalNode
	FORCE() antlr.TerminalNode

	// IsAlter_cluster_stmtContext differentiates from other interfaces.
	IsAlter_cluster_stmtContext()
}

type Alter_cluster_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_cluster_stmtContext() *Alter_cluster_stmtContext {
	var p = new(Alter_cluster_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_cluster_stmt
	return p
}

func InitEmptyAlter_cluster_stmtContext(p *Alter_cluster_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_alter_cluster_stmt
}

func (*Alter_cluster_stmtContext) IsAlter_cluster_stmtContext() {}

func NewAlter_cluster_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_cluster_stmtContext {
	var p = new(Alter_cluster_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_alter_cluster_stmt

	return p
}

func (s *Alter_cluster_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_cluster_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(OBParserALTER, 0)
}

func (s *Alter_cluster_stmtContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(OBParserSYSTEM, 0)
}

func (s *Alter_cluster_stmtContext) Cluster_action() ICluster_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICluster_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICluster_actionContext)
}

func (s *Alter_cluster_stmtContext) Cluster_name() ICluster_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICluster_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICluster_nameContext)
}

func (s *Alter_cluster_stmtContext) CLUSTER_ID() antlr.TerminalNode {
	return s.GetToken(OBParserCLUSTER_ID, 0)
}

func (s *Alter_cluster_stmtContext) Conf_const() IConf_constContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConf_constContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConf_constContext)
}

func (s *Alter_cluster_stmtContext) COMP_EQ() antlr.TerminalNode {
	return s.GetToken(OBParserCOMP_EQ, 0)
}

func (s *Alter_cluster_stmtContext) FORCE() antlr.TerminalNode {
	return s.GetToken(OBParserFORCE, 0)
}

func (s *Alter_cluster_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_cluster_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_cluster_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterAlter_cluster_stmt(s)
	}
}

func (s *Alter_cluster_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitAlter_cluster_stmt(s)
	}
}

func (s *Alter_cluster_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitAlter_cluster_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Alter_cluster_stmt() (localctx IAlter_cluster_stmtContext) {
	localctx = NewAlter_cluster_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 920, OBParserRULE_alter_cluster_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8207)
		p.Match(OBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8208)
		p.Match(OBParserSYSTEM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8209)
		p.Cluster_action()
	}
	{
		p.SetState(8210)
		p.Cluster_name()
	}
	{
		p.SetState(8211)
		p.Match(OBParserCLUSTER_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(8213)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserCOMP_EQ {
		{
			p.SetState(8212)
			p.Match(OBParserCOMP_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(8215)
		p.Conf_const()
	}
	p.SetState(8217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == OBParserFORCE {
		{
			p.SetState(8216)
			p.Match(OBParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICluster_actionContext is an interface to support dynamic dispatch.
type ICluster_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	SYNCHRONIZATION() antlr.TerminalNode
	DISABLE() antlr.TerminalNode

	// IsCluster_actionContext differentiates from other interfaces.
	IsCluster_actionContext()
}

type Cluster_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCluster_actionContext() *Cluster_actionContext {
	var p = new(Cluster_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cluster_action
	return p
}

func InitEmptyCluster_actionContext(p *Cluster_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cluster_action
}

func (*Cluster_actionContext) IsCluster_actionContext() {}

func NewCluster_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cluster_actionContext {
	var p = new(Cluster_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_cluster_action

	return p
}

func (s *Cluster_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cluster_actionContext) ADD() antlr.TerminalNode {
	return s.GetToken(OBParserADD, 0)
}

func (s *Cluster_actionContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(OBParserCLUSTER, 0)
}

func (s *Cluster_actionContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(OBParserREMOVE, 0)
}

func (s *Cluster_actionContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(OBParserENABLE, 0)
}

func (s *Cluster_actionContext) SYNCHRONIZATION() antlr.TerminalNode {
	return s.GetToken(OBParserSYNCHRONIZATION, 0)
}

func (s *Cluster_actionContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(OBParserDISABLE, 0)
}

func (s *Cluster_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cluster_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cluster_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCluster_action(s)
	}
}

func (s *Cluster_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCluster_action(s)
	}
}

func (s *Cluster_actionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCluster_action(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Cluster_action() (localctx ICluster_actionContext) {
	localctx = NewCluster_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 922, OBParserRULE_cluster_action)
	p.SetState(8229)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserADD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8219)
			p.Match(OBParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8220)
			p.Match(OBParserCLUSTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserREMOVE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8221)
			p.Match(OBParserREMOVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8222)
			p.Match(OBParserCLUSTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserENABLE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8223)
			p.Match(OBParserENABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8224)
			p.Match(OBParserCLUSTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8225)
			p.Match(OBParserSYNCHRONIZATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserDISABLE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8226)
			p.Match(OBParserDISABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8227)
			p.Match(OBParserCLUSTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8228)
			p.Match(OBParserSYNCHRONIZATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchover_cluster_stmtContext is an interface to support dynamic dispatch.
type ISwitchover_cluster_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	Commit_switchover_clause() ICommit_switchover_clauseContext

	// IsSwitchover_cluster_stmtContext differentiates from other interfaces.
	IsSwitchover_cluster_stmtContext()
}

type Switchover_cluster_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchover_cluster_stmtContext() *Switchover_cluster_stmtContext {
	var p = new(Switchover_cluster_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_switchover_cluster_stmt
	return p
}

func InitEmptySwitchover_cluster_stmtContext(p *Switchover_cluster_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_switchover_cluster_stmt
}

func (*Switchover_cluster_stmtContext) IsSwitchover_cluster_stmtContext() {}

func NewSwitchover_cluster_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Switchover_cluster_stmtContext {
	var p = new(Switchover_cluster_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_switchover_cluster_stmt

	return p
}

func (s *Switchover_cluster_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Switchover_cluster_stmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(OBParserALTER, 0)
}

func (s *Switchover_cluster_stmtContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(OBParserSYSTEM, 0)
}

func (s *Switchover_cluster_stmtContext) Commit_switchover_clause() ICommit_switchover_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommit_switchover_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommit_switchover_clauseContext)
}

func (s *Switchover_cluster_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Switchover_cluster_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Switchover_cluster_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterSwitchover_cluster_stmt(s)
	}
}

func (s *Switchover_cluster_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitSwitchover_cluster_stmt(s)
	}
}

func (s *Switchover_cluster_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitSwitchover_cluster_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Switchover_cluster_stmt() (localctx ISwitchover_cluster_stmtContext) {
	localctx = NewSwitchover_cluster_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 924, OBParserRULE_switchover_cluster_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8231)
		p.Match(OBParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8232)
		p.Match(OBParserSYSTEM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8233)
		p.Commit_switchover_clause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommit_switchover_clauseContext is an interface to support dynamic dispatch.
type ICommit_switchover_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMIT() antlr.TerminalNode
	AllTO() []antlr.TerminalNode
	TO(i int) antlr.TerminalNode
	SWITCHOVER() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	WITH() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	SHUTDOWN() antlr.TerminalNode
	PHYSICAL() antlr.TerminalNode
	STANDBY() antlr.TerminalNode
	ACTIVATE() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	CONVERT() antlr.TerminalNode

	// IsCommit_switchover_clauseContext differentiates from other interfaces.
	IsCommit_switchover_clauseContext()
}

type Commit_switchover_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommit_switchover_clauseContext() *Commit_switchover_clauseContext {
	var p = new(Commit_switchover_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_commit_switchover_clause
	return p
}

func InitEmptyCommit_switchover_clauseContext(p *Commit_switchover_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_commit_switchover_clause
}

func (*Commit_switchover_clauseContext) IsCommit_switchover_clauseContext() {}

func NewCommit_switchover_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Commit_switchover_clauseContext {
	var p = new(Commit_switchover_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_commit_switchover_clause

	return p
}

func (s *Commit_switchover_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Commit_switchover_clauseContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(OBParserCOMMIT, 0)
}

func (s *Commit_switchover_clauseContext) AllTO() []antlr.TerminalNode {
	return s.GetTokens(OBParserTO)
}

func (s *Commit_switchover_clauseContext) TO(i int) antlr.TerminalNode {
	return s.GetToken(OBParserTO, i)
}

func (s *Commit_switchover_clauseContext) SWITCHOVER() antlr.TerminalNode {
	return s.GetToken(OBParserSWITCHOVER, 0)
}

func (s *Commit_switchover_clauseContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(OBParserPRIMARY, 0)
}

func (s *Commit_switchover_clauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(OBParserWITH, 0)
}

func (s *Commit_switchover_clauseContext) SESSION() antlr.TerminalNode {
	return s.GetToken(OBParserSESSION, 0)
}

func (s *Commit_switchover_clauseContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(OBParserSHUTDOWN, 0)
}

func (s *Commit_switchover_clauseContext) PHYSICAL() antlr.TerminalNode {
	return s.GetToken(OBParserPHYSICAL, 0)
}

func (s *Commit_switchover_clauseContext) STANDBY() antlr.TerminalNode {
	return s.GetToken(OBParserSTANDBY, 0)
}

func (s *Commit_switchover_clauseContext) ACTIVATE() antlr.TerminalNode {
	return s.GetToken(OBParserACTIVATE, 0)
}

func (s *Commit_switchover_clauseContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(OBParserCLUSTER, 0)
}

func (s *Commit_switchover_clauseContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(OBParserCONVERT, 0)
}

func (s *Commit_switchover_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Commit_switchover_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Commit_switchover_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCommit_switchover_clause(s)
	}
}

func (s *Commit_switchover_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCommit_switchover_clause(s)
	}
}

func (s *Commit_switchover_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCommit_switchover_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Commit_switchover_clause() (localctx ICommit_switchover_clauseContext) {
	localctx = NewCommit_switchover_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 926, OBParserRULE_commit_switchover_clause)
	var _la int

	p.SetState(8264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 864, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8235)
			p.Match(OBParserCOMMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8236)
			p.Match(OBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8237)
			p.Match(OBParserSWITCHOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8238)
			p.Match(OBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8239)
			p.Match(OBParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8243)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserWITH {
			{
				p.SetState(8240)
				p.Match(OBParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8241)
				p.Match(OBParserSESSION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8242)
				p.Match(OBParserSHUTDOWN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8245)
			p.Match(OBParserCOMMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8246)
			p.Match(OBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8247)
			p.Match(OBParserSWITCHOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8248)
			p.Match(OBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8249)
			p.Match(OBParserPHYSICAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8250)
			p.Match(OBParserSTANDBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8254)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == OBParserWITH {
			{
				p.SetState(8251)
				p.Match(OBParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8252)
				p.Match(OBParserSESSION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8253)
				p.Match(OBParserSHUTDOWN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8256)
			p.Match(OBParserACTIVATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8257)
			p.Match(OBParserPHYSICAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8258)
			p.Match(OBParserSTANDBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8259)
			p.Match(OBParserCLUSTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8260)
			p.Match(OBParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8261)
			p.Match(OBParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8262)
			p.Match(OBParserPHYSICAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8263)
			p.Match(OBParserSTANDBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICluster_nameContext is an interface to support dynamic dispatch.
type ICluster_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Relation_name() IRelation_nameContext
	STRING_VALUE() antlr.TerminalNode

	// IsCluster_nameContext differentiates from other interfaces.
	IsCluster_nameContext()
}

type Cluster_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCluster_nameContext() *Cluster_nameContext {
	var p = new(Cluster_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cluster_name
	return p
}

func InitEmptyCluster_nameContext(p *Cluster_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_cluster_name
}

func (*Cluster_nameContext) IsCluster_nameContext() {}

func NewCluster_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cluster_nameContext {
	var p = new(Cluster_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_cluster_name

	return p
}

func (s *Cluster_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Cluster_nameContext) Relation_name() IRelation_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelation_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelation_nameContext)
}

func (s *Cluster_nameContext) STRING_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING_VALUE, 0)
}

func (s *Cluster_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cluster_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cluster_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterCluster_name(s)
	}
}

func (s *Cluster_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitCluster_name(s)
	}
}

func (s *Cluster_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitCluster_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Cluster_name() (localctx ICluster_nameContext) {
	localctx = NewCluster_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 928, OBParserRULE_cluster_name)
	p.SetState(8268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserNAME_OB, OBParserSTAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8266)
			p.Relation_name()
		}

	case OBParserSTRING_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8267)
			p.Match(OBParserSTRING_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVar_nameContext is an interface to support dynamic dispatch.
type IVar_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME_OB() antlr.TerminalNode
	Unreserved_keyword_normal() IUnreserved_keyword_normalContext

	// IsVar_nameContext differentiates from other interfaces.
	IsVar_nameContext()
}

type Var_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_nameContext() *Var_nameContext {
	var p = new(Var_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_var_name
	return p
}

func InitEmptyVar_nameContext(p *Var_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_var_name
}

func (*Var_nameContext) IsVar_nameContext() {}

func NewVar_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_nameContext {
	var p = new(Var_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_var_name

	return p
}

func (s *Var_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Var_nameContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Var_nameContext) Unreserved_keyword_normal() IUnreserved_keyword_normalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keyword_normalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keyword_normalContext)
}

func (s *Var_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterVar_name(s)
	}
}

func (s *Var_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitVar_name(s)
	}
}

func (s *Var_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitVar_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Var_name() (localctx IVar_nameContext) {
	localctx = NewVar_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 930, OBParserRULE_var_name)
	p.SetState(8272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserNAME_OB:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8270)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserSTAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8271)
			p.Unreserved_keyword_normal()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_nameContext is an interface to support dynamic dispatch.
type IColumn_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME_OB() antlr.TerminalNode
	Unreserved_keyword() IUnreserved_keywordContext

	// IsColumn_nameContext differentiates from other interfaces.
	IsColumn_nameContext()
}

type Column_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_nameContext() *Column_nameContext {
	var p = new(Column_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_name
	return p
}

func InitEmptyColumn_nameContext(p *Column_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_name
}

func (*Column_nameContext) IsColumn_nameContext() {}

func NewColumn_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_nameContext {
	var p = new(Column_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_column_name

	return p
}

func (s *Column_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_nameContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Column_nameContext) Unreserved_keyword() IUnreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keywordContext)
}

func (s *Column_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterColumn_name(s)
	}
}

func (s *Column_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitColumn_name(s)
	}
}

func (s *Column_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitColumn_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Column_name() (localctx IColumn_nameContext) {
	localctx = NewColumn_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 932, OBParserRULE_column_name)
	p.SetState(8276)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserNAME_OB:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8274)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserSTAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8275)
			p.Unreserved_keyword()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelation_nameContext is an interface to support dynamic dispatch.
type IRelation_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME_OB() antlr.TerminalNode
	Unreserved_keyword() IUnreserved_keywordContext

	// IsRelation_nameContext differentiates from other interfaces.
	IsRelation_nameContext()
}

type Relation_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelation_nameContext() *Relation_nameContext {
	var p = new(Relation_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_name
	return p
}

func InitEmptyRelation_nameContext(p *Relation_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_relation_name
}

func (*Relation_nameContext) IsRelation_nameContext() {}

func NewRelation_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relation_nameContext {
	var p = new(Relation_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_relation_name

	return p
}

func (s *Relation_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Relation_nameContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Relation_nameContext) Unreserved_keyword() IUnreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keywordContext)
}

func (s *Relation_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relation_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relation_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterRelation_name(s)
	}
}

func (s *Relation_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitRelation_name(s)
	}
}

func (s *Relation_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitRelation_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Relation_name() (localctx IRelation_nameContext) {
	localctx = NewRelation_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 934, OBParserRULE_relation_name)
	p.SetState(8280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserNAME_OB:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8278)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserSTAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8279)
			p.Unreserved_keyword()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunction_nameContext is an interface to support dynamic dispatch.
type IFunction_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME_OB() antlr.TerminalNode
	DUMP() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	KEY_VERSION() antlr.TerminalNode
	USER() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	COALESCE() antlr.TerminalNode
	REPEAT() antlr.TerminalNode
	ROW_COUNT() antlr.TerminalNode
	REVERSE() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	SYSTEM_USER() antlr.TerminalNode
	SESSION_USER() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode

	// IsFunction_nameContext differentiates from other interfaces.
	IsFunction_nameContext()
}

type Function_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_nameContext() *Function_nameContext {
	var p = new(Function_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_function_name
	return p
}

func InitEmptyFunction_nameContext(p *Function_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_function_name
}

func (*Function_nameContext) IsFunction_nameContext() {}

func NewFunction_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_nameContext {
	var p = new(Function_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_function_name

	return p
}

func (s *Function_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_nameContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Function_nameContext) DUMP() antlr.TerminalNode {
	return s.GetToken(OBParserDUMP, 0)
}

func (s *Function_nameContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(OBParserCHARSET, 0)
}

func (s *Function_nameContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(OBParserCOLLATION, 0)
}

func (s *Function_nameContext) KEY_VERSION() antlr.TerminalNode {
	return s.GetToken(OBParserKEY_VERSION, 0)
}

func (s *Function_nameContext) USER() antlr.TerminalNode {
	return s.GetToken(OBParserUSER, 0)
}

func (s *Function_nameContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(OBParserDATABASE, 0)
}

func (s *Function_nameContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(OBParserCOALESCE, 0)
}

func (s *Function_nameContext) REPEAT() antlr.TerminalNode {
	return s.GetToken(OBParserREPEAT, 0)
}

func (s *Function_nameContext) ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(OBParserROW_COUNT, 0)
}

func (s *Function_nameContext) REVERSE() antlr.TerminalNode {
	return s.GetToken(OBParserREVERSE, 0)
}

func (s *Function_nameContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(OBParserRIGHT, 0)
}

func (s *Function_nameContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(OBParserCURRENT_USER, 0)
}

func (s *Function_nameContext) SYSTEM_USER() antlr.TerminalNode {
	return s.GetToken(OBParserSYSTEM_USER, 0)
}

func (s *Function_nameContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(OBParserSESSION_USER, 0)
}

func (s *Function_nameContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(OBParserREPLACE, 0)
}

func (s *Function_nameContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(OBParserTRUNCATE, 0)
}

func (s *Function_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterFunction_name(s)
	}
}

func (s *Function_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitFunction_name(s)
	}
}

func (s *Function_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitFunction_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Function_name() (localctx IFunction_nameContext) {
	localctx = NewFunction_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 936, OBParserRULE_function_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8282)
		_la = p.GetTokenStream().LA(1)

		if !(_la == OBParserCURRENT_USER || _la == OBParserDATABASE || ((int64((_la-179)) & ^0x3f) == 0 && ((int64(1)<<(_la-179))&131) != 0) || _la == OBParserTRUNCATE || _la == OBParserCOLLATION || _la == OBParserCOALESCE || _la == OBParserDUMP || _la == OBParserREVERSE || _la == OBParserROW_COUNT || ((int64((_la-577)) & ^0x3f) == 0 && ((int64(1)<<(_la-577))&67108869) != 0) || _la == OBParserSESSION_USER || _la == OBParserSYSTEM_USER || _la == OBParserNAME_OB) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_labelContext is an interface to support dynamic dispatch.
type IColumn_labelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME_OB() antlr.TerminalNode
	Unreserved_keyword() IUnreserved_keywordContext

	// IsColumn_labelContext differentiates from other interfaces.
	IsColumn_labelContext()
}

type Column_labelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_labelContext() *Column_labelContext {
	var p = new(Column_labelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_label
	return p
}

func InitEmptyColumn_labelContext(p *Column_labelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_column_label
}

func (*Column_labelContext) IsColumn_labelContext() {}

func NewColumn_labelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_labelContext {
	var p = new(Column_labelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_column_label

	return p
}

func (s *Column_labelContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_labelContext) NAME_OB() antlr.TerminalNode {
	return s.GetToken(OBParserNAME_OB, 0)
}

func (s *Column_labelContext) Unreserved_keyword() IUnreserved_keywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keywordContext)
}

func (s *Column_labelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_labelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_labelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterColumn_label(s)
	}
}

func (s *Column_labelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitColumn_label(s)
	}
}

func (s *Column_labelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitColumn_label(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Column_label() (localctx IColumn_labelContext) {
	localctx = NewColumn_labelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 938, OBParserRULE_column_label)
	p.SetState(8286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserNAME_OB:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8284)
			p.Match(OBParserNAME_OB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserPASSWORD, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserSTAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8285)
			p.Unreserved_keyword()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDate_unitContext is an interface to support dynamic dispatch.
type IDate_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DAY() antlr.TerminalNode
	DAY_HOUR() antlr.TerminalNode
	DAY_MICROSECOND() antlr.TerminalNode
	DAY_MINUTE() antlr.TerminalNode
	DAY_SECOND() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	HOUR_MICROSECOND() antlr.TerminalNode
	HOUR_MINUTE() antlr.TerminalNode
	HOUR_SECOND() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MINUTE_MICROSECOND() antlr.TerminalNode
	MINUTE_SECOND() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SECOND_MICROSECOND() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	YEAR_MONTH() antlr.TerminalNode

	// IsDate_unitContext differentiates from other interfaces.
	IsDate_unitContext()
}

type Date_unitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDate_unitContext() *Date_unitContext {
	var p = new(Date_unitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_date_unit
	return p
}

func InitEmptyDate_unitContext(p *Date_unitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_date_unit
}

func (*Date_unitContext) IsDate_unitContext() {}

func NewDate_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Date_unitContext {
	var p = new(Date_unitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_date_unit

	return p
}

func (s *Date_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Date_unitContext) DAY() antlr.TerminalNode {
	return s.GetToken(OBParserDAY, 0)
}

func (s *Date_unitContext) DAY_HOUR() antlr.TerminalNode {
	return s.GetToken(OBParserDAY_HOUR, 0)
}

func (s *Date_unitContext) DAY_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(OBParserDAY_MICROSECOND, 0)
}

func (s *Date_unitContext) DAY_MINUTE() antlr.TerminalNode {
	return s.GetToken(OBParserDAY_MINUTE, 0)
}

func (s *Date_unitContext) DAY_SECOND() antlr.TerminalNode {
	return s.GetToken(OBParserDAY_SECOND, 0)
}

func (s *Date_unitContext) HOUR() antlr.TerminalNode {
	return s.GetToken(OBParserHOUR, 0)
}

func (s *Date_unitContext) HOUR_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(OBParserHOUR_MICROSECOND, 0)
}

func (s *Date_unitContext) HOUR_MINUTE() antlr.TerminalNode {
	return s.GetToken(OBParserHOUR_MINUTE, 0)
}

func (s *Date_unitContext) HOUR_SECOND() antlr.TerminalNode {
	return s.GetToken(OBParserHOUR_SECOND, 0)
}

func (s *Date_unitContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(OBParserMICROSECOND, 0)
}

func (s *Date_unitContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(OBParserMINUTE, 0)
}

func (s *Date_unitContext) MINUTE_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(OBParserMINUTE_MICROSECOND, 0)
}

func (s *Date_unitContext) MINUTE_SECOND() antlr.TerminalNode {
	return s.GetToken(OBParserMINUTE_SECOND, 0)
}

func (s *Date_unitContext) MONTH() antlr.TerminalNode {
	return s.GetToken(OBParserMONTH, 0)
}

func (s *Date_unitContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(OBParserQUARTER, 0)
}

func (s *Date_unitContext) SECOND() antlr.TerminalNode {
	return s.GetToken(OBParserSECOND, 0)
}

func (s *Date_unitContext) SECOND_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(OBParserSECOND_MICROSECOND, 0)
}

func (s *Date_unitContext) WEEK() antlr.TerminalNode {
	return s.GetToken(OBParserWEEK, 0)
}

func (s *Date_unitContext) YEAR() antlr.TerminalNode {
	return s.GetToken(OBParserYEAR, 0)
}

func (s *Date_unitContext) YEAR_MONTH() antlr.TerminalNode {
	return s.GetToken(OBParserYEAR_MONTH, 0)
}

func (s *Date_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Date_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Date_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterDate_unit(s)
	}
}

func (s *Date_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitDate_unit(s)
	}
}

func (s *Date_unitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitDate_unit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Date_unit() (localctx IDate_unitContext) {
	localctx = NewDate_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 940, OBParserRULE_date_unit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8288)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-43)) & ^0x3f) == 0 && ((int64(1)<<(_la-43))&492581209243663) != 0) || ((int64((_la-147)) & ^0x3f) == 0 && ((int64(1)<<(_la-147))&2199023255555) != 0) || _la == OBParserYEAR_MONTH || _la == OBParserYEAR || _la == OBParserSECOND || ((int64((_la-694)) & ^0x3f) == 0 && ((int64(1)<<(_la-694))&144116287587516417) != 0) || _la == OBParserQUARTER || _la == OBParserDAY || _la == OBParserWEEK) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnreserved_keywordContext is an interface to support dynamic dispatch.
type IUnreserved_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Unreserved_keyword_normal() IUnreserved_keyword_normalContext
	Unreserved_keyword_special() IUnreserved_keyword_specialContext

	// IsUnreserved_keywordContext differentiates from other interfaces.
	IsUnreserved_keywordContext()
}

type Unreserved_keywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnreserved_keywordContext() *Unreserved_keywordContext {
	var p = new(Unreserved_keywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_unreserved_keyword
	return p
}

func InitEmptyUnreserved_keywordContext(p *Unreserved_keywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_unreserved_keyword
}

func (*Unreserved_keywordContext) IsUnreserved_keywordContext() {}

func NewUnreserved_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unreserved_keywordContext {
	var p = new(Unreserved_keywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_unreserved_keyword

	return p
}

func (s *Unreserved_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Unreserved_keywordContext) Unreserved_keyword_normal() IUnreserved_keyword_normalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keyword_normalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keyword_normalContext)
}

func (s *Unreserved_keywordContext) Unreserved_keyword_special() IUnreserved_keyword_specialContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnreserved_keyword_specialContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnreserved_keyword_specialContext)
}

func (s *Unreserved_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unreserved_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unreserved_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUnreserved_keyword(s)
	}
}

func (s *Unreserved_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUnreserved_keyword(s)
	}
}

func (s *Unreserved_keywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUnreserved_keyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Unreserved_keyword() (localctx IUnreserved_keywordContext) {
	localctx = NewUnreserved_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 942, OBParserRULE_unreserved_keyword)
	p.SetState(8292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case OBParserCIPHER, OBParserCOLUMNS, OBParserNUMBER, OBParserFIELDS, OBParserID, OBParserISSUER, OBParserLANGUAGE, OBParserLOCAL, OBParserMODE, OBParserPARSER, OBParserROWS, OBParserSUBJECT, OBParserSYSDATE, OBParserTEXT, OBParserX509, OBParserWARNINGS, OBParserFORMAT, OBParserUNINSTALL, OBParserUNDOFILE, OBParserMASTER_SSL_CA, OBParserYEAR, OBParserSTOP, OBParserSTORAGE_FORMAT_WORK_VERSION, OBParserAT, OBParserRELAY_LOG_POS, OBParserPOOL, OBParserCURDATE, OBParserZONE_TYPE, OBParserLOCATION, OBParserWEIGHT_STRING, OBParserCHANGED, OBParserMASTER_SSL_CAPATH, OBParserREWRITE_MERGE_VERSION, OBParserNTH_VALUE, OBParserSERIAL, OBParserPROGRESSIVE_MERGE_NUM, OBParserTABLET_MAX_SIZE, OBParserILOGCACHE, OBParserAUTHORS, OBParserMIGRATE, OBParserCONSISTENT, OBParserSUSPEND, OBParserSECURITY, OBParserREMOTE_OSS, OBParserSET_SLAVE_CLUSTER, OBParserFAST, OBParserTRUNCATE, OBParserCONSTRAINT_SCHEMA, OBParserMASTER_SSL_CERT, OBParserTABLE_NAME, OBParserDO, OBParserMASTER_RETRY_COUNT, OBParserREPLICA, OBParserOLD_KEY, OBParserDISABLE, OBParserPORT, OBParserREBUILD, OBParserFOLLOWER, OBParserROOT, OBParserREDOFILE, OBParserMASTER_SERVER_ID, OBParserNCHAR, OBParserKEY_BLOCK_SIZE, OBParserMIGRATION, OBParserSUBPARTITION, OBParserROW_NUMBER, OBParserCOMPRESSION, OBParserBIT, OBParserMAX_DISK_SIZE, OBParserSAMPLE, OBParserUNLOCKED, OBParserCLASS_ORIGIN, OBParserACTION, OBParserREDUNDANT, OBParserUPGRADE, OBParserSTART, OBParserTEMPTABLE, OBParserRECYCLEBIN, OBParserPROFILES, OBParserERRORS, OBParserLEAVES, OBParserUNDEFINED, OBParserEVERY, OBParserBYTE, OBParserFLUSH, OBParserMIN_ROWS, OBParserERROR_P, OBParserMAX_USER_CONNECTIONS, OBParserMAX_CPU, OBParserLOCKED, OBParserIO, OBParserBTREE, OBParserSLOT_IDX, OBParserHASH, OBParserROTATE, OBParserCOLLATION, OBParserMASTER, OBParserENCRYPTION, OBParserMAX, OBParserSQL_TSI_MONTH, OBParserMAX_QUERIES_PER_HOUR, OBParserCOMMENT, OBParserCTX_ID, OBParserMIN_IOPS, OBParserNVARCHAR, OBParserPAUSE, OBParserQUICK, OBParserDUPLICATE, OBParserWAIT, OBParserDES_KEY_FILE, OBParserENGINES, OBParserRETURNS, OBParserMASTER_USER, OBParserSOCKET, OBParserMASTER_DELAY, OBParserFILE_ID, OBParserFIRST, OBParserTABLET, OBParserCLIENT, OBParserENGINE_, OBParserTABLES, OBParserTRADITIONAL, OBParserBOOTSTRAP, OBParserSTDDEV, OBParserDATAFILE, OBParserINVOKER, OBParserDEPTH, OBParserNORMAL, OBParserCOLUMN_NAME, OBParserTRIGGERS, OBParserRESET, OBParserEVENT, OBParserCOALESCE, OBParserRESPECT, OBParserSTATUS, OBParserUNBOUNDED, OBParserWRAPPER, OBParserTIMESTAMP, OBParserPARTITIONS, OBParserSUBSTR, OBParserCHUNK, OBParserFILEX, OBParserUNIT, OBParserPRIVILEGES, OBParserLESS, OBParserSWITCH, OBParserDIAGNOSTICS, OBParserREDO_BUFFER_SIZE, OBParserNO, OBParserMAJOR, OBParserACTIVE, OBParserROUTINE, OBParserREAD_ONLY, OBParserROLLBACK, OBParserPARTITION_ID, OBParserDUMP, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, OBParserGROUPING, OBParserMAX_CONNECTIONS_PER_HOUR, OBParserSECOND, OBParserUNKNOWN, OBParserPOINT, OBParserPOLYGON, OBParserTABLE_ID, OBParserCONTEXT, OBParserFINAL_COUNT, OBParserMASTER_CONNECT_RETRY, OBParserPOSITION, OBParserDISCARD, OBParserPREV, OBParserRECOVER, OBParserPROCESS, OBParserDEALLOCATE, OBParserOLD_PASSWORD, OBParserLISTAGG, OBParserSLOW, OBParserSUM, OBParserOPTIONS, OBParserMIN, OBParserRELOAD, OBParserONE, OBParserDELAY_KEY_WRITE, OBParserSQL_TSI_HOUR, OBParserTIMESTAMPDIFF, OBParserRESTORE, OBParserOFFSET, OBParserTEMPORARY, OBParserVARIANCE, OBParserSNAPSHOT, OBParserSERVER_TYPE, OBParserCOMMITTED, OBParserINDEXES, OBParserFREEZE, OBParserSCOPE, OBParserIDC, OBParserVIEW, OBParserONE_SHOT, OBParserACCOUNT, OBParserLOCALITY, OBParserREVERSE, OBParserCLUSTER_ID, OBParserMAX_SIZE, OBParserPAGE, OBParserNAME, OBParserROW_COUNT, OBParserLAST, OBParserLOGONLY_REPLICA_NUM, OBParserDELAY, OBParserSUBDATE, OBParserROLLING, OBParserCONTAINS, OBParserGENERAL, OBParserVISIBLE, OBParserSIGNED, OBParserSERVER, OBParserNEXT, OBParserENDS, OBParserGLOBAL, OBParserSHUTDOWN, OBParserVERBOSE, OBParserCLUSTER_NAME, OBParserMASTER_PORT, OBParserMYSQL_ERRNO, OBParserXA, OBParserTIME, OBParserDATETIME, OBParserBOOL, OBParserDIRECTORY, OBParserDATA_TABLE_ID, OBParserVALID, OBParserMASTER_SSL_KEY, OBParserMASTER_PASSWORD, OBParserPLAN, OBParserSHARE, OBParserMULTIPOLYGON, OBParserSTDDEV_SAMP, OBParserUSE_BLOOM_FILTER, OBParserCONSTRAINT_CATALOG, OBParserCLUSTER, OBParserEXCHANGE, OBParserGRANTS, OBParserCAST, OBParserSERVER_PORT, OBParserSQL_CACHE, OBParserMAX_USED_PART_ID, OBParserINSTANCE, OBParserFUNCTION, OBParserNOWAIT, OBParserINVISIBLE, OBParserDENSE_RANK, OBParserCOUNT, OBParserNAMES, OBParserP_ENTITY, OBParserISOLATE, OBParserMAX_ROWS, OBParserCTXCAT, OBParserISOLATION, OBParserREPLICATION, OBParserREMOVE, OBParserSTATS_AUTO_RECALC, OBParserCONSISTENT_MODE, OBParserMODIFY, OBParserUNCOMMITTED, OBParserPHYSICAL, OBParserNO_WAIT, OBParserUNIT_NUM, OBParserMAX_IOPS, OBParserSPFILE, OBParserREPEATABLE, OBParserCOMPLETION, OBParserROOTTABLE, OBParserSUBSTRING, OBParserZONE, OBParserTEMPLATE, OBParserDATE_SUB, OBParserEXPIRE_INFO, OBParserEXPIRE, OBParserENABLE, OBParserHOSTS, OBParserSCHEMA_NAME, OBParserEXPANSION, OBParserREORGANIZE, OBParserBLOCK_SIZE, OBParserMINOR, OBParserRESUME, OBParserSTATS_PERSISTENT, OBParserNODEGROUP, OBParserPARTITIONING, OBParserSUPER, OBParserCOMMIT, OBParserSAVEPOINT, OBParserUNTIL, OBParserUSER, OBParserMEMTABLE, OBParserCHARSET, OBParserMOVE, OBParserXML, OBParserIPC, OBParserTRIM, OBParserRANK, OBParserDEFAULT_AUTH, OBParserEXTENT_SIZE, OBParserBINLOG, OBParserCLOG, OBParserGEOMETRYCOLLECTION, OBParserSTORAGE, OBParserMEDIUM, OBParserUSE_FRM, OBParserMASTER_HEARTBEAT_PERIOD, OBParserSUBPARTITIONS, OBParserCUBE, OBParserBALANCE, OBParserQUERY, OBParserSQL_TSI_QUARTER, OBParserREPAIR, OBParserMASTER_SSL_CIPHER, OBParserKEY_VERSION, OBParserCATALOG_NAME, OBParserNDBCLUSTER, OBParserCONNECTION, OBParserCOMPACT, OBParserSYNCHRONIZATION, OBParserINCR, OBParserCANCEL, OBParserSIMPLE, OBParserVARIABLES, OBParserSQL_TSI_WEEK, OBParserP_CHUNK, OBParserSYSTEM, OBParserPLUGIN_DIR, OBParserASCII, OBParserINFO, OBParserSQL_THREAD, OBParserTYPES, OBParserLEADER, OBParserFOUND, OBParserEXTRACT, OBParserFIXED, OBParserCACHE, OBParserCURRENT, OBParserRETURNED_SQLSTATE, OBParserEND, OBParserPRESERVE, OBParserSQL_BUFFER_RESULT, OBParserJSON, OBParserSOME, OBParserINDEX_TABLE_ID, OBParserFREQUENCY, OBParserLOCKS, OBParserMANUAL, OBParserGEOMETRY, OBParserIDENTIFIED, OBParserSTORAGE_FORMAT_VERSION, OBParserOVER, OBParserMAX_SESSION_NUM, OBParserUSER_RESOURCES, OBParserDESTINATION, OBParserSONAME, OBParserOUTLINE, OBParserMASTER_LOG_FILE, OBParserSLAVE, OBParserGTS, OBParserEXPORT, OBParserAVG_ROW_LENGTH, OBParserSESSION_USER, OBParserTABLEGROUPS, OBParserCURTIME, OBParserREPLICA_TYPE, OBParserAGGREGATE, OBParserPERCENT_RANK, OBParserENUM, OBParserNATIONAL, OBParserRECYCLE, OBParserREGION, OBParserMUTEX, OBParserNDB, OBParserSYSTEM_USER, OBParserMAX_UPDATES_PER_HOUR, OBParserCURSOR_NAME, OBParserCONCURRENT, OBParserDUMPFILE, OBParserCOMPRESSED, OBParserLINESTRING, OBParserDYNAMIC, OBParserCHAIN, OBParserLAG, OBParserBASELINE_ID, OBParserNEW, OBParserSQL_TSI_YEAR, OBParserTHAN, OBParserCPU, OBParserHOST, OBParserVALUE, OBParserLOGS, OBParserSERIALIZABLE, OBParserAUTO_INCREMENT, OBParserBACKUP, OBParserLOGFILE, OBParserROW_FORMAT, OBParserSET_MASTER_CLUSTER, OBParserMINUTE, OBParserSWAPS, OBParserTASK, OBParserINNODB, OBParserIO_THREAD, OBParserPCTFREE, OBParserPARAMETERS, OBParserTABLESPACE, OBParserAUTO, OBParserROW, OBParserMESSAGE_TEXT, OBParserDISK, OBParserFAULTS, OBParserHOUR, OBParserREFRESH, OBParserCOLUMN_STAT, OBParserANY, OBParserERROR_CODE, OBParserPHASE, OBParserENTITY, OBParserPROFILE, OBParserLAST_VALUE, OBParserRESTART, OBParserTRACE, OBParserDATE_ADD, OBParserBLOCK_INDEX, OBParserSERVER_IP, OBParserCODE, OBParserPLUGINS, OBParserADDDATE, OBParserVIRTUAL_COLUMN_ID, OBParserCOLUMN_FORMAT, OBParserMAX_MEMORY, OBParserCLEAN, OBParserMASTER_SSL, OBParserCLEAR, OBParserCHECKSUM, OBParserINSTALL, OBParserMONTH, OBParserAFTER, OBParserCLOSE, OBParserSET_TP, OBParserOWNER, OBParserBLOOM_FILTER, OBParserILOG, OBParserMETA, OBParserSTARTS, OBParserPLANREGRESS, OBParserAUTOEXTEND_SIZE, OBParserSOURCE, OBParserIGNORE_SERVER_IDS, OBParserREPLICA_NUM, OBParserBINDING, OBParserMICROSECOND, OBParserUNDO_BUFFER_SIZE, OBParserSWITCHOVER, OBParserEXTENDED_NOADDR, OBParserGLOBAL_NAME, OBParserSPLIT, OBParserBASELINE, OBParserMEMORY, OBParserSEED, OBParserRTREE, OBParserRESOURCE, OBParserSTDDEV_POP, OBParserRUN, OBParserSQL_AFTER_GTIDS, OBParserOPEN, OBParserSQL_TSI_DAY, OBParserSTRING, OBParserRELAY_THREAD, OBParserBREADTH, OBParserUNUSUAL, OBParserRELAYLOG, OBParserSQL_BEFORE_GTIDS, OBParserPRIMARY_ZONE, OBParserTABLE_CHECKSUM, OBParserZONE_LIST, OBParserDATABASE_ID, OBParserTP_NO, OBParserBOOLEAN, OBParserAVG, OBParserMULTILINESTRING, OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, OBParserNOW, OBParserPROXY, OBParserDUPLICATE_SCOPE, OBParserSTATS_SAMPLE_PAGES, OBParserTABLET_SIZE, OBParserBASE, OBParserKVCACHE, OBParserRELAY, OBParserCONTRIBUTORS, OBParserPARTIAL, OBParserREPORT, OBParserESCAPE, OBParserMASTER_AUTO_POSITION, OBParserDISKGROUP, OBParserTP_NAME, OBParserACTIVATE, OBParserSQL_AFTER_MTS_GAPS, OBParserEFFECTIVE, OBParserFIRST_VALUE, OBParserSQL_TSI_MINUTE, OBParserUNICODE, OBParserQUARTER, OBParserANALYSE, OBParserDEFINER, OBParserNONE, OBParserPROCESSLIST, OBParserTYPE, OBParserINSERT_METHOD, OBParserEXTENDED, OBParserLEVEL, OBParserTIME_ZONE_INFO, OBParserTIMESTAMPADD, OBParserGET_FORMAT, OBParserPREPARE, OBParserSTANDBY, OBParserMATERIALIZED, OBParserWORK, OBParserHANDLER, OBParserCUME_DIST, OBParserINITIAL_SIZE, OBParserRELAY_LOG_FILE, OBParserSTORING, OBParserIMPORT, OBParserMIN_MEMORY, OBParserHELP, OBParserCREATE_TIMESTAMP, OBParserSOUNDS, OBParserTABLE_MODE, OBParserCOPY, OBParserSESSION, OBParserSQL_NO_CACHE, OBParserEXECUTE, OBParserSWITCHES, OBParserPACK_KEYS, OBParserSQL_ID, OBParserTENANT_ID, OBParserCHECKPOINT, OBParserDAY, OBParserGROUP_CONCAT, OBParserLEAD, OBParserEVENTS, OBParserONLY, OBParserTABLEGROUP_ID, OBParserMASTER_SSL_CRL, OBParserRESOURCE_POOL_LIST, OBParserNTILE, OBParserIS_TENANT_SYS_POOL, OBParserSCHEDULE, OBParserJOB, OBParserMASTER_LOG_POS, OBParserSUBCLASS_ORIGIN, OBParserMULTIPOINT, OBParserBLOCK, OBParserSQL_TSI_SECOND, OBParserDATE, OBParserROLLUP, OBParserMIN_CPU, OBParserOCCUR, OBParserDATA, OBParserMASTER_HOST, OBParserALGORITHM, OBParserCONSTRAINT_NAME, OBParserAPPROX_COUNT_DISTINCT, OBParserBASIC, OBParserDEFAULT_TABLEGROUP, OBParserLIST_, OBParserWEEK, OBParserMASTER_SSL_CRLPATH, OBParserCASCADED, OBParserPLUGIN, OBParserTENANT, OBParserSTAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8290)
			p.Unreserved_keyword_normal()
		}

	case OBParserPASSWORD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8291)
			p.Unreserved_keyword_special()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnreserved_keyword_normalContext is an interface to support dynamic dispatch.
type IUnreserved_keyword_normalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCOUNT() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	ACTIVE() antlr.TerminalNode
	ADDDATE() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	ALGORITHM() antlr.TerminalNode
	ANALYSE() antlr.TerminalNode
	ANY() antlr.TerminalNode
	APPROX_COUNT_DISTINCT() antlr.TerminalNode
	APPROX_COUNT_DISTINCT_SYNOPSIS() antlr.TerminalNode
	APPROX_COUNT_DISTINCT_SYNOPSIS_MERGE() antlr.TerminalNode
	ASCII() antlr.TerminalNode
	AT() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	AUTO() antlr.TerminalNode
	AUTOEXTEND_SIZE() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	AVG() antlr.TerminalNode
	AVG_ROW_LENGTH() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	BASE() antlr.TerminalNode
	BASELINE() antlr.TerminalNode
	BASELINE_ID() antlr.TerminalNode
	BASIC() antlr.TerminalNode
	BALANCE() antlr.TerminalNode
	BINDING() antlr.TerminalNode
	BINLOG() antlr.TerminalNode
	BIT() antlr.TerminalNode
	BLOCK() antlr.TerminalNode
	BLOCK_SIZE() antlr.TerminalNode
	BLOCK_INDEX() antlr.TerminalNode
	BLOOM_FILTER() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BOOTSTRAP() antlr.TerminalNode
	BTREE() antlr.TerminalNode
	BYTE() antlr.TerminalNode
	BREADTH() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	KVCACHE() antlr.TerminalNode
	ILOGCACHE() antlr.TerminalNode
	CANCEL() antlr.TerminalNode
	CASCADED() antlr.TerminalNode
	CAST() antlr.TerminalNode
	CATALOG_NAME() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	CHANGED() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHECKSUM() antlr.TerminalNode
	CHECKPOINT() antlr.TerminalNode
	CHUNK() antlr.TerminalNode
	CIPHER() antlr.TerminalNode
	CLASS_ORIGIN() antlr.TerminalNode
	CLEAN() antlr.TerminalNode
	CLEAR() antlr.TerminalNode
	CLIENT() antlr.TerminalNode
	CLOSE() antlr.TerminalNode
	CLOG() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	CLUSTER_ID() antlr.TerminalNode
	CLUSTER_NAME() antlr.TerminalNode
	COALESCE() antlr.TerminalNode
	CODE() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	COLUMN_FORMAT() antlr.TerminalNode
	COLUMN_NAME() antlr.TerminalNode
	COLUMN_STAT() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	COMPLETION() antlr.TerminalNode
	COMPRESSED() antlr.TerminalNode
	COMPRESSION() antlr.TerminalNode
	CONCURRENT() antlr.TerminalNode
	CONNECTION() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	CONSISTENT_MODE() antlr.TerminalNode
	CONSTRAINT_CATALOG() antlr.TerminalNode
	CONSTRAINT_NAME() antlr.TerminalNode
	CONSTRAINT_SCHEMA() antlr.TerminalNode
	CONTAINS() antlr.TerminalNode
	CONTEXT() antlr.TerminalNode
	CONTRIBUTORS() antlr.TerminalNode
	COPY() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CPU() antlr.TerminalNode
	CREATE_TIMESTAMP() antlr.TerminalNode
	CTXCAT() antlr.TerminalNode
	CTX_ID() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	CURDATE() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	CURSOR_NAME() antlr.TerminalNode
	CURTIME() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATABASE_ID() antlr.TerminalNode
	DATAFILE() antlr.TerminalNode
	DATA_TABLE_ID() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATE_ADD() antlr.TerminalNode
	DATE_SUB() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DEALLOCATE() antlr.TerminalNode
	DEFAULT_AUTH() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	DELAY() antlr.TerminalNode
	DELAY_KEY_WRITE() antlr.TerminalNode
	DENSE_RANK() antlr.TerminalNode
	DEPTH() antlr.TerminalNode
	DES_KEY_FILE() antlr.TerminalNode
	DESTINATION() antlr.TerminalNode
	DIAGNOSTICS() antlr.TerminalNode
	DIRECTORY() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISCARD() antlr.TerminalNode
	DISK() antlr.TerminalNode
	DISKGROUP() antlr.TerminalNode
	DO() antlr.TerminalNode
	DUMP() antlr.TerminalNode
	DUMPFILE() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	DUPLICATE_SCOPE() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	DEFAULT_TABLEGROUP() antlr.TerminalNode
	EFFECTIVE() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	ENCRYPTION() antlr.TerminalNode
	END() antlr.TerminalNode
	ENDS() antlr.TerminalNode
	ENGINE_() antlr.TerminalNode
	ENGINES() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	ENTITY() antlr.TerminalNode
	ERROR_CODE() antlr.TerminalNode
	ERROR_P() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	EXCHANGE() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	EXPANSION() antlr.TerminalNode
	EXPIRE() antlr.TerminalNode
	EXPIRE_INFO() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	EXTENDED_NOADDR() antlr.TerminalNode
	EXTENT_SIZE() antlr.TerminalNode
	EXTRACT() antlr.TerminalNode
	FAST() antlr.TerminalNode
	FAULTS() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILEX() antlr.TerminalNode
	FILE_ID() antlr.TerminalNode
	FINAL_COUNT() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FIRST_VALUE() antlr.TerminalNode
	FIXED() antlr.TerminalNode
	FLUSH() antlr.TerminalNode
	FOLLOWER() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FOUND() antlr.TerminalNode
	FREEZE() antlr.TerminalNode
	FREQUENCY() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GENERAL() antlr.TerminalNode
	GEOMETRY() antlr.TerminalNode
	GEOMETRYCOLLECTION() antlr.TerminalNode
	GET_FORMAT() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GLOBAL_NAME() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	GTS() antlr.TerminalNode
	HANDLER() antlr.TerminalNode
	HASH() antlr.TerminalNode
	HELP() antlr.TerminalNode
	HOST() antlr.TerminalNode
	HOSTS() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	ID() antlr.TerminalNode
	IDC() antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	IGNORE_SERVER_IDS() antlr.TerminalNode
	ILOG() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INDEX_TABLE_ID() antlr.TerminalNode
	INCR() antlr.TerminalNode
	INFO() antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	INNODB() antlr.TerminalNode
	INSERT_METHOD() antlr.TerminalNode
	INSTALL() antlr.TerminalNode
	INSTANCE() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	IO() antlr.TerminalNode
	IO_THREAD() antlr.TerminalNode
	IPC() antlr.TerminalNode
	ISOLATION() antlr.TerminalNode
	ISOLATE() antlr.TerminalNode
	ISSUER() antlr.TerminalNode
	IS_TENANT_SYS_POOL() antlr.TerminalNode
	JOB() antlr.TerminalNode
	JSON() antlr.TerminalNode
	KEY_BLOCK_SIZE() antlr.TerminalNode
	KEY_VERSION() antlr.TerminalNode
	LAG() antlr.TerminalNode
	LANGUAGE() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LAST_VALUE() antlr.TerminalNode
	LEAD() antlr.TerminalNode
	LEADER() antlr.TerminalNode
	LEAVES() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LINESTRING() antlr.TerminalNode
	LIST_() antlr.TerminalNode
	LISTAGG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOCALITY() antlr.TerminalNode
	LOCKED() antlr.TerminalNode
	LOCKS() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	LOGONLY_REPLICA_NUM() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	MAJOR() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	MASTER_AUTO_POSITION() antlr.TerminalNode
	MASTER_CONNECT_RETRY() antlr.TerminalNode
	MASTER_DELAY() antlr.TerminalNode
	MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode
	MASTER_HOST() antlr.TerminalNode
	MASTER_LOG_FILE() antlr.TerminalNode
	MASTER_LOG_POS() antlr.TerminalNode
	MASTER_PASSWORD() antlr.TerminalNode
	MASTER_PORT() antlr.TerminalNode
	MASTER_RETRY_COUNT() antlr.TerminalNode
	MASTER_SERVER_ID() antlr.TerminalNode
	MASTER_SSL() antlr.TerminalNode
	MASTER_SSL_CA() antlr.TerminalNode
	MASTER_SSL_CAPATH() antlr.TerminalNode
	MASTER_SSL_CERT() antlr.TerminalNode
	MASTER_SSL_CIPHER() antlr.TerminalNode
	MASTER_SSL_CRL() antlr.TerminalNode
	MASTER_SSL_CRLPATH() antlr.TerminalNode
	MASTER_SSL_KEY() antlr.TerminalNode
	MASTER_USER() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode
	MAX_CPU() antlr.TerminalNode
	MAX_DISK_SIZE() antlr.TerminalNode
	MAX_IOPS() antlr.TerminalNode
	MAX_MEMORY() antlr.TerminalNode
	MAX_QUERIES_PER_HOUR() antlr.TerminalNode
	MAX_ROWS() antlr.TerminalNode
	MAX_SESSION_NUM() antlr.TerminalNode
	MAX_SIZE() antlr.TerminalNode
	MAX_UPDATES_PER_HOUR() antlr.TerminalNode
	MAX_USER_CONNECTIONS() antlr.TerminalNode
	MEDIUM() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	MEMTABLE() antlr.TerminalNode
	MESSAGE_TEXT() antlr.TerminalNode
	META() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode
	MIGRATE() antlr.TerminalNode
	MIGRATION() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MIN_CPU() antlr.TerminalNode
	MIN_IOPS() antlr.TerminalNode
	MIN_MEMORY() antlr.TerminalNode
	MINOR() antlr.TerminalNode
	MIN_ROWS() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MODE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MOVE() antlr.TerminalNode
	MULTILINESTRING() antlr.TerminalNode
	MULTIPOINT() antlr.TerminalNode
	MULTIPOLYGON() antlr.TerminalNode
	MUTEX() antlr.TerminalNode
	MYSQL_ERRNO() antlr.TerminalNode
	MAX_USED_PART_ID() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAMES() antlr.TerminalNode
	NATIONAL() antlr.TerminalNode
	NCHAR() antlr.TerminalNode
	NDB() antlr.TerminalNode
	NDBCLUSTER() antlr.TerminalNode
	NEW() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	NO() antlr.TerminalNode
	NODEGROUP() antlr.TerminalNode
	NONE() antlr.TerminalNode
	NORMAL() antlr.TerminalNode
	NOW() antlr.TerminalNode
	NOWAIT() antlr.TerminalNode
	NO_WAIT() antlr.TerminalNode
	NTILE() antlr.TerminalNode
	NTH_VALUE() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	NVARCHAR() antlr.TerminalNode
	OCCUR() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	OLD_PASSWORD() antlr.TerminalNode
	OLD_KEY() antlr.TerminalNode
	OVER() antlr.TerminalNode
	ONE() antlr.TerminalNode
	ONE_SHOT() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPTIONS() antlr.TerminalNode
	REMOTE_OSS() antlr.TerminalNode
	OUTLINE() antlr.TerminalNode
	OWNER() antlr.TerminalNode
	PACK_KEYS() antlr.TerminalNode
	PAGE() antlr.TerminalNode
	PARAMETERS() antlr.TerminalNode
	PARSER() antlr.TerminalNode
	PARTIAL() antlr.TerminalNode
	PARTITION_ID() antlr.TerminalNode
	PARTITIONING() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	PAUSE() antlr.TerminalNode
	PHASE() antlr.TerminalNode
	PHYSICAL() antlr.TerminalNode
	PLANREGRESS() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	PLUGIN_DIR() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	POINT() antlr.TerminalNode
	POLYGON() antlr.TerminalNode
	POOL() antlr.TerminalNode
	PORT() antlr.TerminalNode
	POSITION() antlr.TerminalNode
	PREPARE() antlr.TerminalNode
	PRESERVE() antlr.TerminalNode
	PREV() antlr.TerminalNode
	PRIMARY_ZONE() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	PROFILES() antlr.TerminalNode
	PROGRESSIVE_MERGE_NUM() antlr.TerminalNode
	PROXY() antlr.TerminalNode
	PCTFREE() antlr.TerminalNode
	P_ENTITY() antlr.TerminalNode
	P_CHUNK() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	QUICK() antlr.TerminalNode
	RANK() antlr.TerminalNode
	READ_ONLY() antlr.TerminalNode
	REBUILD() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	RECYCLE() antlr.TerminalNode
	RECYCLEBIN() antlr.TerminalNode
	ROTATE() antlr.TerminalNode
	ROW_NUMBER() antlr.TerminalNode
	REDO_BUFFER_SIZE() antlr.TerminalNode
	REDOFILE() antlr.TerminalNode
	REDUNDANT() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	REGION() antlr.TerminalNode
	RELAY() antlr.TerminalNode
	RELAYLOG() antlr.TerminalNode
	RELAY_LOG_FILE() antlr.TerminalNode
	RELAY_LOG_POS() antlr.TerminalNode
	RELAY_THREAD() antlr.TerminalNode
	RELOAD() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	REORGANIZE() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	REPLICA_NUM() antlr.TerminalNode
	REPLICA_TYPE() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	REPORT() antlr.TerminalNode
	RESET() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	RESOURCE_POOL_LIST() antlr.TerminalNode
	RESPECT() antlr.TerminalNode
	RESTART() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETURNED_SQLSTATE() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	REVERSE() antlr.TerminalNode
	REWRITE_MERGE_VERSION() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROLLING() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROOT() antlr.TerminalNode
	ROOTTABLE() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	ROW() antlr.TerminalNode
	ROW_COUNT() antlr.TerminalNode
	ROW_FORMAT() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	RTREE() antlr.TerminalNode
	RUN() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	SCHEMA_NAME() antlr.TerminalNode
	SCOPE() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	SEED() antlr.TerminalNode
	SERIAL() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	SERVER_IP() antlr.TerminalNode
	SERVER_PORT() antlr.TerminalNode
	SERVER_TYPE() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	SESSION_USER() antlr.TerminalNode
	SET_MASTER_CLUSTER() antlr.TerminalNode
	SET_SLAVE_CLUSTER() antlr.TerminalNode
	SET_TP() antlr.TerminalNode
	SHARE() antlr.TerminalNode
	SHUTDOWN() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	SIMPLE() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	SLOW() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	SOCKET() antlr.TerminalNode
	SOME() antlr.TerminalNode
	SONAME() antlr.TerminalNode
	SOUNDS() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SPFILE() antlr.TerminalNode
	SPLIT() antlr.TerminalNode
	SQL_AFTER_GTIDS() antlr.TerminalNode
	SQL_AFTER_MTS_GAPS() antlr.TerminalNode
	SQL_BEFORE_GTIDS() antlr.TerminalNode
	SQL_BUFFER_RESULT() antlr.TerminalNode
	SQL_CACHE() antlr.TerminalNode
	SQL_ID() antlr.TerminalNode
	SQL_NO_CACHE() antlr.TerminalNode
	SQL_THREAD() antlr.TerminalNode
	SQL_TSI_DAY() antlr.TerminalNode
	SQL_TSI_HOUR() antlr.TerminalNode
	SQL_TSI_MINUTE() antlr.TerminalNode
	SQL_TSI_MONTH() antlr.TerminalNode
	SQL_TSI_QUARTER() antlr.TerminalNode
	SQL_TSI_SECOND() antlr.TerminalNode
	SQL_TSI_WEEK() antlr.TerminalNode
	SQL_TSI_YEAR() antlr.TerminalNode
	STANDBY() antlr.TerminalNode
	START() antlr.TerminalNode
	STARTS() antlr.TerminalNode
	STAT() antlr.TerminalNode
	STATS_AUTO_RECALC() antlr.TerminalNode
	STATS_PERSISTENT() antlr.TerminalNode
	STATS_SAMPLE_PAGES() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	STDDEV() antlr.TerminalNode
	STDDEV_POP() antlr.TerminalNode
	STDDEV_SAMP() antlr.TerminalNode
	STOP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	STORAGE_FORMAT_VERSION() antlr.TerminalNode
	STORAGE_FORMAT_WORK_VERSION() antlr.TerminalNode
	STORING() antlr.TerminalNode
	STRING() antlr.TerminalNode
	SUBCLASS_ORIGIN() antlr.TerminalNode
	SUBDATE() antlr.TerminalNode
	SUBJECT() antlr.TerminalNode
	SUBPARTITION() antlr.TerminalNode
	SUBPARTITIONS() antlr.TerminalNode
	SUBSTR() antlr.TerminalNode
	SUBSTRING() antlr.TerminalNode
	SUM() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	SUSPEND() antlr.TerminalNode
	SWAPS() antlr.TerminalNode
	SWITCH() antlr.TerminalNode
	SWITCHES() antlr.TerminalNode
	SWITCHOVER() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	SYSTEM_USER() antlr.TerminalNode
	SYSDATE() antlr.TerminalNode
	TABLE_CHECKSUM() antlr.TerminalNode
	TABLE_MODE() antlr.TerminalNode
	TABLEGROUPS() antlr.TerminalNode
	TABLE_ID() antlr.TerminalNode
	TABLE_NAME() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	TABLET() antlr.TerminalNode
	TABLET_SIZE() antlr.TerminalNode
	TABLET_MAX_SIZE() antlr.TerminalNode
	TASK() antlr.TerminalNode
	TEMPLATE() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TEMPTABLE() antlr.TerminalNode
	TENANT() antlr.TerminalNode
	TENANT_ID() antlr.TerminalNode
	SLOT_IDX() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	THAN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	TIMESTAMPDIFF() antlr.TerminalNode
	TIME_ZONE_INFO() antlr.TerminalNode
	TP_NAME() antlr.TerminalNode
	TP_NO() antlr.TerminalNode
	TRACE() antlr.TerminalNode
	TRADITIONAL() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	TRIM() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	TYPES() antlr.TerminalNode
	TABLEGROUP_ID() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	UNDEFINED() antlr.TerminalNode
	UNDO_BUFFER_SIZE() antlr.TerminalNode
	UNDOFILE() antlr.TerminalNode
	UNICODE() antlr.TerminalNode
	UNKNOWN() antlr.TerminalNode
	UNINSTALL() antlr.TerminalNode
	UNIT() antlr.TerminalNode
	UNIT_NUM() antlr.TerminalNode
	UNLOCKED() antlr.TerminalNode
	UNTIL() antlr.TerminalNode
	UNUSUAL() antlr.TerminalNode
	UPGRADE() antlr.TerminalNode
	USE_BLOOM_FILTER() antlr.TerminalNode
	USE_FRM() antlr.TerminalNode
	USER() antlr.TerminalNode
	USER_RESOURCES() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	VALID() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	VARIANCE() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	VIRTUAL_COLUMN_ID() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	WAIT() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WEIGHT_STRING() antlr.TerminalNode
	WORK() antlr.TerminalNode
	WRAPPER() antlr.TerminalNode
	X509() antlr.TerminalNode
	XA() antlr.TerminalNode
	XML() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	ZONE() antlr.TerminalNode
	ZONE_LIST() antlr.TerminalNode
	ZONE_TYPE() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	VISIBLE() antlr.TerminalNode
	INVISIBLE() antlr.TerminalNode
	ACTIVATE() antlr.TerminalNode
	SYNCHRONIZATION() antlr.TerminalNode

	// IsUnreserved_keyword_normalContext differentiates from other interfaces.
	IsUnreserved_keyword_normalContext()
}

type Unreserved_keyword_normalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnreserved_keyword_normalContext() *Unreserved_keyword_normalContext {
	var p = new(Unreserved_keyword_normalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_unreserved_keyword_normal
	return p
}

func InitEmptyUnreserved_keyword_normalContext(p *Unreserved_keyword_normalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_unreserved_keyword_normal
}

func (*Unreserved_keyword_normalContext) IsUnreserved_keyword_normalContext() {}

func NewUnreserved_keyword_normalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unreserved_keyword_normalContext {
	var p = new(Unreserved_keyword_normalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_unreserved_keyword_normal

	return p
}

func (s *Unreserved_keyword_normalContext) GetParser() antlr.Parser { return s.parser }

func (s *Unreserved_keyword_normalContext) ACCOUNT() antlr.TerminalNode {
	return s.GetToken(OBParserACCOUNT, 0)
}

func (s *Unreserved_keyword_normalContext) ACTION() antlr.TerminalNode {
	return s.GetToken(OBParserACTION, 0)
}

func (s *Unreserved_keyword_normalContext) ACTIVE() antlr.TerminalNode {
	return s.GetToken(OBParserACTIVE, 0)
}

func (s *Unreserved_keyword_normalContext) ADDDATE() antlr.TerminalNode {
	return s.GetToken(OBParserADDDATE, 0)
}

func (s *Unreserved_keyword_normalContext) AFTER() antlr.TerminalNode {
	return s.GetToken(OBParserAFTER, 0)
}

func (s *Unreserved_keyword_normalContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(OBParserAGGREGATE, 0)
}

func (s *Unreserved_keyword_normalContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(OBParserALGORITHM, 0)
}

func (s *Unreserved_keyword_normalContext) ANALYSE() antlr.TerminalNode {
	return s.GetToken(OBParserANALYSE, 0)
}

func (s *Unreserved_keyword_normalContext) ANY() antlr.TerminalNode {
	return s.GetToken(OBParserANY, 0)
}

func (s *Unreserved_keyword_normalContext) APPROX_COUNT_DISTINCT() antlr.TerminalNode {
	return s.GetToken(OBParserAPPROX_COUNT_DISTINCT, 0)
}

func (s *Unreserved_keyword_normalContext) APPROX_COUNT_DISTINCT_SYNOPSIS() antlr.TerminalNode {
	return s.GetToken(OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS, 0)
}

func (s *Unreserved_keyword_normalContext) APPROX_COUNT_DISTINCT_SYNOPSIS_MERGE() antlr.TerminalNode {
	return s.GetToken(OBParserAPPROX_COUNT_DISTINCT_SYNOPSIS_MERGE, 0)
}

func (s *Unreserved_keyword_normalContext) ASCII() antlr.TerminalNode {
	return s.GetToken(OBParserASCII, 0)
}

func (s *Unreserved_keyword_normalContext) AT() antlr.TerminalNode {
	return s.GetToken(OBParserAT, 0)
}

func (s *Unreserved_keyword_normalContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(OBParserAUTHORS, 0)
}

func (s *Unreserved_keyword_normalContext) AUTO() antlr.TerminalNode {
	return s.GetToken(OBParserAUTO, 0)
}

func (s *Unreserved_keyword_normalContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserAUTOEXTEND_SIZE, 0)
}

func (s *Unreserved_keyword_normalContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(OBParserAUTO_INCREMENT, 0)
}

func (s *Unreserved_keyword_normalContext) AVG() antlr.TerminalNode {
	return s.GetToken(OBParserAVG, 0)
}

func (s *Unreserved_keyword_normalContext) AVG_ROW_LENGTH() antlr.TerminalNode {
	return s.GetToken(OBParserAVG_ROW_LENGTH, 0)
}

func (s *Unreserved_keyword_normalContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(OBParserBACKUP, 0)
}

func (s *Unreserved_keyword_normalContext) BASE() antlr.TerminalNode {
	return s.GetToken(OBParserBASE, 0)
}

func (s *Unreserved_keyword_normalContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(OBParserBASELINE, 0)
}

func (s *Unreserved_keyword_normalContext) BASELINE_ID() antlr.TerminalNode {
	return s.GetToken(OBParserBASELINE_ID, 0)
}

func (s *Unreserved_keyword_normalContext) BASIC() antlr.TerminalNode {
	return s.GetToken(OBParserBASIC, 0)
}

func (s *Unreserved_keyword_normalContext) BALANCE() antlr.TerminalNode {
	return s.GetToken(OBParserBALANCE, 0)
}

func (s *Unreserved_keyword_normalContext) BINDING() antlr.TerminalNode {
	return s.GetToken(OBParserBINDING, 0)
}

func (s *Unreserved_keyword_normalContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(OBParserBINLOG, 0)
}

func (s *Unreserved_keyword_normalContext) BIT() antlr.TerminalNode {
	return s.GetToken(OBParserBIT, 0)
}

func (s *Unreserved_keyword_normalContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(OBParserBLOCK, 0)
}

func (s *Unreserved_keyword_normalContext) BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserBLOCK_SIZE, 0)
}

func (s *Unreserved_keyword_normalContext) BLOCK_INDEX() antlr.TerminalNode {
	return s.GetToken(OBParserBLOCK_INDEX, 0)
}

func (s *Unreserved_keyword_normalContext) BLOOM_FILTER() antlr.TerminalNode {
	return s.GetToken(OBParserBLOOM_FILTER, 0)
}

func (s *Unreserved_keyword_normalContext) BOOL() antlr.TerminalNode {
	return s.GetToken(OBParserBOOL, 0)
}

func (s *Unreserved_keyword_normalContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(OBParserBOOLEAN, 0)
}

func (s *Unreserved_keyword_normalContext) BOOTSTRAP() antlr.TerminalNode {
	return s.GetToken(OBParserBOOTSTRAP, 0)
}

func (s *Unreserved_keyword_normalContext) BTREE() antlr.TerminalNode {
	return s.GetToken(OBParserBTREE, 0)
}

func (s *Unreserved_keyword_normalContext) BYTE() antlr.TerminalNode {
	return s.GetToken(OBParserBYTE, 0)
}

func (s *Unreserved_keyword_normalContext) BREADTH() antlr.TerminalNode {
	return s.GetToken(OBParserBREADTH, 0)
}

func (s *Unreserved_keyword_normalContext) CACHE() antlr.TerminalNode {
	return s.GetToken(OBParserCACHE, 0)
}

func (s *Unreserved_keyword_normalContext) KVCACHE() antlr.TerminalNode {
	return s.GetToken(OBParserKVCACHE, 0)
}

func (s *Unreserved_keyword_normalContext) ILOGCACHE() antlr.TerminalNode {
	return s.GetToken(OBParserILOGCACHE, 0)
}

func (s *Unreserved_keyword_normalContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(OBParserCANCEL, 0)
}

func (s *Unreserved_keyword_normalContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(OBParserCASCADED, 0)
}

func (s *Unreserved_keyword_normalContext) CAST() antlr.TerminalNode {
	return s.GetToken(OBParserCAST, 0)
}

func (s *Unreserved_keyword_normalContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(OBParserCATALOG_NAME, 0)
}

func (s *Unreserved_keyword_normalContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(OBParserCHAIN, 0)
}

func (s *Unreserved_keyword_normalContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(OBParserCHANGED, 0)
}

func (s *Unreserved_keyword_normalContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(OBParserCHARSET, 0)
}

func (s *Unreserved_keyword_normalContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(OBParserCHECKSUM, 0)
}

func (s *Unreserved_keyword_normalContext) CHECKPOINT() antlr.TerminalNode {
	return s.GetToken(OBParserCHECKPOINT, 0)
}

func (s *Unreserved_keyword_normalContext) CHUNK() antlr.TerminalNode {
	return s.GetToken(OBParserCHUNK, 0)
}

func (s *Unreserved_keyword_normalContext) CIPHER() antlr.TerminalNode {
	return s.GetToken(OBParserCIPHER, 0)
}

func (s *Unreserved_keyword_normalContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(OBParserCLASS_ORIGIN, 0)
}

func (s *Unreserved_keyword_normalContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(OBParserCLEAN, 0)
}

func (s *Unreserved_keyword_normalContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(OBParserCLEAR, 0)
}

func (s *Unreserved_keyword_normalContext) CLIENT() antlr.TerminalNode {
	return s.GetToken(OBParserCLIENT, 0)
}

func (s *Unreserved_keyword_normalContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(OBParserCLOSE, 0)
}

func (s *Unreserved_keyword_normalContext) CLOG() antlr.TerminalNode {
	return s.GetToken(OBParserCLOG, 0)
}

func (s *Unreserved_keyword_normalContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(OBParserCLUSTER, 0)
}

func (s *Unreserved_keyword_normalContext) CLUSTER_ID() antlr.TerminalNode {
	return s.GetToken(OBParserCLUSTER_ID, 0)
}

func (s *Unreserved_keyword_normalContext) CLUSTER_NAME() antlr.TerminalNode {
	return s.GetToken(OBParserCLUSTER_NAME, 0)
}

func (s *Unreserved_keyword_normalContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(OBParserCOALESCE, 0)
}

func (s *Unreserved_keyword_normalContext) CODE() antlr.TerminalNode {
	return s.GetToken(OBParserCODE, 0)
}

func (s *Unreserved_keyword_normalContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(OBParserCOLLATION, 0)
}

func (s *Unreserved_keyword_normalContext) COLUMN_FORMAT() antlr.TerminalNode {
	return s.GetToken(OBParserCOLUMN_FORMAT, 0)
}

func (s *Unreserved_keyword_normalContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(OBParserCOLUMN_NAME, 0)
}

func (s *Unreserved_keyword_normalContext) COLUMN_STAT() antlr.TerminalNode {
	return s.GetToken(OBParserCOLUMN_STAT, 0)
}

func (s *Unreserved_keyword_normalContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(OBParserCOLUMNS, 0)
}

func (s *Unreserved_keyword_normalContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(OBParserCOMMENT, 0)
}

func (s *Unreserved_keyword_normalContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(OBParserCOMMIT, 0)
}

func (s *Unreserved_keyword_normalContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(OBParserCOMMITTED, 0)
}

func (s *Unreserved_keyword_normalContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(OBParserCOMPACT, 0)
}

func (s *Unreserved_keyword_normalContext) COMPLETION() antlr.TerminalNode {
	return s.GetToken(OBParserCOMPLETION, 0)
}

func (s *Unreserved_keyword_normalContext) COMPRESSED() antlr.TerminalNode {
	return s.GetToken(OBParserCOMPRESSED, 0)
}

func (s *Unreserved_keyword_normalContext) COMPRESSION() antlr.TerminalNode {
	return s.GetToken(OBParserCOMPRESSION, 0)
}

func (s *Unreserved_keyword_normalContext) CONCURRENT() antlr.TerminalNode {
	return s.GetToken(OBParserCONCURRENT, 0)
}

func (s *Unreserved_keyword_normalContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(OBParserCONNECTION, 0)
}

func (s *Unreserved_keyword_normalContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(OBParserCONSISTENT, 0)
}

func (s *Unreserved_keyword_normalContext) CONSISTENT_MODE() antlr.TerminalNode {
	return s.GetToken(OBParserCONSISTENT_MODE, 0)
}

func (s *Unreserved_keyword_normalContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(OBParserCONSTRAINT_CATALOG, 0)
}

func (s *Unreserved_keyword_normalContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(OBParserCONSTRAINT_NAME, 0)
}

func (s *Unreserved_keyword_normalContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(OBParserCONSTRAINT_SCHEMA, 0)
}

func (s *Unreserved_keyword_normalContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(OBParserCONTAINS, 0)
}

func (s *Unreserved_keyword_normalContext) CONTEXT() antlr.TerminalNode {
	return s.GetToken(OBParserCONTEXT, 0)
}

func (s *Unreserved_keyword_normalContext) CONTRIBUTORS() antlr.TerminalNode {
	return s.GetToken(OBParserCONTRIBUTORS, 0)
}

func (s *Unreserved_keyword_normalContext) COPY() antlr.TerminalNode {
	return s.GetToken(OBParserCOPY, 0)
}

func (s *Unreserved_keyword_normalContext) COUNT() antlr.TerminalNode {
	return s.GetToken(OBParserCOUNT, 0)
}

func (s *Unreserved_keyword_normalContext) CPU() antlr.TerminalNode {
	return s.GetToken(OBParserCPU, 0)
}

func (s *Unreserved_keyword_normalContext) CREATE_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(OBParserCREATE_TIMESTAMP, 0)
}

func (s *Unreserved_keyword_normalContext) CTXCAT() antlr.TerminalNode {
	return s.GetToken(OBParserCTXCAT, 0)
}

func (s *Unreserved_keyword_normalContext) CTX_ID() antlr.TerminalNode {
	return s.GetToken(OBParserCTX_ID, 0)
}

func (s *Unreserved_keyword_normalContext) CUBE() antlr.TerminalNode {
	return s.GetToken(OBParserCUBE, 0)
}

func (s *Unreserved_keyword_normalContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(OBParserCUME_DIST, 0)
}

func (s *Unreserved_keyword_normalContext) CURDATE() antlr.TerminalNode {
	return s.GetToken(OBParserCURDATE, 0)
}

func (s *Unreserved_keyword_normalContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(OBParserCURRENT, 0)
}

func (s *Unreserved_keyword_normalContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(OBParserCURSOR_NAME, 0)
}

func (s *Unreserved_keyword_normalContext) CURTIME() antlr.TerminalNode {
	return s.GetToken(OBParserCURTIME, 0)
}

func (s *Unreserved_keyword_normalContext) DATA() antlr.TerminalNode {
	return s.GetToken(OBParserDATA, 0)
}

func (s *Unreserved_keyword_normalContext) DATABASE_ID() antlr.TerminalNode {
	return s.GetToken(OBParserDATABASE_ID, 0)
}

func (s *Unreserved_keyword_normalContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(OBParserDATAFILE, 0)
}

func (s *Unreserved_keyword_normalContext) DATA_TABLE_ID() antlr.TerminalNode {
	return s.GetToken(OBParserDATA_TABLE_ID, 0)
}

func (s *Unreserved_keyword_normalContext) DATE() antlr.TerminalNode {
	return s.GetToken(OBParserDATE, 0)
}

func (s *Unreserved_keyword_normalContext) DATE_ADD() antlr.TerminalNode {
	return s.GetToken(OBParserDATE_ADD, 0)
}

func (s *Unreserved_keyword_normalContext) DATE_SUB() antlr.TerminalNode {
	return s.GetToken(OBParserDATE_SUB, 0)
}

func (s *Unreserved_keyword_normalContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(OBParserDATETIME, 0)
}

func (s *Unreserved_keyword_normalContext) DAY() antlr.TerminalNode {
	return s.GetToken(OBParserDAY, 0)
}

func (s *Unreserved_keyword_normalContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(OBParserDEALLOCATE, 0)
}

func (s *Unreserved_keyword_normalContext) DEFAULT_AUTH() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT_AUTH, 0)
}

func (s *Unreserved_keyword_normalContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(OBParserDEFINER, 0)
}

func (s *Unreserved_keyword_normalContext) DELAY() antlr.TerminalNode {
	return s.GetToken(OBParserDELAY, 0)
}

func (s *Unreserved_keyword_normalContext) DELAY_KEY_WRITE() antlr.TerminalNode {
	return s.GetToken(OBParserDELAY_KEY_WRITE, 0)
}

func (s *Unreserved_keyword_normalContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(OBParserDENSE_RANK, 0)
}

func (s *Unreserved_keyword_normalContext) DEPTH() antlr.TerminalNode {
	return s.GetToken(OBParserDEPTH, 0)
}

func (s *Unreserved_keyword_normalContext) DES_KEY_FILE() antlr.TerminalNode {
	return s.GetToken(OBParserDES_KEY_FILE, 0)
}

func (s *Unreserved_keyword_normalContext) DESTINATION() antlr.TerminalNode {
	return s.GetToken(OBParserDESTINATION, 0)
}

func (s *Unreserved_keyword_normalContext) DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(OBParserDIAGNOSTICS, 0)
}

func (s *Unreserved_keyword_normalContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(OBParserDIRECTORY, 0)
}

func (s *Unreserved_keyword_normalContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(OBParserDISABLE, 0)
}

func (s *Unreserved_keyword_normalContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(OBParserDISCARD, 0)
}

func (s *Unreserved_keyword_normalContext) DISK() antlr.TerminalNode {
	return s.GetToken(OBParserDISK, 0)
}

func (s *Unreserved_keyword_normalContext) DISKGROUP() antlr.TerminalNode {
	return s.GetToken(OBParserDISKGROUP, 0)
}

func (s *Unreserved_keyword_normalContext) DO() antlr.TerminalNode {
	return s.GetToken(OBParserDO, 0)
}

func (s *Unreserved_keyword_normalContext) DUMP() antlr.TerminalNode {
	return s.GetToken(OBParserDUMP, 0)
}

func (s *Unreserved_keyword_normalContext) DUMPFILE() antlr.TerminalNode {
	return s.GetToken(OBParserDUMPFILE, 0)
}

func (s *Unreserved_keyword_normalContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(OBParserDUPLICATE, 0)
}

func (s *Unreserved_keyword_normalContext) DUPLICATE_SCOPE() antlr.TerminalNode {
	return s.GetToken(OBParserDUPLICATE_SCOPE, 0)
}

func (s *Unreserved_keyword_normalContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(OBParserDYNAMIC, 0)
}

func (s *Unreserved_keyword_normalContext) DEFAULT_TABLEGROUP() antlr.TerminalNode {
	return s.GetToken(OBParserDEFAULT_TABLEGROUP, 0)
}

func (s *Unreserved_keyword_normalContext) EFFECTIVE() antlr.TerminalNode {
	return s.GetToken(OBParserEFFECTIVE, 0)
}

func (s *Unreserved_keyword_normalContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(OBParserENABLE, 0)
}

func (s *Unreserved_keyword_normalContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(OBParserENCRYPTION, 0)
}

func (s *Unreserved_keyword_normalContext) END() antlr.TerminalNode {
	return s.GetToken(OBParserEND, 0)
}

func (s *Unreserved_keyword_normalContext) ENDS() antlr.TerminalNode {
	return s.GetToken(OBParserENDS, 0)
}

func (s *Unreserved_keyword_normalContext) ENGINE_() antlr.TerminalNode {
	return s.GetToken(OBParserENGINE_, 0)
}

func (s *Unreserved_keyword_normalContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(OBParserENGINES, 0)
}

func (s *Unreserved_keyword_normalContext) ENUM() antlr.TerminalNode {
	return s.GetToken(OBParserENUM, 0)
}

func (s *Unreserved_keyword_normalContext) ENTITY() antlr.TerminalNode {
	return s.GetToken(OBParserENTITY, 0)
}

func (s *Unreserved_keyword_normalContext) ERROR_CODE() antlr.TerminalNode {
	return s.GetToken(OBParserERROR_CODE, 0)
}

func (s *Unreserved_keyword_normalContext) ERROR_P() antlr.TerminalNode {
	return s.GetToken(OBParserERROR_P, 0)
}

func (s *Unreserved_keyword_normalContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(OBParserERRORS, 0)
}

func (s *Unreserved_keyword_normalContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(OBParserESCAPE, 0)
}

func (s *Unreserved_keyword_normalContext) EVENT() antlr.TerminalNode {
	return s.GetToken(OBParserEVENT, 0)
}

func (s *Unreserved_keyword_normalContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(OBParserEVENTS, 0)
}

func (s *Unreserved_keyword_normalContext) EVERY() antlr.TerminalNode {
	return s.GetToken(OBParserEVERY, 0)
}

func (s *Unreserved_keyword_normalContext) EXCHANGE() antlr.TerminalNode {
	return s.GetToken(OBParserEXCHANGE, 0)
}

func (s *Unreserved_keyword_normalContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(OBParserEXECUTE, 0)
}

func (s *Unreserved_keyword_normalContext) EXPANSION() antlr.TerminalNode {
	return s.GetToken(OBParserEXPANSION, 0)
}

func (s *Unreserved_keyword_normalContext) EXPIRE() antlr.TerminalNode {
	return s.GetToken(OBParserEXPIRE, 0)
}

func (s *Unreserved_keyword_normalContext) EXPIRE_INFO() antlr.TerminalNode {
	return s.GetToken(OBParserEXPIRE_INFO, 0)
}

func (s *Unreserved_keyword_normalContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(OBParserEXPORT, 0)
}

func (s *Unreserved_keyword_normalContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(OBParserEXTENDED, 0)
}

func (s *Unreserved_keyword_normalContext) EXTENDED_NOADDR() antlr.TerminalNode {
	return s.GetToken(OBParserEXTENDED_NOADDR, 0)
}

func (s *Unreserved_keyword_normalContext) EXTENT_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserEXTENT_SIZE, 0)
}

func (s *Unreserved_keyword_normalContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(OBParserEXTRACT, 0)
}

func (s *Unreserved_keyword_normalContext) FAST() antlr.TerminalNode {
	return s.GetToken(OBParserFAST, 0)
}

func (s *Unreserved_keyword_normalContext) FAULTS() antlr.TerminalNode {
	return s.GetToken(OBParserFAULTS, 0)
}

func (s *Unreserved_keyword_normalContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(OBParserFIELDS, 0)
}

func (s *Unreserved_keyword_normalContext) FILEX() antlr.TerminalNode {
	return s.GetToken(OBParserFILEX, 0)
}

func (s *Unreserved_keyword_normalContext) FILE_ID() antlr.TerminalNode {
	return s.GetToken(OBParserFILE_ID, 0)
}

func (s *Unreserved_keyword_normalContext) FINAL_COUNT() antlr.TerminalNode {
	return s.GetToken(OBParserFINAL_COUNT, 0)
}

func (s *Unreserved_keyword_normalContext) FIRST() antlr.TerminalNode {
	return s.GetToken(OBParserFIRST, 0)
}

func (s *Unreserved_keyword_normalContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserFIRST_VALUE, 0)
}

func (s *Unreserved_keyword_normalContext) FIXED() antlr.TerminalNode {
	return s.GetToken(OBParserFIXED, 0)
}

func (s *Unreserved_keyword_normalContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(OBParserFLUSH, 0)
}

func (s *Unreserved_keyword_normalContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(OBParserFOLLOWER, 0)
}

func (s *Unreserved_keyword_normalContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(OBParserFORMAT, 0)
}

func (s *Unreserved_keyword_normalContext) FOUND() antlr.TerminalNode {
	return s.GetToken(OBParserFOUND, 0)
}

func (s *Unreserved_keyword_normalContext) FREEZE() antlr.TerminalNode {
	return s.GetToken(OBParserFREEZE, 0)
}

func (s *Unreserved_keyword_normalContext) FREQUENCY() antlr.TerminalNode {
	return s.GetToken(OBParserFREQUENCY, 0)
}

func (s *Unreserved_keyword_normalContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(OBParserFUNCTION, 0)
}

func (s *Unreserved_keyword_normalContext) GENERAL() antlr.TerminalNode {
	return s.GetToken(OBParserGENERAL, 0)
}

func (s *Unreserved_keyword_normalContext) GEOMETRY() antlr.TerminalNode {
	return s.GetToken(OBParserGEOMETRY, 0)
}

func (s *Unreserved_keyword_normalContext) GEOMETRYCOLLECTION() antlr.TerminalNode {
	return s.GetToken(OBParserGEOMETRYCOLLECTION, 0)
}

func (s *Unreserved_keyword_normalContext) GET_FORMAT() antlr.TerminalNode {
	return s.GetToken(OBParserGET_FORMAT, 0)
}

func (s *Unreserved_keyword_normalContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(OBParserGLOBAL, 0)
}

func (s *Unreserved_keyword_normalContext) GLOBAL_NAME() antlr.TerminalNode {
	return s.GetToken(OBParserGLOBAL_NAME, 0)
}

func (s *Unreserved_keyword_normalContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(OBParserGRANTS, 0)
}

func (s *Unreserved_keyword_normalContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(OBParserGROUPING, 0)
}

func (s *Unreserved_keyword_normalContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(OBParserGROUP_CONCAT, 0)
}

func (s *Unreserved_keyword_normalContext) GTS() antlr.TerminalNode {
	return s.GetToken(OBParserGTS, 0)
}

func (s *Unreserved_keyword_normalContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(OBParserHANDLER, 0)
}

func (s *Unreserved_keyword_normalContext) HASH() antlr.TerminalNode {
	return s.GetToken(OBParserHASH, 0)
}

func (s *Unreserved_keyword_normalContext) HELP() antlr.TerminalNode {
	return s.GetToken(OBParserHELP, 0)
}

func (s *Unreserved_keyword_normalContext) HOST() antlr.TerminalNode {
	return s.GetToken(OBParserHOST, 0)
}

func (s *Unreserved_keyword_normalContext) HOSTS() antlr.TerminalNode {
	return s.GetToken(OBParserHOSTS, 0)
}

func (s *Unreserved_keyword_normalContext) HOUR() antlr.TerminalNode {
	return s.GetToken(OBParserHOUR, 0)
}

func (s *Unreserved_keyword_normalContext) ID() antlr.TerminalNode {
	return s.GetToken(OBParserID, 0)
}

func (s *Unreserved_keyword_normalContext) IDC() antlr.TerminalNode {
	return s.GetToken(OBParserIDC, 0)
}

func (s *Unreserved_keyword_normalContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(OBParserIDENTIFIED, 0)
}

func (s *Unreserved_keyword_normalContext) IGNORE_SERVER_IDS() antlr.TerminalNode {
	return s.GetToken(OBParserIGNORE_SERVER_IDS, 0)
}

func (s *Unreserved_keyword_normalContext) ILOG() antlr.TerminalNode {
	return s.GetToken(OBParserILOG, 0)
}

func (s *Unreserved_keyword_normalContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(OBParserIMPORT, 0)
}

func (s *Unreserved_keyword_normalContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(OBParserINDEXES, 0)
}

func (s *Unreserved_keyword_normalContext) INDEX_TABLE_ID() antlr.TerminalNode {
	return s.GetToken(OBParserINDEX_TABLE_ID, 0)
}

func (s *Unreserved_keyword_normalContext) INCR() antlr.TerminalNode {
	return s.GetToken(OBParserINCR, 0)
}

func (s *Unreserved_keyword_normalContext) INFO() antlr.TerminalNode {
	return s.GetToken(OBParserINFO, 0)
}

func (s *Unreserved_keyword_normalContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserINITIAL_SIZE, 0)
}

func (s *Unreserved_keyword_normalContext) INNODB() antlr.TerminalNode {
	return s.GetToken(OBParserINNODB, 0)
}

func (s *Unreserved_keyword_normalContext) INSERT_METHOD() antlr.TerminalNode {
	return s.GetToken(OBParserINSERT_METHOD, 0)
}

func (s *Unreserved_keyword_normalContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(OBParserINSTALL, 0)
}

func (s *Unreserved_keyword_normalContext) INSTANCE() antlr.TerminalNode {
	return s.GetToken(OBParserINSTANCE, 0)
}

func (s *Unreserved_keyword_normalContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(OBParserINVOKER, 0)
}

func (s *Unreserved_keyword_normalContext) IO() antlr.TerminalNode {
	return s.GetToken(OBParserIO, 0)
}

func (s *Unreserved_keyword_normalContext) IO_THREAD() antlr.TerminalNode {
	return s.GetToken(OBParserIO_THREAD, 0)
}

func (s *Unreserved_keyword_normalContext) IPC() antlr.TerminalNode {
	return s.GetToken(OBParserIPC, 0)
}

func (s *Unreserved_keyword_normalContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(OBParserISOLATION, 0)
}

func (s *Unreserved_keyword_normalContext) ISOLATE() antlr.TerminalNode {
	return s.GetToken(OBParserISOLATE, 0)
}

func (s *Unreserved_keyword_normalContext) ISSUER() antlr.TerminalNode {
	return s.GetToken(OBParserISSUER, 0)
}

func (s *Unreserved_keyword_normalContext) IS_TENANT_SYS_POOL() antlr.TerminalNode {
	return s.GetToken(OBParserIS_TENANT_SYS_POOL, 0)
}

func (s *Unreserved_keyword_normalContext) JOB() antlr.TerminalNode {
	return s.GetToken(OBParserJOB, 0)
}

func (s *Unreserved_keyword_normalContext) JSON() antlr.TerminalNode {
	return s.GetToken(OBParserJSON, 0)
}

func (s *Unreserved_keyword_normalContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserKEY_BLOCK_SIZE, 0)
}

func (s *Unreserved_keyword_normalContext) KEY_VERSION() antlr.TerminalNode {
	return s.GetToken(OBParserKEY_VERSION, 0)
}

func (s *Unreserved_keyword_normalContext) LAG() antlr.TerminalNode {
	return s.GetToken(OBParserLAG, 0)
}

func (s *Unreserved_keyword_normalContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(OBParserLANGUAGE, 0)
}

func (s *Unreserved_keyword_normalContext) LAST() antlr.TerminalNode {
	return s.GetToken(OBParserLAST, 0)
}

func (s *Unreserved_keyword_normalContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserLAST_VALUE, 0)
}

func (s *Unreserved_keyword_normalContext) LEAD() antlr.TerminalNode {
	return s.GetToken(OBParserLEAD, 0)
}

func (s *Unreserved_keyword_normalContext) LEADER() antlr.TerminalNode {
	return s.GetToken(OBParserLEADER, 0)
}

func (s *Unreserved_keyword_normalContext) LEAVES() antlr.TerminalNode {
	return s.GetToken(OBParserLEAVES, 0)
}

func (s *Unreserved_keyword_normalContext) LESS() antlr.TerminalNode {
	return s.GetToken(OBParserLESS, 0)
}

func (s *Unreserved_keyword_normalContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(OBParserLEVEL, 0)
}

func (s *Unreserved_keyword_normalContext) LINESTRING() antlr.TerminalNode {
	return s.GetToken(OBParserLINESTRING, 0)
}

func (s *Unreserved_keyword_normalContext) LIST_() antlr.TerminalNode {
	return s.GetToken(OBParserLIST_, 0)
}

func (s *Unreserved_keyword_normalContext) LISTAGG() antlr.TerminalNode {
	return s.GetToken(OBParserLISTAGG, 0)
}

func (s *Unreserved_keyword_normalContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(OBParserLOCAL, 0)
}

func (s *Unreserved_keyword_normalContext) LOCALITY() antlr.TerminalNode {
	return s.GetToken(OBParserLOCALITY, 0)
}

func (s *Unreserved_keyword_normalContext) LOCKED() antlr.TerminalNode {
	return s.GetToken(OBParserLOCKED, 0)
}

func (s *Unreserved_keyword_normalContext) LOCKS() antlr.TerminalNode {
	return s.GetToken(OBParserLOCKS, 0)
}

func (s *Unreserved_keyword_normalContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(OBParserLOGFILE, 0)
}

func (s *Unreserved_keyword_normalContext) LOGONLY_REPLICA_NUM() antlr.TerminalNode {
	return s.GetToken(OBParserLOGONLY_REPLICA_NUM, 0)
}

func (s *Unreserved_keyword_normalContext) LOGS() antlr.TerminalNode {
	return s.GetToken(OBParserLOGS, 0)
}

func (s *Unreserved_keyword_normalContext) MAJOR() antlr.TerminalNode {
	return s.GetToken(OBParserMAJOR, 0)
}

func (s *Unreserved_keyword_normalContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(OBParserMANUAL, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_AUTO_POSITION() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_AUTO_POSITION, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_CONNECT_RETRY() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_CONNECT_RETRY, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_DELAY() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_DELAY, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_HEARTBEAT_PERIOD, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_HOST() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_HOST, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_LOG_FILE, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_LOG_POS() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_LOG_POS, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_PASSWORD() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_PASSWORD, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_PORT() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_PORT, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_RETRY_COUNT() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_RETRY_COUNT, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_SERVER_ID() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_SERVER_ID, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_SSL() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_SSL, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_SSL_CA() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_SSL_CA, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_SSL_CAPATH() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_SSL_CAPATH, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_SSL_CERT() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_SSL_CERT, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_SSL_CIPHER() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_SSL_CIPHER, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_SSL_CRL() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_SSL_CRL, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_SSL_CRLPATH() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_SSL_CRLPATH, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_SSL_KEY() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_SSL_KEY, 0)
}

func (s *Unreserved_keyword_normalContext) MASTER_USER() antlr.TerminalNode {
	return s.GetToken(OBParserMASTER_USER, 0)
}

func (s *Unreserved_keyword_normalContext) MAX() antlr.TerminalNode {
	return s.GetToken(OBParserMAX, 0)
}

func (s *Unreserved_keyword_normalContext) MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_CONNECTIONS_PER_HOUR, 0)
}

func (s *Unreserved_keyword_normalContext) MAX_CPU() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_CPU, 0)
}

func (s *Unreserved_keyword_normalContext) MAX_DISK_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_DISK_SIZE, 0)
}

func (s *Unreserved_keyword_normalContext) MAX_IOPS() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_IOPS, 0)
}

func (s *Unreserved_keyword_normalContext) MAX_MEMORY() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_MEMORY, 0)
}

func (s *Unreserved_keyword_normalContext) MAX_QUERIES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_QUERIES_PER_HOUR, 0)
}

func (s *Unreserved_keyword_normalContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_ROWS, 0)
}

func (s *Unreserved_keyword_normalContext) MAX_SESSION_NUM() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_SESSION_NUM, 0)
}

func (s *Unreserved_keyword_normalContext) MAX_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_SIZE, 0)
}

func (s *Unreserved_keyword_normalContext) MAX_UPDATES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_UPDATES_PER_HOUR, 0)
}

func (s *Unreserved_keyword_normalContext) MAX_USER_CONNECTIONS() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_USER_CONNECTIONS, 0)
}

func (s *Unreserved_keyword_normalContext) MEDIUM() antlr.TerminalNode {
	return s.GetToken(OBParserMEDIUM, 0)
}

func (s *Unreserved_keyword_normalContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(OBParserMEMORY, 0)
}

func (s *Unreserved_keyword_normalContext) MEMTABLE() antlr.TerminalNode {
	return s.GetToken(OBParserMEMTABLE, 0)
}

func (s *Unreserved_keyword_normalContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(OBParserMESSAGE_TEXT, 0)
}

func (s *Unreserved_keyword_normalContext) META() antlr.TerminalNode {
	return s.GetToken(OBParserMETA, 0)
}

func (s *Unreserved_keyword_normalContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(OBParserMICROSECOND, 0)
}

func (s *Unreserved_keyword_normalContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(OBParserMIGRATE, 0)
}

func (s *Unreserved_keyword_normalContext) MIGRATION() antlr.TerminalNode {
	return s.GetToken(OBParserMIGRATION, 0)
}

func (s *Unreserved_keyword_normalContext) MIN() antlr.TerminalNode {
	return s.GetToken(OBParserMIN, 0)
}

func (s *Unreserved_keyword_normalContext) MIN_CPU() antlr.TerminalNode {
	return s.GetToken(OBParserMIN_CPU, 0)
}

func (s *Unreserved_keyword_normalContext) MIN_IOPS() antlr.TerminalNode {
	return s.GetToken(OBParserMIN_IOPS, 0)
}

func (s *Unreserved_keyword_normalContext) MIN_MEMORY() antlr.TerminalNode {
	return s.GetToken(OBParserMIN_MEMORY, 0)
}

func (s *Unreserved_keyword_normalContext) MINOR() antlr.TerminalNode {
	return s.GetToken(OBParserMINOR, 0)
}

func (s *Unreserved_keyword_normalContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(OBParserMIN_ROWS, 0)
}

func (s *Unreserved_keyword_normalContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(OBParserMINUTE, 0)
}

func (s *Unreserved_keyword_normalContext) MODE() antlr.TerminalNode {
	return s.GetToken(OBParserMODE, 0)
}

func (s *Unreserved_keyword_normalContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(OBParserMODIFY, 0)
}

func (s *Unreserved_keyword_normalContext) MONTH() antlr.TerminalNode {
	return s.GetToken(OBParserMONTH, 0)
}

func (s *Unreserved_keyword_normalContext) MOVE() antlr.TerminalNode {
	return s.GetToken(OBParserMOVE, 0)
}

func (s *Unreserved_keyword_normalContext) MULTILINESTRING() antlr.TerminalNode {
	return s.GetToken(OBParserMULTILINESTRING, 0)
}

func (s *Unreserved_keyword_normalContext) MULTIPOINT() antlr.TerminalNode {
	return s.GetToken(OBParserMULTIPOINT, 0)
}

func (s *Unreserved_keyword_normalContext) MULTIPOLYGON() antlr.TerminalNode {
	return s.GetToken(OBParserMULTIPOLYGON, 0)
}

func (s *Unreserved_keyword_normalContext) MUTEX() antlr.TerminalNode {
	return s.GetToken(OBParserMUTEX, 0)
}

func (s *Unreserved_keyword_normalContext) MYSQL_ERRNO() antlr.TerminalNode {
	return s.GetToken(OBParserMYSQL_ERRNO, 0)
}

func (s *Unreserved_keyword_normalContext) MAX_USED_PART_ID() antlr.TerminalNode {
	return s.GetToken(OBParserMAX_USED_PART_ID, 0)
}

func (s *Unreserved_keyword_normalContext) NAME() antlr.TerminalNode {
	return s.GetToken(OBParserNAME, 0)
}

func (s *Unreserved_keyword_normalContext) NAMES() antlr.TerminalNode {
	return s.GetToken(OBParserNAMES, 0)
}

func (s *Unreserved_keyword_normalContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(OBParserNATIONAL, 0)
}

func (s *Unreserved_keyword_normalContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(OBParserNCHAR, 0)
}

func (s *Unreserved_keyword_normalContext) NDB() antlr.TerminalNode {
	return s.GetToken(OBParserNDB, 0)
}

func (s *Unreserved_keyword_normalContext) NDBCLUSTER() antlr.TerminalNode {
	return s.GetToken(OBParserNDBCLUSTER, 0)
}

func (s *Unreserved_keyword_normalContext) NEW() antlr.TerminalNode {
	return s.GetToken(OBParserNEW, 0)
}

func (s *Unreserved_keyword_normalContext) NEXT() antlr.TerminalNode {
	return s.GetToken(OBParserNEXT, 0)
}

func (s *Unreserved_keyword_normalContext) NO() antlr.TerminalNode {
	return s.GetToken(OBParserNO, 0)
}

func (s *Unreserved_keyword_normalContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(OBParserNODEGROUP, 0)
}

func (s *Unreserved_keyword_normalContext) NONE() antlr.TerminalNode {
	return s.GetToken(OBParserNONE, 0)
}

func (s *Unreserved_keyword_normalContext) NORMAL() antlr.TerminalNode {
	return s.GetToken(OBParserNORMAL, 0)
}

func (s *Unreserved_keyword_normalContext) NOW() antlr.TerminalNode {
	return s.GetToken(OBParserNOW, 0)
}

func (s *Unreserved_keyword_normalContext) NOWAIT() antlr.TerminalNode {
	return s.GetToken(OBParserNOWAIT, 0)
}

func (s *Unreserved_keyword_normalContext) NO_WAIT() antlr.TerminalNode {
	return s.GetToken(OBParserNO_WAIT, 0)
}

func (s *Unreserved_keyword_normalContext) NTILE() antlr.TerminalNode {
	return s.GetToken(OBParserNTILE, 0)
}

func (s *Unreserved_keyword_normalContext) NTH_VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserNTH_VALUE, 0)
}

func (s *Unreserved_keyword_normalContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(OBParserNUMBER, 0)
}

func (s *Unreserved_keyword_normalContext) NVARCHAR() antlr.TerminalNode {
	return s.GetToken(OBParserNVARCHAR, 0)
}

func (s *Unreserved_keyword_normalContext) OCCUR() antlr.TerminalNode {
	return s.GetToken(OBParserOCCUR, 0)
}

func (s *Unreserved_keyword_normalContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(OBParserOFFSET, 0)
}

func (s *Unreserved_keyword_normalContext) OLD_PASSWORD() antlr.TerminalNode {
	return s.GetToken(OBParserOLD_PASSWORD, 0)
}

func (s *Unreserved_keyword_normalContext) OLD_KEY() antlr.TerminalNode {
	return s.GetToken(OBParserOLD_KEY, 0)
}

func (s *Unreserved_keyword_normalContext) OVER() antlr.TerminalNode {
	return s.GetToken(OBParserOVER, 0)
}

func (s *Unreserved_keyword_normalContext) ONE() antlr.TerminalNode {
	return s.GetToken(OBParserONE, 0)
}

func (s *Unreserved_keyword_normalContext) ONE_SHOT() antlr.TerminalNode {
	return s.GetToken(OBParserONE_SHOT, 0)
}

func (s *Unreserved_keyword_normalContext) ONLY() antlr.TerminalNode {
	return s.GetToken(OBParserONLY, 0)
}

func (s *Unreserved_keyword_normalContext) OPEN() antlr.TerminalNode {
	return s.GetToken(OBParserOPEN, 0)
}

func (s *Unreserved_keyword_normalContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(OBParserOPTIONS, 0)
}

func (s *Unreserved_keyword_normalContext) REMOTE_OSS() antlr.TerminalNode {
	return s.GetToken(OBParserREMOTE_OSS, 0)
}

func (s *Unreserved_keyword_normalContext) OUTLINE() antlr.TerminalNode {
	return s.GetToken(OBParserOUTLINE, 0)
}

func (s *Unreserved_keyword_normalContext) OWNER() antlr.TerminalNode {
	return s.GetToken(OBParserOWNER, 0)
}

func (s *Unreserved_keyword_normalContext) PACK_KEYS() antlr.TerminalNode {
	return s.GetToken(OBParserPACK_KEYS, 0)
}

func (s *Unreserved_keyword_normalContext) PAGE() antlr.TerminalNode {
	return s.GetToken(OBParserPAGE, 0)
}

func (s *Unreserved_keyword_normalContext) PARAMETERS() antlr.TerminalNode {
	return s.GetToken(OBParserPARAMETERS, 0)
}

func (s *Unreserved_keyword_normalContext) PARSER() antlr.TerminalNode {
	return s.GetToken(OBParserPARSER, 0)
}

func (s *Unreserved_keyword_normalContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(OBParserPARTIAL, 0)
}

func (s *Unreserved_keyword_normalContext) PARTITION_ID() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITION_ID, 0)
}

func (s *Unreserved_keyword_normalContext) PARTITIONING() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITIONING, 0)
}

func (s *Unreserved_keyword_normalContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(OBParserPARTITIONS, 0)
}

func (s *Unreserved_keyword_normalContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(OBParserPERCENT_RANK, 0)
}

func (s *Unreserved_keyword_normalContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(OBParserPAUSE, 0)
}

func (s *Unreserved_keyword_normalContext) PHASE() antlr.TerminalNode {
	return s.GetToken(OBParserPHASE, 0)
}

func (s *Unreserved_keyword_normalContext) PHYSICAL() antlr.TerminalNode {
	return s.GetToken(OBParserPHYSICAL, 0)
}

func (s *Unreserved_keyword_normalContext) PLANREGRESS() antlr.TerminalNode {
	return s.GetToken(OBParserPLANREGRESS, 0)
}

func (s *Unreserved_keyword_normalContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(OBParserPLUGIN, 0)
}

func (s *Unreserved_keyword_normalContext) PLUGIN_DIR() antlr.TerminalNode {
	return s.GetToken(OBParserPLUGIN_DIR, 0)
}

func (s *Unreserved_keyword_normalContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(OBParserPLUGINS, 0)
}

func (s *Unreserved_keyword_normalContext) POINT() antlr.TerminalNode {
	return s.GetToken(OBParserPOINT, 0)
}

func (s *Unreserved_keyword_normalContext) POLYGON() antlr.TerminalNode {
	return s.GetToken(OBParserPOLYGON, 0)
}

func (s *Unreserved_keyword_normalContext) POOL() antlr.TerminalNode {
	return s.GetToken(OBParserPOOL, 0)
}

func (s *Unreserved_keyword_normalContext) PORT() antlr.TerminalNode {
	return s.GetToken(OBParserPORT, 0)
}

func (s *Unreserved_keyword_normalContext) POSITION() antlr.TerminalNode {
	return s.GetToken(OBParserPOSITION, 0)
}

func (s *Unreserved_keyword_normalContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(OBParserPREPARE, 0)
}

func (s *Unreserved_keyword_normalContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(OBParserPRESERVE, 0)
}

func (s *Unreserved_keyword_normalContext) PREV() antlr.TerminalNode {
	return s.GetToken(OBParserPREV, 0)
}

func (s *Unreserved_keyword_normalContext) PRIMARY_ZONE() antlr.TerminalNode {
	return s.GetToken(OBParserPRIMARY_ZONE, 0)
}

func (s *Unreserved_keyword_normalContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(OBParserPRIVILEGES, 0)
}

func (s *Unreserved_keyword_normalContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(OBParserPROCESS, 0)
}

func (s *Unreserved_keyword_normalContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(OBParserPROCESSLIST, 0)
}

func (s *Unreserved_keyword_normalContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(OBParserPROFILE, 0)
}

func (s *Unreserved_keyword_normalContext) PROFILES() antlr.TerminalNode {
	return s.GetToken(OBParserPROFILES, 0)
}

func (s *Unreserved_keyword_normalContext) PROGRESSIVE_MERGE_NUM() antlr.TerminalNode {
	return s.GetToken(OBParserPROGRESSIVE_MERGE_NUM, 0)
}

func (s *Unreserved_keyword_normalContext) PROXY() antlr.TerminalNode {
	return s.GetToken(OBParserPROXY, 0)
}

func (s *Unreserved_keyword_normalContext) PCTFREE() antlr.TerminalNode {
	return s.GetToken(OBParserPCTFREE, 0)
}

func (s *Unreserved_keyword_normalContext) P_ENTITY() antlr.TerminalNode {
	return s.GetToken(OBParserP_ENTITY, 0)
}

func (s *Unreserved_keyword_normalContext) P_CHUNK() antlr.TerminalNode {
	return s.GetToken(OBParserP_CHUNK, 0)
}

func (s *Unreserved_keyword_normalContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(OBParserQUARTER, 0)
}

func (s *Unreserved_keyword_normalContext) QUERY() antlr.TerminalNode {
	return s.GetToken(OBParserQUERY, 0)
}

func (s *Unreserved_keyword_normalContext) QUICK() antlr.TerminalNode {
	return s.GetToken(OBParserQUICK, 0)
}

func (s *Unreserved_keyword_normalContext) RANK() antlr.TerminalNode {
	return s.GetToken(OBParserRANK, 0)
}

func (s *Unreserved_keyword_normalContext) READ_ONLY() antlr.TerminalNode {
	return s.GetToken(OBParserREAD_ONLY, 0)
}

func (s *Unreserved_keyword_normalContext) REBUILD() antlr.TerminalNode {
	return s.GetToken(OBParserREBUILD, 0)
}

func (s *Unreserved_keyword_normalContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(OBParserRECOVER, 0)
}

func (s *Unreserved_keyword_normalContext) RECYCLE() antlr.TerminalNode {
	return s.GetToken(OBParserRECYCLE, 0)
}

func (s *Unreserved_keyword_normalContext) RECYCLEBIN() antlr.TerminalNode {
	return s.GetToken(OBParserRECYCLEBIN, 0)
}

func (s *Unreserved_keyword_normalContext) ROTATE() antlr.TerminalNode {
	return s.GetToken(OBParserROTATE, 0)
}

func (s *Unreserved_keyword_normalContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(OBParserROW_NUMBER, 0)
}

func (s *Unreserved_keyword_normalContext) REDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserREDO_BUFFER_SIZE, 0)
}

func (s *Unreserved_keyword_normalContext) REDOFILE() antlr.TerminalNode {
	return s.GetToken(OBParserREDOFILE, 0)
}

func (s *Unreserved_keyword_normalContext) REDUNDANT() antlr.TerminalNode {
	return s.GetToken(OBParserREDUNDANT, 0)
}

func (s *Unreserved_keyword_normalContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(OBParserREFRESH, 0)
}

func (s *Unreserved_keyword_normalContext) REGION() antlr.TerminalNode {
	return s.GetToken(OBParserREGION, 0)
}

func (s *Unreserved_keyword_normalContext) RELAY() antlr.TerminalNode {
	return s.GetToken(OBParserRELAY, 0)
}

func (s *Unreserved_keyword_normalContext) RELAYLOG() antlr.TerminalNode {
	return s.GetToken(OBParserRELAYLOG, 0)
}

func (s *Unreserved_keyword_normalContext) RELAY_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(OBParserRELAY_LOG_FILE, 0)
}

func (s *Unreserved_keyword_normalContext) RELAY_LOG_POS() antlr.TerminalNode {
	return s.GetToken(OBParserRELAY_LOG_POS, 0)
}

func (s *Unreserved_keyword_normalContext) RELAY_THREAD() antlr.TerminalNode {
	return s.GetToken(OBParserRELAY_THREAD, 0)
}

func (s *Unreserved_keyword_normalContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(OBParserRELOAD, 0)
}

func (s *Unreserved_keyword_normalContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(OBParserREMOVE, 0)
}

func (s *Unreserved_keyword_normalContext) REORGANIZE() antlr.TerminalNode {
	return s.GetToken(OBParserREORGANIZE, 0)
}

func (s *Unreserved_keyword_normalContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(OBParserREPAIR, 0)
}

func (s *Unreserved_keyword_normalContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(OBParserREPEATABLE, 0)
}

func (s *Unreserved_keyword_normalContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(OBParserREPLICA, 0)
}

func (s *Unreserved_keyword_normalContext) REPLICA_NUM() antlr.TerminalNode {
	return s.GetToken(OBParserREPLICA_NUM, 0)
}

func (s *Unreserved_keyword_normalContext) REPLICA_TYPE() antlr.TerminalNode {
	return s.GetToken(OBParserREPLICA_TYPE, 0)
}

func (s *Unreserved_keyword_normalContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(OBParserREPLICATION, 0)
}

func (s *Unreserved_keyword_normalContext) REPORT() antlr.TerminalNode {
	return s.GetToken(OBParserREPORT, 0)
}

func (s *Unreserved_keyword_normalContext) RESET() antlr.TerminalNode {
	return s.GetToken(OBParserRESET, 0)
}

func (s *Unreserved_keyword_normalContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(OBParserRESOURCE, 0)
}

func (s *Unreserved_keyword_normalContext) RESOURCE_POOL_LIST() antlr.TerminalNode {
	return s.GetToken(OBParserRESOURCE_POOL_LIST, 0)
}

func (s *Unreserved_keyword_normalContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(OBParserRESPECT, 0)
}

func (s *Unreserved_keyword_normalContext) RESTART() antlr.TerminalNode {
	return s.GetToken(OBParserRESTART, 0)
}

func (s *Unreserved_keyword_normalContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(OBParserRESTORE, 0)
}

func (s *Unreserved_keyword_normalContext) RESUME() antlr.TerminalNode {
	return s.GetToken(OBParserRESUME, 0)
}

func (s *Unreserved_keyword_normalContext) RETURNED_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(OBParserRETURNED_SQLSTATE, 0)
}

func (s *Unreserved_keyword_normalContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(OBParserRETURNS, 0)
}

func (s *Unreserved_keyword_normalContext) REVERSE() antlr.TerminalNode {
	return s.GetToken(OBParserREVERSE, 0)
}

func (s *Unreserved_keyword_normalContext) REWRITE_MERGE_VERSION() antlr.TerminalNode {
	return s.GetToken(OBParserREWRITE_MERGE_VERSION, 0)
}

func (s *Unreserved_keyword_normalContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(OBParserROLLBACK, 0)
}

func (s *Unreserved_keyword_normalContext) ROLLING() antlr.TerminalNode {
	return s.GetToken(OBParserROLLING, 0)
}

func (s *Unreserved_keyword_normalContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(OBParserROLLUP, 0)
}

func (s *Unreserved_keyword_normalContext) ROOT() antlr.TerminalNode {
	return s.GetToken(OBParserROOT, 0)
}

func (s *Unreserved_keyword_normalContext) ROOTTABLE() antlr.TerminalNode {
	return s.GetToken(OBParserROOTTABLE, 0)
}

func (s *Unreserved_keyword_normalContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(OBParserROUTINE, 0)
}

func (s *Unreserved_keyword_normalContext) ROW() antlr.TerminalNode {
	return s.GetToken(OBParserROW, 0)
}

func (s *Unreserved_keyword_normalContext) ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(OBParserROW_COUNT, 0)
}

func (s *Unreserved_keyword_normalContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(OBParserROW_FORMAT, 0)
}

func (s *Unreserved_keyword_normalContext) ROWS() antlr.TerminalNode {
	return s.GetToken(OBParserROWS, 0)
}

func (s *Unreserved_keyword_normalContext) RTREE() antlr.TerminalNode {
	return s.GetToken(OBParserRTREE, 0)
}

func (s *Unreserved_keyword_normalContext) RUN() antlr.TerminalNode {
	return s.GetToken(OBParserRUN, 0)
}

func (s *Unreserved_keyword_normalContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(OBParserSAMPLE, 0)
}

func (s *Unreserved_keyword_normalContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(OBParserSAVEPOINT, 0)
}

func (s *Unreserved_keyword_normalContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(OBParserSCHEDULE, 0)
}

func (s *Unreserved_keyword_normalContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(OBParserSCHEMA_NAME, 0)
}

func (s *Unreserved_keyword_normalContext) SCOPE() antlr.TerminalNode {
	return s.GetToken(OBParserSCOPE, 0)
}

func (s *Unreserved_keyword_normalContext) SECOND() antlr.TerminalNode {
	return s.GetToken(OBParserSECOND, 0)
}

func (s *Unreserved_keyword_normalContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(OBParserSECURITY, 0)
}

func (s *Unreserved_keyword_normalContext) SEED() antlr.TerminalNode {
	return s.GetToken(OBParserSEED, 0)
}

func (s *Unreserved_keyword_normalContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(OBParserSERIAL, 0)
}

func (s *Unreserved_keyword_normalContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(OBParserSERIALIZABLE, 0)
}

func (s *Unreserved_keyword_normalContext) SERVER() antlr.TerminalNode {
	return s.GetToken(OBParserSERVER, 0)
}

func (s *Unreserved_keyword_normalContext) SERVER_IP() antlr.TerminalNode {
	return s.GetToken(OBParserSERVER_IP, 0)
}

func (s *Unreserved_keyword_normalContext) SERVER_PORT() antlr.TerminalNode {
	return s.GetToken(OBParserSERVER_PORT, 0)
}

func (s *Unreserved_keyword_normalContext) SERVER_TYPE() antlr.TerminalNode {
	return s.GetToken(OBParserSERVER_TYPE, 0)
}

func (s *Unreserved_keyword_normalContext) SESSION() antlr.TerminalNode {
	return s.GetToken(OBParserSESSION, 0)
}

func (s *Unreserved_keyword_normalContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(OBParserSESSION_USER, 0)
}

func (s *Unreserved_keyword_normalContext) SET_MASTER_CLUSTER() antlr.TerminalNode {
	return s.GetToken(OBParserSET_MASTER_CLUSTER, 0)
}

func (s *Unreserved_keyword_normalContext) SET_SLAVE_CLUSTER() antlr.TerminalNode {
	return s.GetToken(OBParserSET_SLAVE_CLUSTER, 0)
}

func (s *Unreserved_keyword_normalContext) SET_TP() antlr.TerminalNode {
	return s.GetToken(OBParserSET_TP, 0)
}

func (s *Unreserved_keyword_normalContext) SHARE() antlr.TerminalNode {
	return s.GetToken(OBParserSHARE, 0)
}

func (s *Unreserved_keyword_normalContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(OBParserSHUTDOWN, 0)
}

func (s *Unreserved_keyword_normalContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(OBParserSIGNED, 0)
}

func (s *Unreserved_keyword_normalContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(OBParserSIMPLE, 0)
}

func (s *Unreserved_keyword_normalContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(OBParserSLAVE, 0)
}

func (s *Unreserved_keyword_normalContext) SLOW() antlr.TerminalNode {
	return s.GetToken(OBParserSLOW, 0)
}

func (s *Unreserved_keyword_normalContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(OBParserSNAPSHOT, 0)
}

func (s *Unreserved_keyword_normalContext) SOCKET() antlr.TerminalNode {
	return s.GetToken(OBParserSOCKET, 0)
}

func (s *Unreserved_keyword_normalContext) SOME() antlr.TerminalNode {
	return s.GetToken(OBParserSOME, 0)
}

func (s *Unreserved_keyword_normalContext) SONAME() antlr.TerminalNode {
	return s.GetToken(OBParserSONAME, 0)
}

func (s *Unreserved_keyword_normalContext) SOUNDS() antlr.TerminalNode {
	return s.GetToken(OBParserSOUNDS, 0)
}

func (s *Unreserved_keyword_normalContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(OBParserSOURCE, 0)
}

func (s *Unreserved_keyword_normalContext) SPFILE() antlr.TerminalNode {
	return s.GetToken(OBParserSPFILE, 0)
}

func (s *Unreserved_keyword_normalContext) SPLIT() antlr.TerminalNode {
	return s.GetToken(OBParserSPLIT, 0)
}

func (s *Unreserved_keyword_normalContext) SQL_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_AFTER_GTIDS, 0)
}

func (s *Unreserved_keyword_normalContext) SQL_AFTER_MTS_GAPS() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_AFTER_MTS_GAPS, 0)
}

func (s *Unreserved_keyword_normalContext) SQL_BEFORE_GTIDS() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_BEFORE_GTIDS, 0)
}

func (s *Unreserved_keyword_normalContext) SQL_BUFFER_RESULT() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_BUFFER_RESULT, 0)
}

func (s *Unreserved_keyword_normalContext) SQL_CACHE() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_CACHE, 0)
}

func (s *Unreserved_keyword_normalContext) SQL_ID() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_ID, 0)
}

func (s *Unreserved_keyword_normalContext) SQL_NO_CACHE() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_NO_CACHE, 0)
}

func (s *Unreserved_keyword_normalContext) SQL_THREAD() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_THREAD, 0)
}

func (s *Unreserved_keyword_normalContext) SQL_TSI_DAY() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_TSI_DAY, 0)
}

func (s *Unreserved_keyword_normalContext) SQL_TSI_HOUR() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_TSI_HOUR, 0)
}

func (s *Unreserved_keyword_normalContext) SQL_TSI_MINUTE() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_TSI_MINUTE, 0)
}

func (s *Unreserved_keyword_normalContext) SQL_TSI_MONTH() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_TSI_MONTH, 0)
}

func (s *Unreserved_keyword_normalContext) SQL_TSI_QUARTER() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_TSI_QUARTER, 0)
}

func (s *Unreserved_keyword_normalContext) SQL_TSI_SECOND() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_TSI_SECOND, 0)
}

func (s *Unreserved_keyword_normalContext) SQL_TSI_WEEK() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_TSI_WEEK, 0)
}

func (s *Unreserved_keyword_normalContext) SQL_TSI_YEAR() antlr.TerminalNode {
	return s.GetToken(OBParserSQL_TSI_YEAR, 0)
}

func (s *Unreserved_keyword_normalContext) STANDBY() antlr.TerminalNode {
	return s.GetToken(OBParserSTANDBY, 0)
}

func (s *Unreserved_keyword_normalContext) START() antlr.TerminalNode {
	return s.GetToken(OBParserSTART, 0)
}

func (s *Unreserved_keyword_normalContext) STARTS() antlr.TerminalNode {
	return s.GetToken(OBParserSTARTS, 0)
}

func (s *Unreserved_keyword_normalContext) STAT() antlr.TerminalNode {
	return s.GetToken(OBParserSTAT, 0)
}

func (s *Unreserved_keyword_normalContext) STATS_AUTO_RECALC() antlr.TerminalNode {
	return s.GetToken(OBParserSTATS_AUTO_RECALC, 0)
}

func (s *Unreserved_keyword_normalContext) STATS_PERSISTENT() antlr.TerminalNode {
	return s.GetToken(OBParserSTATS_PERSISTENT, 0)
}

func (s *Unreserved_keyword_normalContext) STATS_SAMPLE_PAGES() antlr.TerminalNode {
	return s.GetToken(OBParserSTATS_SAMPLE_PAGES, 0)
}

func (s *Unreserved_keyword_normalContext) STATUS() antlr.TerminalNode {
	return s.GetToken(OBParserSTATUS, 0)
}

func (s *Unreserved_keyword_normalContext) STDDEV() antlr.TerminalNode {
	return s.GetToken(OBParserSTDDEV, 0)
}

func (s *Unreserved_keyword_normalContext) STDDEV_POP() antlr.TerminalNode {
	return s.GetToken(OBParserSTDDEV_POP, 0)
}

func (s *Unreserved_keyword_normalContext) STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(OBParserSTDDEV_SAMP, 0)
}

func (s *Unreserved_keyword_normalContext) STOP() antlr.TerminalNode {
	return s.GetToken(OBParserSTOP, 0)
}

func (s *Unreserved_keyword_normalContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(OBParserSTORAGE, 0)
}

func (s *Unreserved_keyword_normalContext) STORAGE_FORMAT_VERSION() antlr.TerminalNode {
	return s.GetToken(OBParserSTORAGE_FORMAT_VERSION, 0)
}

func (s *Unreserved_keyword_normalContext) STORAGE_FORMAT_WORK_VERSION() antlr.TerminalNode {
	return s.GetToken(OBParserSTORAGE_FORMAT_WORK_VERSION, 0)
}

func (s *Unreserved_keyword_normalContext) STORING() antlr.TerminalNode {
	return s.GetToken(OBParserSTORING, 0)
}

func (s *Unreserved_keyword_normalContext) STRING() antlr.TerminalNode {
	return s.GetToken(OBParserSTRING, 0)
}

func (s *Unreserved_keyword_normalContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(OBParserSUBCLASS_ORIGIN, 0)
}

func (s *Unreserved_keyword_normalContext) SUBDATE() antlr.TerminalNode {
	return s.GetToken(OBParserSUBDATE, 0)
}

func (s *Unreserved_keyword_normalContext) SUBJECT() antlr.TerminalNode {
	return s.GetToken(OBParserSUBJECT, 0)
}

func (s *Unreserved_keyword_normalContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(OBParserSUBPARTITION, 0)
}

func (s *Unreserved_keyword_normalContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(OBParserSUBPARTITIONS, 0)
}

func (s *Unreserved_keyword_normalContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(OBParserSUBSTR, 0)
}

func (s *Unreserved_keyword_normalContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(OBParserSUBSTRING, 0)
}

func (s *Unreserved_keyword_normalContext) SUM() antlr.TerminalNode {
	return s.GetToken(OBParserSUM, 0)
}

func (s *Unreserved_keyword_normalContext) SUPER() antlr.TerminalNode {
	return s.GetToken(OBParserSUPER, 0)
}

func (s *Unreserved_keyword_normalContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(OBParserSUSPEND, 0)
}

func (s *Unreserved_keyword_normalContext) SWAPS() antlr.TerminalNode {
	return s.GetToken(OBParserSWAPS, 0)
}

func (s *Unreserved_keyword_normalContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(OBParserSWITCH, 0)
}

func (s *Unreserved_keyword_normalContext) SWITCHES() antlr.TerminalNode {
	return s.GetToken(OBParserSWITCHES, 0)
}

func (s *Unreserved_keyword_normalContext) SWITCHOVER() antlr.TerminalNode {
	return s.GetToken(OBParserSWITCHOVER, 0)
}

func (s *Unreserved_keyword_normalContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(OBParserSYSTEM, 0)
}

func (s *Unreserved_keyword_normalContext) SYSTEM_USER() antlr.TerminalNode {
	return s.GetToken(OBParserSYSTEM_USER, 0)
}

func (s *Unreserved_keyword_normalContext) SYSDATE() antlr.TerminalNode {
	return s.GetToken(OBParserSYSDATE, 0)
}

func (s *Unreserved_keyword_normalContext) TABLE_CHECKSUM() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE_CHECKSUM, 0)
}

func (s *Unreserved_keyword_normalContext) TABLE_MODE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE_MODE, 0)
}

func (s *Unreserved_keyword_normalContext) TABLEGROUPS() antlr.TerminalNode {
	return s.GetToken(OBParserTABLEGROUPS, 0)
}

func (s *Unreserved_keyword_normalContext) TABLE_ID() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE_ID, 0)
}

func (s *Unreserved_keyword_normalContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(OBParserTABLE_NAME, 0)
}

func (s *Unreserved_keyword_normalContext) TABLES() antlr.TerminalNode {
	return s.GetToken(OBParserTABLES, 0)
}

func (s *Unreserved_keyword_normalContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLESPACE, 0)
}

func (s *Unreserved_keyword_normalContext) TABLET() antlr.TerminalNode {
	return s.GetToken(OBParserTABLET, 0)
}

func (s *Unreserved_keyword_normalContext) TABLET_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLET_SIZE, 0)
}

func (s *Unreserved_keyword_normalContext) TABLET_MAX_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserTABLET_MAX_SIZE, 0)
}

func (s *Unreserved_keyword_normalContext) TASK() antlr.TerminalNode {
	return s.GetToken(OBParserTASK, 0)
}

func (s *Unreserved_keyword_normalContext) TEMPLATE() antlr.TerminalNode {
	return s.GetToken(OBParserTEMPLATE, 0)
}

func (s *Unreserved_keyword_normalContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(OBParserTEMPORARY, 0)
}

func (s *Unreserved_keyword_normalContext) TEMPTABLE() antlr.TerminalNode {
	return s.GetToken(OBParserTEMPTABLE, 0)
}

func (s *Unreserved_keyword_normalContext) TENANT() antlr.TerminalNode {
	return s.GetToken(OBParserTENANT, 0)
}

func (s *Unreserved_keyword_normalContext) TENANT_ID() antlr.TerminalNode {
	return s.GetToken(OBParserTENANT_ID, 0)
}

func (s *Unreserved_keyword_normalContext) SLOT_IDX() antlr.TerminalNode {
	return s.GetToken(OBParserSLOT_IDX, 0)
}

func (s *Unreserved_keyword_normalContext) TEXT() antlr.TerminalNode {
	return s.GetToken(OBParserTEXT, 0)
}

func (s *Unreserved_keyword_normalContext) THAN() antlr.TerminalNode {
	return s.GetToken(OBParserTHAN, 0)
}

func (s *Unreserved_keyword_normalContext) TIME() antlr.TerminalNode {
	return s.GetToken(OBParserTIME, 0)
}

func (s *Unreserved_keyword_normalContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(OBParserTIMESTAMP, 0)
}

func (s *Unreserved_keyword_normalContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(OBParserTIMESTAMPADD, 0)
}

func (s *Unreserved_keyword_normalContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(OBParserTIMESTAMPDIFF, 0)
}

func (s *Unreserved_keyword_normalContext) TIME_ZONE_INFO() antlr.TerminalNode {
	return s.GetToken(OBParserTIME_ZONE_INFO, 0)
}

func (s *Unreserved_keyword_normalContext) TP_NAME() antlr.TerminalNode {
	return s.GetToken(OBParserTP_NAME, 0)
}

func (s *Unreserved_keyword_normalContext) TP_NO() antlr.TerminalNode {
	return s.GetToken(OBParserTP_NO, 0)
}

func (s *Unreserved_keyword_normalContext) TRACE() antlr.TerminalNode {
	return s.GetToken(OBParserTRACE, 0)
}

func (s *Unreserved_keyword_normalContext) TRADITIONAL() antlr.TerminalNode {
	return s.GetToken(OBParserTRADITIONAL, 0)
}

func (s *Unreserved_keyword_normalContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(OBParserTRIGGERS, 0)
}

func (s *Unreserved_keyword_normalContext) TRIM() antlr.TerminalNode {
	return s.GetToken(OBParserTRIM, 0)
}

func (s *Unreserved_keyword_normalContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(OBParserTRUNCATE, 0)
}

func (s *Unreserved_keyword_normalContext) TYPE() antlr.TerminalNode {
	return s.GetToken(OBParserTYPE, 0)
}

func (s *Unreserved_keyword_normalContext) TYPES() antlr.TerminalNode {
	return s.GetToken(OBParserTYPES, 0)
}

func (s *Unreserved_keyword_normalContext) TABLEGROUP_ID() antlr.TerminalNode {
	return s.GetToken(OBParserTABLEGROUP_ID, 0)
}

func (s *Unreserved_keyword_normalContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(OBParserUNCOMMITTED, 0)
}

func (s *Unreserved_keyword_normalContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(OBParserUNDEFINED, 0)
}

func (s *Unreserved_keyword_normalContext) UNDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(OBParserUNDO_BUFFER_SIZE, 0)
}

func (s *Unreserved_keyword_normalContext) UNDOFILE() antlr.TerminalNode {
	return s.GetToken(OBParserUNDOFILE, 0)
}

func (s *Unreserved_keyword_normalContext) UNICODE() antlr.TerminalNode {
	return s.GetToken(OBParserUNICODE, 0)
}

func (s *Unreserved_keyword_normalContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(OBParserUNKNOWN, 0)
}

func (s *Unreserved_keyword_normalContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(OBParserUNINSTALL, 0)
}

func (s *Unreserved_keyword_normalContext) UNIT() antlr.TerminalNode {
	return s.GetToken(OBParserUNIT, 0)
}

func (s *Unreserved_keyword_normalContext) UNIT_NUM() antlr.TerminalNode {
	return s.GetToken(OBParserUNIT_NUM, 0)
}

func (s *Unreserved_keyword_normalContext) UNLOCKED() antlr.TerminalNode {
	return s.GetToken(OBParserUNLOCKED, 0)
}

func (s *Unreserved_keyword_normalContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(OBParserUNTIL, 0)
}

func (s *Unreserved_keyword_normalContext) UNUSUAL() antlr.TerminalNode {
	return s.GetToken(OBParserUNUSUAL, 0)
}

func (s *Unreserved_keyword_normalContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(OBParserUPGRADE, 0)
}

func (s *Unreserved_keyword_normalContext) USE_BLOOM_FILTER() antlr.TerminalNode {
	return s.GetToken(OBParserUSE_BLOOM_FILTER, 0)
}

func (s *Unreserved_keyword_normalContext) USE_FRM() antlr.TerminalNode {
	return s.GetToken(OBParserUSE_FRM, 0)
}

func (s *Unreserved_keyword_normalContext) USER() antlr.TerminalNode {
	return s.GetToken(OBParserUSER, 0)
}

func (s *Unreserved_keyword_normalContext) USER_RESOURCES() antlr.TerminalNode {
	return s.GetToken(OBParserUSER_RESOURCES, 0)
}

func (s *Unreserved_keyword_normalContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(OBParserUNBOUNDED, 0)
}

func (s *Unreserved_keyword_normalContext) VALID() antlr.TerminalNode {
	return s.GetToken(OBParserVALID, 0)
}

func (s *Unreserved_keyword_normalContext) VALUE() antlr.TerminalNode {
	return s.GetToken(OBParserVALUE, 0)
}

func (s *Unreserved_keyword_normalContext) VARIANCE() antlr.TerminalNode {
	return s.GetToken(OBParserVARIANCE, 0)
}

func (s *Unreserved_keyword_normalContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(OBParserVARIABLES, 0)
}

func (s *Unreserved_keyword_normalContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(OBParserVERBOSE, 0)
}

func (s *Unreserved_keyword_normalContext) VIRTUAL_COLUMN_ID() antlr.TerminalNode {
	return s.GetToken(OBParserVIRTUAL_COLUMN_ID, 0)
}

func (s *Unreserved_keyword_normalContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(OBParserMATERIALIZED, 0)
}

func (s *Unreserved_keyword_normalContext) VIEW() antlr.TerminalNode {
	return s.GetToken(OBParserVIEW, 0)
}

func (s *Unreserved_keyword_normalContext) WAIT() antlr.TerminalNode {
	return s.GetToken(OBParserWAIT, 0)
}

func (s *Unreserved_keyword_normalContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(OBParserWARNINGS, 0)
}

func (s *Unreserved_keyword_normalContext) WEEK() antlr.TerminalNode {
	return s.GetToken(OBParserWEEK, 0)
}

func (s *Unreserved_keyword_normalContext) WEIGHT_STRING() antlr.TerminalNode {
	return s.GetToken(OBParserWEIGHT_STRING, 0)
}

func (s *Unreserved_keyword_normalContext) WORK() antlr.TerminalNode {
	return s.GetToken(OBParserWORK, 0)
}

func (s *Unreserved_keyword_normalContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(OBParserWRAPPER, 0)
}

func (s *Unreserved_keyword_normalContext) X509() antlr.TerminalNode {
	return s.GetToken(OBParserX509, 0)
}

func (s *Unreserved_keyword_normalContext) XA() antlr.TerminalNode {
	return s.GetToken(OBParserXA, 0)
}

func (s *Unreserved_keyword_normalContext) XML() antlr.TerminalNode {
	return s.GetToken(OBParserXML, 0)
}

func (s *Unreserved_keyword_normalContext) YEAR() antlr.TerminalNode {
	return s.GetToken(OBParserYEAR, 0)
}

func (s *Unreserved_keyword_normalContext) ZONE() antlr.TerminalNode {
	return s.GetToken(OBParserZONE, 0)
}

func (s *Unreserved_keyword_normalContext) ZONE_LIST() antlr.TerminalNode {
	return s.GetToken(OBParserZONE_LIST, 0)
}

func (s *Unreserved_keyword_normalContext) ZONE_TYPE() antlr.TerminalNode {
	return s.GetToken(OBParserZONE_TYPE, 0)
}

func (s *Unreserved_keyword_normalContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(OBParserLOCATION, 0)
}

func (s *Unreserved_keyword_normalContext) PLAN() antlr.TerminalNode {
	return s.GetToken(OBParserPLAN, 0)
}

func (s *Unreserved_keyword_normalContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(OBParserVISIBLE, 0)
}

func (s *Unreserved_keyword_normalContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(OBParserINVISIBLE, 0)
}

func (s *Unreserved_keyword_normalContext) ACTIVATE() antlr.TerminalNode {
	return s.GetToken(OBParserACTIVATE, 0)
}

func (s *Unreserved_keyword_normalContext) SYNCHRONIZATION() antlr.TerminalNode {
	return s.GetToken(OBParserSYNCHRONIZATION, 0)
}

func (s *Unreserved_keyword_normalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unreserved_keyword_normalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unreserved_keyword_normalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUnreserved_keyword_normal(s)
	}
}

func (s *Unreserved_keyword_normalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUnreserved_keyword_normal(s)
	}
}

func (s *Unreserved_keyword_normalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUnreserved_keyword_normal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Unreserved_keyword_normal() (localctx IUnreserved_keyword_normalContext) {
	localctx = NewUnreserved_keyword_normalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 944, OBParserRULE_unreserved_keyword_normal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8294)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-26)) & ^0x3f) == 0 && ((int64(1)<<(_la-26))&140737496744065) != 0) || ((int64((_la-92)) & ^0x3f) == 0 && ((int64(1)<<(_la-92))&288230513726980097) != 0) || ((int64((_la-163)) & ^0x3f) == 0 && ((int64(1)<<(_la-163))&11821949038624769) != 0) || ((int64((_la-250)) & ^0x3f) == 0 && ((int64(1)<<(_la-250))&-4629700416945258495) != 0) || ((int64((_la-314)) & ^0x3f) == 0 && ((int64(1)<<(_la-314))&-587737344112594961) != 0) || ((int64((_la-378)) & ^0x3f) == 0 && ((int64(1)<<(_la-378))&-603552873430712321) != 0) || ((int64((_la-442)) & ^0x3f) == 0 && ((int64(1)<<(_la-442))&-2305913515397021697) != 0) || ((int64((_la-506)) & ^0x3f) == 0 && ((int64(1)<<(_la-506))&8070450531845275647) != 0) || ((int64((_la-570)) & ^0x3f) == 0 && ((int64(1)<<(_la-570))&-18159534061387777) != 0) || ((int64((_la-634)) & ^0x3f) == 0 && ((int64(1)<<(_la-634))&-18146237874177) != 0) || ((int64((_la-698)) & ^0x3f) == 0 && ((int64(1)<<(_la-698))&-2533274790395971) != 0) || ((int64((_la-762)) & ^0x3f) == 0 && ((int64(1)<<(_la-762))&-1157425104234217473) != 0) || ((int64((_la-826)) & ^0x3f) == 0 && ((int64(1)<<(_la-826))&137342196111112175) != 0) || _la == OBParserSTAT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnreserved_keyword_specialContext is an interface to support dynamic dispatch.
type IUnreserved_keyword_specialContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PASSWORD() antlr.TerminalNode

	// IsUnreserved_keyword_specialContext differentiates from other interfaces.
	IsUnreserved_keyword_specialContext()
}

type Unreserved_keyword_specialContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnreserved_keyword_specialContext() *Unreserved_keyword_specialContext {
	var p = new(Unreserved_keyword_specialContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_unreserved_keyword_special
	return p
}

func InitEmptyUnreserved_keyword_specialContext(p *Unreserved_keyword_specialContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_unreserved_keyword_special
}

func (*Unreserved_keyword_specialContext) IsUnreserved_keyword_specialContext() {}

func NewUnreserved_keyword_specialContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unreserved_keyword_specialContext {
	var p = new(Unreserved_keyword_specialContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_unreserved_keyword_special

	return p
}

func (s *Unreserved_keyword_specialContext) GetParser() antlr.Parser { return s.parser }

func (s *Unreserved_keyword_specialContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(OBParserPASSWORD, 0)
}

func (s *Unreserved_keyword_specialContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unreserved_keyword_specialContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unreserved_keyword_specialContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterUnreserved_keyword_special(s)
	}
}

func (s *Unreserved_keyword_specialContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitUnreserved_keyword_special(s)
	}
}

func (s *Unreserved_keyword_specialContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitUnreserved_keyword_special(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Unreserved_keyword_special() (localctx IUnreserved_keyword_specialContext) {
	localctx = NewUnreserved_keyword_specialContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 946, OBParserRULE_unreserved_keyword_special)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8296)
		p.Match(OBParserPASSWORD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyContext is an interface to support dynamic dispatch.
type IEmptyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsEmptyContext differentiates from other interfaces.
	IsEmptyContext()
}

type EmptyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyContext() *EmptyContext {
	var p = new(EmptyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_empty
	return p
}

func InitEmptyEmptyContext(p *EmptyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_empty
}

func (*EmptyContext) IsEmptyContext() {}

func NewEmptyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyContext {
	var p = new(EmptyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_empty

	return p
}

func (s *EmptyContext) GetParser() antlr.Parser { return s.parser }
func (s *EmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterEmpty(s)
	}
}

func (s *EmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitEmpty(s)
	}
}

func (s *EmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Empty() (localctx IEmptyContext) {
	localctx = NewEmptyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 948, OBParserRULE_empty)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForward_exprContext is an interface to support dynamic dispatch.
type IForward_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	EOF() antlr.TerminalNode

	// IsForward_exprContext differentiates from other interfaces.
	IsForward_exprContext()
}

type Forward_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForward_exprContext() *Forward_exprContext {
	var p = new(Forward_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_forward_expr
	return p
}

func InitEmptyForward_exprContext(p *Forward_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_forward_expr
}

func (*Forward_exprContext) IsForward_exprContext() {}

func NewForward_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Forward_exprContext {
	var p = new(Forward_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_forward_expr

	return p
}

func (s *Forward_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Forward_exprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Forward_exprContext) EOF() antlr.TerminalNode {
	return s.GetToken(OBParserEOF, 0)
}

func (s *Forward_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Forward_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Forward_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterForward_expr(s)
	}
}

func (s *Forward_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitForward_expr(s)
	}
}

func (s *Forward_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitForward_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Forward_expr() (localctx IForward_exprContext) {
	localctx = NewForward_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 950, OBParserRULE_forward_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8300)
		p.expr(0)
	}
	{
		p.SetState(8301)
		p.Match(OBParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForward_sql_stmtContext is an interface to support dynamic dispatch.
type IForward_sql_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Stmt() IStmtContext
	EOF() antlr.TerminalNode

	// IsForward_sql_stmtContext differentiates from other interfaces.
	IsForward_sql_stmtContext()
}

type Forward_sql_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForward_sql_stmtContext() *Forward_sql_stmtContext {
	var p = new(Forward_sql_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_forward_sql_stmt
	return p
}

func InitEmptyForward_sql_stmtContext(p *Forward_sql_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = OBParserRULE_forward_sql_stmt
}

func (*Forward_sql_stmtContext) IsForward_sql_stmtContext() {}

func NewForward_sql_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Forward_sql_stmtContext {
	var p = new(Forward_sql_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = OBParserRULE_forward_sql_stmt

	return p
}

func (s *Forward_sql_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Forward_sql_stmtContext) Stmt() IStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *Forward_sql_stmtContext) EOF() antlr.TerminalNode {
	return s.GetToken(OBParserEOF, 0)
}

func (s *Forward_sql_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Forward_sql_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Forward_sql_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.EnterForward_sql_stmt(s)
	}
}

func (s *Forward_sql_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(OBParserListener); ok {
		listenerT.ExitForward_sql_stmt(s)
	}
}

func (s *Forward_sql_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case OBParserVisitor:
		return t.VisitForward_sql_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *OBParser) Forward_sql_stmt() (localctx IForward_sql_stmtContext) {
	localctx = NewForward_sql_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 952, OBParserRULE_forward_sql_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8303)
		p.Stmt()
	}
	{
		p.SetState(8304)
		p.Match(OBParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *OBParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 14:
		var t *Bool_priContext = nil
		if localctx != nil {
			t = localctx.(*Bool_priContext)
		}
		return p.Bool_pri_Sempred(t, predIndex)

	case 16:
		var t *Bit_exprContext = nil
		if localctx != nil {
			t = localctx.(*Bit_exprContext)
		}
		return p.Bit_expr_Sempred(t, predIndex)

	case 17:
		var t *Simple_exprContext = nil
		if localctx != nil {
			t = localctx.(*Simple_exprContext)
		}
		return p.Simple_expr_Sempred(t, predIndex)

	case 18:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	case 61:
		var t *Opt_resource_unit_option_listContext = nil
		if localctx != nil {
			t = localctx.(*Opt_resource_unit_option_listContext)
		}
		return p.Opt_resource_unit_option_list_Sempred(t, predIndex)

	case 63:
		var t *Opt_create_resource_pool_option_listContext = nil
		if localctx != nil {
			t = localctx.(*Opt_create_resource_pool_option_listContext)
		}
		return p.Opt_create_resource_pool_option_list_Sempred(t, predIndex)

	case 71:
		var t *Opt_tenant_option_listContext = nil
		if localctx != nil {
			t = localctx.(*Opt_tenant_option_listContext)
		}
		return p.Opt_tenant_option_list_Sempred(t, predIndex)

	case 106:
		var t *Opt_reference_option_listContext = nil
		if localctx != nil {
			t = localctx.(*Opt_reference_option_listContext)
		}
		return p.Opt_reference_option_list_Sempred(t, predIndex)

	case 111:
		var t *Opt_generated_column_attribute_listContext = nil
		if localctx != nil {
			t = localctx.(*Opt_generated_column_attribute_listContext)
		}
		return p.Opt_generated_column_attribute_list_Sempred(t, predIndex)

	case 133:
		var t *Opt_column_attribute_listContext = nil
		if localctx != nil {
			t = localctx.(*Opt_column_attribute_listContext)
		}
		return p.Opt_column_attribute_list_Sempred(t, predIndex)

	case 215:
		var t *Insert_vals_listContext = nil
		if localctx != nil {
			t = localctx.(*Insert_vals_listContext)
		}
		return p.Insert_vals_list_Sempred(t, predIndex)

	case 216:
		var t *Insert_valsContext = nil
		if localctx != nil {
			t = localctx.(*Insert_valsContext)
		}
		return p.Insert_vals_Sempred(t, predIndex)

	case 225:
		var t *Select_clause_setContext = nil
		if localctx != nil {
			t = localctx.(*Select_clause_setContext)
		}
		return p.Select_clause_set_Sempred(t, predIndex)

	case 252:
		var t *Opt_hint_listContext = nil
		if localctx != nil {
			t = localctx.(*Opt_hint_listContext)
		}
		return p.Opt_hint_list_Sempred(t, predIndex)

	case 254:
		var t *Name_listContext = nil
		if localctx != nil {
			t = localctx.(*Name_listContext)
		}
		return p.Name_list_Sempred(t, predIndex)

	case 303:
		var t *Relation_factor_in_leading_hint_listContext = nil
		if localctx != nil {
			t = localctx.(*Relation_factor_in_leading_hint_listContext)
		}
		return p.Relation_factor_in_leading_hint_list_Sempred(t, predIndex)

	case 305:
		var t *Relation_factor_in_use_join_hint_listContext = nil
		if localctx != nil {
			t = localctx.(*Relation_factor_in_use_join_hint_listContext)
		}
		return p.Relation_factor_in_use_join_hint_list_Sempred(t, predIndex)

	case 308:
		var t *Joined_tableContext = nil
		if localctx != nil {
			t = localctx.(*Joined_tableContext)
		}
		return p.Joined_table_Sempred(t, predIndex)

	case 341:
		var t *Tls_option_listContext = nil
		if localctx != nil {
			t = localctx.(*Tls_option_listContext)
		}
		return p.Tls_option_list_Sempred(t, predIndex)

	case 393:
		var t *Alter_table_actionsContext = nil
		if localctx != nil {
			t = localctx.(*Alter_table_actionsContext)
		}
		return p.Alter_table_actions_Sempred(t, predIndex)

	case 428:
		var t *Add_or_alter_zone_optionsContext = nil
		if localctx != nil {
			t = localctx.(*Add_or_alter_zone_optionsContext)
		}
		return p.Add_or_alter_zone_options_Sempred(t, predIndex)

	case 446:
		var t *Alter_system_settp_actionsContext = nil
		if localctx != nil {
			t = localctx.(*Alter_system_settp_actionsContext)
		}
		return p.Alter_system_settp_actions_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *OBParser) Bool_pri_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Bit_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 15:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 22:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 24:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 25:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 26:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 27:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 28:
		return p.Precpred(p.GetParserRuleContext(), 8)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Simple_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 29:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 30:
		return p.Precpred(p.GetParserRuleContext(), 19)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 31:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 32:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 33:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 34:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 35:
		return p.Precpred(p.GetParserRuleContext(), 8)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Opt_resource_unit_option_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 36:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Opt_create_resource_pool_option_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 37:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Opt_tenant_option_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 38:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Opt_reference_option_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 39:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Opt_generated_column_attribute_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 40:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Opt_column_attribute_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 41:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Insert_vals_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 42:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Insert_vals_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 43:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Select_clause_set_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 44:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 45:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 46:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Opt_hint_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 47:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Name_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 48:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 49:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Relation_factor_in_leading_hint_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 50:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 51:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 52:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Relation_factor_in_use_join_hint_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 53:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 54:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Joined_table_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 55:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 56:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 57:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 58:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 59:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Tls_option_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 60:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 61:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Alter_table_actions_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 62:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Add_or_alter_zone_options_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 63:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *OBParser) Alter_system_settp_actions_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 64:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
